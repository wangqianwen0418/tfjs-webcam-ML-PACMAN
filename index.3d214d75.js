// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"iKiqL":[function(require,module,exports) {
"use strict";
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "0a8ecb283d214d75";
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('ðŸš¨ [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] ðŸš¨ Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] âœ¨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>ðŸ’¡ ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                var oldDeps = modules[asset.id][1];
                for(var dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    var id = oldDeps[dep];
                    var parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id1) {
    var modules = bundle.modules;
    if (!modules) return;
    if (modules[id1]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        var deps = modules[id1][1];
        var orphans = [];
        for(var dep in deps){
            var parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id1];
        delete bundle.cache[id1]; // Now delete the orphans.
        orphans.forEach(function(id) {
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id1);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    var parents = getParents(module.bundle.root, id);
    var accepted = false;
    while(parents.length > 0){
        var v = parents.shift();
        var a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            var p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push.apply(parents, _toConsumableArray(p));
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"bB7Pu":[function(require,module,exports) {
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ var _tfjs = require("@tensorflow/tfjs");
var _tfjsData = require("@tensorflow/tfjs-data");
var _controllerDataset = require("./controller_dataset");
var _ui = require("./ui");
// The number of classes we want to predict. In this example, we will be
// predicting 4 classes for up, down, left, and right.
const NUM_CLASSES = 4;
// A webcam iterator that generates Tensors from the images from the webcam.
let webcam;
// The dataset object where we will store activations.
const controllerDataset = new _controllerDataset.ControllerDataset(NUM_CLASSES);
let truncatedMobileNet;
let model;
// Loads mobilenet and returns a model that returns the internal activation
// we'll use as input to our classifier model.
async function loadTruncatedMobileNet() {
    const mobilenet = await _tfjs.loadLayersModel('https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_0.25_224/model.json');
    // Return a model that outputs an internal activation.
    const layer = mobilenet.getLayer('conv_pw_13_relu');
    return _tfjs.model({
        inputs: mobilenet.inputs,
        outputs: layer.output
    });
}
// When the UI buttons are pressed, read a frame from the webcam and associate
// it with the class label given by the button. up, down, left, right are
// labels 0, 1, 2, 3 respectively.
_ui.setExampleHandler(async (label)=>{
    let img = await getImage();
    controllerDataset.addExample(truncatedMobileNet.predict(img), label);
    // Draw the preview thumbnail.
    _ui.drawThumb(img, label);
    img.dispose();
});
/**
 * Sets up and trains the classifier.
 */ async function train() {
    if (controllerDataset.xs == null) throw new Error('Add some examples before training!');
    // Creates a 2-layer fully connected model. By creating a separate model,
    // rather than adding layers to the mobilenet model, we "freeze" the weights
    // of the mobilenet model, and only train weights from the new model.
    model = _tfjs.sequential({
        layers: [
            // Flattens the input to a vector so we can use it in a dense layer. While
            // technically a layer, this only performs a reshape (and has no training
            // parameters).
            _tfjs.layers.flatten({
                inputShape: truncatedMobileNet.outputs[0].shape.slice(1)
            }),
            // Layer 1.
            _tfjs.layers.dense({
                units: _ui.getDenseUnits(),
                activation: 'relu',
                kernelInitializer: 'varianceScaling',
                useBias: true
            }),
            // Layer 2. The number of units of the last layer should correspond
            // to the number of classes we want to predict.
            _tfjs.layers.dense({
                units: NUM_CLASSES,
                kernelInitializer: 'varianceScaling',
                useBias: false,
                activation: 'softmax'
            })
        ]
    });
    // Creates the optimizers which drives training of the model.
    const optimizer = _tfjs.train.adam(_ui.getLearningRate());
    // We use categoricalCrossentropy which is the loss function we use for
    // categorical classification which measures the error between our predicted
    // probability distribution over classes (probability that an input is of each
    // class), versus the label (100% probability in the true class)>
    model.compile({
        optimizer: optimizer,
        loss: 'categoricalCrossentropy'
    });
    // We parameterize batch size as a fraction of the entire dataset because the
    // number of examples that are collected depends on how many examples the user
    // collects. This allows us to have a flexible batch size.
    const batchSize = Math.floor(controllerDataset.xs.shape[0] * _ui.getBatchSizeFraction());
    if (!(batchSize > 0)) throw new Error(`Batch size is 0 or NaN. Please choose a non-zero fraction.`);
    // Train the model! Model.fit() will shuffle xs & ys so we don't have to.
    model.fit(controllerDataset.xs, controllerDataset.ys, {
        batchSize,
        epochs: _ui.getEpochs(),
        callbacks: {
            onBatchEnd: async (batch, logs)=>{
                _ui.trainStatus('Loss: ' + logs.loss.toFixed(5));
            }
        }
    });
}
let isPredicting = false;
async function predict() {
    _ui.isPredicting();
    while(isPredicting){
        // Capture the frame from the webcam.
        const img = await getImage();
        // Make a prediction through mobilenet, getting the internal activation of
        // the mobilenet model, i.e., "embeddings" of the input images.
        const embeddings = truncatedMobileNet.predict(img);
        // Make a prediction through our newly-trained model using the embeddings
        // from mobilenet as input.
        const predictions = model.predict(embeddings);
        // Returns the index with the maximum probability. This number corresponds
        // to the class the model thinks is the most probable given the input.
        const predictedClass = predictions.as1D().argMax();
        const classId = (await predictedClass.data())[0];
        img.dispose();
        _ui.predictClass(classId);
        await _tfjs.nextFrame();
    }
    _ui.donePredicting();
}
/**
 * Captures a frame from the webcam and normalizes it between -1 and 1.
 * Returns a batched image (1-element batch) of shape [1, w, h, c].
 */ async function getImage() {
    const img = await webcam.capture();
    const processedImg = _tfjs.tidy(()=>img.expandDims(0).toFloat().div(127).sub(1)
    );
    img.dispose();
    return processedImg;
}
document.getElementById('train').addEventListener('click', async ()=>{
    _ui.trainStatus('Training...');
    await _tfjs.nextFrame();
    await _tfjs.nextFrame();
    isPredicting = false;
    train();
});
document.getElementById('predict').addEventListener('click', ()=>{
    _ui.startPacman();
    isPredicting = true;
    predict();
});
async function init() {
    try {
        webcam = await _tfjsData.webcam(document.getElementById('webcam'));
    } catch (e) {
        console.log(e);
        document.getElementById('no-webcam').style.display = 'block';
    }
    truncatedMobileNet = await loadTruncatedMobileNet();
    _ui.init();
    // Warm up the model. This uploads weights to the GPU and compiles the WebGL
    // programs so the first time we collect data from the webcam it will be
    // quick.
    const screenShot = await webcam.capture();
    truncatedMobileNet.predict(screenShot.expandDims(0));
    screenShot.dispose();
}
// Initialize the application.
init();

},{"@tensorflow/tfjs":"2Nmqy","@tensorflow/tfjs-data":"847Hn","./controller_dataset":"5PKub","./ui":"jRvde"}],"2Nmqy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "data", ()=>_tfjsData
);
parcelHelpers.export(exports, "version", ()=>version$1
);
// @tensorflow/tfjs Copyright 2020 Google
var _tfjsCore = require("@tensorflow/tfjs-core");
var _tfjsLayers = require("@tensorflow/tfjs-layers");
var _tfjsConverter = require("@tensorflow/tfjs-converter");
var _tfjsData = require("@tensorflow/tfjs-data");
parcelHelpers.exportAll(_tfjsCore, exports);
parcelHelpers.exportAll(_tfjsLayers, exports);
parcelHelpers.exportAll(_tfjsConverter, exports);
var version = "1.7.4", version$1 = {
    "tfjs-core": _tfjsCore.version_core,
    "tfjs-data": _tfjsData.version_data,
    "tfjs-layers": _tfjsLayers.version_layers,
    "tfjs-converter": _tfjsConverter.version_converter,
    tfjs: version
};

},{"@tensorflow/tfjs-core":"djGzH","@tensorflow/tfjs-layers":"lRvbi","@tensorflow/tfjs-converter":"h4Rqn","@tensorflow/tfjs-data":"847Hn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"djGzH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AdadeltaOptimizer", ()=>Yd
);
parcelHelpers.export(exports, "AdagradOptimizer", ()=>$d
);
parcelHelpers.export(exports, "AdamOptimizer", ()=>Qd
);
parcelHelpers.export(exports, "AdamaxOptimizer", ()=>Jd
);
parcelHelpers.export(exports, "Add", ()=>xr
);
parcelHelpers.export(exports, "AddN", ()=>br
);
parcelHelpers.export(exports, "BroadcastTo", ()=>Sr
);
parcelHelpers.export(exports, "DataStorage", ()=>ca
);
parcelHelpers.export(exports, "Div", ()=>wr
);
parcelHelpers.export(exports, "ENV", ()=>s
);
parcelHelpers.export(exports, "Environment", ()=>o
);
parcelHelpers.export(exports, "FromPixels", ()=>Fr
);
parcelHelpers.export(exports, "FusedBatchNorm", ()=>Cr
);
parcelHelpers.export(exports, "Identity", ()=>Tr
);
parcelHelpers.export(exports, "KernelBackend", ()=>la
);
parcelHelpers.export(exports, "MaxPoolWithArgmax", ()=>_r
);
parcelHelpers.export(exports, "MomentumOptimizer", ()=>tp
);
parcelHelpers.export(exports, "NonMaxSuppressionV5", ()=>kr
);
parcelHelpers.export(exports, "OneHot", ()=>Ar
);
parcelHelpers.export(exports, "Optimizer", ()=>Xd
);
parcelHelpers.export(exports, "PadV2", ()=>Nr
);
parcelHelpers.export(exports, "RMSPropOptimizer", ()=>ep
);
parcelHelpers.export(exports, "Rank", ()=>Ct
);
parcelHelpers.export(exports, "Reduction", ()=>Nh
);
parcelHelpers.export(exports, "SGDOptimizer", ()=>Zd
);
parcelHelpers.export(exports, "Square", ()=>Rr
);
parcelHelpers.export(exports, "SquaredDifference", ()=>Er
);
parcelHelpers.export(exports, "Tensor", ()=>wt
);
parcelHelpers.export(exports, "TensorBuffer", ()=>mt
);
parcelHelpers.export(exports, "Tile", ()=>Dr
);
parcelHelpers.export(exports, "Transpose", ()=>Ir
);
parcelHelpers.export(exports, "Variable", ()=>St
);
parcelHelpers.export(exports, "abs", ()=>Lr
);
parcelHelpers.export(exports, "acos", ()=>Wr
);
parcelHelpers.export(exports, "acosh", ()=>Ur
);
parcelHelpers.export(exports, "add", ()=>Or
);
parcelHelpers.export(exports, "addN", ()=>$u
);
parcelHelpers.export(exports, "addStrict", ()=>xo
);
parcelHelpers.export(exports, "all", ()=>ql
);
parcelHelpers.export(exports, "any", ()=>Kl
);
parcelHelpers.export(exports, "argMax", ()=>jl
);
parcelHelpers.export(exports, "argMin", ()=>Xl
);
parcelHelpers.export(exports, "asin", ()=>Vr
);
parcelHelpers.export(exports, "asinh", ()=>zr
);
parcelHelpers.export(exports, "atan", ()=>Gr
);
parcelHelpers.export(exports, "atan2", ()=>bo
);
parcelHelpers.export(exports, "atanh", ()=>Hr
);
parcelHelpers.export(exports, "avgPool", ()=>Ol
);
parcelHelpers.export(exports, "avgPool3d", ()=>Pl
);
parcelHelpers.export(exports, "backend", ()=>hn
);
parcelHelpers.export(exports, "backend_util", ()=>Sa
);
parcelHelpers.export(exports, "basicLSTMCell", ()=>lh
);
parcelHelpers.export(exports, "batchNorm", ()=>nc
);
parcelHelpers.export(exports, "batchNorm2d", ()=>ac
);
parcelHelpers.export(exports, "batchNorm3d", ()=>uc
);
parcelHelpers.export(exports, "batchNorm4d", ()=>hc
);
parcelHelpers.export(exports, "batchNormalization", ()=>ec
);
parcelHelpers.export(exports, "batchNormalization2d", ()=>oc
);
parcelHelpers.export(exports, "batchNormalization3d", ()=>sc
);
parcelHelpers.export(exports, "batchNormalization4d", ()=>lc
);
parcelHelpers.export(exports, "batchToSpaceND", ()=>rr
);
parcelHelpers.export(exports, "booleanMaskAsync", ()=>ul
);
parcelHelpers.export(exports, "broadcastTo", ()=>fc
);
parcelHelpers.export(exports, "browser", ()=>Vd
);
parcelHelpers.export(exports, "buffer", ()=>er
);
parcelHelpers.export(exports, "cast", ()=>or
);
parcelHelpers.export(exports, "ceil", ()=>qr
);
parcelHelpers.export(exports, "clipByValue", ()=>Kr
);
parcelHelpers.export(exports, "clone", ()=>dc
);
parcelHelpers.export(exports, "complex", ()=>Tn
);
parcelHelpers.export(exports, "concat", ()=>Yn
);
parcelHelpers.export(exports, "concat1d", ()=>$n
);
parcelHelpers.export(exports, "concat2d", ()=>Qn
);
parcelHelpers.export(exports, "concat3d", ()=>Jn
);
parcelHelpers.export(exports, "concat4d", ()=>Zn
);
parcelHelpers.export(exports, "conv1d", ()=>fl
);
parcelHelpers.export(exports, "conv2d", ()=>dl
);
parcelHelpers.export(exports, "conv2dTranspose", ()=>wl
);
parcelHelpers.export(exports, "conv3d", ()=>pl
);
parcelHelpers.export(exports, "conv3dTranspose", ()=>Cl
);
parcelHelpers.export(exports, "cos", ()=>jr
);
parcelHelpers.export(exports, "cosh", ()=>Xr
);
parcelHelpers.export(exports, "cumsum", ()=>ar
);
parcelHelpers.export(exports, "customGrad", ()=>oa
);
parcelHelpers.export(exports, "deprecationWarn", ()=>Xe
);
parcelHelpers.export(exports, "depthToSpace", ()=>ir
);
parcelHelpers.export(exports, "depthwiseConv2d", ()=>ml
);
parcelHelpers.export(exports, "diag", ()=>Eh
);
parcelHelpers.export(exports, "disableDeprecationWarnings", ()=>je
);
parcelHelpers.export(exports, "dispose", ()=>tn
);
parcelHelpers.export(exports, "disposeVariables", ()=>Ye
);
parcelHelpers.export(exports, "div", ()=>Bo
);
parcelHelpers.export(exports, "divNoNan", ()=>bc
);
parcelHelpers.export(exports, "divStrict", ()=>wo
);
parcelHelpers.export(exports, "dot", ()=>Rl
);
parcelHelpers.export(exports, "dropout", ()=>Rh
);
parcelHelpers.export(exports, "elu", ()=>nh
);
parcelHelpers.export(exports, "enableDebugMode", ()=>Ke
);
parcelHelpers.export(exports, "enableProdMode", ()=>qe
);
parcelHelpers.export(exports, "engine", ()=>$e
);
parcelHelpers.export(exports, "env", ()=>i
);
parcelHelpers.export(exports, "equal", ()=>Kc
);
parcelHelpers.export(exports, "equalStrict", ()=>jc
);
parcelHelpers.export(exports, "erf", ()=>Yr
);
parcelHelpers.export(exports, "exp", ()=>$r
);
parcelHelpers.export(exports, "expandDims", ()=>sr
);
parcelHelpers.export(exports, "expm1", ()=>Qr
);
parcelHelpers.export(exports, "eye", ()=>Cc
);
parcelHelpers.export(exports, "fft", ()=>gh
);
parcelHelpers.export(exports, "fill", ()=>Hn
);
parcelHelpers.export(exports, "findBackend", ()=>un
);
parcelHelpers.export(exports, "findBackendFactory", ()=>cn
);
parcelHelpers.export(exports, "floor", ()=>Jr
);
parcelHelpers.export(exports, "floorDiv", ()=>Co
);
parcelHelpers.export(exports, "frame", ()=>Ah
);
parcelHelpers.export(exports, "fused", ()=>hf
);
parcelHelpers.export(exports, "gather", ()=>il
);
parcelHelpers.export(exports, "gatherND", ()=>Ch
);
parcelHelpers.export(exports, "gather_util", ()=>Lo
);
parcelHelpers.export(exports, "getBackend", ()=>an
);
parcelHelpers.export(exports, "getGradient", ()=>h
);
parcelHelpers.export(exports, "getKernel", ()=>l
);
parcelHelpers.export(exports, "getKernelsForBackend", ()=>f
);
parcelHelpers.export(exports, "grad", ()=>Zo
);
parcelHelpers.export(exports, "grads", ()=>ta
);
parcelHelpers.export(exports, "greater", ()=>Xc
);
parcelHelpers.export(exports, "greaterEqual", ()=>Yc
);
parcelHelpers.export(exports, "greaterEqualStrict", ()=>$c
);
parcelHelpers.export(exports, "greaterStrict", ()=>Qc
);
parcelHelpers.export(exports, "hammingWindow", ()=>Sh
);
parcelHelpers.export(exports, "hannWindow", ()=>kh
);
parcelHelpers.export(exports, "ifft", ()=>mh
);
parcelHelpers.export(exports, "imag", ()=>Nn
);
parcelHelpers.export(exports, "image", ()=>nf
);
parcelHelpers.export(exports, "inTopKAsync", ()=>Fh
);
parcelHelpers.export(exports, "io", ()=>Bd
);
parcelHelpers.export(exports, "irfft", ()=>xh
);
parcelHelpers.export(exports, "isFinite", ()=>lo
);
parcelHelpers.export(exports, "isInf", ()=>co
);
parcelHelpers.export(exports, "isNaN", ()=>uo
);
parcelHelpers.export(exports, "keep", ()=>en
);
parcelHelpers.export(exports, "leakyRelu", ()=>rh
);
parcelHelpers.export(exports, "less", ()=>Jc
);
parcelHelpers.export(exports, "lessEqual", ()=>Zc
);
parcelHelpers.export(exports, "lessEqualStrict", ()=>tl
);
parcelHelpers.export(exports, "lessStrict", ()=>el
);
parcelHelpers.export(exports, "linalg", ()=>jh
);
parcelHelpers.export(exports, "linspace", ()=>qn
);
parcelHelpers.export(exports, "localResponseNormalization", ()=>uh
);
parcelHelpers.export(exports, "log", ()=>Zr
);
parcelHelpers.export(exports, "log1p", ()=>to
);
parcelHelpers.export(exports, "logSigmoid", ()=>eo
);
parcelHelpers.export(exports, "logSoftmax", ()=>sa
);
parcelHelpers.export(exports, "logSumExp", ()=>Yl
);
parcelHelpers.export(exports, "logicalAnd", ()=>pc
);
parcelHelpers.export(exports, "logicalNot", ()=>vc
);
parcelHelpers.export(exports, "logicalOr", ()=>gc
);
parcelHelpers.export(exports, "logicalXor", ()=>mc
);
parcelHelpers.export(exports, "losses", ()=>zh
);
parcelHelpers.export(exports, "matMul", ()=>El
);
parcelHelpers.export(exports, "math", ()=>Wd
);
parcelHelpers.export(exports, "max", ()=>$l
);
parcelHelpers.export(exports, "maxPool", ()=>_l
);
parcelHelpers.export(exports, "maxPool3d", ()=>Bl
);
parcelHelpers.export(exports, "maxPoolWithArgmax", ()=>Ll
);
parcelHelpers.export(exports, "maximum", ()=>Eo
);
parcelHelpers.export(exports, "maximumStrict", ()=>Ro
);
parcelHelpers.export(exports, "mean", ()=>Ql
);
parcelHelpers.export(exports, "memory", ()=>Qe
);
parcelHelpers.export(exports, "min", ()=>Jl
);
parcelHelpers.export(exports, "minimum", ()=>Io
);
parcelHelpers.export(exports, "minimumStrict", ()=>ko
);
parcelHelpers.export(exports, "mod", ()=>So
);
parcelHelpers.export(exports, "modStrict", ()=>Ao
);
parcelHelpers.export(exports, "moments", ()=>Zl
);
parcelHelpers.export(exports, "movingAverage", ()=>fh
);
parcelHelpers.export(exports, "mul", ()=>To
);
parcelHelpers.export(exports, "mulStrict", ()=>Do
);
parcelHelpers.export(exports, "multiRNNCell", ()=>hh
);
parcelHelpers.export(exports, "multinomial", ()=>Ec
);
parcelHelpers.export(exports, "neg", ()=>no
);
parcelHelpers.export(exports, "nextFrame", ()=>ap
);
parcelHelpers.export(exports, "norm", ()=>ch
);
parcelHelpers.export(exports, "notEqual", ()=>nl
);
parcelHelpers.export(exports, "notEqualStrict", ()=>rl
);
parcelHelpers.export(exports, "oneHot", ()=>Rc
);
parcelHelpers.export(exports, "ones", ()=>zn
);
parcelHelpers.export(exports, "onesLike", ()=>jn
);
parcelHelpers.export(exports, "op", ()=>An
);
parcelHelpers.export(exports, "outerProduct", ()=>Il
);
parcelHelpers.export(exports, "pad", ()=>Ic
);
parcelHelpers.export(exports, "pad1d", ()=>kc
);
parcelHelpers.export(exports, "pad2d", ()=>Sc
);
parcelHelpers.export(exports, "pad3d", ()=>Ac
);
parcelHelpers.export(exports, "pad4d", ()=>Tc
);
parcelHelpers.export(exports, "pool", ()=>Ml
);
parcelHelpers.export(exports, "pow", ()=>No
);
parcelHelpers.export(exports, "powStrict", ()=>Fo
);
parcelHelpers.export(exports, "prelu", ()=>oh
);
parcelHelpers.export(exports, "print", ()=>nr
);
parcelHelpers.export(exports, "prod", ()=>eh
);
parcelHelpers.export(exports, "profile", ()=>Je
);
parcelHelpers.export(exports, "rand", ()=>Dc
);
parcelHelpers.export(exports, "randomGamma", ()=>Uc
);
parcelHelpers.export(exports, "randomNormal", ()=>Vc
);
parcelHelpers.export(exports, "randomUniform", ()=>zc
);
parcelHelpers.export(exports, "range", ()=>Kn
);
parcelHelpers.export(exports, "ready", ()=>on
);
parcelHelpers.export(exports, "real", ()=>Dn
);
parcelHelpers.export(exports, "reciprocal", ()=>ro
);
parcelHelpers.export(exports, "registerBackend", ()=>ln
);
parcelHelpers.export(exports, "registerGradient", ()=>p
);
parcelHelpers.export(exports, "registerKernel", ()=>d
);
parcelHelpers.export(exports, "relu", ()=>ah
);
parcelHelpers.export(exports, "relu6", ()=>ih
);
parcelHelpers.export(exports, "removeBackend", ()=>sn
);
parcelHelpers.export(exports, "reshape", ()=>ur
);
parcelHelpers.export(exports, "reverse", ()=>kl
);
parcelHelpers.export(exports, "reverse1d", ()=>Sl
);
parcelHelpers.export(exports, "reverse2d", ()=>Al
);
parcelHelpers.export(exports, "reverse3d", ()=>Tl
);
parcelHelpers.export(exports, "reverse4d", ()=>Dl
);
parcelHelpers.export(exports, "rfft", ()=>yh
);
parcelHelpers.export(exports, "round", ()=>oo
);
parcelHelpers.export(exports, "rsqrt", ()=>ao
);
parcelHelpers.export(exports, "scalar", ()=>On
);
parcelHelpers.export(exports, "scatterND", ()=>vh
);
parcelHelpers.export(exports, "scatter_util", ()=>Ho
);
parcelHelpers.export(exports, "selu", ()=>sh
);
parcelHelpers.export(exports, "separableConv2d", ()=>bl
);
parcelHelpers.export(exports, "serialization", ()=>qd
);
parcelHelpers.export(exports, "setBackend", ()=>rn
);
parcelHelpers.export(exports, "setPlatform", ()=>fn
);
parcelHelpers.export(exports, "setdiff1dAsync", ()=>dr
);
parcelHelpers.export(exports, "sigmoid", ()=>io
);
parcelHelpers.export(exports, "sign", ()=>so
);
parcelHelpers.export(exports, "signal", ()=>Dh
);
parcelHelpers.export(exports, "sin", ()=>ho
);
parcelHelpers.export(exports, "sinh", ()=>fo
);
parcelHelpers.export(exports, "slice", ()=>Wl
);
parcelHelpers.export(exports, "slice1d", ()=>Ul
);
parcelHelpers.export(exports, "slice2d", ()=>Vl
);
parcelHelpers.export(exports, "slice3d", ()=>zl
);
parcelHelpers.export(exports, "slice4d", ()=>Gl
);
parcelHelpers.export(exports, "slice_util", ()=>Jo
);
parcelHelpers.export(exports, "softmax", ()=>ia
);
parcelHelpers.export(exports, "softplus", ()=>po
);
parcelHelpers.export(exports, "spaceToBatchND", ()=>cr
);
parcelHelpers.export(exports, "sparseToDense", ()=>wh
);
parcelHelpers.export(exports, "spectral", ()=>bh
);
parcelHelpers.export(exports, "split", ()=>tr
);
parcelHelpers.export(exports, "sqrt", ()=>vo
);
parcelHelpers.export(exports, "square", ()=>Gc
);
parcelHelpers.export(exports, "squaredDifference", ()=>Hc
);
parcelHelpers.export(exports, "squaredDifferenceStrict", ()=>_o
);
parcelHelpers.export(exports, "squeeze", ()=>lr
);
parcelHelpers.export(exports, "stack", ()=>hr
);
parcelHelpers.export(exports, "step", ()=>go
);
parcelHelpers.export(exports, "stft", ()=>Th
);
parcelHelpers.export(exports, "stridedSlice", ()=>dh
);
parcelHelpers.export(exports, "sub", ()=>Oo
);
parcelHelpers.export(exports, "subStrict", ()=>Mo
);
parcelHelpers.export(exports, "sum", ()=>th
);
parcelHelpers.export(exports, "sumOutType", ()=>Dt
);
parcelHelpers.export(exports, "tan", ()=>mo
);
parcelHelpers.export(exports, "tanh", ()=>yo
);
parcelHelpers.export(exports, "tensor", ()=>Fn
);
parcelHelpers.export(exports, "tensor1d", ()=>Mn
);
parcelHelpers.export(exports, "tensor2d", ()=>Bn
);
parcelHelpers.export(exports, "tensor3d", ()=>Pn
);
parcelHelpers.export(exports, "tensor4d", ()=>Ln
);
parcelHelpers.export(exports, "tensor5d", ()=>Wn
);
parcelHelpers.export(exports, "tensor6d", ()=>Un
);
parcelHelpers.export(exports, "tensor_util", ()=>Mt
);
parcelHelpers.export(exports, "test_util", ()=>Bc
);
parcelHelpers.export(exports, "tidy", ()=>Ze
);
parcelHelpers.export(exports, "tile", ()=>wc
);
parcelHelpers.export(exports, "time", ()=>nn
);
parcelHelpers.export(exports, "topk", ()=>ph
);
parcelHelpers.export(exports, "train", ()=>rp
);
parcelHelpers.export(exports, "transpose", ()=>ua
);
parcelHelpers.export(exports, "truncatedNormal", ()=>qc
);
parcelHelpers.export(exports, "unregisterGradient", ()=>g
);
parcelHelpers.export(exports, "unregisterKernel", ()=>v
);
parcelHelpers.export(exports, "unsortedSegmentSum", ()=>sl
);
parcelHelpers.export(exports, "unstack", ()=>fr
);
parcelHelpers.export(exports, "util", ()=>st
);
parcelHelpers.export(exports, "valueAndGrad", ()=>ea
);
parcelHelpers.export(exports, "valueAndGrads", ()=>na
);
parcelHelpers.export(exports, "variable", ()=>Vn
);
parcelHelpers.export(exports, "variableGrads", ()=>ra
);
parcelHelpers.export(exports, "version_core", ()=>Kd
);
parcelHelpers.export(exports, "webgl", ()=>jd
);
parcelHelpers.export(exports, "where", ()=>yc
);
parcelHelpers.export(exports, "whereAsync", ()=>xc
);
parcelHelpers.export(exports, "zeros", ()=>Gn
);
parcelHelpers.export(exports, "zerosLike", ()=>Xn
);
var global = arguments[3];
var process = require("process");
var Buffer = require("buffer").Buffer;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ var t = function(e1, n1) {
    return (t = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(t1, e2) {
        t1.__proto__ = e2;
    } || function(t2, e3) {
        for(var n2 in e3)e3.hasOwnProperty(n2) && (t2[n2] = e3[n2]);
    })(e1, n1);
};
function e(e4, n3) {
    function r1() {
        this.constructor = e4;
    }
    t(e4, n3), e4.prototype = null === n3 ? Object.create(n3) : (r1.prototype = n3.prototype, new r1);
}
function n(t3, e5, n4, r2) {
    return new (n4 || (n4 = Promise))(function(o1, a1) {
        function i1(t4) {
            try {
                u1(r2.next(t4));
            } catch (t5) {
                a1(t5);
            }
        }
        function s1(t6) {
            try {
                u1(r2.throw(t6));
            } catch (t7) {
                a1(t7);
            }
        }
        function u1(t8) {
            t8.done ? o1(t8.value) : new n4(function(e6) {
                e6(t8.value);
            }).then(i1, s1);
        }
        u1((r2 = r2.apply(t3, e5 || [])).next());
    });
}
function r(t9, e7) {
    var n5, r3, o2, a2, i2 = {
        label: 0,
        sent: function() {
            if (1 & o2[0]) throw o2[1];
            return o2[1];
        },
        trys: [],
        ops: []
    };
    function s2(a3) {
        return function(s3) {
            return (function(a4) {
                if (n5) throw new TypeError("Generator is already executing.");
                for(; i2;)try {
                    if (n5 = 1, r3 && (o2 = 2 & a4[0] ? r3.return : a4[0] ? r3.throw || ((o2 = r3.return) && o2.call(r3), 0) : r3.next) && !(o2 = o2.call(r3, a4[1])).done) return o2;
                    switch(r3 = 0, o2 && (a4 = [
                        2 & a4[0],
                        o2.value
                    ]), a4[0]){
                        case 0:
                        case 1:
                            o2 = a4;
                            break;
                        case 4:
                            return i2.label++, {
                                value: a4[1],
                                done: !1
                            };
                        case 5:
                            i2.label++, r3 = a4[1], a4 = [
                                0
                            ];
                            continue;
                        case 7:
                            a4 = i2.ops.pop(), i2.trys.pop();
                            continue;
                        default:
                            if (!(o2 = (o2 = i2.trys).length > 0 && o2[o2.length - 1]) && (6 === a4[0] || 2 === a4[0])) {
                                i2 = 0;
                                continue;
                            }
                            if (3 === a4[0] && (!o2 || a4[1] > o2[0] && a4[1] < o2[3])) {
                                i2.label = a4[1];
                                break;
                            }
                            if (6 === a4[0] && i2.label < o2[1]) {
                                i2.label = o2[1], o2 = a4;
                                break;
                            }
                            if (o2 && i2.label < o2[2]) {
                                i2.label = o2[2], i2.ops.push(a4);
                                break;
                            }
                            o2[2] && i2.ops.pop(), i2.trys.pop();
                            continue;
                    }
                    a4 = e7.call(t9, i2);
                } catch (t10) {
                    a4 = [
                        6,
                        t10
                    ], r3 = 0;
                } finally{
                    n5 = o2 = 0;
                }
                if (5 & a4[0]) throw a4[1];
                return {
                    value: a4[0] ? a4[1] : void 0,
                    done: !0
                };
            })([
                a3,
                s3
            ]);
        };
    }
    return a2 = {
        next: s2(0),
        throw: s2(1),
        return: s2(2)
    }, "function" == typeof Symbol && (a2[Symbol.iterator] = function() {
        return this;
    }), a2;
}
var o = function() {
    function t11(t12) {
        this.global = t12, this.flags = {
        }, this.flagRegistry = {
        }, this.urlFlags = {
        }, this.populateURLFlags();
    }
    return t11.prototype.setPlatform = function(t13, e8) {
        null != this.platform && console.warn("Platform " + this.platformName + " has already been set. Overwriting the platform with " + e8 + "."), this.platformName = t13, this.platform = e8;
    }, t11.prototype.registerFlag = function(t14, e9, n6) {
        if (this.flagRegistry[t14] = {
            evaluationFn: e9,
            setHook: n6
        }, null != this.urlFlags[t14]) {
            var r4 = this.urlFlags[t14];
            console.warn("Setting feature override from URL " + t14 + ": " + r4 + "."), this.set(t14, r4);
        }
    }, t11.prototype.get = function(t15) {
        return t15 in this.flags ? this.flags[t15] : (this.flags[t15] = this.evaluateFlag(t15), this.flags[t15]);
    }, t11.prototype.getNumber = function(t16) {
        return this.get(t16);
    }, t11.prototype.getBool = function(t17) {
        return this.get(t17);
    }, t11.prototype.getFlags = function() {
        return this.flags;
    }, Object.defineProperty(t11.prototype, "features", {
        get: function() {
            return this.flags;
        },
        enumerable: !0,
        configurable: !0
    }), t11.prototype.set = function(t18, e10) {
        if (null == this.flagRegistry[t18]) throw new Error("Cannot set flag " + t18 + " as it has not been registered.");
        this.flags[t18] = e10, null != this.flagRegistry[t18].setHook && this.flagRegistry[t18].setHook(e10);
    }, t11.prototype.evaluateFlag = function(t19) {
        if (null == this.flagRegistry[t19]) throw new Error("Cannot evaluate flag '" + t19 + "': no evaluation function found.");
        return this.flagRegistry[t19].evaluationFn();
    }, t11.prototype.setFlags = function(t20) {
        this.flags = Object.assign({
        }, t20);
    }, t11.prototype.reset = function() {
        this.flags = {
        }, this.urlFlags = {
        }, this.populateURLFlags();
    }, t11.prototype.populateURLFlags = function() {
        var t21 = this;
        if (void 0 !== this.global && void 0 !== this.global.location && void 0 !== this.global.location.search) {
            var e11, n7, r5 = (e11 = this.global.location.search, n7 = {
            }, e11.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function(t) {
                for(var e12 = [], r7 = 1; r7 < arguments.length; r7++)e12[r7 - 1] = arguments[r7];
                return a(n7, e12[0], e12[1]), e12.join("=");
            }), n7);
            if ("tfjsflags" in r5) r5.tfjsflags.split(",").forEach(function(e13) {
                var n8 = e13.split(":"), r8 = n8[0], o3 = n8[1];
                t21.urlFlags[r8] = (function(t22, e14) {
                    if ("true" === (e14 = e14.toLowerCase()) || "false" === e14) return "true" === e14;
                    if ("" + +e14 === e14) return +e14;
                    throw new Error("Could not parse value flag value " + e14 + " for flag " + t22 + ".");
                })(r8, o3);
            });
        }
    }, t11;
}();
function a(t23, e, n9) {
    t23[decodeURIComponent(e)] = decodeURIComponent(n9 || "");
}
function i() {
    return s;
}
var s = null;
var u = new Map, c = new Map;
function l(t24, e15) {
    var n10 = m(t24, e15);
    return u.get(n10);
}
function h(t25) {
    return c.get(t25);
}
function f(t26) {
    for(var e16 = u.entries(), n11 = [];;){
        var r9 = e16.next(), o4 = r9.done, a5 = r9.value;
        if (o4) break;
        var i3 = a5[0], s4 = a5[1];
        i3.split("_")[0] === t26 && n11.push(s4);
    }
    return n11;
}
function d(t27) {
    var e17 = t27.kernelName, n12 = t27.backendName, r10 = m(e17, n12);
    if (u.has(r10)) throw new Error("The kernel '" + e17 + "' for backend '" + n12 + "' is already registered");
    u.set(r10, t27);
}
function p(t28) {
    var e18 = t28.kernelName;
    c.has(e18) && console.warn("Overriding the gradient for '" + e18 + "'"), c.set(e18, t28);
}
function v(t29, e19) {
    var n13 = m(t29, e19);
    if (!u.has(n13)) throw new Error("The kernel '" + t29 + "' for backend '" + e19 + "' is not registered");
    u.delete(n13);
}
function g(t30) {
    if (!c.has(t30)) throw new Error("The gradient '" + t30 + "' for backend is not registered");
    c.delete(t30);
}
function m(t31, e20) {
    return e20 + "_" + t31;
}
function y(t32) {
    for(var e21 = t32.length, n14 = 0, r11 = 0; e21 > 0;)r11 = Math.random() * e21 | 0, n14 = t32[--e21], t32[e21] = t32[r11], t32[r11] = n14;
}
function x(t33, e22, n15) {
    return Math.max(t33, Math.min(e22, n15));
}
function b(t34) {
    return t34 % 2 == 0 ? t34 : t34 + 1;
}
function w(t35) {
    for(var e23 = 0, n16 = 0; n16 < t35.length; n16++)e23 += t35[n16];
    return e23;
}
function C(t36, e24) {
    if (!t36) throw new Error("string" == typeof e24 ? e24 : e24());
}
function E(t37, e25, n17) {
    void 0 === n17 && (n17 = ""), C(S(t37, e25), function() {
        return n17 + " Shapes " + t37 + " and " + e25 + " must match";
    });
}
function R(t38) {
    C(null != t38, function() {
        return "The input to the tensor constructor must be a non-null value.";
    });
}
function I(t39, e26, n18) {
    if (void 0 === e26 && (e26 = []), void 0 === n18 && (n18 = !1), null == e26 && (e26 = []), Array.isArray(t39) || V(t39) && !n18) for(var r12 = 0; r12 < t39.length; ++r12)I(t39[r12], e26, n18);
    else e26.push(t39);
    return e26;
}
function k(t40) {
    if (0 === t40.length) return 1;
    for(var e27 = t40[0], n19 = 1; n19 < t40.length; n19++)e27 *= t40[n19];
    return e27;
}
function S(t41, e28) {
    if (t41 === e28) return !0;
    if (null == t41 || null == e28) return !1;
    if (t41.length !== e28.length) return !1;
    for(var n20 = 0; n20 < t41.length; n20++)if (t41[n20] !== e28[n20]) return !1;
    return !0;
}
function A(t42) {
    return t42 % 1 == 0;
}
function T(t43) {
    if (null != Math.tanh) return Math.tanh(t43);
    if (t43 === 1 / 0) return 1;
    if (t43 === -1 / 0) return -1;
    var e29 = Math.exp(2 * t43);
    return (e29 - 1) / (e29 + 1);
}
function D(t44) {
    var e30 = Math.ceil(Math.sqrt(t44));
    return [
        e30,
        Math.ceil(t44 / e30)
    ];
}
function N(t45, e31) {
    return e31 <= t45.length ? t45 : t45 + " ".repeat(e31 - t45.length);
}
function F(t46, e32, n21) {
    return void 0 === e32 && (e32 = function(t) {
        return 0;
    }), new Promise(function(r13, o5) {
        var a6 = 0, i4 = function() {
            if (t46()) r13();
            else {
                a6++;
                var s5 = e32(a6);
                null != n21 && a6 >= n21 ? o5() : setTimeout(i4, s5);
            }
        };
        i4();
    });
}
function _14(t47, e33) {
    for(var n22 = 1, r14 = -1, o6 = 0; o6 < t47.length; ++o6)if (t47[o6] >= 0) n22 *= t47[o6];
    else if (-1 === t47[o6]) {
        if (-1 !== r14) throw Error("Shapes can only have 1 implicit size. Found -1 at dim " + r14 + " and dim " + o6);
        r14 = o6;
    } else if (t47[o6] < 0) throw Error("Shapes can not be < 0. Found " + t47[o6] + " at dim " + o6);
    if (-1 === r14) {
        if (e33 > 0 && e33 !== n22) throw Error("Size(" + e33 + ") must match the product of shape " + t47);
        return t47;
    }
    if (0 === n22) throw Error("Cannot infer the missing size in [" + t47 + "] when there are 0 elements");
    if (e33 % n22 != 0) throw Error("The implicit shape can't be a fractional number. Got " + e33 + " / " + n22);
    var a7 = t47.slice();
    return a7[r14] = e33 / n22, a7;
}
function O(t48, e34) {
    var n23 = e34.length;
    return C((t48 = null == t48 ? e34.map(function(t, e35) {
        return e35;
    }) : [].concat(t48)).every(function(t49) {
        return t49 >= -n23 && t49 < n23;
    }), function() {
        return "All values in axis param must be in range [-" + n23 + ", " + n23 + ") but got axis " + t48;
    }), C(t48.every(function(t50) {
        return A(t50);
    }), function() {
        return "All values in axis param must be integers but got axis " + t48;
    }), t48.map(function(t51) {
        return t51 < 0 ? n23 + t51 : t51;
    });
}
function M(t52, e36) {
    for(var n24 = [], r15 = [], o7 = null != e36 && Array.isArray(e36) && 0 === e36.length, a8 = null == e36 || o7 ? null : O(e36, t52).sort(), i5 = 0, s6 = 0; s6 < t52.length; ++s6){
        if (null != a8) {
            if (a8[i5] === s6 && 1 !== t52[s6]) throw new Error("Can't squeeze axis " + s6 + " since its dim '" + t52[s6] + "' is not 1");
            (null == a8[i5] || a8[i5] > s6) && 1 === t52[s6] && (n24.push(t52[s6]), r15.push(s6)), a8[i5] <= s6 && i5++;
        }
        1 !== t52[s6] && (n24.push(t52[s6]), r15.push(s6));
    }
    return {
        newShape: n24,
        keptDims: r15
    };
}
function B(t53, e37) {
    var n25 = null;
    if (null == t53 || "float32" === t53) n25 = new Float32Array(e37);
    else if ("int32" === t53) n25 = new Int32Array(e37);
    else {
        if ("bool" !== t53) throw new Error("Unknown data type " + t53);
        n25 = new Uint8Array(e37);
    }
    return n25;
}
function P(t54, e38) {
    var n26 = null;
    if (null == t54 || "float32" === t54) n26 = new Float32Array(e38);
    else if ("int32" === t54) n26 = new Int32Array(e38);
    else if ("bool" === t54) n26 = new Uint8Array(e38);
    else {
        if ("string" !== t54) throw new Error("Unknown data type " + t54);
        n26 = new Array(e38);
    }
    return n26;
}
function L(t55, e39) {
    for(var n27 = 0; n27 < t55.length; n27++){
        var r16 = t55[n27];
        if (isNaN(r16) || !isFinite(r16)) throw Error("A tensor of type " + e39 + " being uploaded contains " + r16 + ".");
    }
}
function W(t56) {
    return "bool" === t56 || "complex64" === t56 || "float32" === t56 || "int32" === t56 || "string" === t56;
}
function U(t57, e40) {
    return "complex64" !== e40 && ("float32" !== e40 || "complex64" === t57) && ("int32" !== e40 || "float32" === t57 || "complex64" === t57) && ("bool" !== e40 || "bool" !== t57);
}
function V(t58) {
    return t58 instanceof Float32Array || t58 instanceof Int32Array || t58 instanceof Uint8Array;
}
function z(t59) {
    if ("float32" === t59 || "int32" === t59) return 4;
    if ("complex64" === t59) return 8;
    if ("bool" === t59) return 1;
    throw new Error("Unknown dtype " + t59);
}
function G(t60) {
    if (null == t60) return 0;
    var e41 = 0;
    return t60.forEach(function(t61) {
        return e41 += t61.length;
    }), e41;
}
function H(t62) {
    return "string" == typeof t62 || t62 instanceof String;
}
function q(t63) {
    return "boolean" == typeof t63;
}
function K(t64) {
    return "number" == typeof t64;
}
function j(t65) {
    return Array.isArray(t65) ? j(t65[0]) : t65 instanceof Float32Array ? "float32" : t65 instanceof Int32Array || t65 instanceof Uint8Array ? "int32" : K(t65) ? "float32" : H(t65) ? "string" : q(t65) ? "bool" : "float32";
}
function X(t66) {
    return !!(t66 && t66.constructor && t66.call && t66.apply);
}
function Y(t67, e42) {
    for(var n28 = e42; n28 < t67; ++n28)if (t67 % n28 == 0) return n28;
    return t67;
}
function $(t68) {
    var e43 = t68.length;
    if (e43 < 2) return [];
    var n29 = new Array(e43 - 1);
    n29[e43 - 2] = t68[e43 - 1];
    for(var r17 = e43 - 3; r17 >= 0; --r17)n29[r17] = n29[r17 + 1] * t68[r17 + 1];
    return n29;
}
function Q(t69, e44, n30) {
    if ("string" === e44) throw new Error("Cannot convert a string[] to a TypedArray");
    if (Array.isArray(t69) && (t69 = I(t69)), n30 && L(t69, e44), (function(t70, e45) {
        return t70 instanceof Float32Array && "float32" === e45 || t70 instanceof Int32Array && "int32" === e45 || t70 instanceof Uint8Array && "bool" === e45;
    })(t69, e44)) return t69;
    if (null == e44 || "float32" === e44 || "complex64" === e44) return new Float32Array(t69);
    if ("int32" === e44) return new Int32Array(t69);
    if ("bool" === e44) {
        for(var r18 = new Uint8Array(t69.length), o8 = 0; o8 < r18.length; ++o8)0 !== Math.round(t69[o8]) && (r18[o8] = 1);
        return r18;
    }
    throw new Error("Unknown data type " + e44);
}
function J(t71, e46) {
    if (0 === t71.length) return e46[0];
    var n31 = t71.reduce(function(t72, e47) {
        return t72 * e47;
    });
    if (0 === n31) return [];
    if (n31 !== e46.length) throw new Error("[" + t71 + "] does not match the input size.");
    return (function t73(e48, n32, r19) {
        var o9 = new Array;
        if (1 === n32.length) for(var a9 = n32[0], i6 = 0; i6 < a9; i6++)o9[i6] = r19[e48 + i6];
        else {
            a9 = n32[0];
            var s7 = n32.slice(1), u2 = s7.reduce(function(t74, e49) {
                return t74 * e49;
            });
            for(i6 = 0; i6 < a9; i6++)o9[i6] = t73(e48 + i6 * u2, s7, r19);
        }
        return o9;
    })(0, t71, e46);
}
function Z(t75, e50) {
    for(var n33 = tt(t75, e50), r20 = 0; r20 < n33.length; r20++)n33[r20] = 1;
    return n33;
}
function tt(t76, e51) {
    if (null == e51 || "float32" === e51 || "complex64" === e51) return new Float32Array(t76);
    if ("int32" === e51) return new Int32Array(t76);
    if ("bool" === e51) return new Uint8Array(t76);
    throw new Error("Unknown data type " + e51);
}
function et() {
    return i().platform.now();
}
function nt(t77) {
    t77.forEach(function(e52) {
        C(Number.isInteger(e52) && e52 >= 0, function() {
            return "Tensor must have a shape comprised of positive integers but got shape [" + t77 + "].";
        });
    });
}
function rt(t78, e53) {
    return void 0 === e53 && (e53 = "utf-8"), e53 = e53 || "utf-8", i().platform.encode(t78, e53);
}
function ot(t79, e54) {
    return void 0 === e54 && (e54 = "utf-8"), e54 = e54 || "utf-8", i().platform.decode(t79, e54);
}
function at(t80, e55, n34) {
    if (0 === e55) return 0;
    if (1 === e55) return t80[0];
    for(var r21 = t80[t80.length - 1], o10 = 0; o10 < t80.length - 1; ++o10)r21 += n34[o10] * t80[o10];
    return r21;
}
function it(t81, e56, n35) {
    if (0 === e56) return [];
    if (1 === e56) return [
        t81
    ];
    for(var r22 = new Array(e56), o11 = 0; o11 < r22.length - 1; ++o11)r22[o11] = Math.floor(t81 / n35[o11]), t81 -= r22[o11] * n35[o11];
    return r22[r22.length - 1] = t81, r22;
}
var st = Object.freeze({
    shuffle: y,
    clamp: x,
    nearestLargerEven: b,
    sum: w,
    randUniform: function(t82, e57) {
        var n36 = Math.random();
        return e57 * n36 + (1 - n36) * t82;
    },
    distSquared: function(t83, e58) {
        for(var n37 = 0, r23 = 0; r23 < t83.length; r23++){
            var o12 = Number(t83[r23]) - Number(e58[r23]);
            n37 += o12 * o12;
        }
        return n37;
    },
    assert: C,
    assertShapesMatch: E,
    assertNonNull: R,
    flatten: I,
    sizeFromShape: k,
    isScalarShape: function(t84) {
        return 0 === t84.length;
    },
    arraysEqual: S,
    isInt: A,
    tanh: T,
    sizeToSquarishShape: D,
    createShuffledIndices: function(t85) {
        for(var e59 = new Uint32Array(t85), n38 = 0; n38 < t85; ++n38)e59[n38] = n38;
        return y(e59), e59;
    },
    rightPad: N,
    repeatedTry: F,
    inferFromImplicitShape: _14,
    parseAxisParam: O,
    squeezeShape: M,
    getTypedArrayFromDType: B,
    getArrayFromDType: P,
    checkConversionForErrors: L,
    isValidDtype: W,
    hasEncodingLoss: U,
    isTypedArray: V,
    bytesPerElement: z,
    bytesFromStringArray: G,
    isString: H,
    isBoolean: q,
    isNumber: K,
    inferDtype: j,
    isFunction: X,
    nearestDivisor: Y,
    computeStrides: $,
    toTypedArray: Q,
    toNestedArray: J,
    makeOnesTypedArray: Z,
    makeZerosTypedArray: tt,
    now: et,
    assertNonNegativeIntegerDimensions: nt,
    fetch: function(t86, e60) {
        return i().platform.fetch(t86, e60);
    },
    encodeString: rt,
    decodeString: ot,
    locToIndex: at,
    indexToLoc: it
}), ut = function() {
    function t87(t88, e61) {
        this.backendTimer = t88, this.logger = e61, null == e61 && (this.logger = new ct);
    }
    return t87.prototype.profileKernel = function(t89, e62, n39) {
        var r24, o13 = this, a10 = this.backendTimer.time(function() {
            r24 = n39();
        });
        return r24.forEach(function(n40) {
            n40.data().then(function(r25) {
                !function(t90, e63, n41) {
                    if ("float32" !== e63) return !1;
                    for(var r26 = 0; r26 < t90.length; r26++){
                        var o14 = t90[r26];
                        if (isNaN(o14) || !isFinite(o14)) return console.warn("Found " + o14 + " in the result of '" + n41 + "'"), !0;
                    }
                }(r25, n40.dtype, t89), a10.then(function(a11) {
                    var i7 = "";
                    null != a11.getExtraProfileInfo && (i7 = a11.getExtraProfileInfo()), o13.logger.logKernelProfile(t89, n40, r25, a11.kernelMs, e62, i7);
                });
            });
        }), r24;
    }, t87;
}();
var ct = function() {
    function t91() {
    }
    return t91.prototype.logKernelProfile = function(t92, e64, n, r27, o15, a12) {
        var i8 = "number" == typeof r27 ? N(r27 + "ms", 9) : r27.error, s8 = N(t92, 25), u3 = e64.rank, c1 = e64.size, l1 = N(e64.shape.toString(), 14), h1 = "";
        for(var f1 in o15){
            var d1 = o15[f1].shape || e64.shape, p1 = d1.length;
            h1 += f1 + ": " + p1 + "D " + (p1 > 0 ? d1 : "") + " ";
        }
        console.log("%c" + s8 + "\t%c" + i8 + "\t%c" + u3 + "D " + l1 + "\t%c" + c1 + "\t%c" + h1 + "\t%c" + a12, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
    }, t91;
}();
var lt = 20, ht = 3, ft = 7;
function dt(t93, e65, n42, r28) {
    var o16 = $(e65), a13 = function(t94, e66, n43, r29) {
        var o17 = k(e66), a14 = r29[r29.length - 1], i10 = new Array(a14).fill(0), s10 = e66.length, u5 = "complex64" === n43 ? gt(t94) : t94;
        if (s10 > 1) for(var c2 = 0; c2 < o17 / a14; c2++)for(var l = c2 * a14, h2 = 0; h2 < a14; h2++)i10[h2] = Math.max(i10[h2], pt(u5[l + h2], 0, n43).length);
        return i10;
    }(t93, e65, n42, o16), i9 = e65.length, s9 = function t95(e67, n44, r30, o18, a15, i11) {
        void 0 === i11 && (i11 = !0);
        var s11 = "complex64" === r30 ? 2 : 1, u6 = n44[0], c3 = n44.length;
        if (0 === c3) return "complex64" === r30 ? [
            pt(gt(e67)[0], 0, r30)
        ] : "bool" === r30 ? [
            vt(e67[0])
        ] : [
            e67[0].toString()
        ];
        if (1 === c3) {
            if (u6 > lt) {
                var l2 = ht * s11, h3 = Array.from(e67.slice(0, l2)), f2 = Array.from(e67.slice((u6 - ht) * s11, u6 * s11));
                return "complex64" === r30 && (h3 = gt(h3), f2 = gt(f2)), [
                    "[" + h3.map(function(t96, e) {
                        return pt(t96, a15[e], r30);
                    }).join(", ") + ", ..., " + f2.map(function(t97, e) {
                        return pt(t97, a15[u6 - ht + e], r30);
                    }).join(", ") + "]"
                ];
            }
            return [
                "[" + ("complex64" === r30 ? gt(e67) : Array.from(e67)).map(function(t98, e) {
                    return pt(t98, a15[e], r30);
                }).join(", ") + "]"
            ];
        }
        var d2 = n44.slice(1), p2 = o18.slice(1), v1 = o18[0] * s11, g1 = [];
        if (u6 > lt) {
            for(var m1 = 0; m1 < ht; m1++){
                var y1 = (x1 = m1 * v1) + v1;
                g1.push.apply(g1, t95(e67.slice(x1, y1), d2, r30, p2, a15, !1));
            }
            g1.push("...");
            for(m1 = u6 - ht; m1 < u6; m1++){
                y1 = (x1 = m1 * v1) + v1;
                g1.push.apply(g1, t95(e67.slice(x1, y1), d2, r30, p2, a15, m1 === u6 - 1));
            }
        } else for(m1 = 0; m1 < u6; m1++){
            var x1;
            y1 = (x1 = m1 * v1) + v1;
            g1.push.apply(g1, t95(e67.slice(x1, y1), d2, r30, p2, a15, m1 === u6 - 1));
        }
        var b1 = 2 === c3 ? "," : "";
        g1[0] = "[" + g1[0] + b1;
        for(m1 = 1; m1 < g1.length - 1; m1++)g1[m1] = " " + g1[m1] + b1;
        var w1 = ",\n";
        for(m1 = 2; m1 < c3; m1++)w1 += "\n";
        return g1[g1.length - 1] = " " + g1[g1.length - 1] + "]" + (i11 ? "" : w1), g1;
    }(t93, e65, n42, o16, a13), u4 = [
        "Tensor"
    ];
    return r28 && (u4.push("  dtype: " + n42), u4.push("  rank: " + i9), u4.push("  shape: [" + e65 + "]"), u4.push("  values:")), u4.push(s9.map(function(t99) {
        return "    " + t99;
    }).join("\n")), u4.join("\n");
}
function pt(t100, e68, n45) {
    return N(Array.isArray(t100) ? parseFloat(t100[0].toFixed(ft)) + " + " + parseFloat(t100[1].toFixed(ft)) + "j" : H(t100) ? "'" + t100 + "'" : "bool" === n45 ? vt(t100) : parseFloat(t100.toFixed(ft)).toString(), e68);
}
function vt(t101) {
    return 0 === t101 ? "false" : "true";
}
function gt(t102) {
    for(var e69 = [], n46 = 0; n46 < t102.length; n46 += 2)e69.push([
        t102[n46],
        t102[n46 + 1]
    ]);
    return e69;
}
var mt = function() {
    function t103(t104, e70, n47) {
        var r31 = this;
        if (this.dtype = e70, this.shape = t104.slice(), this.size = k(t104), null != n47) {
            var o19 = n47.length;
            C(o19 === this.size, function() {
                return "Length of values '" + o19 + "' does not match the size inferred by the shape '" + r31.size + "'.";
            });
        }
        if ("complex64" === e70) throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
        this.values = n47 || P(e70, this.size), this.strides = $(t104);
    }
    return t103.prototype.set = function(t105) {
        for(var e71 = this, n48 = [], r32 = 1; r32 < arguments.length; r32++)n48[r32 - 1] = arguments[r32];
        0 === n48.length && (n48 = [
            0
        ]), C(n48.length === this.rank, function() {
            return "The number of provided coordinates (" + n48.length + ") must match the rank (" + e71.rank + ")";
        });
        var o = this.locToIndex(n48);
        this.values[o] = t105;
    }, t103.prototype.get = function() {
        for(var t106 = [], e72 = 0; e72 < arguments.length; e72++)t106[e72] = arguments[e72];
        0 === t106.length && (t106 = [
            0
        ]);
        for(var n49 = 0, r33 = 0, o20 = t106; r33 < o20.length; r33++){
            var a16 = o20[r33];
            if (a16 < 0 || a16 >= this.shape[n49]) {
                var i12 = "Requested out of range element at " + t106 + ".   Buffer shape=" + this.shape;
                throw new Error(i12);
            }
            n49++;
        }
        for(var s12 = t106[t106.length - 1], u7 = 0; u7 < t106.length - 1; ++u7)s12 += this.strides[u7] * t106[u7];
        return this.values[s12];
    }, t103.prototype.locToIndex = function(t107) {
        if (0 === this.rank) return 0;
        if (1 === this.rank) return t107[0];
        for(var e73 = t107[t107.length - 1], n50 = 0; n50 < t107.length - 1; ++n50)e73 += this.strides[n50] * t107[n50];
        return e73;
    }, t103.prototype.indexToLoc = function(t108) {
        if (0 === this.rank) return [];
        if (1 === this.rank) return [
            t108
        ];
        for(var e74 = new Array(this.shape.length), n51 = 0; n51 < e74.length - 1; ++n51)e74[n51] = Math.floor(t108 / this.strides[n51]), t108 -= e74[n51] * this.strides[n51];
        return e74[e74.length - 1] = t108, e74;
    }, Object.defineProperty(t103.prototype, "rank", {
        get: function() {
            return this.shape.length;
        },
        enumerable: !0,
        configurable: !0
    }), t103.prototype.toTensor = function() {
        return yt().makeTensor(this.values, this.shape, this.dtype);
    }, t103;
}(), yt = null, xt = null, bt = null;
var wt = function() {
    function t109(t110, e75, n52, r34) {
        this.kept = !1, this.isDisposedInternal = !1, this.shape = t110.slice(), this.dtype = e75 || "float32", this.size = k(t110), this.strides = $(t110), this.dataId = n52, this.id = r34, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
    }
    return t109.prototype.flatten = function() {
        return this.throwIfDisposed(), this.as1D();
    }, t109.prototype.asScalar = function() {
        return this.throwIfDisposed(), C(1 === this.size, function() {
            return "The array must have only 1 element.";
        }), this.reshape([]);
    }, t109.prototype.as1D = function() {
        return this.throwIfDisposed(), this.reshape([
            this.size
        ]);
    }, t109.prototype.as2D = function(t111, e76) {
        return this.throwIfDisposed(), this.reshape([
            t111,
            e76
        ]);
    }, t109.prototype.as3D = function(t112, e77, n53) {
        return this.throwIfDisposed(), this.reshape([
            t112,
            e77,
            n53
        ]);
    }, t109.prototype.as4D = function(t113, e78, n54, r35) {
        return this.throwIfDisposed(), this.reshape([
            t113,
            e78,
            n54,
            r35
        ]);
    }, t109.prototype.as5D = function(t114, e79, n55, r36, o21) {
        return this.throwIfDisposed(), this.reshape([
            t114,
            e79,
            n55,
            r36,
            o21
        ]);
    }, t109.prototype.asType = function(t115) {
        return this.throwIfDisposed(), xt.cast(this, t115);
    }, Object.defineProperty(t109.prototype, "rank", {
        get: function() {
            return this.shape.length;
        },
        enumerable: !0,
        configurable: !0
    }), t109.prototype.buffer = function() {
        return n(this, void 0, void 0, function() {
            var t116;
            return r(this, function(e80) {
                switch(e80.label){
                    case 0:
                        return [
                            4,
                            this.data()
                        ];
                    case 1:
                        return t116 = e80.sent(), [
                            2,
                            xt.buffer(this.shape, this.dtype, t116)
                        ];
                }
            });
        });
    }, t109.prototype.bufferSync = function() {
        return xt.buffer(this.shape, this.dtype, this.dataSync());
    }, t109.prototype.array = function() {
        return n(this, void 0, void 0, function() {
            var t117;
            return r(this, function(e81) {
                switch(e81.label){
                    case 0:
                        return [
                            4,
                            this.data()
                        ];
                    case 1:
                        return t117 = e81.sent(), [
                            2,
                            J(this.shape, t117)
                        ];
                }
            });
        });
    }, t109.prototype.arraySync = function() {
        return J(this.shape, this.dataSync());
    }, t109.prototype.data = function() {
        return n(this, void 0, void 0, function() {
            var t118, e82;
            return r(this, function(n56) {
                switch(n56.label){
                    case 0:
                        return this.throwIfDisposed(), t118 = yt().read(this.dataId), "string" !== this.dtype ? [
                            3,
                            2
                        ] : [
                            4,
                            t118
                        ];
                    case 1:
                        e82 = n56.sent();
                        try {
                            return [
                                2,
                                e82.map(function(t119) {
                                    return ot(t119);
                                })
                            ];
                        } catch (t) {
                            throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
                        }
                        n56.label = 2;
                    case 2:
                        return [
                            2,
                            t118
                        ];
                }
            });
        });
    }, t109.prototype.dataSync = function() {
        this.throwIfDisposed();
        var t120 = yt().readSync(this.dataId);
        if ("string" === this.dtype) try {
            return t120.map(function(t121) {
                return ot(t121);
            });
        } catch (t) {
            throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
        return t120;
    }, t109.prototype.bytes = function() {
        return n(this, void 0, void 0, function() {
            var t122;
            return r(this, function(e83) {
                switch(e83.label){
                    case 0:
                        return this.throwIfDisposed(), [
                            4,
                            yt().read(this.dataId)
                        ];
                    case 1:
                        return t122 = e83.sent(), "string" === this.dtype ? [
                            2,
                            t122
                        ] : [
                            2,
                            new Uint8Array(t122.buffer)
                        ];
                }
            });
        });
    }, t109.prototype.dispose = function() {
        this.isDisposed || (yt().disposeTensor(this), this.isDisposedInternal = !0);
    }, Object.defineProperty(t109.prototype, "isDisposed", {
        get: function() {
            return this.isDisposedInternal;
        },
        enumerable: !0,
        configurable: !0
    }), t109.prototype.throwIfDisposed = function() {
        if (this.isDisposed) throw new Error("Tensor is disposed.");
    }, t109.prototype.toFloat = function() {
        return this.asType("float32");
    }, t109.prototype.toInt = function() {
        return this.asType("int32");
    }, t109.prototype.toBool = function() {
        return this.asType("bool");
    }, t109.prototype.print = function(t123) {
        return void 0 === t123 && (t123 = !1), xt.print(this, t123);
    }, t109.prototype.reshape = function(t124) {
        return this.throwIfDisposed(), xt.reshape(this, t124);
    }, t109.prototype.reshapeAs = function(t125) {
        return this.throwIfDisposed(), this.reshape(t125.shape);
    }, t109.prototype.expandDims = function(t126) {
        return void 0 === t126 && (t126 = 0), xt.expandDims(this, t126);
    }, t109.prototype.cumsum = function(t127, e84, n57) {
        return void 0 === t127 && (t127 = 0), void 0 === e84 && (e84 = !1), void 0 === n57 && (n57 = !1), xt.cumsum(this, t127, e84, n57);
    }, t109.prototype.squeeze = function(t128) {
        return this.throwIfDisposed(), xt.squeeze(this, t128);
    }, t109.prototype.clone = function() {
        return this.throwIfDisposed(), xt.clone(this);
    }, t109.prototype.toString = function(t129) {
        return void 0 === t129 && (t129 = !1), dt(this.dataSync(), this.shape, this.dtype, t129);
    }, t109.prototype.gather = function(t130, e85) {
        return void 0 === e85 && (e85 = 0), this.throwIfDisposed(), xt.gather(this, t130, e85);
    }, t109.prototype.matMul = function(t131, e86, n58) {
        return void 0 === e86 && (e86 = !1), void 0 === n58 && (n58 = !1), this.throwIfDisposed(), xt.matMul(this, t131, e86, n58);
    }, t109.prototype.dot = function(t132) {
        return this.throwIfDisposed(), xt.dot(this, t132);
    }, t109.prototype.norm = function(t133, e87, n59) {
        return void 0 === t133 && (t133 = "euclidean"), void 0 === e87 && (e87 = null), void 0 === n59 && (n59 = !1), this.throwIfDisposed(), xt.norm(this, t133, e87, n59);
    }, t109.prototype.slice = function(t134, e88) {
        return this.throwIfDisposed(), xt.slice(this, t134, e88);
    }, t109.prototype.reverse = function(t135) {
        return this.throwIfDisposed(), xt.reverse(this, t135);
    }, t109.prototype.concat = function(e89, n60) {
        return void 0 === n60 && (n60 = 0), this.throwIfDisposed(), e89 instanceof t109 && (e89 = [
            e89
        ]), xt.concat([
            this
        ].concat(e89), n60);
    }, t109.prototype.split = function(t136, e90) {
        return void 0 === e90 && (e90 = 0), this.throwIfDisposed(), xt.split(this, t136, e90);
    }, t109.prototype.stack = function(t137, e91) {
        return void 0 === e91 && (e91 = 0), xt.stack([
            this,
            t137
        ], e91);
    }, t109.prototype.unstack = function(t138) {
        return void 0 === t138 && (t138 = 0), xt.unstack(this, t138);
    }, t109.prototype.batchNormalization = function(t139, e92, n61, r37, o22) {
        return void 0 === n61 && (n61 = 0.001), bt("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"), this.batchNorm(t139, e92, o22, r37, n61);
    }, t109.prototype.all = function(t140, e93) {
        return void 0 === t140 && (t140 = null), void 0 === e93 && (e93 = !1), this.throwIfDisposed(), xt.all(this, t140, e93);
    }, t109.prototype.any = function(t141, e94) {
        return void 0 === t141 && (t141 = null), void 0 === e94 && (e94 = !1), this.throwIfDisposed(), xt.any(this, t141, e94);
    }, t109.prototype.logSumExp = function(t142, e95) {
        return void 0 === t142 && (t142 = null), void 0 === e95 && (e95 = !1), this.throwIfDisposed(), xt.logSumExp(this, t142, e95);
    }, t109.prototype.sum = function(t143, e96) {
        return void 0 === t143 && (t143 = null), void 0 === e96 && (e96 = !1), this.throwIfDisposed(), xt.sum(this, t143, e96);
    }, t109.prototype.prod = function(t144, e97) {
        return void 0 === t144 && (t144 = null), void 0 === e97 && (e97 = !1), this.throwIfDisposed(), xt.prod(this, t144, e97);
    }, t109.prototype.mean = function(t145, e98) {
        return void 0 === t145 && (t145 = null), void 0 === e98 && (e98 = !1), this.throwIfDisposed(), xt.mean(this, t145, e98);
    }, t109.prototype.min = function(t146, e99) {
        return void 0 === t146 && (t146 = null), void 0 === e99 && (e99 = !1), this.throwIfDisposed(), xt.min(this, t146, e99);
    }, t109.prototype.max = function(t147, e100) {
        return void 0 === t147 && (t147 = null), void 0 === e100 && (e100 = !1), this.throwIfDisposed(), xt.max(this, t147, e100);
    }, t109.prototype.argMin = function(t148) {
        return void 0 === t148 && (t148 = null), this.throwIfDisposed(), xt.argMin(this, t148);
    }, t109.prototype.argMax = function(t149) {
        return void 0 === t149 && (t149 = null), this.throwIfDisposed(), xt.argMax(this, t149);
    }, t109.prototype.cast = function(t150) {
        return this.throwIfDisposed(), xt.cast(this, t150);
    }, t109.prototype.addStrict = function(t151) {
        return this.throwIfDisposed(), xt.addStrict(this, t151);
    }, t109.prototype.atan2 = function(t152) {
        return this.throwIfDisposed(), xt.atan2(this, t152);
    }, t109.prototype.sub = function(t153) {
        return this.throwIfDisposed(), xt.sub(this, t153);
    }, t109.prototype.subStrict = function(t154) {
        return this.throwIfDisposed(), xt.subStrict(this, t154);
    }, t109.prototype.pow = function(t155) {
        return this.throwIfDisposed(), xt.pow(this, t155);
    }, t109.prototype.powStrict = function(t156) {
        return this.throwIfDisposed(), xt.powStrict(this, t156);
    }, t109.prototype.mul = function(t157) {
        return this.throwIfDisposed(), xt.mul(this, t157);
    }, t109.prototype.mulStrict = function(t158) {
        return this.throwIfDisposed(), xt.mulStrict(this, t158);
    }, t109.prototype.floorDiv = function(t159) {
        return this.throwIfDisposed(), xt.floorDiv(this, t159);
    }, t109.prototype.divStrict = function(t160) {
        return this.throwIfDisposed(), xt.divStrict(this, t160);
    }, t109.prototype.minimum = function(t161) {
        return this.throwIfDisposed(), xt.minimum(this, t161);
    }, t109.prototype.minimumStrict = function(t162) {
        return this.throwIfDisposed(), xt.minimumStrict(this, t162);
    }, t109.prototype.maximum = function(t163) {
        return this.throwIfDisposed(), xt.maximum(this, t163);
    }, t109.prototype.maximumStrict = function(t164) {
        return this.throwIfDisposed(), xt.maximumStrict(this, t164);
    }, t109.prototype.mod = function(t165) {
        return this.throwIfDisposed(), xt.mod(this, t165);
    }, t109.prototype.modStrict = function(t166) {
        return this.throwIfDisposed(), xt.modStrict(this, t166);
    }, t109.prototype.squaredDifferenceStrict = function(t167) {
        return this.throwIfDisposed(), xt.squaredDifferenceStrict(this, t167);
    }, t109.prototype.notEqual = function(t168) {
        return this.throwIfDisposed(), xt.notEqual(this, t168);
    }, t109.prototype.notEqualStrict = function(t169) {
        return this.throwIfDisposed(), xt.notEqualStrict(this, t169);
    }, t109.prototype.less = function(t170) {
        return this.throwIfDisposed(), xt.less(this, t170);
    }, t109.prototype.lessStrict = function(t171) {
        return this.throwIfDisposed(), xt.lessStrict(this, t171);
    }, t109.prototype.equal = function(t172) {
        return this.throwIfDisposed(), xt.equal(this, t172);
    }, t109.prototype.equalStrict = function(t173) {
        return this.throwIfDisposed(), xt.equalStrict(this, t173);
    }, t109.prototype.lessEqual = function(t174) {
        return this.throwIfDisposed(), xt.lessEqual(this, t174);
    }, t109.prototype.lessEqualStrict = function(t175) {
        return this.throwIfDisposed(), xt.lessEqualStrict(this, t175);
    }, t109.prototype.greater = function(t176) {
        return this.throwIfDisposed(), xt.greater(this, t176);
    }, t109.prototype.greaterStrict = function(t177) {
        return this.throwIfDisposed(), xt.greaterStrict(this, t177);
    }, t109.prototype.greaterEqual = function(t178) {
        return this.throwIfDisposed(), xt.greaterEqual(this, t178);
    }, t109.prototype.greaterEqualStrict = function(t179) {
        return this.throwIfDisposed(), xt.greaterEqualStrict(this, t179);
    }, t109.prototype.logicalAnd = function(t180) {
        return this.throwIfDisposed(), xt.logicalAnd(this, t180);
    }, t109.prototype.logicalOr = function(t181) {
        return this.throwIfDisposed(), xt.logicalOr(this, t181);
    }, t109.prototype.logicalNot = function() {
        return this.throwIfDisposed(), xt.logicalNot(this);
    }, t109.prototype.logicalXor = function(t182) {
        return this.throwIfDisposed(), xt.logicalXor(this, t182);
    }, t109.prototype.where = function(t183, e101) {
        return this.throwIfDisposed(), xt.where(t183, this, e101);
    }, t109.prototype.neg = function() {
        return this.throwIfDisposed(), xt.neg(this);
    }, t109.prototype.ceil = function() {
        return this.throwIfDisposed(), xt.ceil(this);
    }, t109.prototype.floor = function() {
        return this.throwIfDisposed(), xt.floor(this);
    }, t109.prototype.sign = function() {
        return this.throwIfDisposed(), xt.sign(this);
    }, t109.prototype.isNaN = function() {
        return this.throwIfDisposed(), xt.isNaN(this);
    }, t109.prototype.isInf = function() {
        return this.throwIfDisposed(), xt.isInf(this);
    }, t109.prototype.isFinite = function() {
        return this.throwIfDisposed(), xt.isFinite(this);
    }, t109.prototype.exp = function() {
        return this.throwIfDisposed(), xt.exp(this);
    }, t109.prototype.expm1 = function() {
        return this.throwIfDisposed(), xt.expm1(this);
    }, t109.prototype.log = function() {
        return this.throwIfDisposed(), xt.log(this);
    }, t109.prototype.log1p = function() {
        return this.throwIfDisposed(), xt.log1p(this);
    }, t109.prototype.sqrt = function() {
        return this.throwIfDisposed(), xt.sqrt(this);
    }, t109.prototype.rsqrt = function() {
        return this.throwIfDisposed(), xt.rsqrt(this);
    }, t109.prototype.square = function() {
        return this.throwIfDisposed(), xt.square(this);
    }, t109.prototype.reciprocal = function() {
        return this.throwIfDisposed(), xt.reciprocal(this);
    }, t109.prototype.abs = function() {
        return this.throwIfDisposed(), xt.abs(this);
    }, t109.prototype.clipByValue = function(t184, e102) {
        return this.throwIfDisposed(), xt.clipByValue(this, t184, e102);
    }, t109.prototype.relu = function() {
        return this.throwIfDisposed(), xt.relu(this);
    }, t109.prototype.relu6 = function() {
        return this.throwIfDisposed(), xt.relu6(this);
    }, t109.prototype.elu = function() {
        return this.throwIfDisposed(), xt.elu(this);
    }, t109.prototype.selu = function() {
        return this.throwIfDisposed(), xt.selu(this);
    }, t109.prototype.leakyRelu = function(t185) {
        return void 0 === t185 && (t185 = 0.2), this.throwIfDisposed(), xt.leakyRelu(this, t185);
    }, t109.prototype.prelu = function(t186) {
        return this.throwIfDisposed(), xt.prelu(this, t186);
    }, t109.prototype.sigmoid = function() {
        return this.throwIfDisposed(), xt.sigmoid(this);
    }, t109.prototype.logSigmoid = function() {
        return this.throwIfDisposed(), xt.logSigmoid(this);
    }, t109.prototype.softplus = function() {
        return this.throwIfDisposed(), xt.softplus(this);
    }, t109.prototype.zerosLike = function() {
        return this.throwIfDisposed(), xt.zerosLike(this);
    }, t109.prototype.onesLike = function() {
        return this.throwIfDisposed(), xt.onesLike(this);
    }, t109.prototype.sin = function() {
        return this.throwIfDisposed(), xt.sin(this);
    }, t109.prototype.cos = function() {
        return this.throwIfDisposed(), xt.cos(this);
    }, t109.prototype.tan = function() {
        return this.throwIfDisposed(), xt.tan(this);
    }, t109.prototype.asin = function() {
        return this.throwIfDisposed(), xt.asin(this);
    }, t109.prototype.acos = function() {
        return this.throwIfDisposed(), xt.acos(this);
    }, t109.prototype.atan = function() {
        return this.throwIfDisposed(), xt.atan(this);
    }, t109.prototype.sinh = function() {
        return this.throwIfDisposed(), xt.sinh(this);
    }, t109.prototype.cosh = function() {
        return this.throwIfDisposed(), xt.cosh(this);
    }, t109.prototype.tanh = function() {
        return this.throwIfDisposed(), xt.tanh(this);
    }, t109.prototype.asinh = function() {
        return this.throwIfDisposed(), xt.asinh(this);
    }, t109.prototype.acosh = function() {
        return this.throwIfDisposed(), xt.acosh(this);
    }, t109.prototype.atanh = function() {
        return this.throwIfDisposed(), xt.atanh(this);
    }, t109.prototype.erf = function() {
        return this.throwIfDisposed(), xt.erf(this);
    }, t109.prototype.round = function() {
        return this.throwIfDisposed(), xt.round(this);
    }, t109.prototype.step = function(t187) {
        return void 0 === t187 && (t187 = 0), this.throwIfDisposed(), xt.step(this, t187);
    }, t109.prototype.softmax = function(t188) {
        return void 0 === t188 && (t188 = -1), this.throwIfDisposed(), xt.softmax(this, t188);
    }, t109.prototype.logSoftmax = function(t189) {
        return void 0 === t189 && (t189 = -1), this.throwIfDisposed(), xt.logSoftmax(this, t189);
    }, t109.prototype.resizeBilinear = function(t190, e103) {
        return void 0 === e103 && (e103 = !1), this.throwIfDisposed(), xt.image.resizeBilinear(this, t190, e103);
    }, t109.prototype.resizeNearestNeighbor = function(t191, e104) {
        return void 0 === e104 && (e104 = !1), this.throwIfDisposed(), xt.image.resizeNearestNeighbor(this, t191, e104);
    }, t109.prototype.conv1d = function(t192, e105, n62, r38, o23, a17) {
        return void 0 === r38 && (r38 = "NWC"), void 0 === o23 && (o23 = 1), this.throwIfDisposed(), xt.conv1d(this, t192, e105, n62, r38, o23, a17);
    }, t109.prototype.conv2d = function(t193, e106, n63, r39, o24, a18) {
        return void 0 === r39 && (r39 = "NHWC"), void 0 === o24 && (o24 = [
            1,
            1
        ]), this.throwIfDisposed(), xt.conv2d(this, t193, e106, n63, r39, o24, a18);
    }, t109.prototype.conv2dTranspose = function(t194, e107, n64, r40, o25) {
        return this.throwIfDisposed(), xt.conv2dTranspose(this, t194, e107, n64, r40, o25);
    }, t109.prototype.depthwiseConv2D = function(t195, e108, n65, r41, o26, a19) {
        return void 0 === r41 && (r41 = "NHWC"), void 0 === o26 && (o26 = [
            1,
            1
        ]), this.throwIfDisposed(), xt.depthwiseConv2d(this, t195, e108, n65, r41, o26, a19);
    }, t109.prototype.separableConv2d = function(t196, e109, n66, r42, o27, a20) {
        return void 0 === o27 && (o27 = [
            1,
            1
        ]), void 0 === a20 && (a20 = "NHWC"), this.throwIfDisposed(), xt.separableConv2d(this, t196, e109, n66, r42, o27, a20);
    }, t109.prototype.avgPool = function(t197, e110, n67, r43) {
        return this.throwIfDisposed(), xt.avgPool(this, t197, e110, n67, r43);
    }, t109.prototype.maxPool = function(t198, e111, n68, r44) {
        return this.throwIfDisposed(), xt.maxPool(this, t198, e111, n68, r44);
    }, t109.prototype.localResponseNormalization = function(t199, e112, n69, r45) {
        return void 0 === t199 && (t199 = 5), void 0 === e112 && (e112 = 1), void 0 === n69 && (n69 = 1), void 0 === r45 && (r45 = 0.5), xt.localResponseNormalization(this, t199, e112, n69, r45);
    }, t109.prototype.pool = function(t200, e113, n70, r46, o28) {
        return this.throwIfDisposed(), xt.pool(this, t200, e113, n70, r46, o28);
    }, t109.prototype.variable = function(t201, e114, n71) {
        return void 0 === t201 && (t201 = !0), this.throwIfDisposed(), yt().makeVariable(this, t201, e114, n71);
    }, t109.prototype.unsortedSegmentSum = function(t202, e115) {
        return this.throwIfDisposed(), xt.unsortedSegmentSum(this, t202, e115);
    }, t109.prototype.batchToSpaceND = function(t203, e116) {
        return this.throwIfDisposed(), xt.batchToSpaceND(this, t203, e116);
    }, t109.prototype.spaceToBatchND = function(t204, e117) {
        return this.throwIfDisposed(), xt.spaceToBatchND(this, t204, e117);
    }, t109.prototype.topk = function(t205, e118) {
        return void 0 === t205 && (t205 = 1), void 0 === e118 && (e118 = !0), this.throwIfDisposed(), xt.topk(this, t205, e118);
    }, t109.prototype.stridedSlice = function(t206, e119, n72, r47, o29, a21, i13, s13) {
        return void 0 === r47 && (r47 = 0), void 0 === o29 && (o29 = 0), void 0 === a21 && (a21 = 0), void 0 === i13 && (i13 = 0), void 0 === s13 && (s13 = 0), this.throwIfDisposed(), xt.stridedSlice(this, t206, e119, n72, r47, o29, a21, i13, s13);
    }, t109.prototype.depthToSpace = function(t207, e120) {
        return this.throwIfDisposed(), xt.depthToSpace(this, t207, e120);
    }, t109.prototype.fft = function() {
        return this.throwIfDisposed(), xt.spectral.fft(this);
    }, t109.prototype.ifft = function() {
        return this.throwIfDisposed(), xt.spectral.ifft(this);
    }, t109.prototype.rfft = function() {
        return this.throwIfDisposed(), xt.spectral.rfft(this);
    }, t109.prototype.irfft = function() {
        return this.throwIfDisposed(), xt.spectral.irfft(this);
    }, t109;
}();
Object.defineProperty(wt, Symbol.hasInstance, {
    value: function(t208) {
        return !!t208 && null != t208.dataId && null != t208.shape && null != t208.dtype;
    }
});
var Ct, Et, Rt, It, kt, St = function(t209) {
    function n73(e121, n74, r48, o30) {
        var a22 = t209.call(this, e121.shape, e121.dtype, e121.dataId, o30) || this;
        return a22.trainable = n74, a22.name = r48, a22;
    }
    return e(n73, t209), n73.prototype.assign = function(t210) {
        if (t210.dtype !== this.dtype) throw new Error("dtype of the new value (" + t210.dtype + ") and previous value (" + this.dtype + ") must match");
        if (!S(t210.shape, this.shape)) throw new Error("shape of the new value (" + t210.shape + ") and previous value (" + this.shape + ") must match");
        yt().disposeTensor(this), this.dataId = t210.dataId, yt().incRef(this, null);
    }, n73.prototype.dispose = function() {
        yt().disposeVariable(this), this.isDisposedInternal = !0;
    }, n73;
}(wt);
Object.defineProperty(St, Symbol.hasInstance, {
    value: function(t211) {
        return t211 instanceof wt && null != t211.assign && t211.assign instanceof Function;
    }
}), (function(t212) {
    t212.R0 = "R0", t212.R1 = "R1", t212.R2 = "R2", t212.R3 = "R3", t212.R4 = "R4", t212.R5 = "R5", t212.R6 = "R6";
})(Ct || (Ct = {
})), (function(t213) {
    t213.float32 = "float32", t213.int32 = "int32", t213.bool = "int32", t213.complex64 = "complex64";
})(Et || (Et = {
})), (function(t214) {
    t214.float32 = "float32", t214.int32 = "int32", t214.bool = "bool", t214.complex64 = "complex64";
})(Rt || (Rt = {
})), (function(t215) {
    t215.float32 = "float32", t215.int32 = "float32", t215.bool = "float32", t215.complex64 = "complex64";
})(It || (It = {
})), (function(t216) {
    t216.float32 = "complex64", t216.int32 = "complex64", t216.bool = "complex64", t216.complex64 = "complex64";
})(kt || (kt = {
}));
var At = {
    float32: It,
    int32: Et,
    bool: Rt,
    complex64: kt
};
function Tt(t217, e122) {
    if ("string" === t217 || "string" === e122) {
        if ("string" === t217 && "string" === e122) return "string";
        throw new Error("Can not upcast " + t217 + " with " + e122);
    }
    return At[t217][e122];
}
function Dt(t218) {
    return Tt(t218, "int32");
}
function Nt(t219, e123) {
    if (t219.dtype === e123.dtype) return [
        t219,
        e123
    ];
    var n75 = Tt(t219.dtype, e123.dtype);
    return [
        t219.cast(n75),
        e123.cast(n75)
    ];
}
function Ft(t220, e124) {
    C(t220.dtype === e124.dtype, function() {
        return "The dtypes of the first(" + t220.dtype + ") and second(" + e124.dtype + ") input must match";
    });
}
function _t(t221) {
    var e125 = [];
    return (function t222(e126, n76, r49) {
        if (null == e126) return;
        if (e126 instanceof wt) return void n76.push(e126);
        if (o31 = e126, !Array.isArray(o31) && "object" != typeof o31) return;
        var o31;
        var a23 = e126;
        for(var i in a23){
            var s14 = a23[i];
            r49.has(s14) || (r49.add(s14), t222(s14, n76, r49));
        }
    })(t221, e125, new Set), e125;
}
var Ot, Mt = Object.freeze({
    makeTypesMatch: Nt,
    assertTypesMatch: Ft,
    isTensorInList: function(t223, e127) {
        return e127.some(function(e128) {
            return e128.id === t223.id;
        });
    },
    getTensorsInContainer: _t
}), Bt = function() {
    function t224() {
        this.registeredVariables = {
        }, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap, this.profiling = !1, this.activeProfile = {
            newBytes: 0,
            newTensors: 0,
            peakBytes: 0,
            kernels: [],
            result: null
        };
    }
    return t224.prototype.dispose = function() {
        for(var t in this.registeredVariables)this.registeredVariables[t].dispose();
    }, t224;
}(), Pt = function() {
    function t225(t226) {
        this.ENV = t226, this.registry = {
        }, this.registryFactory = {
        }, this.pendingBackendInitId = 0, this.state = new Bt;
    }
    return t225.prototype.ready = function() {
        return n(this, void 0, void 0, function() {
            var t227, e129, n77;
            return r(this, function(r50) {
                switch(r50.label){
                    case 0:
                        if (null != this.pendingBackendInit) return [
                            2,
                            this.pendingBackendInit.then(function() {
                            })
                        ];
                        if (null != this.backendInstance) return [
                            2
                        ];
                        t227 = this.getSortedBackends(), e129 = 0, r50.label = 1;
                    case 1:
                        return e129 < t227.length ? (n77 = t227[e129], [
                            4,
                            this.initializeBackend(n77).success
                        ]) : [
                            3,
                            5
                        ];
                    case 2:
                        return r50.sent() ? [
                            4,
                            this.setBackend(n77)
                        ] : [
                            3,
                            4
                        ];
                    case 3:
                        return r50.sent(), [
                            2
                        ];
                    case 4:
                        return e129++, [
                            3,
                            1
                        ];
                    case 5:
                        throw new Error("Could not initialize any backends, all backend initializations failed.");
                }
            });
        });
    }, Object.defineProperty(t225.prototype, "backend", {
        get: function() {
            if (null != this.pendingBackendInit) throw new Error("Backend '" + this.backendName + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
            if (null == this.backendInstance) {
                var t228 = this.initializeBackendsAndReturnBest(), e130 = t228.name;
                if (t228.asyncInit) throw new Error("The highest priority backend '" + e130 + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
                this.setBackend(e130);
            }
            return this.backendInstance;
        },
        enumerable: !0,
        configurable: !0
    }), t225.prototype.backendNames = function() {
        return Object.keys(this.registryFactory);
    }, t225.prototype.findBackend = function(t229) {
        if (!(t229 in this.registry)) {
            if (!(t229 in this.registryFactory)) return null;
            if (this.initializeBackend(t229).asyncInit) return null;
        }
        return this.registry[t229];
    }, t225.prototype.findBackendFactory = function(t230) {
        return t230 in this.registryFactory ? this.registryFactory[t230].factory : null;
    }, t225.prototype.registerBackend = function(t231, e131, n78) {
        return void 0 === n78 && (n78 = 1), t231 in this.registryFactory ? (console.warn(t231 + " backend was already registered. Reusing existing backend factory."), !1) : (this.registryFactory[t231] = {
            factory: e131,
            priority: n78
        }, !0);
    }, t225.prototype.setBackend = function(t232) {
        return n(this, void 0, void 0, function() {
            var e132, n79, o32;
            return r(this, function(r51) {
                switch(r51.label){
                    case 0:
                        if (null == this.registryFactory[t232]) throw new Error("Backend name '" + t232 + "' not found in registry");
                        return this.backendName = t232, null != this.registry[t232] ? [
                            3,
                            4
                        ] : (this.backendInstance = null, e132 = this.initializeBackend(t232), n79 = e132.success, e132.asyncInit ? [
                            4,
                            n79
                        ] : [
                            3,
                            2
                        ]);
                    case 1:
                        return o32 = r51.sent(), [
                            3,
                            3
                        ];
                    case 2:
                        o32 = n79, r51.label = 3;
                    case 3:
                        if (!o32) return [
                            2,
                            !1
                        ];
                        r51.label = 4;
                    case 4:
                        return this.backendInstance = this.registry[t232], this.setupRegisteredKernels(), this.profiler = new ut(this.backendInstance), [
                            2,
                            !0
                        ];
                }
            });
        });
    }, t225.prototype.setupRegisteredKernels = function() {
        var t233 = this;
        f(this.backendName).forEach(function(e133) {
            null != e133.setupFunc && e133.setupFunc(t233.backendInstance);
        });
    }, t225.prototype.disposeRegisteredKernels = function(t234) {
        var e134 = this;
        f(t234).forEach(function(n80) {
            null != n80.disposeFunc && n80.disposeFunc(e134.registry[t234]);
        });
    }, t225.prototype.initializeBackend = function(t235) {
        var e135 = this, n81 = this.registryFactory[t235];
        if (null == n81) throw new Error("Cannot initialize backend " + t235 + ", no registration found.");
        try {
            var r52 = n81.factory();
            if (Promise.resolve(r52) === r52) {
                var o33 = ++this.pendingBackendInitId, a24 = r52.then(function(n82) {
                    return !(o33 < e135.pendingBackendInitId) && (e135.registry[t235] = n82, e135.pendingBackendInit = null, !0);
                }).catch(function(n83) {
                    return !(o33 < e135.pendingBackendInitId) && (e135.pendingBackendInit = null, console.warn("Initialization of backend " + t235 + " failed"), console.warn(n83.stack || n83.message), !1);
                });
                return this.pendingBackendInit = a24, {
                    success: a24,
                    asyncInit: !0
                };
            }
            return this.registry[t235] = r52, {
                success: !0,
                asyncInit: !1
            };
        } catch (e136) {
            return console.warn("Initialization of backend " + t235 + " failed"), console.warn(e136.stack || e136.message), {
                success: !1,
                asyncInit: !1
            };
        }
    }, t225.prototype.removeBackend = function(t236) {
        if (!(t236 in this.registryFactory)) throw new Error(t236 + " backend not found in registry");
        this.backendName === t236 && null != this.pendingBackendInit && this.pendingBackendInitId++, t236 in this.registry && (this.disposeRegisteredKernels(t236), this.registry[t236].dispose(), delete this.registry[t236]), delete this.registryFactory[t236], this.backendName === t236 && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
    }, t225.prototype.getSortedBackends = function() {
        var t237 = this;
        if (0 === Object.keys(this.registryFactory).length) throw new Error("No backend found in registry.");
        return Object.keys(this.registryFactory).sort(function(e, n) {
            return t237.registryFactory[n].priority - t237.registryFactory[e].priority;
        });
    }, t225.prototype.initializeBackendsAndReturnBest = function() {
        for(var t238 = this.getSortedBackends(), e137 = 0; e137 < t238.length; e137++){
            var n84 = t238[e137], r53 = this.initializeBackend(n84), o34 = r53.success, a25 = r53.asyncInit;
            if (a25 || o34) return {
                name: n84,
                asyncInit: a25
            };
        }
        throw new Error("Could not initialize any backends, all backend initializations failed.");
    }, t225.prototype.moveData = function(t239, e138) {
        var n85 = this.state.tensorInfo.get(e138), r54 = n85.backend, o35 = this.readSync(e138);
        r54.disposeData(e138), n85.backend = t239, t239.move(e138, o35, n85.shape, n85.dtype), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
    }, t225.prototype.tidy = function(t240, e139) {
        var n86, r55 = this, o36 = null;
        if (null == e139) {
            if ("function" != typeof t240) throw new Error("Please provide a function to tidy()");
            e139 = t240;
        } else {
            if ("string" != typeof t240 && !(t240 instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
            if ("function" != typeof e139) throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
            o36 = t240;
        }
        return this.scopedRun(function() {
            return r55.startScope(o36);
        }, function() {
            return r55.endScope(n86);
        }, function() {
            return (n86 = e139()) instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n86;
        });
    }, t225.prototype.scopedRun = function(t241, e140, n87) {
        t241();
        try {
            var r56 = n87();
            return e140(), r56;
        } catch (t242) {
            throw e140(), t242;
        }
    }, t225.prototype.nextTensorId = function() {
        return t225.nextTensorId++;
    }, t225.prototype.nextVariableId = function() {
        return t225.nextVariableId++;
    }, t225.prototype.clone = function(t243) {
        var e141 = this.makeTensorFromDataId(t243.dataId, t243.shape, t243.dtype), n88 = {
            x: t243
        };
        return this.addTapeNode(this.state.activeScope.name, n88, [
            e141
        ], function(t244) {
            return {
                x: function() {
                    return t244.toFloat();
                }
            };
        }, [], {
        }), e141;
    }, t225.prototype.runKernel = function(t245, e142, n89, r57, o37) {
        return this.runKernelFunc(null, e142, null, t245, n89, r57, o37);
    }, t225.prototype.shouldCheckForMemLeaks = function() {
        return this.ENV.getBool("IS_TEST");
    }, t225.prototype.checkKernelForMemLeak = function(t246, e143, n90) {
        var r58 = this.backend.numDataIds(), o38 = 0;
        n90.forEach(function(t247) {
            o38 += "complex64" === t247.dtype ? 3 : 1;
        });
        var a26 = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], i14 = r58 - e143 - o38 - a26;
        if (i14 > 0) throw new Error("Backend '" + this.backendName + "' has an internal memory leak (" + i14 + " data ids) after running '" + t246 + "'");
    }, t225.prototype.runKernelFunc = function(t248, e144, n91, r59, o39, a27, i15) {
        var s15, u8 = this, c4 = [], h4 = this.isTapeOn();
        null == r59 && (r59 = null != this.state.activeScope ? this.state.activeScope.name : "");
        var f3, d3 = this.state.numBytes, p3 = this.state.numTensors;
        this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
        var v2, g2 = l(r59, this.backendName);
        if (null != g2) f3 = function() {
            var t249 = u8.backend.numDataIds();
            v2 = g2.kernelFunc({
                inputs: e144,
                attrs: o39,
                backend: u8.backend
            });
            var n92 = Array.isArray(v2) ? v2 : [
                v2
            ];
            u8.shouldCheckForMemLeaks() && u8.checkKernelForMemLeak(r59, t249, n92);
            var s16 = n92.map(function(t250) {
                var e145 = t250.dataId, n93 = t250.shape, r60 = t250.dtype;
                return u8.makeTensorFromDataId(e145, n93, r60);
            });
            if (h4) {
                var l3 = u8.getTensorsForGradient(r59, e144, s16);
                if (null == l3) {
                    null == i15 && (i15 = []);
                    var f4 = s16.filter(function(t, e) {
                        return i15[e];
                    });
                    l3 = (a27 || []).slice().concat(f4);
                }
                c4 = u8.saveTensorsForBackwardMode(l3);
            }
            return s16;
        };
        else {
            var m2 = function(t251) {
                h4 && (c4 = t251.map(function(t252) {
                    return u8.keep(u8.clone(t252));
                }));
            };
            f3 = function() {
                var e146 = u8.backend.numDataIds();
                v2 = u8.tidy(function() {
                    return t248(u8.backend, m2);
                });
                var n94 = Array.isArray(v2) ? v2 : [
                    v2
                ];
                return u8.shouldCheckForMemLeaks() && u8.checkKernelForMemLeak(r59, e146, n94), n94;
            };
        }
        return this.scopedRun(function() {
            return u8.state.kernelDepth++;
        }, function() {
            return u8.state.kernelDepth--;
        }, function() {
            s15 = u8.ENV.getBool("DEBUG") ? u8.profiler.profileKernel(r59, e144, function() {
                return f3();
            }) : f3();
        }), h4 && this.addTapeNode(r59, e144, s15, n91, c4, o39), this.state.profiling && this.state.activeProfile.kernels.push({
            name: r59,
            bytesAdded: this.state.numBytes - d3,
            totalBytesSnapshot: this.state.numBytes,
            tensorsAdded: this.state.numTensors - p3,
            totalTensorsSnapshot: this.state.numTensors,
            inputShapes: Object.keys(e144).map(function(t) {
                return e144[t].shape;
            }),
            outputShapes: s15.map(function(t253) {
                return t253.shape;
            })
        }), Array.isArray(v2) ? s15 : s15[0];
    }, t225.prototype.saveTensorsForBackwardMode = function(t254) {
        var e147 = this;
        return t254.map(function(t255) {
            return e147.keep(e147.clone(t255));
        });
    }, t225.prototype.getTensorsForGradient = function(t256, e148, n95) {
        var r61 = h(t256);
        if (null != r61) {
            var o40 = r61.inputsToSave || [], a28 = r61.outputsToSave || [], i16 = void 0;
            r61.saveAllInputs ? (C(Array.isArray(e148), function() {
                return "saveAllInputs is true, expected inputs to be an array.";
            }), i16 = Object.keys(e148).map(function(t) {
                return e148[t];
            })) : i16 = o40.map(function(t) {
                return e148[t];
            });
            var s17 = n95.filter(function(t, e) {
                return a28[e];
            });
            return i16.concat(s17);
        }
        return null;
    }, t225.prototype.makeTensor = function(t257, e149, n96, r62) {
        if (null == t257) throw new Error("Values passed to engine.makeTensor() are null");
        n96 = n96 || "float32", r62 = r62 || this.backend;
        var o41 = t257;
        "string" === n96 && H(t257[0]) && (o41 = t257.map(function(t258) {
            return rt(t258);
        }));
        var a29 = r62.write(o41, e149, n96), i17 = new wt(e149, n96, a29, this.nextTensorId());
        if (this.incRef(i17, r62), "string" === n96) {
            var s18 = this.state.tensorInfo.get(a29), u9 = G(o41);
            this.state.numBytes += u9 - s18.bytes, s18.bytes = u9;
        }
        return i17;
    }, t225.prototype.makeTensorFromDataId = function(t259, e150, n97, r63) {
        var o42 = new wt(e150, n97 = n97 || "float32", t259, this.nextTensorId());
        return this.incRef(o42, r63), o42;
    }, t225.prototype.makeVariable = function(t260, e151, n98, r64) {
        void 0 === e151 && (e151 = !0), n98 = n98 || this.nextVariableId().toString(), null != r64 && r64 !== t260.dtype && (t260 = t260.asType(r64));
        var o43 = new St(t260, e151, n98, this.nextTensorId());
        if (null != this.state.registeredVariables[o43.name]) throw new Error("Variable with name " + o43.name + " was already registered");
        return this.state.registeredVariables[o43.name] = o43, this.incRef(o43, this.backend), o43;
    }, t225.prototype.incRef = function(t261, e152) {
        var n99 = this.state.tensorInfo.has(t261.dataId) ? this.state.tensorInfo.get(t261.dataId).refCount : 0;
        if (this.state.numTensors++, "string" === t261.dtype && this.state.numStringTensors++, 0 === n99) {
            this.state.numDataBuffers++;
            var r65 = 0;
            "complex64" !== t261.dtype && "string" !== t261.dtype && (r65 = t261.size * z(t261.dtype)), this.state.tensorInfo.set(t261.dataId, {
                backend: e152 || this.backend,
                dtype: t261.dtype,
                shape: t261.shape,
                bytes: r65,
                refCount: 0
            }), this.state.numBytes += r65;
        }
        this.state.tensorInfo.get(t261.dataId).refCount++, t261 instanceof St || this.track(t261);
    }, t225.prototype.disposeTensor = function(t262) {
        if (this.state.tensorInfo.has(t262.dataId)) {
            this.state.numTensors--, "string" === t262.dtype && this.state.numStringTensors--;
            var e153 = this.state.tensorInfo.get(t262.dataId);
            e153.refCount <= 1 ? ("complex64" !== t262.dtype && (this.state.numBytes -= e153.bytes), this.state.numDataBuffers--, e153.backend.disposeData(t262.dataId), this.state.tensorInfo.delete(t262.dataId)) : this.state.tensorInfo.get(t262.dataId).refCount--;
        }
    }, t225.prototype.disposeVariables = function() {
        for(var t in this.state.registeredVariables){
            var e154 = this.state.registeredVariables[t];
            this.disposeVariable(e154);
        }
    }, t225.prototype.disposeVariable = function(t263) {
        this.disposeTensor(t263), null != this.state.registeredVariables[t263.name] && delete this.state.registeredVariables[t263.name];
    }, t225.prototype.memory = function() {
        var t264 = this.backend.memory();
        return t264.numTensors = this.state.numTensors, t264.numDataBuffers = this.state.numDataBuffers, t264.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t264.unreliable = !0, null == t264.reasons && (t264.reasons = []), t264.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), t264;
    }, t225.prototype.profile = function(t265) {
        return n(this, void 0, void 0, function() {
            var e155, n100;
            return r(this, function(r) {
                return this.state.profiling = !0, e155 = this.state.numBytes, n100 = this.state.numTensors, this.state.activeProfile.kernels = [], this.state.activeProfile.result = t265(), this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map(function(t266) {
                    return t266.totalBytesSnapshot;
                })), this.state.activeProfile.newBytes = this.state.numBytes - e155, this.state.activeProfile.newTensors = this.state.numTensors - n100, [
                    2,
                    this.state.activeProfile
                ];
            });
        });
    }, t225.prototype.isTapeOn = function() {
        return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth;
    }, t225.prototype.addTapeNode = function(t267, e156, n101, r66, o44, a30) {
        var i18 = this, s19 = {
            id: this.state.nextTapeNodeId++,
            kernelName: t267,
            inputs: e156,
            outputs: n101,
            saved: o44
        }, u10 = h(t267);
        null != u10 && (r66 = u10.gradFunc), null != r66 && (s19.gradient = function(t268) {
            return t268 = t268.map(function(t269, e) {
                if (null == t269) {
                    var r67 = n101[e], o45 = tt(r67.size, r67.dtype);
                    return i18.makeTensor(o45, r67.shape, r67.dtype);
                }
                return t269;
            }), r66(t268.length > 1 ? t268 : t268[0], o44, a30);
        }), this.state.activeTape.push(s19);
    }, t225.prototype.keep = function(t270) {
        return t270.kept = !0, t270;
    }, t225.prototype.startTape = function() {
        0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++;
    }, t225.prototype.endTape = function() {
        this.state.gradientDepth--;
    }, t225.prototype.startScope = function(t271) {
        var e157 = {
            track: [],
            name: "unnamed scope",
            id: this.state.nextScopeId++
        };
        t271 && (e157.name = t271), this.state.scopeStack.push(e157), this.state.activeScope = e157;
    }, t225.prototype.endScope = function(t272) {
        for(var e158 = this, n102 = _t(t272), r68 = new Set(n102.map(function(t273) {
            return t273.id;
        })), o46 = 0; o46 < this.state.activeScope.track.length; o46++){
            var a31 = this.state.activeScope.track[o46];
            a31.kept || r68.has(a31.id) || a31.dispose();
        }
        var i19 = this.state.scopeStack.pop();
        this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n102.forEach(function(t274) {
            t274.kept || t274.scopeId !== i19.id || e158.track(t274);
        });
    }, t225.prototype.gradients = function(t275, e159, n103, r69) {
        var o47 = this;
        if (void 0 === r69 && (r69 = !1), C(e159.length > 0, function() {
            return "gradients() received an empty list of xs.";
        }), null != n103 && "float32" !== n103.dtype) throw new Error("dy must have 'float32' dtype, but has '" + n103.dtype + "'");
        var a32 = this.scopedRun(function() {
            return o47.startTape();
        }, function() {
            return o47.endTape();
        }, function() {
            return o47.tidy("forward", t275);
        });
        C(a32 instanceof wt, function() {
            return "The result y returned by f() must be a tensor.";
        });
        var i20 = function(t276, e160, n) {
            for(var r70 = {
            }, o48 = {
            }, a33 = 0; a33 < e160.length; a33++)r70[e160[a33].id] = !0;
            for(a33 = 0; a33 < t276.length; a33++){
                var i21 = (p4 = t276[a33]).inputs;
                for(var s in i21){
                    for(var u = i21[s], c5 = !1, l4 = 0; l4 < e160.length; l4++)if (r70[u.id]) {
                        p4.outputs.forEach(function(t) {
                            return r70[t.id] = !0;
                        }), c5 = !0, o48[p4.id] = !0;
                        break;
                    }
                    if (c5) break;
                }
            }
            var h5 = {
            };
            h5[n.id] = !0;
            var f5 = {
            };
            for(a33 = t276.length - 1; a33 >= 0; a33--)for(i21 = (p4 = t276[a33]).inputs, l4 = 0; l4 < p4.outputs.length; l4++)if (h5[p4.outputs[l4].id]) {
                for(var s in i21)h5[i21[s].id] = !0, f5[p4.id] = !0;
                break;
            }
            var d4 = [];
            for(a33 = 0; a33 < t276.length; a33++){
                var p4;
                if (o48[(p4 = t276[a33]).id] && f5[p4.id]) {
                    var v3 = {
                    };
                    for(var s in p4.inputs){
                        var g3 = p4.inputs[s];
                        r70[g3.id] && (v3[s] = g3);
                    }
                    var m3 = Object.assign({
                    }, p4);
                    m3.inputs = v3, m3.outputs = p4.outputs, d4.push(m3);
                }
            }
            return d4;
        }(this.state.activeTape, e159, a32);
        if (!r69 && 0 === i20.length && e159.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
        return this.tidy("backward", function() {
            var t277, r71, s20 = {
            };
            s20[a32.id] = null == n103 ? (t277 = a32.shape, r71 = Z(k(t277), "float32"), Lt.makeTensor(r71, t277, "float32")) : n103, (function(t278, e161, n104) {
                for(var r72 = function(r73) {
                    var o50 = e161[r73], a34 = [];
                    if (o50.outputs.forEach(function(e) {
                        var n105 = t278[e.id];
                        null != n105 ? a34.push(n105) : a34.push(null);
                    }), null == o50.gradient) throw new Error("Cannot compute gradient: gradient function not found for " + o50.kernelName + ".");
                    var i22 = o50.gradient(a34), s21 = function(e162) {
                        if (!(e162 in i22)) throw new Error("Cannot backprop through input " + e162 + ". Available gradients found: " + Object.keys(i22) + ".");
                        var r74 = n104(function() {
                            return i22[e162]();
                        });
                        if ("float32" !== r74.dtype) throw new Error("Error in gradient for op " + o50.kernelName + ". The gradient of input " + e162 + " must have 'float32' dtype, but has '" + r74.dtype + "'");
                        var a35 = o50.inputs[e162];
                        if (!S(r74.shape, a35.shape)) throw new Error("Error in gradient for op " + o50.kernelName + ". The gradient of input '" + e162 + "' has shape '" + r74.shape + "', which does not match the shape of the input '" + a35.shape + "'");
                        if (null == t278[a35.id]) t278[a35.id] = r74;
                        else {
                            var s22 = t278[a35.id];
                            t278[a35.id] = s22.add(r74), s22.dispose();
                        }
                    };
                    for(var u12 in o50.inputs)s21(u12);
                }, o49 = e161.length - 1; o49 >= 0; o49--)r72(o49);
            })(s20, i20, function(t279) {
                return o47.tidy(t279);
            });
            var u11 = e159.map(function(t) {
                return s20[t.id];
            });
            return 0 === o47.state.gradientDepth && (o47.state.activeTape.forEach(function(t280) {
                for(var e163 = 0, n106 = t280.saved; e163 < n106.length; e163++)n106[e163].dispose();
            }), o47.state.activeTape = null), {
                value: a32,
                grads: u11
            };
        });
    }, t225.prototype.customGrad = function(t281) {
        var e164 = this;
        return C(X(t281), function() {
            return "The f passed in customGrad(f) must be a function.";
        }), function() {
            for(var n107, r75 = [], o51 = 0; o51 < arguments.length; o51++)r75[o51] = arguments[o51];
            C(r75.every(function(t282) {
                return t282 instanceof wt;
            }), function() {
                return "The args passed in customGrad(f)(x1, x2,...) must all be tensors";
            });
            var a36 = {
            };
            return r75.forEach(function(t283, e) {
                a36[e] = t283;
            }), e164.runKernelFunc(function(e, o52) {
                return C((n107 = t281.apply(void 0, r75.concat([
                    o52
                ]))).value instanceof wt, function() {
                    return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor";
                }), C(X(n107.gradFunc), function() {
                    return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.";
                }), n107.value;
            }, a36, function(t284, e165) {
                var o53 = n107.gradFunc(t284, e165), a37 = Array.isArray(o53) ? o53 : [
                    o53
                ];
                C(a37.length === r75.length, function() {
                    return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).";
                }), C(a37.every(function(t285) {
                    return t285 instanceof wt;
                }), function() {
                    return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.";
                });
                var i23 = {
                };
                return a37.forEach(function(t286, e) {
                    i23[e] = function() {
                        return t286;
                    };
                }), i23;
            });
        };
    }, t225.prototype.readSync = function(t287) {
        return this.state.tensorInfo.get(t287).backend.readSync(t287);
    }, t225.prototype.read = function(t288) {
        return this.state.tensorInfo.get(t288).backend.read(t288);
    }, t225.prototype.time = function(t289) {
        return n(this, void 0, void 0, function() {
            var e166, n108;
            return r(this, function(r76) {
                switch(r76.label){
                    case 0:
                        return e166 = et(), [
                            4,
                            this.backend.time(t289)
                        ];
                    case 1:
                        return (n108 = r76.sent()).wallMs = et() - e166, [
                            2,
                            n108
                        ];
                }
            });
        });
    }, t225.prototype.track = function(t290) {
        return null != this.state.activeScope && (t290.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(t290)), t290;
    }, Object.defineProperty(t225.prototype, "registeredVariables", {
        get: function() {
            return this.state.registeredVariables;
        },
        enumerable: !0,
        configurable: !0
    }), t225.prototype.reset = function() {
        for(var t291 in this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Bt, this.registry)this.disposeRegisteredKernels(t291), this.registry[t291].dispose(), delete this.registry[t291];
        this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
    }, t225.nextTensorId = 0, t225.nextVariableId = 0, t225;
}();
var Lt = function() {
    var t292 = function() {
        if (null == Ot) {
            var t293 = void 0;
            if ("undefined" != typeof window) t293 = window;
            else if ("undefined" != typeof global) t293 = global;
            else if ("undefined" != typeof process) t293 = process;
            else {
                if ("undefined" == typeof self) throw new Error("Could not find a global object");
                t293 = self;
            }
            Ot = t293;
        }
        return Ot;
    }();
    if (null == t292._tfengine) {
        var e167 = new o(t292);
        t292._tfengine = new Pt(e167);
    }
    return (function(t294) {
        s = t294;
    })(t292._tfengine.ENV), yt = function() {
        return t292._tfengine;
    }, t292._tfengine;
}();
function Wt() {
    return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope;
}
var Ut = i();
Ut.registerFlag("DEBUG", function() {
    return !1;
}, function(t295) {
    t295 && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
}), Ut.registerFlag("IS_BROWSER", function() {
    return Wt();
}), Ut.registerFlag("IS_NODE", function() {
    return "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node;
}), Ut.registerFlag("IS_CHROME", function() {
    return "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
}), Ut.registerFlag("PROD", function() {
    return !1;
}), Ut.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function() {
    return Ut.getBool("DEBUG");
}), Ut.registerFlag("DEPRECATION_WARNINGS_ENABLED", function() {
    return !0;
}), Ut.registerFlag("IS_TEST", function() {
    return !1;
});
var Vt, zt, Gt, Ht = {
}, qt = {
    alpha: !1,
    antialias: !1,
    premultipliedAlpha: !1,
    preserveDrawingBuffer: !1,
    depth: !1,
    stencil: !1,
    failIfMajorPerformanceCaveat: !0
};
function Kt(t, e168) {
    Ht[t] = e168;
}
function jt(t296) {
    t296 in Ht || (Ht[t296] = (function(t297) {
        if (1 !== t297 && 2 !== t297) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
        var e170 = function(t298) {
            if ("undefined" != typeof OffscreenCanvas && 2 === t298) return new OffscreenCanvas(300, 150);
            if ("undefined" != typeof document) return document.createElement("canvas");
            throw new Error("Cannot create a canvas in this context");
        }(t297);
        if (e170.addEventListener("webglcontextlost", function(e171) {
            e171.preventDefault(), delete Ht[t297];
        }, !1), 1 === t297) return e170.getContext("webgl", qt) || e170.getContext("experimental-webgl", qt);
        return e170.getContext("webgl2", qt);
    })(t296));
    var e169 = Ht[t296];
    return e169.isContextLost() ? (delete Ht[t296], jt(t296)) : (e169.disable(e169.DEPTH_TEST), e169.disable(e169.STENCIL_TEST), e169.disable(e169.BLEND), e169.disable(e169.DITHER), e169.disable(e169.POLYGON_OFFSET_FILL), e169.disable(e169.SAMPLE_COVERAGE), e169.enable(e169.SCISSOR_TEST), e169.enable(e169.CULL_FACE), e169.cullFace(e169.BACK), Ht[t296]);
}
function Xt(t299, e172) {
    return [
        e172,
        t299
    ];
}
function Yt(t300) {
    var e173 = k(t300);
    return D(Math.ceil(e173 / 4));
}
function $t(t301, e174) {
    return [
        Math.max(1, Math.ceil(e174 / 2)),
        Math.max(1, Math.ceil(t301 / 2))
    ];
}
function Qt(t302, e175) {
    var n109, r77, o54, a38, s23, u13, c6, l5, h6, f6 = t302;
    return 2 === i().getNumber("WEBGL_VERSION") ? (n109 = f6.R32F, r77 = f6.R16F, o54 = f6.RGBA16F, a38 = f6.RGBA32F, s23 = f6.RED, u13 = 4, c6 = 1, l5 = f6.HALF_FLOAT, h6 = f6.FLOAT) : (n109 = t302.RGBA, r77 = t302.RGBA, o54 = t302.RGBA, a38 = f6.RGBA, s23 = t302.RGBA, u13 = 4, c6 = 4, l5 = null != e175 ? e175.HALF_FLOAT_OES : null, h6 = t302.FLOAT), {
        internalFormatFloat: n109,
        internalFormatHalfFloat: r77,
        internalFormatPackedHalfFloat: o54,
        internalFormatPackedFloat: a38,
        textureFormatFloat: s23,
        downloadTextureFormat: t302.RGBA,
        downloadUnpackNumChannels: u13,
        defaultNumChannels: c6,
        textureTypeHalfFloat: l5,
        textureTypeFloat: h6
    };
}
function Jt(t303, e176, n110) {
    var r78 = n110();
    return e176 && (function(t304) {
        var e177 = t304.getError();
        if (e177 !== t304.NO_ERROR) throw new Error("WebGL Error: " + ne(t304, e177));
    })(t303), r78;
}
!function(t305) {
    t305[t305.DENSE = 0] = "DENSE", t305[t305.SHARED_BATCH = 1] = "SHARED_BATCH";
}(Vt || (Vt = {
})), (function(t306) {
    t306[t306.RENDER = 0] = "RENDER", t306[t306.UPLOAD = 1] = "UPLOAD", t306[t306.PIXELS = 2] = "PIXELS", t306[t306.DOWNLOAD = 3] = "DOWNLOAD";
})(zt || (zt = {
})), (function(t307) {
    t307[t307.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", t307[t307.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", t307[t307.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", t307[t307.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", t307[t307.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
})(Gt || (Gt = {
}));
var Zt = 0.0000000596, te = 65504;
function ee(t308) {
    return !!(i().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === t308 || Zt < Math.abs(t308) && Math.abs(t308) < te);
}
function ne(t309, e178) {
    switch(e178){
        case t309.NO_ERROR:
            return "NO_ERROR";
        case t309.INVALID_ENUM:
            return "INVALID_ENUM";
        case t309.INVALID_VALUE:
            return "INVALID_VALUE";
        case t309.INVALID_OPERATION:
            return "INVALID_OPERATION";
        case t309.INVALID_FRAMEBUFFER_OPERATION:
            return "INVALID_FRAMEBUFFER_OPERATION";
        case t309.OUT_OF_MEMORY:
            return "OUT_OF_MEMORY";
        case t309.CONTEXT_LOST_WEBGL:
            return "CONTEXT_LOST_WEBGL";
        default:
            return "Unknown error code " + e178;
    }
}
function re(t310, e179, n111) {
    return ke(t310, e179, function() {
        return t310.getExtension(n111);
    }, 'Extension "' + n111 + '" not supported on this browser.');
}
function oe(t311, e180, n112) {
    var r79 = ke(t311, e180, function() {
        return t311.createShader(t311.VERTEX_SHADER);
    }, "Unable to create vertex WebGLShader.");
    if (Jt(t311, e180, function() {
        return t311.shaderSource(r79, n112);
    }), Jt(t311, e180, function() {
        return t311.compileShader(r79);
    }), !1 === t311.getShaderParameter(r79, t311.COMPILE_STATUS)) throw console.log(t311.getShaderInfoLog(r79)), new Error("Failed to compile vertex shader.");
    return r79;
}
function ae(t312, e181, n113) {
    var r80 = ke(t312, e181, function() {
        return t312.createShader(t312.FRAGMENT_SHADER);
    }, "Unable to create fragment WebGLShader.");
    if (Jt(t312, e181, function() {
        return t312.shaderSource(r80, n113);
    }), Jt(t312, e181, function() {
        return t312.compileShader(r80);
    }), !1 === t312.getShaderParameter(r80, t312.COMPILE_STATUS)) throw (function(t313, e182) {
        var n114 = ue.exec(e182);
        if (null == n114) return console.log("Couldn't parse line number in error: " + e182), void console.log(t313);
        for(var r81 = +n114[1], o55 = t313.split("\n"), a39 = o55.length.toString().length + 2, i24 = o55.map(function(t314, e183) {
            return N((e183 + 1).toString(), a39) + t314;
        }), s24 = 0, u14 = 0; u14 < i24.length; u14++)s24 = Math.max(i24[u14].length, s24);
        var c7 = i24.slice(0, r81 - 1), l6 = i24.slice(r81 - 1, r81), h7 = i24.slice(r81);
        console.log(c7.join("\n")), console.log(e182.split("\n")[0]), console.log("%c " + N(l6[0], s24), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(h7.join("\n"));
    })(n113, t312.getShaderInfoLog(r80)), new Error("Failed to compile fragment shader.");
    return r80;
}
var ie, se, ue = /ERROR: [0-9]+:([0-9]+):/g;
function ce(t315, e184) {
    return ke(t315, e184, function() {
        return t315.createProgram();
    }, "Unable to create WebGLProgram.");
}
function le(t316, e185, n115) {
    if (Jt(t316, e185, function() {
        return t316.linkProgram(n115);
    }), !1 === t316.getProgramParameter(n115, t316.LINK_STATUS)) throw console.log(t316.getProgramInfoLog(n115)), new Error("Failed to link vertex and fragment shaders.");
}
function he(t317, e186, n116) {
    if (Jt(t317, e186, function() {
        return t317.validateProgram(n116);
    }), !1 === t317.getProgramParameter(n116, t317.VALIDATE_STATUS)) throw console.log(t317.getProgramInfoLog(n116)), new Error("Shader program validation failed.");
}
function fe(t318, e187, n117) {
    var r82 = ke(t318, e187, function() {
        return t318.createBuffer();
    }, "Unable to create WebGLBuffer");
    return Jt(t318, e187, function() {
        return t318.bindBuffer(t318.ARRAY_BUFFER, r82);
    }), Jt(t318, e187, function() {
        return t318.bufferData(t318.ARRAY_BUFFER, n117, t318.STATIC_DRAW);
    }), r82;
}
function de(t319, e188, n118) {
    var r83 = ke(t319, e188, function() {
        return t319.createBuffer();
    }, "Unable to create WebGLBuffer");
    return Jt(t319, e188, function() {
        return t319.bindBuffer(t319.ELEMENT_ARRAY_BUFFER, r83);
    }), Jt(t319, e188, function() {
        return t319.bufferData(t319.ELEMENT_ARRAY_BUFFER, n118, t319.STATIC_DRAW);
    }), r83;
}
function pe(t320, e189) {
    return ke(t320, e189, function() {
        return t320.createTexture();
    }, "Unable to create WebGLTexture.");
}
function ve(t321, e190) {
    var n119 = i().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (t321 <= 0 || e190 <= 0) {
        var r84 = "[" + t321 + "x" + e190 + "]";
        throw new Error("Requested texture size " + r84 + " is invalid.");
    }
    if (t321 > n119 || e190 > n119) {
        r84 = "[" + t321 + "x" + e190 + "]";
        throw new Error("Requested texture size " + r84 + " greater than WebGL maximum on this browser / GPU " + ("[" + n119 + "x" + n119 + "]") + ".");
    }
}
function ge(t322, e191) {
    return ke(t322, e191, function() {
        return t322.createFramebuffer();
    }, "Unable to create WebGLFramebuffer.");
}
function me(t323, e192, n120, r85, o56, a40, i25, s25) {
    var u15 = t323.getAttribLocation(n120, r85);
    return -1 !== u15 && (Jt(t323, e192, function() {
        return t323.bindBuffer(t323.ARRAY_BUFFER, o56);
    }), Jt(t323, e192, function() {
        return t323.vertexAttribPointer(u15, a40, t323.FLOAT, !1, i25, s25);
    }), Jt(t323, e192, function() {
        return t323.enableVertexAttribArray(u15);
    }), !0);
}
function ye(t324, e193, n121, r86) {
    Se(t324, r86), Jt(t324, e193, function() {
        return t324.activeTexture(t324.TEXTURE0 + r86);
    }), Jt(t324, e193, function() {
        return t324.bindTexture(t324.TEXTURE_2D, n121);
    });
}
function xe(t325, e194, n122, r87) {
    return ke(t325, e194, function() {
        return t325.getUniformLocation(n122, r87);
    }, 'uniform "' + r87 + '" not present in program.');
}
function be(t326, e195, n123) {
    return t326.getUniformLocation(e195, n123);
}
function we(t327, e196, n, r88, o57, a41) {
    Jt(t327, e196, function() {
        return ye(t327, e196, r88, a41);
    }), Jt(t327, e196, function() {
        return t327.uniform1i(o57, a41);
    });
}
function Ce(t328, e197, n124, r89) {
    Jt(t328, e197, function() {
        return t328.bindFramebuffer(t328.FRAMEBUFFER, r89);
    }), Jt(t328, e197, function() {
        return t328.framebufferTexture2D(t328.FRAMEBUFFER, t328.COLOR_ATTACHMENT0, t328.TEXTURE_2D, n124, 0);
    });
}
function Ee(t329, e198, n125) {
    Jt(t329, e198, function() {
        return t329.bindFramebuffer(t329.FRAMEBUFFER, n125);
    }), Jt(t329, e198, function() {
        return t329.framebufferTexture2D(t329.FRAMEBUFFER, t329.COLOR_ATTACHMENT0, t329.TEXTURE_2D, null, 0);
    });
}
function Re(t330) {
    var e199 = t330.checkFramebufferStatus(t330.FRAMEBUFFER);
    if (e199 !== t330.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + Ie(t330, e199));
}
function Ie(t331, e200) {
    switch(e200){
        case t331.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
        case t331.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
        case t331.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
        case t331.FRAMEBUFFER_UNSUPPORTED:
            return "FRAMEBUFFER_UNSUPPORTED";
        default:
            return "unknown error " + e200;
    }
}
function ke(t332, e201, n126, r90) {
    var o58 = Jt(t332, e201, function() {
        return n126();
    });
    if (null == o58) throw new Error(r90);
    return o58;
}
function Se(t333, e202) {
    var n127 = t333.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, r91 = e202 + t333.TEXTURE0;
    if (r91 < t333.TEXTURE0 || r91 > n127) throw new Error("textureUnit must be in " + ("[gl.TEXTURE0, gl.TEXTURE" + n127 + "]") + ".");
}
function Ae(t334, e203) {
    return void 0 === e203 && (e203 = 2), k(t334.slice(0, t334.length - e203));
}
function Te(t335) {
    if (0 === t335.length) throw Error("Cannot get rows and columns of an empty shape array.");
    return [
        t335.length > 1 ? t335[t335.length - 2] : 1,
        t335[t335.length - 1]
    ];
}
function De(t336) {
    var e204 = [
        1,
        1,
        1
    ];
    return 0 === t336.length || 1 === t336.length && 1 === t336[0] || (e204 = [
        Ae(t336)
    ].concat(Te(t336))), e204;
}
function Ne(t337, e205) {
    var n128;
    void 0 === e205 && (e205 = !1);
    var r92 = i().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (e205 && (r92 *= 2, 1 === (t337 = t337.map(function(e, n129) {
        return n129 >= t337.length - 2 ? b(t337[n129]) : t337[n129];
    })).length && (t337 = [
        2,
        t337[0]
    ])), 2 !== t337.length) {
        var o59 = M(t337);
        t337 = o59.newShape;
    }
    var a42 = k(t337);
    if (t337.length <= 1 && a42 <= r92) return [
        1,
        a42
    ];
    if (2 === t337.length && t337[0] <= r92 && t337[1] <= r92) return t337;
    if (3 === t337.length && t337[0] * t337[1] <= r92 && t337[2] <= r92) return [
        t337[0] * t337[1],
        t337[2]
    ];
    if (3 === t337.length && t337[0] <= r92 && t337[1] * t337[2] <= r92) return [
        t337[0],
        t337[1] * t337[2]
    ];
    if (4 === t337.length && t337[0] * t337[1] * t337[2] <= r92 && t337[3] <= r92) return [
        t337[0] * t337[1] * t337[2],
        t337[3]
    ];
    if (4 === t337.length && t337[0] <= r92 && t337[1] * t337[2] * t337[3] <= r92) return [
        t337[0],
        t337[1] * t337[2] * t337[3]
    ];
    if (e205) {
        var s26 = Ae(t337), u16 = 2, c8 = 2;
        return t337.length && (u16 = (n128 = Te(t337))[0], c8 = n128[1]), D(a42 = s26 * (u16 / 2) * (c8 / 2)).map(function(t338) {
            return 2 * t338;
        });
    }
    return D(a42);
}
function Fe(t339) {
    return t339 % 2 == 0;
}
function _e(t340, e206) {
    if (S(t340 = t340.slice(-2), e206 = e206.slice(-2))) return !0;
    if (!t340.length || !e206.length) return !0;
    if (0 === t340[0] || 0 === t340[1] || 0 === e206[0] || 0 === e206[1]) return !0;
    if (t340.length !== e206.length) {
        var n130 = t340.slice(-1)[0], r93 = e206.slice(-1)[0];
        if (n130 === r93) return !0;
        if (Fe(n130) && Fe(r93) && (1 === t340[0] || 1 === e206[0])) return !0;
    }
    return t340[1] === e206[1] && Fe(t340[0]) && Fe(e206[0]);
}
function Oe(t341) {
    if (null == ie) {
        var e207 = jt(t341);
        ie = e207.getParameter(e207.MAX_TEXTURE_SIZE);
    }
    return ie;
}
function Me(t342) {
    if (null == se) {
        var e208 = jt(t342);
        se = e208.getParameter(e208.MAX_TEXTURE_IMAGE_UNITS);
    }
    return Math.min(16, se);
}
function Be(t343) {
    if (0 === t343) return 0;
    var e209 = jt(t343);
    return Pe(e209, "EXT_disjoint_timer_query_webgl2") && 2 === t343 ? 2 : Pe(e209, "EXT_disjoint_timer_query") ? 1 : 0;
}
function Pe(t344, e210) {
    return null != t344.getExtension(e210);
}
function Le(t345) {
    try {
        if (null != jt(t345)) return !0;
    } catch (t) {
        return !1;
    }
    return !1;
}
function We(t346) {
    if (0 === t346) return !1;
    var e211 = jt(t346);
    if (1 === t346) {
        if (!Pe(e211, "OES_texture_float")) return !1;
    } else if (!Pe(e211, "EXT_color_buffer_float")) return !1;
    return Ve(e211);
}
function Ue(t347) {
    if (0 === t347) return !1;
    var e212 = jt(t347);
    if (1 !== t347) {
        if (Pe(e212, "EXT_color_buffer_float")) return Ve(e212);
        if (Pe(e212, "EXT_color_buffer_half_float")) {
            var n131 = e212.getExtension("EXT_color_buffer_half_float");
            return (function(t348, e213) {
                var n134 = Qt(t348, e213), r94 = t348.createTexture();
                t348.bindTexture(t348.TEXTURE_2D, r94);
                t348.texImage2D(t348.TEXTURE_2D, 0, n134.internalFormatHalfFloat, 1, 1, 0, n134.textureFormatFloat, n134.textureTypeHalfFloat, null);
                var o60 = t348.createFramebuffer();
                t348.bindFramebuffer(t348.FRAMEBUFFER, o60), t348.framebufferTexture2D(t348.FRAMEBUFFER, t348.COLOR_ATTACHMENT0, t348.TEXTURE_2D, r94, 0);
                var a43 = t348.checkFramebufferStatus(t348.FRAMEBUFFER) === t348.FRAMEBUFFER_COMPLETE;
                return t348.bindTexture(t348.TEXTURE_2D, null), t348.bindFramebuffer(t348.FRAMEBUFFER, null), t348.deleteTexture(r94), t348.deleteFramebuffer(o60), a43;
            })(e212, n131);
        }
        return !1;
    }
    return !!Pe(e212, "OES_texture_float") && !!Pe(e212, "WEBGL_color_buffer_float") && Ve(e212);
}
function Ve(t349) {
    var e214 = Qt(t349), n135 = t349.createTexture();
    t349.bindTexture(t349.TEXTURE_2D, n135);
    t349.texImage2D(t349.TEXTURE_2D, 0, e214.internalFormatFloat, 1, 1, 0, e214.textureFormatFloat, e214.textureTypeFloat, null);
    var r95 = t349.createFramebuffer();
    t349.bindFramebuffer(t349.FRAMEBUFFER, r95), t349.framebufferTexture2D(t349.FRAMEBUFFER, t349.COLOR_ATTACHMENT0, t349.TEXTURE_2D, n135, 0);
    var o61 = t349.checkFramebufferStatus(t349.FRAMEBUFFER) === t349.FRAMEBUFFER_COMPLETE;
    return t349.bindTexture(t349.TEXTURE_2D, null), t349.bindFramebuffer(t349.FRAMEBUFFER, null), t349.deleteTexture(n135), t349.deleteFramebuffer(r95), o61;
}
function ze(t350) {
    return 2 === t350 && null != jt(t350).fenceSync;
}
var Ge = Object.freeze({
    callAndCheck: Jt,
    canBeRepresented: ee,
    getWebGLErrorMessage: ne,
    getExtensionOrThrow: re,
    createVertexShader: oe,
    createFragmentShader: ae,
    createProgram: ce,
    linkProgram: le,
    validateProgram: he,
    createStaticVertexBuffer: fe,
    createStaticIndexBuffer: de,
    getNumChannels: function() {
        return 2 === i().getNumber("WEBGL_VERSION") ? 1 : 4;
    },
    createTexture: pe,
    validateTextureSize: ve,
    createFramebuffer: ge,
    bindVertexBufferToProgramAttribute: me,
    bindTextureUnit: ye,
    unbindTextureUnit: function(t351, e215, n136) {
        Se(t351, n136), Jt(t351, e215, function() {
            return t351.activeTexture(t351.TEXTURE0 + n136);
        }), Jt(t351, e215, function() {
            return t351.bindTexture(t351.TEXTURE_2D, null);
        });
    },
    getProgramUniformLocationOrThrow: xe,
    getProgramUniformLocation: be,
    bindTextureToProgramUniformSampler: we,
    bindCanvasToFramebuffer: function(t352, e216) {
        Jt(t352, e216, function() {
            return t352.bindFramebuffer(t352.FRAMEBUFFER, null);
        }), Jt(t352, e216, function() {
            return t352.viewport(0, 0, t352.canvas.width, t352.canvas.height);
        }), Jt(t352, e216, function() {
            return t352.scissor(0, 0, t352.canvas.width, t352.canvas.height);
        });
    },
    bindColorTextureToFramebuffer: Ce,
    unbindColorTextureFromFramebuffer: Ee,
    validateFramebuffer: Re,
    getFramebufferErrorMessage: Ie,
    getBatchDim: Ae,
    getRowsCols: Te,
    getShapeAs3D: De,
    getTextureShapeFromLogicalShape: Ne,
    isReshapeFree: _e,
    getWebGLMaxTextureSize: Oe,
    resetMaxTextureSize: function() {
        ie = null;
    },
    resetMaxTexturesInShader: function() {
        se = null;
    },
    getMaxTexturesInShader: Me,
    getWebGLDisjointQueryTimerVersion: Be,
    hasExtension: Pe,
    isWebGLVersionEnabled: Le,
    isCapableOfRenderingToFloatTexture: We,
    isDownloadFloatTextureEnabled: Ue,
    isWebGLFenceEnabled: ze
}), He = i();
function qe() {
    i().set("PROD", !0);
}
function Ke() {
    i().set("DEBUG", !0);
}
function je() {
    i().set("DEPRECATION_WARNINGS_ENABLED", !1), console.warn("TensorFlow.js deprecation warnings have been disabled.");
}
function Xe(t353) {
    i().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(t353 + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
}
function Ye() {
    Lt.disposeVariables();
}
function $e() {
    return Lt;
}
function Qe() {
    return Lt.memory();
}
function Je(t354) {
    return Lt.profile(t354);
}
function Ze(t355, e217) {
    return Lt.tidy(t355, e217);
}
function tn(t356) {
    _t(t356).forEach(function(t357) {
        return t357.dispose();
    });
}
function en(t358) {
    return Lt.keep(t358);
}
function nn(t359) {
    return Lt.time(t359);
}
function rn(t360) {
    return Lt.setBackend(t360);
}
function on() {
    return Lt.ready();
}
function an() {
    return Lt.backendName;
}
function sn(t361) {
    Lt.removeBackend(t361);
}
function un(t362) {
    return Lt.findBackend(t362);
}
function cn(t363) {
    return Lt.findBackendFactory(t363);
}
function ln(t364, e218, n137) {
    return void 0 === n137 && (n137 = 1), Lt.registerBackend(t364, e218, n137);
}
function hn() {
    return Lt.backend;
}
function fn(t365, e219) {
    i().setPlatform(t365, e219);
}
function dn() {
    for(var t366 = [], e220 = 0; e220 < arguments.length; e220++)t366[e220] = arguments[e220];
    i().getBool("IS_TEST") || console.warn.apply(console, t366);
}
function pn(t367, e221) {
    var n138 = t367;
    if (V(t367)) return "string" === e221 ? [] : [
        t367.length
    ];
    if (!Array.isArray(t367)) return [];
    for(var r96 = []; Array.isArray(n138) || V(n138) && "string" !== e221;)r96.push(n138.length), n138 = n138[0];
    return Array.isArray(t367) && i().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && (function t368(e222, n139, r97) {
        if (r97 = r97 || [], !Array.isArray(e222) && !V(e222)) return void C(0 === n139.length, function() {
            return "Element arr[" + r97.join("][") + "] is a primitive, but should be an array/TypedArray of " + n139[0] + " elements";
        });
        C(n139.length > 0, function() {
            return "Element arr[" + r97.join("][") + "] should be a primitive, but is an array of " + e222.length + " elements";
        }), C(e222.length === n139[0], function() {
            return "Element arr[" + r97.join("][") + "] should have " + n139[0] + " elements, but has " + e222.length + " elements";
        });
        for(var o62 = n139.slice(1), a44 = 0; a44 < e222.length; ++a44)t368(e222[a44], o62, r97.concat(a44));
    })(t367, r96, []), r96;
}
function vn(t369, e223, n140, r98) {
    if (null != t369 && ("numeric" !== t369 && t369 !== e223 || "numeric" === t369 && "string" === e223)) throw new Error("Argument '" + n140 + "' passed to '" + r98 + "' must be " + t369 + " tensor, but got " + e223 + " tensor");
}
function gn(t370, e224, n141, r99) {
    if (void 0 === r99 && (r99 = "numeric"), t370 instanceof wt) return vn(r99, t370.dtype, e224, n141), t370;
    var o63 = j(t370);
    if ("string" !== o63 && [
        "bool",
        "int32",
        "float32"
    ].indexOf(r99) >= 0 && (o63 = r99), vn(r99, o63, e224, n141), null == t370 || !V(t370) && !Array.isArray(t370) && "number" != typeof t370 && "boolean" != typeof t370 && "string" != typeof t370) {
        var a45 = null == t370 ? "null" : t370.constructor.name;
        throw new Error("Argument '" + e224 + "' passed to '" + n141 + "' must be a Tensor or TensorLike, but got '" + a45 + "'");
    }
    var s27 = pn(t370, o63);
    V(t370) || Array.isArray(t370) || (t370 = [
        t370
    ]);
    var u17 = "string" !== o63 ? Q(t370, o63, i().getBool("DEBUG")) : I(t370, [], !0);
    return Lt.makeTensor(u17, s27, o63);
}
function mn(t371, e225, n142, r100) {
    if (void 0 === r100 && (r100 = "numeric"), !Array.isArray(t371)) throw new Error("Argument " + e225 + " passed to " + n142 + " must be a `Tensor[]` or `TensorLike[]`");
    return t371.map(function(t372, r101) {
        return gn(t372, e225 + "[" + r101 + "]", n142);
    }, r100);
}
function yn(t373, e226) {
    for(var n143 = 0; n143 < t373.length; ++n143)if (t373[t373.length - n143 - 1] !== e226 - 1 - n143) return !1;
    return !0;
}
function xn(t374, e227, n144) {
    for(var r102 = t374.length + e227.length, o64 = [], a = 0, i = 0, s28 = 0; s28 < r102; s28++)-1 === n144.indexOf(s28) ? o64.push(t374[a++]) : o64.push(e227[i++]);
    return o64;
}
function bn(t375, e228) {
    for(var n145 = [], r103 = t375.length, o65 = 0; o65 < r103; o65++)-1 === e228.indexOf(o65) && n145.push(t375[o65]);
    return [
        n145,
        e228.map(function(e) {
            return t375[e];
        })
    ];
}
function wn(t376, e229) {
    return xn(t376, e229.map(function(t) {
        return 1;
    }), e229);
}
function Cn(t377, e230, n146) {
    C(yn(e230, n146), function() {
        return t377 + " supports only inner-most axes for now. Got axes " + e230 + " and rank-" + n146 + " input.";
    });
}
function En(t378, e231) {
    if (yn(t378, e231)) return null;
    for(var n147 = [], r104 = 0; r104 < e231; ++r104)-1 === t378.indexOf(r104) && n147.push(r104);
    return t378.forEach(function(t379) {
        return n147.push(t379);
    }), n147;
}
function Rn(t380) {
    return t380.map(function(t381, e232) {
        return [
            e232,
            t381
        ];
    }).sort(function(t382, e233) {
        return t382[1] - e233[1];
    }).map(function(t383) {
        return t383[0];
    });
}
function In(t384, e234) {
    for(var n148 = [], r105 = e234 - t384; r105 < e234; ++r105)n148.push(r105);
    return n148;
}
function kn(t385, e235) {
    var n149 = t385[0].length;
    t385.forEach(function(t386, e236) {
        C(t386.length === n149, function() {
            return "Error in concat" + n149 + "D: rank of tensors[" + e236 + "] must be the same as the rank of the rest (" + n149 + ")";
        });
    }), C(e235 >= 0 && e235 < n149, function() {
        return "Error in concat" + n149 + "D: axis must be between 0 and " + (n149 - 1) + ".";
    });
    var r106 = t385[0];
    t385.forEach(function(t387, o66) {
        for(var a46 = 0; a46 < n149; a46++)C(a46 === e235 || t387[a46] === r106[a46], function() {
            return "Error in concat" + n149 + "D: Shape of tensors[" + o66 + "] (" + t387 + ") does not match the shape of the rest (" + r106 + ") along the non-concatenated axis " + o66 + ".";
        });
    });
}
function Sn(t388, e) {
    for(var n150 = t388[0].slice(), r107 = 1; r107 < t388.length; r107++)n150[e] += t388[r107][e];
    return n150;
}
function An(t389) {
    var e237 = Object.keys(t389);
    if (1 !== e237.length) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + e237.length + " keys.");
    var n151 = e237[0], r108 = t389[n151];
    n151.endsWith("_") && (n151 = n151.substring(0, n151.length - 1));
    var o67 = function() {
        for(var t390 = [], e238 = 0; e238 < arguments.length; e238++)t390[e238] = arguments[e238];
        Lt.startScope(n151);
        try {
            var o68 = r108.apply(void 0, t390);
            return o68 instanceof Promise && console.error("Cannot return a Promise inside of tidy."), Lt.endScope(o68), o68;
        } catch (t391) {
            throw Lt.endScope(null), t391;
        }
    };
    return Object.defineProperty(o67, "name", {
        value: n151,
        configurable: !0
    }), o67;
}
He.registerFlag("HAS_WEBGL", function() {
    return He.getNumber("WEBGL_VERSION") > 0;
}), He.registerFlag("WEBGL_VERSION", function() {
    return Le(2) ? 2 : Le(1) ? 1 : 0;
}), He.registerFlag("WEBGL_BUFFER_SUPPORTED", function() {
    return 2 === He.get("WEBGL_VERSION");
}), He.registerFlag("WEBGL_CPU_FORWARD", function() {
    return !0;
}), He.registerFlag("WEBGL_FORCE_F16_TEXTURES", function() {
    return !1;
}), He.registerFlag("WEBGL_PACK", function() {
    return He.getBool("HAS_WEBGL");
}), He.registerFlag("WEBGL_PACK_NORMALIZATION", function() {
    return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_CLIP", function() {
    return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_DEPTHWISECONV", function() {
    return !1;
}), He.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", function() {
    return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", function() {
    return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", function() {
    return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", function() {
    return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_PACK_REDUCE", function() {
    return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_LAZILY_UNPACK", function() {
    return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_CONV_IM2COL", function() {
    return He.getBool("WEBGL_PACK");
}), He.registerFlag("WEBGL_MAX_TEXTURE_SIZE", function() {
    return Oe(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", function() {
    return Me(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", function() {
    var t392 = He.getNumber("WEBGL_VERSION");
    return 0 === t392 ? 0 : Be(t392);
}), He.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", function() {
    var t393;
    return He.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && (t393 = navigator.userAgent || navigator.vendor || window.opera, !(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t393) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t393.substr(0, 4))));
}), He.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", function() {
    return We(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", function() {
    return !He.getBool("WEBGL_FORCE_F16_TEXTURES") && He.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
}), He.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", function() {
    return Ue(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_FENCE_API_ENABLED", function() {
    return ze(He.getNumber("WEBGL_VERSION"));
}), He.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", function() {
    return He.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0;
}), bt = Xe;
var Tn = An({
    complex_: function(t394, e239) {
        var n152 = gn(t394, "real", "complex"), r109 = gn(e239, "imag", "complex");
        return E(n152.shape, r109.shape, "real and imag shapes, " + n152.shape + " and " + r109.shape + ", must match in call to tf.complex()."), Lt.runKernelFunc(function(t395) {
            return t395.complex(n152, r109);
        }, {
            $real: n152,
            $imag: r109
        });
    }
}), Dn = An({
    real_: function(t396) {
        var e240 = gn(t396, "input", "real");
        return Lt.runKernelFunc(function(t397) {
            return t397.real(e240);
        }, {
            $input: e240
        });
    }
}), Nn = An({
    imag_: function(t398) {
        var e241 = gn(t398, "input", "imag");
        return Lt.runKernelFunc(function(t399) {
            return t399.imag(e241);
        }, {
            $input: e241
        });
    }
});
function Fn(t400, e242, n153) {
    return _n(t400, e242, pn(t400, n153), n153);
}
function _n(t401, e243, n154, r110) {
    if (null == r110 && (r110 = j(t401)), "complex64" === r110) throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
    if (!V(t401) && !Array.isArray(t401) && "number" != typeof t401 && "boolean" != typeof t401 && "string" != typeof t401) throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
    if (null != e243) {
        nt(e243);
        var o69 = k(e243), a47 = k(n154);
        C(o69 === a47, function() {
            return "Based on the provided shape, [" + e243 + "], the tensor should have " + o69 + " values but has " + a47;
        });
        for(var s29 = 0; s29 < n154.length; ++s29){
            var u18 = n154[s29], c9 = s29 !== n154.length - 1 || u18 !== k(e243.slice(s29));
            C(n154[s29] === e243[s29] || !c9, function() {
                return "Error creating a new Tensor. Inferred shape (" + n154 + ") does not match the provided shape (" + e243 + "). ";
            });
        }
    }
    return V(t401) || Array.isArray(t401) || (t401 = [
        t401
    ]), e243 = e243 || n154, t401 = "string" !== r110 ? Q(t401, r110, i().getBool("DEBUG")) : I(t401, [], !0), Lt.makeTensor(t401, e243, r110);
}
function On(t402, e244) {
    if ((V(t402) && "string" !== e244 || Array.isArray(t402)) && "complex64" !== e244) throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
    if ("string" === e244 && V(t402) && !(t402 instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
    return _n(t402, [], [], e244);
}
function Mn(t403, e245) {
    R(t403);
    var n155 = pn(t403, e245);
    if (1 !== n155.length) throw new Error("tensor1d() requires values to be a flat/TypedArray");
    return _n(t403, null, n155, e245);
}
function Bn(t404, e246, n156) {
    if (R(t404), null != e246 && 2 !== e246.length) throw new Error("tensor2d() requires shape to have two numbers");
    var r111 = pn(t404, n156);
    if (2 !== r111.length && 1 !== r111.length) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
    if (1 === r111.length && null == e246) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
    return _n(t404, e246, r111, n156);
}
function Pn(t405, e247, n157) {
    if (R(t405), null != e247 && 3 !== e247.length) throw new Error("tensor3d() requires shape to have three numbers");
    var r112 = pn(t405, n157);
    if (3 !== r112.length && 1 !== r112.length) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
    if (1 === r112.length && null == e247) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
    return _n(t405, e247, r112, n157);
}
function Ln(t406, e248, n158) {
    if (R(t406), null != e248 && 4 !== e248.length) throw new Error("tensor4d() requires shape to have four numbers");
    var r113 = pn(t406, n158);
    if (4 !== r113.length && 1 !== r113.length) throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
    if (1 === r113.length && null == e248) throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
    return _n(t406, e248, r113, n158);
}
function Wn(t407, e249, n159) {
    if (R(t407), null != e249 && 5 !== e249.length) throw new Error("tensor5d() requires shape to have five numbers");
    var r114 = pn(t407, n159);
    if (5 !== r114.length && 1 !== r114.length) throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
    if (1 === r114.length && null == e249) throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
    return _n(t407, e249, r114, n159);
}
function Un(t408, e250, n160) {
    if (R(t408), null != e250 && 6 !== e250.length) throw new Error("tensor6d() requires shape to have six numbers");
    var r115 = pn(t408, n160);
    if (6 !== r115.length && 1 !== r115.length) throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
    if (1 === r115.length && null == e250) throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
    return _n(t408, e250 = e250 || r115, r115, n160);
}
function Vn(t409, e251, n161, r116) {
    return void 0 === e251 && (e251 = !0), Lt.makeVariable(t409, e251, n161, r116);
}
function zn(t410, e252) {
    if (void 0 === e252 && (e252 = "float32"), "complex64" === e252) {
        var n162 = zn(t410, "float32"), r117 = Gn(t410, "float32");
        return Tn(n162, r117);
    }
    var o70 = Z(k(t410), e252);
    return Lt.makeTensor(o70, t410, e252);
}
function Gn(t411, e253) {
    if (void 0 === e253 && (e253 = "float32"), "complex64" === e253) {
        var n163 = Gn(t411, "float32"), r118 = Gn(t411, "float32");
        return Tn(n163, r118);
    }
    var o71 = tt(k(t411), e253);
    return Lt.makeTensor(o71, t411, e253);
}
function Hn(t412, e254, n164) {
    return Lt.runKernelFunc(function(r119) {
        return r119.fill(t412, e254, n164);
    }, {
    });
}
function qn(t413, e255, n165) {
    if (n165 <= 0) throw new Error("The number of values should be positive.");
    return Lt.runKernelFunc(function(r120) {
        return r120.linspace(t413, e255, n165);
    }, {
    });
}
function Kn(t414, e256, n166, r121) {
    if (void 0 === n166 && (n166 = 1), void 0 === r121 && (r121 = "float32"), 0 === n166) throw new Error("Cannot have a step of zero");
    if (t414 === e256 || t414 < e256 && n166 < 0 || e256 < t414 && n166 > 1) return Gn([
        0
    ], r121);
    var o72 = tt(Math.abs(Math.ceil((e256 - t414) / n166)), r121);
    e256 < t414 && 1 === n166 && (n166 = -1), o72[0] = t414;
    for(var a48 = 1; a48 < o72.length; a48++)o72[a48] = o72[a48 - 1] + n166;
    return Mn(o72, r121);
}
var jn = An({
    onesLike_: function(t415) {
        var e257 = gn(t415, "x", "onesLike");
        if ("complex64" === e257.dtype) {
            var n167 = jn(Dn(e257)), r122 = Xn(Nn(e257));
            return Tn(n167, r122);
        }
        return Lt.runKernelFunc(function(t416) {
            return t416.onesLike(e257);
        }, {
            x: e257
        }, function(t417, e) {
            return {
                x: function() {
                    return Xn(t417);
                }
            };
        }, "OnesLike");
    }
}), Xn = An({
    zerosLike_: function(t418) {
        var e258 = gn(t418, "x", "zerosLike");
        return Lt.runKernelFunc(function(t419) {
            return t419.zerosLike(e258);
        }, {
            x: e258
        }, function(t420, e) {
            return {
                x: function() {
                    return Xn(t420);
                }
            };
        }, "ZerosLike");
    }
});
var Yn = An({
    concat_: function(t421, e259) {
        void 0 === e259 && (e259 = 0), C(t421.length >= 1, function() {
            return "Pass at least one tensor to concat";
        });
        var n168 = mn(t421, "tensors", "concat");
        "complex64" === n168[0].dtype && n168.forEach(function(t422) {
            if ("complex64" !== t422.dtype) throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype " + t422.dtype + ". ");
        }), e259 = O(e259, n168[0].shape)[0];
        var r123 = Sn(n168.map(function(t423) {
            return t423.shape;
        }), e259);
        if (0 === k(r123)) return Fn([], r123);
        if (1 === (n168 = n168.filter(function(t424) {
            return t424.size > 0;
        })).length) return n168[0];
        var o73 = n168.map(function(t425) {
            return t425.shape;
        });
        kn(o73, e259);
        var a49 = n168, i26 = {
            axis: e259
        };
        return Lt.runKernelFunc(function(t426) {
            return t426.concat(n168, e259);
        }, a49, function(t427) {
            var n169 = o73.map(function(t428) {
                return t428[e259];
            });
            return tr(t427, n169, e259).map(function(t429) {
                return function() {
                    return t429;
                };
            });
        }, "Concat", i26);
    }
}), $n = An({
    concat1d_: function(t430) {
        return Yn(t430, 0);
    }
}), Qn = An({
    concat2d_: function(t431, e260) {
        return Yn(t431, e260);
    }
}), Jn = An({
    concat3d_: function(t432, e261) {
        return Yn(t432, e261);
    }
}), Zn = An({
    concat4d_: function(t433, e262) {
        return Yn(t433, e262);
    }
}), tr = An({
    split_: function(t434, e263, n170) {
        void 0 === n170 && (n170 = 0);
        var r124, o74 = gn(t434, "x", "split");
        return n170 = O(n170, o74.shape)[0], "number" == typeof e263 ? (C(o74.shape[n170] % e263 == 0, function() {
            return "Number of splits must evenly divide the axis.";
        }), r124 = new Array(e263).fill(o74.shape[n170] / e263)) : (C(o74.shape[n170] === e263.reduce(function(t435, e264) {
            return t435 + e264;
        }), function() {
            return "The sum of sizes must match the size of the axis dimension.";
        }), r124 = e263), Lt.runKernelFunc(function(t436) {
            return t436.split(o74, r124, n170);
        }, {
            $x: o74
        }, function(t437) {
            return {
                $x: function() {
                    return Yn(t437, n170);
                }
            };
        });
    }
});
function er(t438, e265, n171) {
    return void 0 === e265 && (e265 = "float32"), e265 = e265 || "float32", nt(t438), new mt(t438, e265, n171);
}
function nr(t439, e266) {
    void 0 === e266 && (e266 = !1), console.log(t439.toString(e266));
}
var rr = An({
    batchToSpaceND_: function(t440, e267, n172) {
        var r125 = gn(t440, "x", "batchToSpaceND"), o75 = e267.reduce(function(t441, e268) {
            return t441 * e268;
        });
        return C(r125.rank >= 1 + e267.length, function() {
            return "input rank is " + r125.rank + " but should be > than blockShape.length " + e267.length;
        }), C(n172.length === e267.length, function() {
            return "crops.length is " + n172.length + " but should be equal to blockShape.length  " + e267.length;
        }), C(r125.shape[0] % o75 == 0, function() {
            return "input tensor batch is " + r125.shape[0] + " but is not divisible by the product of the elements of blockShape " + e267.join(" * ") + " === " + o75;
        }), Lt.runKernelFunc(function(t442) {
            return t442.batchToSpaceND(r125, e267, n172);
        }, {
            $x: r125
        }, function(t443) {
            return {
                $x: function() {
                    return t443.spaceToBatchND(e267, n172);
                }
            };
        });
    }
}), or = An({
    cast_: function(t444, e269) {
        var n173 = gn(t444, "x", "cast");
        if (!W(e269)) throw new Error("Failed to cast to unknown dtype " + e269);
        if ("string" === e269 && "string" !== n173.dtype || "string" !== e269 && "string" === n173.dtype) throw new Error("Only strings can be casted to strings");
        var r126 = {
            dtype: e269
        };
        return Lt.runKernelFunc(function(t445) {
            return t445.cast(n173, e269);
        }, {
            x: n173
        }, function(t446) {
            return {
                x: function() {
                    return t446.clone();
                }
            };
        }, "Cast", r126);
    }
}), ar = An({
    cumsum_: function(t447, e270, n174, r127) {
        void 0 === e270 && (e270 = 0), void 0 === n174 && (n174 = !1), void 0 === r127 && (r127 = !1);
        var o76 = gn(t447, "x", "cumsum"), a50 = En([
            e270 |= 0
        ], o76.rank), i27 = o76;
        null != a50 && (i27 = o76.transpose(a50));
        var s30 = In(1, o76.rank)[0], u19 = Lt.runKernelFunc(function(t448) {
            return t448.cumsum(i27, s30, n174, r127);
        }, {
            permutedX: i27
        }, function(t449) {
            return {
                permutedX: function() {
                    return t449.cumsum(e270, n174, !r127);
                }
            };
        });
        return null != a50 && (u19 = u19.transpose(a50)), u19;
    }
}), ir = An({
    depthToSpace_: function(t450, e271, n175) {
        void 0 === n175 && (n175 = "NHWC");
        var r128 = gn(t450, "x", "depthToSpace"), o77 = "NHWC" === n175 ? r128.shape[1] : r128.shape[2], a51 = "NHWC" === n175 ? r128.shape[2] : r128.shape[3], i28 = "NHWC" === n175 ? r128.shape[3] : r128.shape[1];
        return C(o77 * e271 >= 0, function() {
            return "Negative dimension size caused by overflow when multiplying\n      " + o77 + " and " + e271 + "  for depthToSpace with input shape\n      " + r128.shape;
        }), C(a51 * e271 >= 0, function() {
            return "Negative dimension size caused by overflow when multiplying\n      " + a51 + " and " + e271 + " for depthToSpace with input shape\n          " + r128.shape;
        }), C(i28 % (e271 * e271) == 0, function() {
            return "Dimension size must be evenly divisible by " + e271 * e271 + " but is " + i28 + " for depthToSpace with input shape " + r128.shape;
        }), Lt.runKernelFunc(function(t451) {
            return t451.depthToSpace(r128, e271, n175);
        }, {
            $x: r128
        });
    }
}), sr = An({
    expandDims_: function(t452, e272) {
        void 0 === e272 && (e272 = 0);
        var n176 = gn(t452, "x", "expandDims", null);
        C(e272 <= n176.rank, function() {
            return "Axis must be <= rank of the tensor";
        });
        var r129 = n176.shape.slice();
        return e272 < 0 && (C(-(n176.rank + 1) <= e272, function() {
            return "Axis must be in the interval [" + -(n176.rank + 1) + ", " + n176.rank + "]";
        }), e272 = n176.rank + e272 + 1), r129.splice(e272, 0, 1), ur(n176, r129);
    }
}), ur = An({
    reshape_: function(t453, e273) {
        var n177 = gn(t453, "x", "reshape", null);
        e273 = _14(e273, n177.size), C(n177.size === k(e273), function() {
            return "new shape and old shape must have the same number of elements.";
        });
        var r130 = {
            shape: e273
        };
        return Lt.runKernelFunc(function(t454) {
            return t454.reshape(n177, e273);
        }, {
            x: n177
        }, function(t455) {
            return {
                x: function() {
                    return t455.reshape(n177.shape);
                }
            };
        }, "Reshape", r130);
    }
}), cr = An({
    spaceToBatchND_: function(t456, e274, n178) {
        var r131 = gn(t456, "x", "spaceToBatchND");
        return C(r131.rank >= 1 + e274.length, function() {
            return "input rank " + r131.rank + " should be > than [blockShape] " + e274.length;
        }), C(n178.length === e274.length, function() {
            return "paddings.shape[0] " + n178.length + " must be equal to [blockShape] " + e274.length;
        }), C(r131.shape.reduce(function(t457, r132, o78) {
            return o78 > 0 && o78 <= e274.length ? t457 && (r132 + n178[o78 - 1][0] + n178[o78 - 1][1]) % e274[o78 - 1] == 0 : t457;
        }, !0), function() {
            return "input spatial dimensions " + r131.shape.slice(1) + " with paddings " + n178.toString() + " must be divisible by blockShapes " + e274.toString();
        }), Lt.runKernelFunc(function(t458) {
            return t458.spaceToBatchND(r131, e274, n178);
        }, {
            $x: r131
        }, function(t459) {
            return {
                $x: function() {
                    return t459.batchToSpaceND(e274, n178);
                }
            };
        });
    }
}), lr = An({
    squeeze_: function(t460, e275) {
        var n179 = gn(t460, "x", "squeeze");
        return ur(n179, M(n179.shape, e275).newShape);
    }
}), hr = An({
    stack_: function(t461, e276) {
        void 0 === e276 && (e276 = 0);
        var n180 = mn(t461, "tensors", "stack");
        if (C(n180.length >= 1, function() {
            return "Pass at least one tensor to tf.stack";
        }), 1 === n180.length) return n180[0].expandDims(e276);
        var r133 = n180[0].rank, o79 = n180[0].shape, a52 = n180[0].dtype;
        C(e276 <= r133, function() {
            return "Axis must be <= rank of the tensor";
        }), n180.forEach(function(t462) {
            E(o79, t462.shape, "All tensors passed to stack must have matching shapes");
        }), n180.forEach(function(t463) {
            C(a52 === t463.dtype, function() {
                return "All tensors passed to stack must have matching dtypes";
            });
        });
        var i29 = n180.map(function(t464) {
            return t464.expandDims(e276);
        });
        return Yn(i29, e276);
    }
}), fr = An({
    unstack_: function(t465, e277) {
        void 0 === e277 && (e277 = 0), e277 = e277 || 0;
        var n181 = gn(t465, "x", "unstack");
        C(e277 >= -n181.shape.length && e277 < n181.shape.length, function() {
            return "Axis = " + e277 + " is not in [-" + n181.shape.length + ", " + n181.shape.length + ")";
        }), e277 < 0 && (e277 += n181.shape.length);
        var r134 = {
            axis: e277
        };
        return Lt.runKernelFunc(function(t466) {
            return t466.unstack(n181, e277);
        }, {
            x: n181
        }, function(t467) {
            return {
                x: function() {
                    return hr(t467, e277);
                }
            };
        }, "Unpack", r134);
    }
}), dr = function(t468, e278) {
    return n(this, void 0, void 0, function() {
        var n182, o80, a53, i30, s31, u20, c10, l7, h8, f7;
        return r(this, function(r135) {
            switch(r135.label){
                case 0:
                    return n182 = gn(t468, "x", "setdiff1d"), o80 = gn(e278, "y", "setdiff1d"), C(n182.dtype === o80.dtype, function() {
                        return "x and y should have the same dtype, but got x (" + n182.dtype + ") and y (" + o80.dtype + ").";
                    }), C(1 === n182.rank, function() {
                        return "x should be 1D tensor, but got x (" + n182.shape + ").";
                    }), C(1 === o80.rank, function() {
                        return "y should be 1D tensor, but got y (" + o80.shape + ").";
                    }), [
                        4,
                        n182.data()
                    ];
                case 1:
                    return a53 = r135.sent(), [
                        4,
                        o80.data()
                    ];
                case 2:
                    for(i30 = r135.sent(), s31 = new Set(i30), u20 = 0, h8 = 0; h8 < a53.length; h8++)s31.has(a53[h8]) || u20++;
                    for(c10 = new mt([
                        u20
                    ], n182.dtype), l7 = new mt([
                        u20
                    ], "int32"), h8 = 0, f7 = 0; h8 < a53.length; h8++)s31.has(a53[h8]) || (c10.values[f7] = a53[h8], l7.values[f7] = h8, f7++);
                    return [
                        2,
                        [
                            c10.toTensor(),
                            l7.toTensor()
                        ]
                    ];
            }
        });
    });
};
function pr(t469, e279, n183, r136) {
    void 0 === r136 && (r136 = !0);
    var o81 = [];
    if (r136) (o81 = o81.concat(e279.slice(0))).push(t469[0] / n183), o81 = o81.concat(t469.slice(1));
    else {
        o81 = o81.concat(t469[0]);
        for(var a54 = e279.length, i31 = 0; i31 < a54; ++i31)o81 = o81.concat([
            t469[i31 + 1] / e279[i31],
            e279[i31]
        ]);
        o81 = o81.concat(t469.slice(a54 + 1));
    }
    return o81;
}
function vr(t470, e280, n184) {
    void 0 === n184 && (n184 = !0);
    var r137 = [];
    if (n184) {
        r137.push(e280);
        for(var o82 = e280 + 1; o82 < t470; ++o82)o82 <= 2 * e280 ? (r137.push(o82), r137.push(o82 - (e280 + 1))) : r137.push(o82);
    } else {
        var a55 = [], i32 = [];
        for(o82 = 1; o82 < t470; ++o82)o82 >= 2 * e280 + 1 || o82 % 2 == 1 ? i32.push(o82) : a55.push(o82);
        r137.push.apply(r137, a55), r137.push(0), r137.push.apply(r137, i32);
    }
    return r137;
}
function gr(t471, e281, n185, r138) {
    void 0 === r138 && (r138 = !0);
    var o83 = [];
    r138 ? o83.push(t471[0] / n185) : o83.push(t471[0] * n185);
    for(var a56 = 1; a56 < t471.length; ++a56)a56 <= e281.length ? r138 ? o83.push(e281[a56 - 1] * t471[a56]) : o83.push(t471[a56] / e281[a56 - 1]) : o83.push(t471[a56]);
    return o83;
}
function mr(t472, e282) {
    for(var n186 = [
        0
    ], r139 = 0; r139 < e282; ++r139)n186.push(t472[r139][0]);
    return n186;
}
function yr(t473, e283, n187) {
    for(var r140 = t473.slice(0, 1), o84 = 0; o84 < n187; ++o84)r140.push(t473[o84 + 1] - e283[o84][0] - e283[o84][1]);
    return r140;
}
var xr = "Add", br = "AddN", wr = "Div", Cr = "FusedBatchNorm", Er = "SquaredDifference", Rr = "Square", Ir = "Transpose", kr = "NonMaxSuppressionV5", Sr = "BroadcastTo", Ar = "OneHot", Tr = "Identity", Dr = "Tile", Nr = "PadV2", Fr = "FromPixels", _r = "MaxPoolWithArgmax";
var Or = An({
    add_: function(t474, e284) {
        var n188, r141 = gn(t474, "a", "add"), o85 = gn(e284, "b", "add");
        n188 = Nt(r141, o85), r141 = n188[0], o85 = n188[1];
        var a57 = {
            a: r141,
            b: o85
        };
        return Lt.runKernelFunc(function(t475, e285) {
            var n189 = t475.add(r141, o85);
            return e285([
                r141,
                o85
            ]), n189;
        }, a57, null, xr);
    }
});
function Mr(t476, e286) {
    for(var n190 = t476.length, r142 = [], o86 = 0; o86 < n190; o86++){
        var a58 = n190 - 1 - o86, i33 = t476[a58] || 1;
        (e286[e286.length - 1 - o86] || 1) > 1 && 1 === i33 && r142.unshift(a58);
    }
    return r142;
}
function Br(t477, e287) {
    for(var n191 = [], r143 = 0; r143 < e287.length; r143++){
        var o87 = t477[t477.length - r143 - 1], a59 = e287.length - r143 - 1, i34 = e287[a59];
        (null == o87 || 1 === o87 && i34 > 1) && n191.unshift(a59);
    }
    return n191;
}
function Pr(t478, e288) {
    for(var n192 = [], r144 = Math.max(t478.length, e288.length), o88 = 0; o88 < r144; o88++){
        var a60 = t478[t478.length - o88 - 1];
        null == a60 && (a60 = 1);
        var i35 = e288[e288.length - o88 - 1];
        if (null == i35 && (i35 = 1), 1 === a60) n192.unshift(i35);
        else if (1 === i35) n192.unshift(a60);
        else {
            if (a60 !== i35) throw Error("Operands could not be broadcast together with shapes " + t478 + " and " + e288 + ".");
            n192.unshift(a60);
        }
    }
    return n192;
}
var Lr = An({
    abs_: function(t479) {
        var e289 = gn(t479, "x", "abs");
        return "complex64" === e289.dtype ? Lt.runKernelFunc(function(t480) {
            return t480.complexAbs(e289);
        }, {
            $x: e289
        }) : Lt.runKernelFunc(function(t481, n193) {
            var r145 = t481.abs(e289);
            return n193([
                e289
            ]), r145;
        }, {
            x: e289
        }, function(t482, e290) {
            var n194 = e290[0];
            return {
                x: function() {
                    return t482.mul(n194.toFloat().step(-1));
                }
            };
        }, "Abs");
    }
}), Wr = An({
    acos_: function(t483) {
        var e291 = gn(t483, "x", "acos");
        return Lt.runKernelFunc(function(t484, n195) {
            var r146 = t484.acos(e291);
            return n195([
                e291
            ]), r146;
        }, {
            $x: e291
        }, function(t485, e292) {
            var n196 = e292[0];
            return {
                $x: function() {
                    return t485.divStrict(On(1).sub(n196.toFloat().square()).sqrt()).neg();
                }
            };
        });
    }
}), Ur = An({
    acosh_: function(t486) {
        var e293 = gn(t486, "x", "acosh");
        return Lt.runKernelFunc(function(t487, n197) {
            var r147 = t487.acosh(e293);
            return n197([
                e293
            ]), r147;
        }, {
            $x: e293
        }, function(t488, e294) {
            var n198 = e294[0];
            return {
                $x: function() {
                    return t488.divStrict(n198.toFloat().square().sub(1).sqrt());
                }
            };
        });
    }
}), Vr = An({
    asin_: function(t489) {
        var e295 = gn(t489, "x", "asin");
        return Lt.runKernelFunc(function(t490, n199) {
            var r148 = t490.asin(e295);
            return n199([
                e295
            ]), r148;
        }, {
            $x: e295
        }, function(t491, e296) {
            var n200 = e296[0];
            return {
                $x: function() {
                    return t491.divStrict(On(1).sub(n200.toFloat().square()).sqrt());
                }
            };
        });
    }
}), zr = An({
    asinh_: function(t492) {
        var e297 = gn(t492, "x", "asinh");
        return Lt.runKernelFunc(function(t493, n201) {
            var r149 = t493.asinh(e297);
            return n201([
                e297
            ]), r149;
        }, {
            $x: e297
        }, function(t494, e298) {
            var n202 = e298[0];
            return {
                $x: function() {
                    return t494.divStrict(On(1).add(n202.toFloat().square()).sqrt());
                }
            };
        });
    }
}), Gr = An({
    atan_: function(t495) {
        var e299 = gn(t495, "x", "atan");
        return Lt.runKernelFunc(function(t496, n203) {
            var r150 = t496.atan(e299);
            return n203([
                e299
            ]), r150;
        }, {
            $x: e299
        }, function(t497, e300) {
            var n204 = e300[0];
            return {
                $x: function() {
                    return t497.div(n204.toFloat().square().add(1));
                }
            };
        });
    }
}), Hr = An({
    atanh_: function(t498) {
        var e301 = gn(t498, "x", "atanh");
        return Lt.runKernelFunc(function(t499, n205) {
            var r151 = t499.atanh(e301);
            return n205([
                e301
            ]), r151;
        }, {
            $x: e301
        }, function(t500, e302) {
            var n206 = e302[0];
            return {
                $x: function() {
                    return t500.div(On(1).sub(n206.toFloat().square()));
                }
            };
        });
    }
}), qr = An({
    ceil_: function(t501) {
        var e303 = gn(t501, "x", "ceil");
        return Lt.runKernelFunc(function(t502) {
            return t502.ceil(e303);
        }, {
            $x: e303
        }, function(t503) {
            return {
                $x: function() {
                    return Xn(t503);
                }
            };
        });
    }
}), Kr = An({
    clipByValue_: function(t504, e304, n207) {
        var r152 = gn(t504, "x", "clipByValue");
        C(e304 <= n207, function() {
            return "Error in clip: min (" + e304 + ") must be less than or equal to max (" + n207 + ").";
        });
        var o89 = [
            r152
        ], a61 = {
            min: e304,
            max: n207
        };
        return Lt.runKernelFunc(function(t505, o90) {
            var a62 = t505.clip(r152, e304, n207);
            return o90([
                r152
            ]), a62;
        }, {
            x: r152
        }, function(t506, r153) {
            var o91 = r153[0];
            return {
                x: function() {
                    return t506.where(o91.greaterEqual(e304).logicalAnd(o91.lessEqual(n207)), Xn(t506));
                }
            };
        }, "ClipByValue", a61, o89);
    }
}), jr = An({
    cos_: function(t507) {
        var e305 = gn(t507, "x", "cos"), n208 = [
            e305
        ];
        return Lt.runKernelFunc(function(t508, n209) {
            var r154 = t508.cos(e305);
            return n209([
                e305
            ]), r154;
        }, {
            x: e305
        }, function(t509, e306) {
            var n210 = e306[0];
            return {
                x: function() {
                    return n210.toFloat().sin().neg().mul(t509);
                }
            };
        }, "Cos", {
        }, n208);
    }
}), Xr = An({
    cosh_: function(t510) {
        var e307 = gn(t510, "x", "cosh");
        return Lt.runKernelFunc(function(t511, n211) {
            var r155 = t511.cosh(e307);
            return n211([
                e307
            ]), r155;
        }, {
            $x: e307
        }, function(t512, e308) {
            var n212 = e308[0];
            return {
                $x: function() {
                    return n212.toFloat().sinh().mulStrict(t512);
                }
            };
        });
    }
}), Yr = An({
    erf_: function(t513) {
        var e309 = gn(t513, "x", "erf");
        return C("int32" === e309.dtype || "float32" === e309.dtype, function() {
            return "Input dtype must be `int32` or `float32`.";
        }), "int32" === e309.dtype && (e309 = e309.toFloat()), Lt.runKernelFunc(function(t514, n213) {
            var r156 = t514.erf(e309);
            return n213([
                e309
            ]), r156;
        }, {
            $x: e309
        }, function(t515, e310) {
            var n214 = e310[0];
            return {
                $x: function() {
                    return t515.mul(n214.square().neg().exp().mul(2 / Math.sqrt(Math.PI)));
                }
            };
        });
    }
}), $r = An({
    exp_: function(t516) {
        var e311 = gn(t516, "x", "exp");
        return Lt.runKernelFunc(function(t517, n215) {
            var r157 = t517.exp(e311);
            return n215([
                r157
            ]), r157;
        }, {
            x: e311
        }, function(t518, e312) {
            return {
                x: function() {
                    return t518.mulStrict(e312[0]);
                }
            };
        }, "Exp", {
        }, [], [
            !0
        ]);
    }
}), Qr = An({
    expm1_: function(t519) {
        var e313 = gn(t519, "x", "expm1");
        return Lt.runKernelFunc(function(t520, n216) {
            var r158 = t520.expm1(e313);
            return n216([
                e313
            ]), r158;
        }, {
            $x: e313
        }, function(t521, e314) {
            var n217 = e314[0];
            return {
                $x: function() {
                    return t521.mul(n217.exp());
                }
            };
        });
    }
}), Jr = An({
    floor_: function(t522) {
        var e315 = gn(t522, "x", "floor");
        return Lt.runKernelFunc(function(t523) {
            return t523.floor(e315);
        }, {
            $x: e315
        }, function(t524) {
            return {
                $x: function() {
                    return Xn(t524);
                }
            };
        });
    }
}), Zr = An({
    log_: function(t525) {
        var e316 = gn(t525, "x", "log"), n218 = [
            e316
        ];
        return Lt.runKernelFunc(function(t526, n219) {
            var r159 = t526.log(e316);
            return n219([
                e316
            ]), r159;
        }, {
            x: e316
        }, function(t527, e317) {
            var n220 = e317[0];
            return {
                x: function() {
                    return t527.div(n220.toFloat());
                }
            };
        }, "Log", {
        }, n218);
    }
}), to = An({
    log1p_: function(t528) {
        var e318 = gn(t528, "x", "log1p");
        return Lt.runKernelFunc(function(t529, n221) {
            var r160 = t529.log1p(e318);
            return n221([
                e318
            ]), r160;
        }, {
            $x: e318
        }, function(t530, e319) {
            var n222 = e319[0];
            return {
                $x: function() {
                    return t530.div(n222.add(1));
                }
            };
        });
    }
}), eo = An({
    logSigmoid_: function(t531) {
        var e320 = gn(t531, "x", "logSigmoid");
        return Lt.runKernelFunc(function(t532, n223) {
            var r161 = t532.softplus(e320.neg()).neg();
            return n223([
                e320
            ]), r161;
        }, {
            $x: e320
        }, function(t533, e321) {
            var n224 = e321[0];
            return {
                $x: function() {
                    return t533.mul(n224.neg().sigmoid());
                }
            };
        });
    }
}), no = An({
    neg_: function(t534) {
        var e322 = gn(t534, "x", "neg"), n225 = [
            e322
        ];
        return Lt.runKernelFunc(function(t535) {
            return t535.neg(e322);
        }, {
            x: e322
        }, function(t536) {
            return {
                x: function() {
                    return t536.neg();
                }
            };
        }, "Neg", {
        }, n225);
    }
}), ro = An({
    reciprocal_: function(t537) {
        var e323 = gn(t537, "x", "reciprocal");
        return Lt.runKernelFunc(function(t538, n226) {
            var r162 = t538.reciprocal(e323);
            return n226([
                e323
            ]), r162;
        }, {
            $x: e323
        }, function(t539, e324) {
            var n227 = e324[0];
            return {
                $x: function() {
                    return t539.div(n227.square().neg());
                }
            };
        });
    }
}), oo = An({
    round_: function(t540) {
        var e325 = gn(t540, "x", "round");
        return Lt.runKernelFunc(function(t541) {
            return t541.round(e325);
        }, {
            $x: e325
        }, function(t542) {
            return {
                $x: function() {
                    return Xn(t542);
                }
            };
        });
    }
}), ao = An({
    rsqrt_: function(t543) {
        var e326 = gn(t543, "x", "rsqrt"), n228 = [
            e326
        ];
        return Lt.runKernelFunc(function(t544, n229) {
            var r163 = t544.rsqrt(e326);
            return n229([
                e326
            ]), r163;
        }, {
            x: e326
        }, function(t545, e327) {
            var n230 = e327[0];
            return {
                x: function() {
                    return t545.div(n230.pow(1.5).mul(2)).neg();
                }
            };
        }, "Rsqrt", {
        }, n228);
    }
}), io = An({
    sigmoid_: function(t546) {
        var e328 = gn(t546, "x", "sigmoid");
        return Lt.runKernelFunc(function(t547, n231) {
            var r164 = t547.sigmoid(e328);
            return n231([
                r164
            ]), r164;
        }, {
            x: e328
        }, function(t548, e329) {
            var n232 = e329[0];
            return {
                x: function() {
                    return t548.mul(n232.mul(On(1).sub(n232)));
                }
            };
        }, "Sigmoid");
    }
}), so = An({
    sign_: function(t549) {
        var e330 = gn(t549, "x", "sign");
        return Lt.runKernelFunc(function(t550) {
            return t550.sign(e330);
        }, {
            $x: e330
        }, function(t551) {
            return {
                $x: function() {
                    return Xn(t551);
                }
            };
        });
    }
}), uo = An({
    isNaN_: function(t552) {
        var e331 = gn(t552, "x", "isNaN");
        return Lt.runKernelFunc(function(t553) {
            return t553.isNaN(e331);
        }, {
            $x: e331
        }, function(t554) {
            return {
                $x: function() {
                    return Xn(t554);
                }
            };
        });
    }
}), co = An({
    isInf_: function(t555) {
        var e332 = gn(t555, "x", "isInf");
        return Lt.runKernelFunc(function(t556) {
            return t556.isInf(e332);
        }, {
            $x: e332
        }, function(t557) {
            return {
                $x: function() {
                    return Xn(t557);
                }
            };
        });
    }
}), lo = An({
    isFinite_: function(t558) {
        var e333 = gn(t558, "x", "isFinite");
        return Lt.runKernelFunc(function(t559) {
            return t559.isFinite(e333);
        }, {
            $x: e333
        }, function(t560) {
            return {
                $x: function() {
                    return Xn(t560);
                }
            };
        });
    }
}), ho = An({
    sin_: function(t561) {
        var e334 = gn(t561, "x", "sin"), n233 = [
            e334
        ];
        return Lt.runKernelFunc(function(t562, n234) {
            var r165 = t562.sin(e334);
            return n234([
                e334
            ]), r165;
        }, {
            x: e334
        }, function(t563, e335) {
            var n235 = e335[0];
            return {
                x: function() {
                    return n235.toFloat().cos().mul(t563);
                }
            };
        }, "Sin", {
        }, n233);
    }
}), fo = An({
    sinh_: function(t564) {
        var e336 = gn(t564, "x", "sinh");
        return Lt.runKernelFunc(function(t565, n236) {
            var r166 = t565.sinh(e336);
            return n236([
                e336
            ]), r166;
        }, {
            $x: e336
        }, function(t566, e337) {
            var n237 = e337[0];
            return {
                $x: function() {
                    return n237.toFloat().cosh().mulStrict(t566);
                }
            };
        });
    }
}), po = An({
    softplus_: function(t567) {
        var e338 = gn(t567, "x", "softplus");
        return Lt.runKernelFunc(function(t568, n238) {
            var r167 = t568.softplus(e338);
            return n238([
                e338
            ]), r167;
        }, {
            $x: e338
        }, function(t569, e339) {
            var n239 = e339[0];
            return {
                $x: function() {
                    return t569.mul(n239.sigmoid());
                }
            };
        });
    }
}), vo = An({
    sqrt_: function(t570) {
        var e340 = gn(t570, "x", "sqrt");
        return Lt.runKernelFunc(function(t571, n240) {
            var r168 = t571.sqrt(e340);
            return n240([
                e340
            ]), r168;
        }, {
            $x: e340
        }, function(t572, e341) {
            var n241 = e341[0];
            return {
                $x: function() {
                    return t572.div(n241.toFloat().sqrt().mul(2));
                }
            };
        });
    }
}), go = An({
    step_: function(t573, e342) {
        void 0 === e342 && (e342 = 0);
        var n242 = gn(t573, "x", "step");
        return Lt.runKernelFunc(function(t574) {
            return t574.step(n242, e342);
        }, {
            $x: n242
        }, function(t575) {
            return {
                $x: function() {
                    return Xn(t575);
                }
            };
        });
    }
}), mo = An({
    tan_: function(t576) {
        var e343 = gn(t576, "x", "tan");
        return Lt.runKernelFunc(function(t577, n243) {
            var r169 = t577.tan(e343);
            return n243([
                e343
            ]), r169;
        }, {
            $x: e343
        }, function(t578, e344) {
            var n244 = e344[0];
            return {
                $x: function() {
                    return t578.div(n244.cos().square());
                }
            };
        });
    }
}), yo = An({
    tanh_: function(t579) {
        var e345 = gn(t579, "x", "tanh");
        return Lt.runKernelFunc(function(t580, n245) {
            var r170 = t580.tanh(e345);
            return n245([
                r170
            ]), r170;
        }, {
            x: e345
        }, function(t581, e346) {
            var n246 = e346[0];
            return {
                x: function() {
                    return On(1).sub(n246.square()).mulStrict(t581);
                }
            };
        }, "Tanh", {
        }, null, [
            !0
        ]);
    }
});
var xo = An({
    addStrict_: function(t582, e347) {
        var n247 = gn(t582, "a", "addStrict"), r171 = gn(e347, "b", "addStrict");
        return E(n247.shape, r171.shape, "Error in addStrict: "), n247.add(r171);
    }
}), bo = An({
    atan2_: function(t583, e348) {
        var n248, r172 = gn(t583, "a", "atan2"), o92 = gn(e348, "b", "atan2");
        n248 = Nt(r172, o92), r172 = n248[0], o92 = n248[1];
        var a63 = Pr(r172.shape, o92.shape);
        return Lt.runKernelFunc(function(t584, e349) {
            var n249 = t584.atan2(r172, o92);
            return e349([
                r172,
                o92
            ]), n249;
        }, {
            $a: r172,
            $b: o92
        }, function(t585, e350) {
            var n250 = e350[0], r173 = e350[1];
            return {
                $a: function() {
                    var e351 = Or(n250.square(), r173.square()), o93 = t585.mul(r173.div(e351)), i36 = Br(n250.shape, a63);
                    return i36.length > 0 && (o93 = o93.sum(i36)), o93.reshape(n250.shape);
                },
                $b: function() {
                    var e352 = Or(n250.square(), r173.square()), o94 = no(t585.mul(n250.div(e352))), i37 = Br(r173.shape, a63);
                    return i37.length > 0 && (o94 = o94.sum(i37)), o94.reshape(r173.shape);
                }
            };
        });
    }
}), wo = An({
    divStrict_: function(t586, e353) {
        var n251 = gn(t586, "a", "div"), r174 = gn(e353, "b", "div");
        return E(n251.shape, r174.shape, "Error in divideStrict: "), n251.div(r174);
    }
}), Co = An({
    floorDiv_: function(t587, e354) {
        var n252, r175 = gn(t587, "a", "floorDiv"), o95 = gn(e354, "b", "floorDiv");
        n252 = Nt(r175, o95), r175 = n252[0], o95 = n252[1];
        var a64 = Pr(r175.shape, o95.shape);
        return Lt.runKernelFunc(function(t588, e355) {
            var n253 = t588.floorDiv(r175, o95);
            return e355([
                r175,
                o95
            ]), n253;
        }, {
            a: r175,
            b: o95
        }, function(t589, e356) {
            var n254 = e356[0], r176 = e356[1];
            return {
                a: function() {
                    var e357 = t589.div(r176.toFloat()), o96 = Br(n254.shape, a64);
                    return o96.length > 0 ? e357.sum(o96).reshape(n254.shape) : e357;
                },
                b: function() {
                    var e358 = t589.mul(n254.toFloat()), o97 = Br(r176.shape, a64);
                    o97.length > 0 && (e358 = e358.sum(o97).reshape(r176.shape));
                    var i38 = r176.square();
                    return e358.div(i38.toFloat()).neg();
                }
            };
        }, "FloorDiv");
    }
}), Eo = An({
    maximum_: function(t590, e359) {
        var n255, r177 = gn(t590, "a", "maximum"), o98 = gn(e359, "b", "maximum");
        return n255 = Nt(r177, o98), r177 = n255[0], o98 = n255[1], "bool" === r177.dtype && (r177 = r177.toInt(), o98 = o98.toInt()), Pr(r177.shape, o98.shape), Lt.runKernelFunc(function(t591, e360) {
            var n256 = t591.maximum(r177, o98);
            return e360([
                r177,
                o98
            ]), n256;
        }, {
            a: r177,
            b: o98
        }, function(t592, e361) {
            var n257 = e361[0], r178 = e361[1];
            return {
                a: function() {
                    return t592.mul(n257.greaterEqual(r178).toFloat());
                },
                b: function() {
                    return t592.mul(n257.less(r178).toFloat());
                }
            };
        }, "Maximum");
    }
}), Ro = An({
    maximumStrict_: function(t593, e362) {
        var n258 = gn(t593, "a", "maximumStrict"), r179 = gn(e362, "b", "maximumStrict");
        return E(n258.shape, r179.shape, "Error in maximumStrict: "), n258.maximum(r179);
    }
}), Io = An({
    minimum_: function(t594, e363) {
        var n259, r180 = gn(t594, "a", "minimum"), o99 = gn(e363, "b", "minimum");
        return n259 = Nt(r180, o99), r180 = n259[0], o99 = n259[1], "bool" === r180.dtype && (r180 = r180.toInt(), o99 = o99.toInt()), Pr(r180.shape, o99.shape), Lt.runKernelFunc(function(t595, e364) {
            var n260 = t595.minimum(r180, o99);
            return e364([
                r180,
                o99
            ]), n260;
        }, {
            a: r180,
            b: o99
        }, function(t596, e365) {
            var n261 = e365[0], r181 = e365[1];
            return {
                a: function() {
                    return t596.mul(n261.lessEqual(r181).toFloat());
                },
                b: function() {
                    return t596.mul(n261.greater(r181).toFloat());
                }
            };
        }, "Minimum");
    }
}), ko = An({
    minimumStrict_: function(t597, e366) {
        var n262 = gn(t597, "a", "minimumStrict"), r182 = gn(e366, "b", "minimumStrict");
        return E(n262.shape, r182.shape, "Error in minimumStrict: "), n262.minimum(r182);
    }
}), So = An({
    mod_: function(t598, e367) {
        var n263, r183 = gn(t598, "a", "mod"), o100 = gn(e367, "b", "mod");
        n263 = Nt(r183, o100), r183 = n263[0], o100 = n263[1];
        var a65 = Pr(r183.shape, o100.shape);
        return Lt.runKernelFunc(function(t599, e368) {
            var n264 = t599.mod(r183, o100);
            return e368([
                r183,
                o100
            ]), n264;
        }, {
            $a: r183,
            $b: o100
        }, function(t600, e369) {
            var n265 = e369[0], r184 = e369[1];
            return {
                $a: function() {
                    var e370 = Br(n265.shape, a65);
                    return e370.length > 0 ? t600.sum(e370).reshape(n265.shape) : t600;
                },
                $b: function() {
                    var e371 = t600.mul(n265.div(r184).floor().neg()), o101 = Br(r184.shape, a65);
                    return o101.length > 0 ? e371.sum(o101).reshape(r184.shape) : e371;
                }
            };
        });
    }
}), Ao = An({
    modStrict_: function(t601, e372) {
        var n266 = gn(t601, "a", "modStrict"), r185 = gn(e372, "b", "modStrict");
        return E(n266.shape, r185.shape, "Error in modStrict: "), n266.mod(r185);
    }
}), To = An({
    mul_: function(t602, e373) {
        var n267, r186 = gn(t602, "a", "mul"), o102 = gn(e373, "b", "mul");
        n267 = Nt(r186, o102), r186 = n267[0], o102 = n267[1];
        var a66 = Pr(r186.shape, o102.shape);
        return Lt.runKernelFunc(function(t603, e374) {
            var n268 = t603.multiply(r186, o102);
            return e374([
                r186,
                o102
            ]), n268;
        }, {
            a: r186,
            b: o102
        }, function(t604, e375) {
            var n269 = e375[0], r187 = e375[1];
            return {
                a: function() {
                    var e376 = t604.mul(r187.toFloat()), o103 = Br(n269.shape, a66);
                    return o103.length > 0 ? e376.sum(o103).reshape(n269.shape) : e376;
                },
                b: function() {
                    var e377 = t604.mul(n269.toFloat()), o104 = Br(r187.shape, a66);
                    return o104.length > 0 ? e377.sum(o104).reshape(r187.shape) : e377;
                }
            };
        }, "Mul");
    }
}), Do = An({
    mulStrict_: function(t605, e378) {
        var n270 = gn(t605, "a", "mul"), r188 = gn(e378, "b", "mul");
        return E(n270.shape, r188.shape, "Error in multiplyStrict: "), n270.mul(r188);
    }
}), No = An({
    pow_: function(t606, e379) {
        var n271, r189 = gn(t606, "base", "pow"), o105 = gn(e379, "exp", "pow");
        n271 = Nt(r189, o105), r189 = n271[0], o105 = n271[1];
        var a67 = Pr(r189.shape, o105.shape), i39 = [
            r189,
            o105
        ];
        return Lt.runKernelFunc(function(t607, e380) {
            var n272 = t607.pow(r189, o105);
            return e380([
                r189,
                o105,
                n272
            ]), n272;
        }, {
            a: r189,
            b: o105
        }, function(t608, e381) {
            var n273 = e381[0], r190 = e381[1], o106 = e381[2];
            return {
                a: function() {
                    var e382 = r190.toFloat(), o107 = t608.mul(e382.mul(n273.pow(e382.sub(On(1))))), i40 = Br(n273.shape, a67);
                    return i40.length > 0 && (o107 = o107.sum(i40)), o107.reshape(n273.shape);
                },
                b: function() {
                    var e383 = n273.greater(0), i41 = n273.log().where(e383, Xn(n273)), s32 = t608.mul(o106.mul(i41)), u21 = Br(r190.shape, a67);
                    return u21.length > 0 && (s32 = s32.sum(u21)), s32.reshape(r190.shape);
                }
            };
        }, "Pow", {
        }, i39, [
            !0
        ]);
    }
}), Fo = An({
    powStrict_: function(t609, e384) {
        return E(t609.shape, e384.shape, "Error in powStrict: "), t609.pow(e384);
    }
}), _o = An({
    squaredDifferenceStrict_: function(t610, e385) {
        var n274 = gn(t610, "a", "squaredDifferenceStrict"), r191 = gn(e385, "b", "squaredDifferenceStrict");
        return E(n274.shape, r191.shape, "Error in squaredDifferenceStrict: "), n274.squaredDifference(r191);
    }
}), Oo = An({
    sub_: function(t611, e386) {
        var n275, r192 = gn(t611, "a", "sub"), o108 = gn(e386, "b", "sub");
        n275 = Nt(r192, o108), r192 = n275[0], o108 = n275[1];
        var a68 = Pr(r192.shape, o108.shape);
        return Lt.runKernelFunc(function(t612) {
            return t612.subtract(r192, o108);
        }, {
            a: r192,
            b: o108
        }, function(t613) {
            return {
                a: function() {
                    var e387 = t613, n276 = Br(r192.shape, a68);
                    return n276.length > 0 && (e387 = e387.sum(n276)), e387.reshape(r192.shape);
                },
                b: function() {
                    var e388 = t613, n277 = Br(o108.shape, a68);
                    return n277.length > 0 && (e388 = e388.sum(n277)), e388.neg().reshape(o108.shape);
                }
            };
        }, "Sub");
    }
}), Mo = An({
    subStrict_: function(t614, e389) {
        var n278 = gn(t614, "a", "subStrict"), r193 = gn(e389, "b", "subStrict");
        return E(n278.shape, r193.shape, "Error in subStrict: "), n278.sub(r193);
    }
});
var Bo = An({
    div_: function(t615, e390) {
        var n279, r194 = gn(t615, "a", "div"), o109 = gn(e390, "b", "div");
        if (n279 = Nt(r194, o109), r194 = n279[0], o109 = n279[1], "int32" === r194.dtype && "int32" === o109.dtype) return Co(r194, o109);
        var a69 = {
            a: r194,
            b: o109
        };
        return Lt.runKernelFunc(function(t616, e391) {
            var n280 = t616.realDivide(r194, o109);
            return e391([
                r194,
                o109
            ]), n280;
        }, a69, null, wr, {
        });
    }
});
function Po(t617, e392) {
    if (t617.rank < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was " + t617.rank + ".");
    if (e392.rank < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was " + e392.rank + ".");
    if ("int32" !== e392.dtype) throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was " + e392.dtype + ".");
    if (e392.shape[e392.rank - 1] > t617.rank) throw new Error("index innermost dimension length must be <= tensor rank; saw: " + e392.shape[e392.rank - 1] + " vs. " + t617.rank);
    if (0 === t617.size) throw new Error("Requested more than 0 entries, but input is empty. Input shape: " + t617.shape + ".");
    for(var n281 = e392.shape, r195 = n281[n281.length - 1], o110 = 1, a70 = 0; a70 < n281.length - 1; ++a70)o110 *= n281[a70];
    var i42 = t617.shape, s33 = n281.slice();
    s33.pop();
    var u22 = 1;
    for(a70 = r195; a70 < t617.rank; ++a70)u22 *= i42[a70], s33.push(i42[a70]);
    var c11 = $(t617.shape).map(function(t618) {
        return t618 / u22;
    }).concat([
        1
    ]).slice(0, r195);
    return [
        s33,
        o110,
        u22,
        c11
    ];
}
var Lo = Object.freeze({
    prepareAndValidate: Po
}), Wo = 30;
function Uo(t619) {
    return t619 <= Wo ? t619 : Y(t619, Math.floor(Math.sqrt(t619)));
}
function Vo(t620, e393, n282) {
    var r196 = e393.rank > 1 ? e393.shape[e393.rank - 1] : 1, o111 = e393.rank > 1 ? e393.rank - 1 : 1, a71 = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: " + n282.shape + ", indices.shape: " + e393.shape + ", shape: " + t620 + ", sliceDim: " + r196 + ", and batchDim: " + o111 + ".";
    if (n282.rank < o111) throw new Error(a71 + " update.rank < " + o111 + ". ");
    if (t620.length < r196 + (n282.rank - o111)) throw new Error(a71 + " Output shape length < " + (r196 + (n282.rank - o111)));
    if (n282.rank !== o111 + t620.length - r196) throw new Error(a71 + " update.rank != " + (o111 + t620.length - r196));
    for(var i43 = 0; i43 < o111; ++i43)if (n282.shape[i43] !== e393.shape[i43]) throw new Error(a71 + " updates.shape[" + i43 + "] (" + n282.shape[i43] + ") != indices.shape[" + i43 + "] (" + e393.shape[i43] + ").");
    for(i43 = 0; i43 < n282.rank - o111; ++i43)if (n282.shape[i43 + o111] !== t620[i43 + r196]) throw new Error(a71 + " updates.shape[" + (i43 + o111) + "] (" + n282.shape[i43 + o111] + ") != shape[" + (i43 + o111) + "] (" + t620[i43 + o111] + ")");
}
function zo(t621, e394, n283) {
    if (e394.rank < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was " + e394.rank + ".");
    if (t621.rank < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was " + t621.rank + ".");
    if ("int32" !== e394.dtype) throw new Error("The dtype of 'indices' should be int32, but got dtype: " + e394.dtype);
    if (n283.length < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: " + n283);
    if (0 === n283.length) {
        if (0 === e394.size) throw new Error("Indices specified for empty output. indices shape: " + e394.shape);
        if (0 === t621.size) throw new Error("Updates specified for empty output. updates shape: " + t621.shape);
    }
    Vo(n283, e394, t621);
}
function Go(t, e395, n284) {
    for(var r197 = e395.shape.length, o112 = r197 > 1 ? e395.shape[r197 - 1] : 1, a72 = n284.length, i44 = 1, s34 = o112; s34 < a72; ++s34)i44 *= n284[s34];
    var u23 = o112 < 1 ? 1 : o112;
    return {
        sliceRank: o112,
        numUpdates: k(e395.shape) / u23,
        sliceSize: i44,
        strides: $(n284.slice(0, o112)).concat([
            1
        ]),
        outputSize: k(n284)
    };
}
var Ho = Object.freeze({
    validateUpdateShape: Vo,
    validateInput: zo,
    calculateShapes: Go
});
function qo(t622, e396, n285) {
    C(t622.rank === e396.length, function() {
        return "Error in slice" + t622.rank + "D: Length of begin " + e396 + " must match the rank of the array (" + t622.rank + ").";
    }), C(t622.rank === n285.length, function() {
        return "Error in slice" + t622.rank + "D: Length of size " + n285 + " must match the rank of the array (" + t622.rank + ").";
    });
    for(var r198 = function(r199) {
        C(e396[r199] + n285[r199] <= t622.shape[r199], function() {
            return "Error in slice" + t622.rank + "D: begin[" + r199 + "] + size[" + r199 + "] (" + (e396[r199] + n285[r199]) + ") would overflow input.shape[" + r199 + "] (" + t622.shape[r199] + ")";
        });
    }, o113 = 0; o113 < t622.rank; ++o113)r198(o113);
}
function Ko(t623) {
    for(var e397 = [], n286 = 0; t623 > 0;)1 & t623 && e397.push(n286), t623 /= 2, n286++;
    return e397;
}
function jo(t624, e398, n287) {
    for(var r200 = [], o114 = 0; o114 < t624.length; o114++)r200[o114] = Math.ceil((e398[o114] - t624[o114]) / n287[o114]);
    return r200;
}
function Xo(t625, e399, n288, r201, o115) {
    var a73 = e399[o115], i45 = n288[o115] || 1;
    (t625 & 1 << o115 || null == a73) && (a73 = i45 > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
    var s35 = r201[o115];
    return a73 < 0 && (a73 += s35), a73 = x(0, a73, s35 - 1);
}
function Yo(t626, e400, n289, r202, o116) {
    var a74 = e400[o116], i46 = n289[o116] || 1;
    (t626 & 1 << o116 || null == a74) && (a74 = i46 > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
    var s36 = r202[o116];
    return a74 < 0 && (a74 += s36), a74 = i46 > 0 ? x(0, a74, s36) : x(-1, a74, s36 - 1);
}
function $o(t627, e401, n290) {
    for(var r203 = n290.length, o117 = 0; o117 < n290.length; o117++)if (n290[o117] > 1) {
        r203 = o117;
        break;
    }
    for(o117 = r203 + 1; o117 < n290.length; o117++)if (e401[o117] > 0 || n290[o117] !== t627[o117]) return !1;
    return !0;
}
function Qo(t628, e402) {
    for(var n291 = t628.length > 0 ? t628[t628.length - 1] : 1, r204 = 0; r204 < t628.length - 1; r204++)n291 += t628[r204] * e402[r204];
    return n291;
}
var Jo = Object.freeze({
    assertParamsValid: qo,
    maskToAxes: Ko,
    computeOutShape: jo,
    startForAxis: Xo,
    stopForAxis: Yo,
    isSliceContinous: $o,
    computeFlatOffset: Qo
});
function Zo(t629) {
    return C(X(t629), function() {
        return "The f passed in grad(f) must be a function";
    }), function(e403, n292) {
        var r205 = gn(e403, "x", "tf.grad", null), o118 = null != n292 ? gn(n292, "dy", "tf.grad") : null;
        return Lt.tidy(function() {
            var e404 = Lt.gradients(function() {
                return t629(r205);
            }, [
                r205
            ], o118), n293 = e404.value, a75 = e404.grads;
            return null != o118 && E(n293.shape, o118.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), aa(a75), a75[0];
        });
    };
}
function ta(t630) {
    return C(X(t630), function() {
        return "The f passed in grads(f) must be a function";
    }), function(e405, n294) {
        C(Array.isArray(e405), function() {
            return "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s";
        });
        var r206 = mn(e405, "args", "tf.grads", null), o119 = null != n294 ? gn(n294, "dy", "tf.grads") : null;
        return Lt.tidy(function() {
            var e406 = Lt.gradients(function() {
                return t630.apply(void 0, r206);
            }, r206, o119), n295 = e406.value, a76 = e406.grads;
            return null != o119 && E(n295.shape, o119.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), aa(a76), a76;
        });
    };
}
function ea(t631) {
    return C(X(t631), function() {
        return "The f passed in valueAndGrad(f) must be a function";
    }), function(e407, n296) {
        C(e407 instanceof wt, function() {
            return "The x passed in valueAndGrad(f)(x) must be a tensor";
        }), C(null == n296 || n296 instanceof wt, function() {
            return "The dy passed in valueAndGrad(f)(x, dy) must be a tensor";
        });
        var r207 = Lt.gradients(function() {
            return t631(e407);
        }, [
            e407
        ], n296), o120 = r207.grads, a77 = r207.value;
        return aa(o120), {
            grad: o120[0],
            value: a77
        };
    };
}
function na(t632) {
    return C(X(t632), function() {
        return "The f passed in valueAndGrads(f) must be a function";
    }), function(e408, n297) {
        C(Array.isArray(e408) && e408.every(function(t633) {
            return t633 instanceof wt;
        }), function() {
            return "The args passed in valueAndGrads(f)(args) must be array of tensors";
        }), C(null == n297 || n297 instanceof wt, function() {
            return "The dy passed in valueAndGrads(f)(args, dy) must be a tensor";
        });
        var r208 = Lt.gradients(function() {
            return t632.apply(void 0, e408);
        }, e408, n297);
        return null != n297 && E(r208.value.shape, n297.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), aa(r208.grads), r208;
    };
}
function ra(t634, e409) {
    C(X(t634), function() {
        return "The f passed in variableGrads(f) must be a function";
    }), C(null == e409 || Array.isArray(e409) && e409.every(function(t635) {
        return t635 instanceof St;
    }), function() {
        return "The varList passed in variableGrads(f, varList) must be an array of variables";
    });
    var n298 = null != e409;
    if (!n298) for(var r in e409 = [], Lt.registeredVariables)e409.push(Lt.registeredVariables[r]);
    var o121 = n298 ? e409.filter(function(t636) {
        return !t636.trainable;
    }) : null, a78 = e409.length;
    C((e409 = e409.filter(function(t637) {
        return t637.trainable;
    })).length > 0, function() {
        return "variableGrads() expects at least one of the input variables to be trainable, but none of the " + a78 + " variables is trainable.";
    });
    var i47 = Lt.gradients(t634, e409, null, !0), s37 = i47.value, u24 = i47.grads;
    C(u24.some(function(t638) {
        return null != t638;
    }), function() {
        return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().";
    }), C(0 === s37.rank, function() {
        return "The f passed in variableGrads(f) must return a scalar, but it returned a rank-" + s37.rank + " tensor";
    });
    var c12 = {
    };
    return e409.forEach(function(t, e) {
        null != u24[e] && (c12[t.name] = u24[e]);
    }), null != o121 && o121.forEach(function(t) {
        return c12[t.name] = null;
    }), {
        value: s37,
        grads: c12
    };
}
function oa(t639) {
    return Lt.customGrad(t639);
}
function aa(t640) {
    if (t640.filter(function(t641) {
        return null == t641;
    }).length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.");
}
var ia = An({
    softmax_: function(t642, e410) {
        void 0 === e410 && (e410 = -1);
        var n299 = gn(t642, "logits", "softmax", "float32");
        if (-1 === e410 && (e410 = n299.rank - 1), e410 !== n299.rank - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank " + n299.rank + " and dim was " + e410);
        return Lt.runKernelFunc(function(t643, r209) {
            var o122 = t643.softmax(n299, e410);
            return r209([
                o122
            ]), o122;
        }, {
            logits: n299
        }, function(t644, n300) {
            var r210 = n300[0], o123 = t644.mul(r210);
            return {
                logits: function() {
                    return o123.sub(o123.sum([
                        e410
                    ], !0).mul(r210));
                }
            };
        }, "Softmax", {
            dim: e410
        }, [], [
            !0
        ]);
    }
}), sa = An({
    logSoftmax_: function(t645, e411) {
        void 0 === e411 && (e411 = -1);
        var n301 = gn(t645, "logits", "logSoftmax");
        if (-1 === e411 && (e411 = n301.rank - 1), e411 !== n301.rank - 1) throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank " + n301.rank + " and axis was " + e411);
        return oa(function(t646, n302) {
            var r211 = t646.max(e411, !0), o124 = t646.sub(r211), a79 = o124.toFloat().sub(o124.exp().sum(e411, !0).log());
            n302([
                a79
            ]);
            return {
                value: a79,
                gradFunc: function(t647, n303) {
                    var r212 = n303[0].exp();
                    return t647.sub(t647.sum(e411, !0).mul(r212));
                }
            };
        })(n301);
    }
});
var ua = An({
    transpose_: function(t648, e412) {
        var n304 = gn(t648, "x", "transpose");
        if (null == e412 && (e412 = n304.shape.map(function(t, e413) {
            return e413;
        }).reverse()), C(n304.rank === e412.length, function() {
            return "Error in transpose: rank of input " + n304.rank + " must match length of perm " + e412 + ".";
        }), e412.forEach(function(t649) {
            C(t649 >= 0 && t649 < n304.rank, function() {
                return "All entries in 'perm' must be between 0 and " + (n304.rank - 1) + " but got " + e412;
            });
        }), n304.rank <= 1) return n304.clone();
        var r213 = {
            perm: e412
        };
        return Lt.runKernelFunc(function(t650) {
            return t650.transpose(n304, e412);
        }, {
            x: n304
        }, null, "Transpose", r213);
    }
}), ca = function() {
    function t651(t652, e414) {
        this.backend = t652, this.dataMover = e414, this.data = new WeakMap, this.dataIdsCount = 0;
    }
    return t651.prototype.get = function(t653) {
        return this.data.has(t653) || this.dataMover.moveData(this.backend, t653), this.data.get(t653);
    }, t651.prototype.set = function(t654, e415) {
        this.dataIdsCount++, this.data.set(t654, e415);
    }, t651.prototype.has = function(t655) {
        return this.data.has(t655);
    }, t651.prototype.delete = function(t656) {
        return this.dataIdsCount--, this.data.delete(t656);
    }, t651.prototype.numDataIds = function() {
        return this.dataIdsCount;
    }, t651;
}(), la = function() {
    function t657() {
    }
    return t657.prototype.time = function(t) {
        return ha("time");
    }, t657.prototype.read = function(t) {
        return ha("read");
    }, t657.prototype.readSync = function(t) {
        return ha("readSync");
    }, t657.prototype.numDataIds = function() {
        return ha("numDataIds");
    }, t657.prototype.disposeData = function(t) {
        return ha("disposeData");
    }, t657.prototype.write = function(t, e, n) {
        return ha("write");
    }, t657.prototype.move = function(t, e, n, r) {
        return ha("move");
    }, t657.prototype.memory = function() {
        return ha("memory");
    }, t657.prototype.floatPrecision = function() {
        return ha("floatPrecision");
    }, t657.prototype.epsilon = function() {
        return 32 === this.floatPrecision() ? 0.0000001 : 0.0001;
    }, t657.prototype.batchMatMul = function(t, e, n, r) {
        return ha("batchMatMul");
    }, t657.prototype.fusedBatchMatMul = function(t658) {
        t658.a, t658.b, t658.transposeA, t658.transposeB, t658.bias, t658.activation, t658.preluActivationWeights;
        return ha("fusedBatchMatMul");
    }, t657.prototype.slice = function(t, e, n) {
        return ha("slice");
    }, t657.prototype.stridedSlice = function(t, e, n, r) {
        return ha("stridedSlice");
    }, t657.prototype.unstack = function(t, e) {
        return ha("unstack");
    }, t657.prototype.reverse = function(t, e) {
        return ha("reverse");
    }, t657.prototype.concat = function(t, e) {
        return ha("concat");
    }, t657.prototype.neg = function(t) {
        return ha("neg");
    }, t657.prototype.add = function(t, e) {
        return ha("add");
    }, t657.prototype.addN = function(t) {
        return ha("addN");
    }, t657.prototype.subtract = function(t, e) {
        return ha("subtract");
    }, t657.prototype.multiply = function(t, e) {
        return ha("multiply");
    }, t657.prototype.realDivide = function(t, e) {
        return ha("realDivide");
    }, t657.prototype.floorDiv = function(t, e) {
        return ha("floorDiv");
    }, t657.prototype.sum = function(t, e) {
        return ha("sum");
    }, t657.prototype.prod = function(t, e) {
        return ha("prod");
    }, t657.prototype.unsortedSegmentSum = function(t, e, n) {
        return ha("unsortedSegmentSum");
    }, t657.prototype.argMin = function(t, e) {
        return ha("argMin");
    }, t657.prototype.argMax = function(t, e) {
        return ha("argMax");
    }, t657.prototype.equal = function(t, e) {
        return ha("equal");
    }, t657.prototype.notEqual = function(t, e) {
        return ha("notEqual");
    }, t657.prototype.less = function(t, e) {
        return ha("less");
    }, t657.prototype.lessEqual = function(t, e) {
        return ha("lessEqual");
    }, t657.prototype.greater = function(t, e) {
        return ha("greater");
    }, t657.prototype.greaterEqual = function(t, e) {
        return ha("greaterEqual");
    }, t657.prototype.logicalNot = function(t) {
        return ha("logicalNot");
    }, t657.prototype.logicalAnd = function(t, e) {
        return ha("logicalAnd");
    }, t657.prototype.logicalOr = function(t, e) {
        return ha("logicalOr");
    }, t657.prototype.where = function(t) {
        return ha("where");
    }, t657.prototype.select = function(t, e, n) {
        return ha("select");
    }, t657.prototype.topk = function(t, e, n) {
        return ha("topk");
    }, t657.prototype.min = function(t, e) {
        return ha("min");
    }, t657.prototype.minimum = function(t, e) {
        return ha("minimum");
    }, t657.prototype.mod = function(t, e) {
        return ha("mod");
    }, t657.prototype.max = function(t, e) {
        return ha("max");
    }, t657.prototype.maximum = function(t, e) {
        return ha("maximum");
    }, t657.prototype.all = function(t, e) {
        return ha("all");
    }, t657.prototype.any = function(t, e) {
        return ha("any");
    }, t657.prototype.squaredDifference = function(t, e) {
        return ha("squaredDifference");
    }, t657.prototype.ceil = function(t) {
        return ha("ceil");
    }, t657.prototype.floor = function(t) {
        return ha("floor");
    }, t657.prototype.round = function(t) {
        return ha("round");
    }, t657.prototype.sign = function(t) {
        return ha("sign");
    }, t657.prototype.isNaN = function(t) {
        return ha("isNaN");
    }, t657.prototype.isInf = function(t) {
        return ha("isInf");
    }, t657.prototype.isFinite = function(t) {
        return ha("isFinite");
    }, t657.prototype.pow = function(t, e) {
        return ha("pow");
    }, t657.prototype.exp = function(t) {
        return ha("exp");
    }, t657.prototype.expm1 = function(t) {
        return ha("expm1");
    }, t657.prototype.softmax = function(t, e) {
        return ha("softmax");
    }, t657.prototype.log = function(t) {
        return ha("log");
    }, t657.prototype.log1p = function(t) {
        return ha("log1p");
    }, t657.prototype.sqrt = function(t) {
        return ha("sqrt");
    }, t657.prototype.rsqrt = function(t) {
        return ha("rsqrt");
    }, t657.prototype.square = function(t) {
        return ha("square");
    }, t657.prototype.reciprocal = function(t) {
        return ha("reciprocal");
    }, t657.prototype.relu = function(t) {
        return ha("relu");
    }, t657.prototype.relu6 = function(t) {
        return ha("relu6");
    }, t657.prototype.prelu = function(t, e) {
        return ha("prelu");
    }, t657.prototype.elu = function(t) {
        return ha("elu");
    }, t657.prototype.eluDer = function(t, e) {
        return ha("eluDer");
    }, t657.prototype.selu = function(t) {
        return ha("selu");
    }, t657.prototype.int = function(t) {
        return ha("int");
    }, t657.prototype.clip = function(t, e, n) {
        return ha("clip");
    }, t657.prototype.abs = function(t) {
        return ha("abs");
    }, t657.prototype.complexAbs = function(t) {
        return ha("complexAbs");
    }, t657.prototype.sigmoid = function(t) {
        return ha("sigmoid");
    }, t657.prototype.softplus = function(t) {
        return ha("softplus");
    }, t657.prototype.sin = function(t) {
        return ha("sin");
    }, t657.prototype.cos = function(t) {
        return ha("cos");
    }, t657.prototype.tan = function(t) {
        return ha("tan");
    }, t657.prototype.asin = function(t) {
        return ha("asin");
    }, t657.prototype.acos = function(t) {
        return ha("acos");
    }, t657.prototype.atan = function(t) {
        return ha("atan");
    }, t657.prototype.atan2 = function(t, e) {
        return ha("atan2");
    }, t657.prototype.sinh = function(t) {
        return ha("sinh");
    }, t657.prototype.cosh = function(t) {
        return ha("cosh");
    }, t657.prototype.tanh = function(t) {
        return ha("tanh");
    }, t657.prototype.asinh = function(t) {
        return ha("asinh");
    }, t657.prototype.acosh = function(t) {
        return ha("acosh");
    }, t657.prototype.atanh = function(t) {
        return ha("atanh");
    }, t657.prototype.erf = function(t) {
        return ha("erf");
    }, t657.prototype.step = function(t, e) {
        return ha("step");
    }, t657.prototype.fusedConv2d = function(t659) {
        t659.input, t659.filter, t659.convInfo, t659.bias, t659.activation, t659.preluActivationWeights;
        return ha("fusedConv2d");
    }, t657.prototype.conv2d = function(t, e, n) {
        return ha("conv2d");
    }, t657.prototype.conv2dDerInput = function(t, e, n) {
        return ha("conv2dDerInput");
    }, t657.prototype.conv2dDerFilter = function(t, e, n) {
        return ha("conv2dDerFilter");
    }, t657.prototype.fusedDepthwiseConv2D = function(t660) {
        t660.input, t660.filter, t660.convInfo, t660.bias, t660.activation, t660.preluActivationWeights;
        return ha("fusedDepthwiseConv2D");
    }, t657.prototype.depthwiseConv2D = function(t, e, n) {
        return ha("depthwiseConv2D");
    }, t657.prototype.depthwiseConv2DDerInput = function(t, e, n) {
        return ha("depthwiseConv2DDerInput");
    }, t657.prototype.depthwiseConv2DDerFilter = function(t, e, n) {
        return ha("depthwiseConv2DDerFilter");
    }, t657.prototype.conv3d = function(t, e, n) {
        return ha("conv3d");
    }, t657.prototype.conv3dDerInput = function(t, e, n) {
        return ha("conv3dDerInput");
    }, t657.prototype.conv3dDerFilter = function(t, e, n) {
        return ha("conv3dDerFilter");
    }, t657.prototype.maxPool = function(t, e) {
        return ha("maxPool");
    }, t657.prototype.maxPoolBackprop = function(t, e, n, r) {
        return ha("maxPoolBackprop");
    }, t657.prototype.avgPool = function(t, e) {
        return ha("avgPool");
    }, t657.prototype.avgPoolBackprop = function(t, e, n) {
        return ha("avgPoolBackprop");
    }, t657.prototype.avgPool3d = function(t, e) {
        return ha("avgPool3d");
    }, t657.prototype.avgPool3dBackprop = function(t, e, n) {
        return ha("avgPool3dBackprop");
    }, t657.prototype.maxPool3d = function(t, e) {
        return ha("maxPool3d");
    }, t657.prototype.maxPool3dBackprop = function(t, e, n, r) {
        return ha("maxPool3dBackprop");
    }, t657.prototype.reshape = function(t, e) {
        return ha("reshape");
    }, t657.prototype.cast = function(t, e) {
        return ha("cast");
    }, t657.prototype.tile = function(t, e) {
        return ha("tile");
    }, t657.prototype.pad = function(t, e, n) {
        return ha("pad");
    }, t657.prototype.transpose = function(t, e) {
        return ha("transpose");
    }, t657.prototype.gather = function(t, e, n) {
        return ha("gather");
    }, t657.prototype.gatherND = function(t, e) {
        return ha("gatherND");
    }, t657.prototype.scatterND = function(t, e, n) {
        return ha("scatterND");
    }, t657.prototype.batchToSpaceND = function(t, e, n) {
        return ha("batchToSpaceND");
    }, t657.prototype.spaceToBatchND = function(t, e, n) {
        return ha("spaceToBatchND");
    }, t657.prototype.resizeBilinear = function(t, e, n, r) {
        return ha("resizeBilinear");
    }, t657.prototype.resizeBilinearBackprop = function(t, e, n) {
        return ha("resizeBilinearBackprop");
    }, t657.prototype.resizeNearestNeighbor = function(t, e, n, r) {
        return ha("resizeNearestNeighbor");
    }, t657.prototype.resizeNearestNeighborBackprop = function(t, e, n) {
        return ha("resizeNearestNeighborBackprop");
    }, t657.prototype.batchNormalization = function(t, e, n, r, o, a) {
        return ha("batchNormalization");
    }, t657.prototype.localResponseNormalization4D = function(t, e, n, r, o) {
        return ha("localResponseNormalization4D");
    }, t657.prototype.LRNGrad = function(t, e, n, r, o, a, i) {
        return ha("LRNGrad");
    }, t657.prototype.multinomial = function(t, e, n, r) {
        return ha("multinomial");
    }, t657.prototype.oneHot = function(t, e, n, r) {
        return ha("oneHot");
    }, t657.prototype.cumsum = function(t, e, n, r) {
        return ha("cumsum");
    }, t657.prototype.nonMaxSuppression = function(t, e, n, r, o) {
        return ha("nonMaxSuppression");
    }, t657.prototype.fft = function(t) {
        return ha("fft");
    }, t657.prototype.ifft = function(t) {
        return ha("ifft");
    }, t657.prototype.complex = function(t, e) {
        return ha("complex");
    }, t657.prototype.real = function(t) {
        return ha("real");
    }, t657.prototype.imag = function(t) {
        return ha("imag");
    }, t657.prototype.cropAndResize = function(t, e, n, r, o, a) {
        return ha("cropAndResize");
    }, t657.prototype.depthToSpace = function(t, e, n) {
        return ha("depthToSpace");
    }, t657.prototype.split = function(t, e, n) {
        return ha("split");
    }, t657.prototype.sparseToDense = function(t, e, n, r) {
        return ha("sparseToDense");
    }, t657.prototype.diag = function(t) {
        return ha("diag");
    }, t657.prototype.fill = function(t, e, n) {
        return ha("fill");
    }, t657.prototype.onesLike = function(t) {
        return ha("onesLike");
    }, t657.prototype.zerosLike = function(t) {
        return ha("zerosLike");
    }, t657.prototype.linspace = function(t, e, n) {
        return ha("linspace");
    }, t657.prototype.dispose = function() {
        return ha("dispose");
    }, t657;
}();
function ha(t661) {
    throw new Error("'" + t661 + "' not yet implemented or not found in the registry. Did you forget to import the kernel?");
}
function fa(t662, e416, n305, r214, o125, a80, i48) {
    void 0 === i48 && (i48 = "channelsLast");
    var s38, u25 = ma(e416), c13 = u25[0], l8 = u25[1];
    if ("channelsLast" === i48) s38 = [
        c13,
        l8,
        t662[3],
        t662[3]
    ];
    else {
        if ("channelsFirst" !== i48) throw new Error("Unknown dataFormat " + i48);
        s38 = [
            c13,
            l8,
            t662[1],
            t662[1]
        ];
    }
    return pa(t662, s38, n305, r214, o125, a80, !1, i48);
}
function da(t663, e417, n306, r215, o126, a81, i49) {
    void 0 === i49 && (i49 = "NDHWC");
    var s39, u26, c14 = ya(e417), l9 = c14[0], h9 = c14[1], f8 = c14[2];
    if ("NDHWC" === i49) u26 = "channelsLast", s39 = [
        l9,
        h9,
        f8,
        t663[4],
        t663[4]
    ];
    else {
        if ("NCDHW" !== i49) throw new Error("Unknown dataFormat " + i49);
        u26 = "channelsFirst", s39 = [
            l9,
            h9,
            f8,
            t663[1],
            t663[1]
        ];
    }
    return va(t663, s39, n306, r215, o126, !1, u26, a81);
}
function pa(t664, e418, n307, r216, o127, a82, i50, s40) {
    void 0 === i50 && (i50 = !1), void 0 === s40 && (s40 = "channelsLast");
    var u27 = [
        -1,
        -1,
        -1,
        -1
    ], c15 = u27[0], l10 = u27[1], h10 = u27[2], f9 = u27[3];
    if ("channelsLast" === s40) c15 = t664[0], l10 = t664[1], h10 = t664[2], f9 = t664[3];
    else {
        if ("channelsFirst" !== s40) throw new Error("Unknown dataFormat " + s40);
        c15 = t664[0], f9 = t664[1], l10 = t664[2], h10 = t664[3];
    }
    var d5, p5 = e418[0], v4 = e418[1], g4 = e418[3], m4 = ma(n307), y2 = m4[0], x2 = m4[1], b2 = ma(r216), w2 = b2[0], E1 = b2[1], R1 = xa(p5, w2), I1 = xa(v4, E1), k1 = function(t665, e419, n308, r217, o128, a83, i51, s41) {
        var u28, c16, l11;
        if ("number" == typeof t665) {
            u28 = {
                top: t665,
                bottom: t665,
                left: t665,
                right: t665,
                type: 0 === t665 ? "VALID" : "NUMBER"
            };
            var h11 = function(t666, e420, n309, r218, o129) {
                null == r218 && (r218 = ga(t666, e420, n309));
                var a84 = t666[0], i52 = t666[1], s42 = ba((a84 - e420 + 2 * r218) / n309 + 1, o129);
                C(A(s42), function() {
                    return "The output # of rows (" + s42 + ") must be an integer. Change the stride and/or zero pad parameters";
                });
                var u29 = ba((i52 - e420 + 2 * r218) / n309 + 1, o129);
                return C(A(u29), function() {
                    return "The output # of columns (" + u29 + ") must be an integer. Change the stride and/or zero pad parameters";
                }), [
                    s42,
                    u29
                ];
            }([
                e419,
                n308
            ], a83, r217, t665, s41);
            c16 = h11[0], l11 = h11[1];
        } else if ("same" === t665) {
            c16 = Math.ceil(e419 / r217), l11 = Math.ceil(n308 / o128);
            var f10 = Math.max(0, (c16 - 1) * r217 + a83 - e419), d6 = Math.max(0, (l11 - 1) * o128 + i51 - n308), p6 = Math.floor(f10 / 2), v5 = f10 - p6, g5 = Math.floor(d6 / 2);
            u28 = {
                top: p6,
                bottom: v5,
                left: g5,
                right: d6 - g5,
                type: "SAME"
            };
        } else {
            if ("valid" !== t665) throw Error("Unknown padding parameter: " + t665);
            u28 = {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                type: "VALID"
            }, c16 = Math.ceil((e419 - a83 + 1) / r217), l11 = Math.ceil((n308 - i51 + 1) / o128);
        }
        return {
            padInfo: u28,
            outHeight: c16,
            outWidth: l11
        };
    }(o127, l10, h10, y2, x2, R1, I1, a82), S1 = k1.padInfo, T1 = k1.outHeight, D1 = k1.outWidth, N1 = i50 ? g4 * f9 : g4;
    return "channelsFirst" === s40 ? d5 = [
        c15,
        N1,
        T1,
        D1
    ] : "channelsLast" === s40 && (d5 = [
        c15,
        T1,
        D1,
        N1
    ]), {
        batchSize: c15,
        dataFormat: s40,
        inHeight: l10,
        inWidth: h10,
        inChannels: f9,
        outHeight: T1,
        outWidth: D1,
        outChannels: N1,
        padInfo: S1,
        strideHeight: y2,
        strideWidth: x2,
        filterHeight: p5,
        filterWidth: v4,
        effectiveFilterHeight: R1,
        effectiveFilterWidth: I1,
        dilationHeight: w2,
        dilationWidth: E1,
        inShape: t664,
        outShape: d5,
        filterShape: e418
    };
}
function va(t667, e421, n310, r219, o130, a85, i53, s43) {
    void 0 === a85 && (a85 = !1), void 0 === i53 && (i53 = "channelsLast");
    var u30 = [
        -1,
        -1,
        -1,
        -1,
        -1
    ], c17 = u30[0], l12 = u30[1], h12 = u30[2], f11 = u30[3], d7 = u30[4];
    if ("channelsLast" === i53) c17 = t667[0], l12 = t667[1], h12 = t667[2], f11 = t667[3], d7 = t667[4];
    else {
        if ("channelsFirst" !== i53) throw new Error("Unknown dataFormat " + i53);
        c17 = t667[0], d7 = t667[1], l12 = t667[2], h12 = t667[3], f11 = t667[4];
    }
    var p7, v6 = e421[0], g6 = e421[1], m5 = e421[2], y3 = e421[4], x3 = ya(n310), b3 = x3[0], w3 = x3[1], E2 = x3[2], R2 = ya(r219), I2 = R2[0], k2 = R2[1], S2 = R2[2], T2 = xa(v6, I2), D2 = xa(g6, k2), N2 = xa(m5, S2), F1 = function(t668, e422, n311, r220, o131, a86, i54, s44, u31, c18, l13) {
        var h13, f12, d8, p8;
        if ("number" == typeof t668) {
            h13 = {
                top: t668,
                bottom: t668,
                left: t668,
                right: t668,
                front: t668,
                back: t668,
                type: 0 === t668 ? "VALID" : "NUMBER"
            };
            var v7 = function(t669, e423, n312, r221, o132, a87) {
                null == o132 && (o132 = ga(t669, e423, r221));
                var i55 = t669[0], s45 = t669[1], u32 = t669[2], c19 = ba((i55 - e423 + 2 * o132) / r221 + 1, a87);
                C(A(c19), function() {
                    return "The output # of depths (" + c19 + ") must be an integer. Change the stride and/or zero pad parameters";
                });
                var l14 = ba((s45 - e423 + 2 * o132) / r221 + 1, a87);
                C(A(l14), function() {
                    return "The output # of rows (" + l14 + ") must be an integer. Change the stride and/or zero pad parameters";
                });
                var h14 = ba((u32 - e423 + 2 * o132) / r221 + 1, a87);
                return C(A(h14), function() {
                    return "The output # of columns (" + h14 + ") must be an integer. Change the stride and/or zero pad parameters";
                }), [
                    c19,
                    l14,
                    h14,
                    n312
                ];
            }([
                e422,
                n311,
                r220,
                1
            ], s44, 1, o131, t668, l13);
            f12 = v7[0], d8 = v7[1], p8 = v7[2];
        } else if ("same" === t668) {
            f12 = Math.ceil(e422 / o131), d8 = Math.ceil(n311 / a86), p8 = Math.ceil(r220 / i54);
            var g7 = (f12 - 1) * o131 + s44 - e422, m6 = (d8 - 1) * a86 + u31 - n311, y4 = (p8 - 1) * i54 + c18 - r220, x4 = Math.floor(g7 / 2), b4 = g7 - x4, w4 = Math.floor(m6 / 2), E3 = m6 - w4, R3 = Math.floor(y4 / 2);
            h13 = {
                top: w4,
                bottom: E3,
                left: R3,
                right: y4 - R3,
                front: x4,
                back: b4,
                type: "SAME"
            };
        } else {
            if ("valid" !== t668) throw Error("Unknown padding parameter: " + t668);
            h13 = {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                front: 0,
                back: 0,
                type: "VALID"
            }, f12 = Math.ceil((e422 - s44 + 1) / o131), d8 = Math.ceil((n311 - u31 + 1) / a86), p8 = Math.ceil((r220 - c18 + 1) / i54);
        }
        return {
            padInfo: h13,
            outDepth: f12,
            outHeight: d8,
            outWidth: p8
        };
    }(o130, l12, h12, f11, b3, w3, E2, T2, D2, N2, s43), _1 = F1.padInfo, O1 = F1.outDepth, M1 = F1.outHeight, B1 = F1.outWidth, P1 = a85 ? y3 * d7 : y3;
    return "channelsFirst" === i53 ? p7 = [
        c17,
        P1,
        O1,
        M1,
        B1
    ] : "channelsLast" === i53 && (p7 = [
        c17,
        O1,
        M1,
        B1,
        P1
    ]), {
        batchSize: c17,
        dataFormat: i53,
        inDepth: l12,
        inHeight: h12,
        inWidth: f11,
        inChannels: d7,
        outDepth: O1,
        outHeight: M1,
        outWidth: B1,
        outChannels: P1,
        padInfo: _1,
        strideDepth: b3,
        strideHeight: w3,
        strideWidth: E2,
        filterDepth: v6,
        filterHeight: g6,
        filterWidth: m5,
        effectiveFilterDepth: T2,
        effectiveFilterHeight: D2,
        effectiveFilterWidth: N2,
        dilationDepth: I2,
        dilationHeight: k2,
        dilationWidth: S2,
        inShape: t667,
        outShape: p7,
        filterShape: e421
    };
}
function ga(t670, e424, n313, r222) {
    void 0 === r222 && (r222 = 1);
    var o133 = xa(e424, r222);
    return Math.floor((t670[0] * (n313 - 1) - n313 + o133) / 2);
}
function ma(t671) {
    return "number" == typeof t671 ? [
        t671,
        t671,
        t671
    ] : 2 === t671.length ? [
        t671[0],
        t671[1],
        1
    ] : t671;
}
function ya(t672) {
    return "number" == typeof t672 ? [
        t672,
        t672,
        t672
    ] : t672;
}
function xa(t673, e425) {
    return e425 <= 1 ? t673 : t673 + (t673 - 1) * (e425 - 1);
}
function ba(t674, e426) {
    if (!e426) return t674;
    switch(e426){
        case "round":
            return Math.round(t674);
        case "ceil":
            return Math.ceil(t674);
        case "floor":
            return Math.floor(t674);
        default:
            throw new Error("Unknown roundingMode " + e426);
    }
}
function wa(t675) {
    var e427 = ma(t675), n314 = e427[0], r223 = e427[1], o134 = e427[2];
    return 1 === n314 && 1 === r223 && 1 === o134;
}
function Ca(t676, e428) {
    return wa(t676) || wa(e428);
}
function Ea(t677) {
    if ("NHWC" === t677) return "channelsLast";
    if ("NCHW" === t677) return "channelsFirst";
    throw new Error("Unknown dataFormat " + t677);
}
function Ra(t678, e429, n315) {
    if ("complex64" === e429) {
        if ("complex64" === t678.dtype) return t678.clone();
        var r224 = Gn(t678.shape), o135 = t678.toFloat(), a88 = n315.complex(o135, r224);
        return r224.dispose(), o135.dispose(), a88;
    }
    if (!U(t678.dtype, e429)) return Lt.makeTensorFromDataId(t678.dataId, t678.shape, e429);
    if ("complex64" === t678.dtype) {
        var i56 = n315.real(t678);
        a88 = i56.cast(e429);
        return i56.dispose(), a88;
    }
    if ("int32" === e429) return n315.int(t678);
    if ("bool" === e429) {
        var s46 = On(0, t678.dtype);
        a88 = n315.notEqual(t678, s46);
        return s46.dispose(), a88;
    }
    throw new Error("Error in Cast: failed to cast " + t678.dtype + " to " + e429);
}
function Ia(t679, e430) {
    return Lt.makeTensorFromDataId(t679.dataId, e430, t679.dtype);
}
function ka(t680, e431, n316) {
    var r225 = (e431 - t680) / (n316 - 1), o136 = tt(n316, "float32");
    o136[0] = t680;
    for(var a89 = 1; a89 < o136.length; a89++)o136[a89] = o136[a89 - 1] + r225;
    return Mn(o136, "float32");
}
var Sa = Object.freeze({
    castTensor: Ra,
    reshapeTensor: Ia,
    linspaceImpl: ka,
    upcastType: Tt,
    axesAreInnerMostDims: yn,
    combineLocations: xn,
    computeOutAndReduceShapes: bn,
    expandShapeToKeepDim: wn,
    assertAxesAreInnerMostDims: Cn,
    getAxesPermutation: En,
    getUndoAxesPermutation: Rn,
    getInnerMostAxes: In,
    getBroadcastDims: Mr,
    getReductionAxes: Br,
    assertAndGetBroadcastShape: Pr,
    assertParamsConsistent: kn,
    computeOutShape: Sn,
    computePool2DInfo: fa,
    computePool3DInfo: da,
    computeConv2DInfo: pa,
    computeConv3DInfo: va,
    computeDefaultPad: ga,
    tupleValuesAreOne: wa,
    eitherStridesOrDilationsAreOne: Ca,
    convertConv2DDataFormat: Ea,
    PARALLELIZE_THRESHOLD: Wo,
    computeOptimalWindowSize: Uo
});
function Aa(t681, e432) {
    if (t681.length !== e432.length) throw new Error("Cannot merge real and imag arrays of different lengths. real:" + t681.length + ", imag: " + e432.length + ".");
    for(var n317 = new Float32Array(2 * t681.length), r226 = 0; r226 < n317.length; r226 += 2)n317[r226] = t681[r226 / 2], n317[r226 + 1] = e432[r226 / 2];
    return n317;
}
function Ta(t682, e) {
    return {
        real: t682[2 * e],
        imag: t682[2 * e + 1]
    };
}
function Da(t683, e433, n318, r) {
    t683[2 * r] = e433, t683[2 * r + 1] = n318;
}
function Na(t684, e434, n319) {
    var r227 = (n319 ? 2 : -2) * Math.PI * (t684 / e434);
    return {
        real: Math.cos(r227),
        imag: Math.sin(r227)
    };
}
function Fa(t685, e435, n320) {
    var r228 = function(t686, e436, n321) {
        return (function(t687, e437, n322) {
            var r229 = 0, o138 = t687.length, a90 = 0, i57 = !1;
            for(; r229 < o138;){
                var s47 = n322(e437, t687[a90 = r229 + (o138 - r229 >>> 1)]);
                s47 > 0 ? r229 = a90 + 1 : (o138 = a90, i57 = !s47);
            }
            return i57 ? r229 : -r229 - 1;
        })(t686, e436, n321 || _a);
    }(t685, e435, n320), o137 = r228 < 0 ? -(r228 + 1) : r228;
    t685.splice(o137, 0, e435);
}
function _a(t688, e438) {
    return t688 > e438 ? 1 : t688 < e438 ? -1 : 0;
}
function Oa(t689, e439, n323, r230, o139) {
    return Ba(t689, e439, n323, r230, o139, 0).selectedIndices;
}
function Ma(t690, e440, n324, r231, o140, a91) {
    var i58 = Ba(t690, e440, n324, r231, o140, a91, !0);
    return i58.numValidOutputs.dispose(), {
        selectedIndices: i58.selectedIndices,
        selectedScores: i58.selectedScores
    };
}
function Ba(t691, e441, n325, r232, o141, a92, i59, s48) {
    void 0 === i59 && (i59 = !1), void 0 === s48 && (s48 = !1);
    for(var u33 = Array.from(e441).map(function(t692, e442) {
        return {
            score: t692,
            boxIndex: e442,
            suppressBeginIndex: 0
        };
    }).filter(function(t693) {
        return t693.score > o141;
    }).sort(Wa), c20 = a92 > 0 ? -0.5 / a92 : 0, l15 = [], h15 = []; l15.length < n325 && u33.length > 0;){
        var f13 = u33.pop(), d9 = f13.score, p9 = f13.boxIndex, v8 = f13.suppressBeginIndex;
        if (d9 < o141) break;
        for(var g8 = !1, m7 = l15.length - 1; m7 >= v8; --m7){
            var y5 = Pa(t691, p9, l15[m7]);
            if (y5 >= r232) {
                g8 = !0;
                break;
            }
            if (f13.score = f13.score * La(r232, c20, y5), f13.score <= o141) break;
        }
        f13.suppressBeginIndex = l15.length, g8 || (f13.score === d9 ? (l15.push(p9), h15.push(f13.score)) : f13.score > o141 && Fa(u33, f13, Wa));
    }
    var x5 = l15.length;
    return s48 && (l15.fill(0, x5), h15.fill(0, x5)), {
        selectedIndices: Mn(l15, "int32"),
        selectedScores: Mn(h15, "float32"),
        numValidOutputs: On(x5, "int32")
    };
}
function Pa(t694, e443, n326) {
    var r233 = t694.subarray(4 * e443, 4 * e443 + 4), o142 = t694.subarray(4 * n326, 4 * n326 + 4), a93 = Math.min(r233[0], r233[2]), i60 = Math.min(r233[1], r233[3]), s49 = Math.max(r233[0], r233[2]), u34 = Math.max(r233[1], r233[3]), c21 = Math.min(o142[0], o142[2]), l16 = Math.min(o142[1], o142[3]), h16 = Math.max(o142[0], o142[2]), f14 = Math.max(o142[1], o142[3]), d10 = (s49 - a93) * (u34 - i60), p10 = (h16 - c21) * (f14 - l16);
    if (d10 <= 0 || p10 <= 0) return 0;
    var v9 = Math.max(a93, c21), g9 = Math.max(i60, l16), m8 = Math.min(s49, h16), y6 = Math.min(u34, f14), x6 = Math.max(m8 - v9, 0) * Math.max(y6 - g9, 0);
    return x6 / (d10 + p10 - x6);
}
function La(t695, e444, n327) {
    var r234 = Math.exp(e444 * n327 * n327);
    return n327 <= t695 ? r234 : 0;
}
function Wa(t696, e445) {
    return t696.score - e445.score || t696.score === e445.score && e445.boxIndex - t696.boxIndex;
}
function Ua(t697, e446, n) {
    var r235 = new Array(t697.rank).fill(0), o143 = t697.shape.slice();
    return e446.map(function(e447) {
        o143[n] = e447;
        var a94 = t697.slice(r235, o143);
        return r235[n] += e447, a94;
    });
}
function Va(t698, e448) {
    for(var n328 = new Array(t698.rank), r236 = 0; r236 < n328.length; r236++)n328[r236] = t698.shape[r236] * e448[r236];
    var o144 = er(n328, t698.dtype);
    for(r236 = 0; r236 < o144.values.length; ++r236){
        for(var a95 = o144.indexToLoc(r236), i61 = new Array(t698.rank), s50 = 0; s50 < i61.length; s50++)i61[s50] = a95[s50] % t698.shape[s50];
        var u = t698.locToIndex(i61);
        o144.values[r236] = t698.values[u];
    }
    return o144.toTensor();
}
function za(t699, e449, n329, r237, o) {
    for(var a96 = e449[e449.length - 1], i62 = [
        t699.length / a96,
        a96
    ], s51 = i62[0], u35 = i62[1], c22 = B(n329, s51 * r237), l17 = B("int32", s51 * r237), h17 = 0; h17 < s51; h17++){
        for(var f15 = h17 * u35, d11 = t699.subarray(f15, f15 + u35), p11 = [], v10 = 0; v10 < d11.length; v10++)p11.push({
            value: d11[v10],
            index: v10
        });
        p11.sort(function(t700, e450) {
            return e450.value - t700.value;
        });
        var g10 = h17 * r237, m9 = c22.subarray(g10, g10 + r237), y7 = l17.subarray(g10, g10 + r237);
        for(v10 = 0; v10 < r237; v10++)m9[v10] = p11[v10].value, y7[v10] = p11[v10].index;
    }
    var x7 = e449.slice();
    return x7[x7.length - 1] = r237, [
        Fn(c22, x7, n329),
        Fn(l17, x7, "int32")
    ];
}
function Ga(t701, e451) {
    for(var n330 = [], r238 = 0; r238 < e451.length; r238++)e451[r238] && n330.push(r238);
    var o145 = er(t701, "int32"), a97 = er([
        n330.length,
        t701.length
    ], "int32");
    for(r238 = 0; r238 < n330.length; r238++){
        var i63 = o145.indexToLoc(n330[r238]), s52 = r238 * t701.length;
        a97.values.set(i63, s52);
    }
    return a97.toTensor();
}
var Ha = function(t702, e452) {
    this.outputShape = [], this.outputShape = t702, this.variableNames = e452.map(function(t, e453) {
        return "T" + e453;
    });
    var n331 = [];
    this.variableNames.forEach(function(t703) {
        n331.push("float v" + t703 + " = get" + t703 + "AtOutCoords();");
    });
    var r239 = this.variableNames.map(function(t704) {
        return "v" + t704;
    }).join(" + ");
    this.userCode = "\n      void main() {\n        " + n331.join("\n        ") + "\n\n        float result = " + r239 + ";\n        setOutput(result);\n      }\n    ";
}, qa = function(t705, e454) {
    this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t705, this.variableNames = e454.map(function(t, e455) {
        return "T" + e455;
    });
    var n332 = [];
    this.variableNames.forEach(function(t706) {
        n332.push("vec4 v" + t706 + " = get" + t706 + "AtOutCoords();");
    });
    var r240 = this.variableNames.map(function(t707) {
        return "v" + t707;
    }).join(" + ");
    this.userCode = "\n      void main() {\n        " + n332.join("\n        ") + "\n\n        vec4 result = " + r240 + ";\n        setOutput(result);\n      }\n    ";
}, Ka = function(t708, e456, n333) {
    this.variableNames = [
        "A"
    ];
    var r241 = t708.windowSize, o146 = t708.batchSize, a98 = t708.inSize, i64 = Math.ceil(a98 / r241);
    n333 || this.variableNames.push("bestIndicesA"), this.outputShape = [
        o146,
        i64
    ];
    var s53 = "max" === e456 ? ">" : "<", u36 = n333 ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
    this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + r241 + ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < " + r241 + "; i++) {\n          int inIdx = " + u36 + ";\n          float candidate = getA(batch, inIdx);\n          if (candidate " + s53 + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
};
function ja(t709, e457) {
    return [
        "x",
        "y",
        "z",
        "w",
        "u",
        "v"
    ].slice(0, e457).map(function(e458) {
        return t709 + "." + e458;
    });
}
function Xa(t710, e459) {
    return 1 === e459 ? [
        t710
    ] : ja(t710, e459);
}
function Ya() {
    var t711, e460, n334, r242, o147, a99, s54, u37, c23, l18;
    return 2 === i().getNumber("WEBGL_VERSION") ? (t711 = "#version 300 es", e460 = "in", n334 = "out", r242 = "in", o147 = "texture", a99 = "outputColor", s54 = "out vec4 outputColor;", u37 = "\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ", c23 = "", l18 = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (t711 = "", e460 = "attribute", n334 = "varying", r242 = "varying", o147 = "texture2D", a99 = "gl_FragColor", s54 = "", u37 = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", c23 = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", l18 = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), {
        version: t711,
        attribute: e460,
        varyingVs: n334,
        varyingFs: r242,
        texture2D: o147,
        output: a99,
        defineOutput: s54,
        defineSpecialNaN: u37,
        defineSpecialInf: c23,
        defineRound: l18
    };
}
function $a(t712, e461, n335) {
    void 0 === n335 && (n335 = "index");
    var r243 = $(e461);
    return r243.map(function(e462, o148) {
        return "int " + t712[o148] + " = " + n335 + " / " + e462 + "; " + (o148 === r243.length - 1 ? "int " + t712[o148 + 1] + " = " + n335 + " - " + t712[o148] + " * " + e462 : "index -= " + t712[o148] + " * " + e462) + ";";
    }).join("");
}
function Qa(t713) {
    var e463 = $(t713).map(function(t714) {
        return t714.toString();
    });
    return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * " + e463[0] + " + coords.y * " + e463[1] + " + coords.z;\n  }\n";
}
var Ja = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";
function Za(t715, e464, n336, r244) {
    var o149 = [];
    t715.forEach(function(t716) {
        var e465 = k(t716.shapeInfo.logicalShape);
        t716.shapeInfo.isUniform ? o149.push("uniform float " + t716.name + (e465 > 1 ? "[" + e465 + "]" : "") + ";") : (o149.push("uniform sampler2D " + t716.name + ";"), o149.push("uniform int offset" + t716.name + ";"));
    });
    var a100, i65, s55 = o149.join("\n"), u38 = t715.map(function(t717) {
        return (function(t718, e466, n337) {
            void 0 === n337 && (n337 = !1);
            var r245 = "";
            r245 += n337 ? ei(t718) : ti(t718);
            var o150 = t718.shapeInfo.logicalShape, a101 = e466.logicalShape;
            o150.length <= a101.length && (r245 += n337 ? (function(t719, e467) {
                var n338, r246 = t719.name, o151 = r246.charAt(0).toUpperCase() + r246.slice(1), a102 = "get" + o151 + "AtOutCoords", i66 = t719.shapeInfo.logicalShape.length, s56 = e467.logicalShape.length, u39 = Mr(t719.shapeInfo.logicalShape, e467.logicalShape), c25 = ui(s56), l = s56 - i66, h19 = [
                    "x",
                    "y",
                    "z",
                    "w",
                    "u",
                    "v"
                ];
                n338 = 0 === i66 ? "" : s56 < 2 && u39.length >= 1 ? "coords = 0;" : u39.map(function(t) {
                    return "coords." + h19[t + l] + " = 0;";
                }).join("\n");
                var f17 = "";
                f17 = s56 < 2 && i66 > 0 ? "coords" : t719.shapeInfo.logicalShape.map(function(t, e) {
                    return "coords." + h19[e + l];
                }).join(", ");
                var d12 = "return outputValue;", p12 = 1 === k(t719.shapeInfo.logicalShape), v11 = 1 === k(e467.logicalShape);
                if (1 !== i66 || p12 || v11) {
                    if (p12 && !v11) d12 = 1 === s56 ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";
                    else if (u39.length) {
                        var g11 = i66 - 2, m10 = i66 - 1;
                        u39.indexOf(g11) > -1 && u39.indexOf(m10) > -1 ? d12 = "return vec4(outputValue.x);" : u39.indexOf(g11) > -1 ? d12 = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : u39.indexOf(m10) > -1 && (d12 = "return vec4(outputValue.xx, outputValue.zz);");
                    }
                } else d12 = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
                return "\n    vec4 " + a102 + "() {\n      " + c25 + " coords = getOutputCoords();\n      " + n338 + "\n      vec4 outputValue = get" + o151 + "(" + f17 + ");\n      " + d12 + "\n    }\n  ";
            })(t718, e466) : (function(t720, e468) {
                var n339 = t720.name, r247 = n339.charAt(0).toUpperCase() + n339.slice(1), o152 = "get" + r247 + "AtOutCoords", a103 = e468.texShape, i67 = t720.shapeInfo.texShape, s57 = t720.shapeInfo.logicalShape.length, u40 = e468.logicalShape.length;
                if (!t720.shapeInfo.isUniform && s57 === u40 && null == t720.shapeInfo.flatOffset && S(i67, a103)) return "\n      float " + o152 + "() {\n        return sampleTexture(" + n339 + ", resultUV);\n      }\n    ";
                var c26, l20 = ui(u40), h20 = Mr(t720.shapeInfo.logicalShape, e468.logicalShape), f = u40 - s57, d13 = [
                    "x",
                    "y",
                    "z",
                    "w",
                    "u",
                    "v"
                ];
                c26 = 0 === s57 ? "" : u40 < 2 && h20.length >= 1 ? "coords = 0;" : h20.map(function(t) {
                    return "coords." + d13[t + f] + " = 0;";
                }).join("\n");
                var p13 = "";
                p13 = u40 < 2 && s57 > 0 ? "coords" : t720.shapeInfo.logicalShape.map(function(t, e) {
                    return "coords." + d13[e + f];
                }).join(", ");
                return "\n    float " + o152 + "() {\n      " + l20 + " coords = getOutputCoords();\n      " + c26 + "\n      return get" + r247 + "(" + p13 + ");\n    }\n  ";
            })(t718, e466));
            return r245;
        })(t717, e464, r244);
    }).join("\n"), c24 = e464.texShape, l19 = Ya(), h18 = function(t721) {
        return "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return " + t721.texture2D + "(textureSampler, uv).r;\n    }\n  ";
    }(l19), f16 = function(t722) {
        return t722.version + "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    " + t722.varyingFs + " vec2 resultUV;\n    " + t722.defineOutput + "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    " + t722.defineSpecialNaN + "\n    " + t722.defineSpecialInf + "\n    " + t722.defineRound + "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    " + ni + "\n    " + ri + "\n    " + oi + "\n  ";
    }(l19);
    return e464.isPacked ? (a100 = (function(t723, e469) {
        switch(t723.length){
            case 0:
                return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
            case 1:
                return (function(t, e470) {
                    var n341 = [
                        Math.ceil(e470[0] / 2),
                        Math.ceil(e470[1] / 2)
                    ];
                    if (1 === n341[0]) return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * " + n341[1] + ".0);\n      }\n    ";
                    if (1 === n341[1]) return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * " + n341[0] + ".0);\n      }\n    ";
                    return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n341[0] + ", " + n341[1] + "));\n      return 2 * (resTexRC.x * " + n341[1] + " + resTexRC.y);\n    }\n  ";
                })(0, e469);
            case 2:
                return (function(t724, e471) {
                    var n342 = [
                        Math.ceil(e471[0] / 2),
                        Math.ceil(e471[1] / 2)
                    ];
                    if (S(t724, e471)) return "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(" + n342[0] + ", " + n342[1] + "));\n      }\n    ";
                    var r249 = Math.ceil(t724[1] / 2);
                    return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n342[0] + ", " + n342[1] + "));\n\n      int index = resTexRC.x * " + n342[1] + " + resTexRC.y;\n      int r = 2 * (index / " + r249 + ");\n      int c = imod(index, " + r249 + ") * 2;\n\n      return ivec2(r, c);\n    }\n  ";
                })(t723, e469);
            case 3:
                return n340 = t723, r248 = e469, o153 = [
                    Math.ceil(r248[0] / 2),
                    Math.ceil(r248[1] / 2)
                ], a104 = Math.ceil(n340[2] / 2), i68 = a104 * Math.ceil(n340[1] / 2), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + o153[0] + ", " + o153[1] + "));\n      int index = resTexRC.x * " + o153[1] + " + resTexRC.y;\n\n      int b = index / " + i68 + ";\n      index -= b * " + i68 + ";\n\n      int r = 2 * (index / " + a104 + ");\n      int c = imod(index, " + a104 + ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
            default:
                return (function(t725, e472) {
                    for(var n343 = [
                        Math.ceil(e472[0] / 2),
                        Math.ceil(e472[1] / 2)
                    ], r250 = Math.ceil(t725[t725.length - 1] / 2), o154 = r250 * Math.ceil(t725[t725.length - 2] / 2), a105 = o154, i69 = "", s58 = "b, r, c", u41 = 2; u41 < t725.length - 1; u41++)a105 *= t725[t725.length - u41 - 1], i69 = "\n      int b" + u41 + " = index / " + a105 + ";\n      index -= b" + u41 + " * " + a105 + ";\n    " + i69, s58 = "b" + u41 + ", " + s58;
                    return "\n    ivec" + t725.length + " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n343[0] + ", " + n343[1] + "));\n      int index = resTexRC.x * " + n343[1] + " + resTexRC.y;\n\n      " + i69 + "\n\n      int b = index / " + o154 + ";\n      index -= b * " + o154 + ";\n\n      int r = 2 * (index / " + r250 + ");\n      int c = imod(index, " + r250 + ") * 2;\n\n      return ivec" + t725.length + "(" + s58 + ");\n    }\n  ";
                })(t723, e469);
        }
        var n340, r248, o153, a104, i68;
    })(e464.logicalShape, c24), i65 = (function(t726) {
        return "\n    void setOutput(vec4 val) {\n      " + t726.output + " = val;\n    }\n  ";
    })(l19)) : (a100 = (function(t727, e473) {
        switch(t727.length){
            case 0:
                return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
            case 1:
                return (function(t, e474) {
                    if (1 === e474[0]) return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + e474[1] + ".0);\n      }\n    ";
                    if (1 === e474[1]) return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + e474[0] + ".0);\n      }\n    ";
                    return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e474[0] + ", " + e474[1] + "));\n      return resTexRC.x * " + e474[1] + " + resTexRC.y;\n    }\n  ";
                })(0, e473);
            case 2:
                return (function(t728, e475) {
                    if (S(t728, e475)) return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + e475[0] + ", " + e475[1] + "));\n      }\n    ";
                    if (1 === t728[1]) return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e475[0] + ", " + e475[1] + "));\n        int index = resTexRC.x * " + e475[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
                    if (1 === t728[0]) return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e475[0] + ", " + e475[1] + "));\n        int index = resTexRC.x * " + e475[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
                    return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e475[0] + ", " + e475[1] + "));\n      int index = resTexRC.x * " + e475[1] + " + resTexRC.y;\n      int r = index / " + t728[1] + ";\n      int c = index - r * " + t728[1] + ";\n      return ivec2(r, c);\n    }\n  ";
                })(t727, e473);
            case 3:
                return n344 = e473, r251 = $a([
                    "r",
                    "c",
                    "d"
                ], t727), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n344[0] + ", " + n344[1] + "));\n      int index = resTexRC.x * " + n344[1] + " + resTexRC.y;\n      " + r251 + "\n      return ivec3(r, c, d);\n    }\n  ";
            case 4:
                return (function(t729, e476) {
                    var n345 = $a([
                        "r",
                        "c",
                        "d",
                        "d2"
                    ], t729);
                    return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e476[0] + ", " + e476[1] + "));\n      int index = resTexRC.x * " + e476[1] + " + resTexRC.y;\n      " + n345 + "\n      return ivec4(r, c, d, d2);\n    }\n  ";
                })(t727, e473);
            case 5:
                return (function(t730, e477) {
                    var n346 = $a([
                        "r",
                        "c",
                        "d",
                        "d2",
                        "d3"
                    ], t730);
                    return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" + e477[0] + ",\n                             " + e477[1] + "));\n\n      int index = resTexRC.x * " + e477[1] + " + resTexRC.y;\n\n      " + n346 + "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ";
                })(t727, e473);
            case 6:
                return (function(t731, e478) {
                    var n347 = $a([
                        "r",
                        "c",
                        "d",
                        "d2",
                        "d3",
                        "d4"
                    ], t731);
                    return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e478[0] + ", " + e478[1] + "));\n      int index = resTexRC.x * " + e478[1] + " + resTexRC.y;\n\n      " + n347 + "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ";
                })(t727, e473);
            default:
                throw new Error(t727.length + "-D output sampling is not yet supported");
        }
        var n344, r251;
    })(e464.logicalShape, c24), i65 = (function(t732) {
        return "\n    void setOutput(float val) {\n      " + t732.output + " = vec4(val, 0, 0, 0);\n    }\n  ";
    })(l19)), r244 && (f16 += ai), [
        f16,
        h18,
        i65,
        s55,
        a100,
        u38,
        n336
    ].join("\n");
}
function ti(t733) {
    var e479 = t733.shapeInfo.logicalShape;
    switch(e479.length){
        case 0:
            return (function(t734) {
                var e480 = t734.name, n348 = "get" + e480.charAt(0).toUpperCase() + e480.slice(1);
                if (t734.shapeInfo.isUniform) return "float " + n348 + "() {return " + e480 + ";}";
                var r252 = t734.shapeInfo.texShape, o155 = r252[0], a106 = r252[1];
                if (1 === o155 && 1 === a106) return "\n      float " + n348 + "() {\n        return sampleTexture(" + e480 + ", halfCR);\n      }\n    ";
                var i70 = t734.shapeInfo.texShape, s59 = i70[0], u42 = i70[1], c27 = ii(e480);
                return "\n    float " + n348 + "() {\n      vec2 uv = uvFromFlat(" + s59 + ", " + u42 + ", " + c27 + ");\n      return sampleTexture(" + e480 + ", uv);\n    }\n  ";
            })(t733);
        case 1:
            return (function(t735) {
                var e481 = t735.name, n349 = "get" + e481.charAt(0).toUpperCase() + e481.slice(1);
                if (t735.shapeInfo.isUniform) return "\n      float " + n349 + "(int index) {\n        " + si(t735) + "\n      }\n    ";
                var r253 = t735.shapeInfo.texShape, o156 = r253[0], a107 = r253[1];
                if (1 === a107 && 1 === o156) return "\n      float " + n349 + "(int index) {\n        return sampleTexture(" + e481 + ", halfCR);\n      }\n    ";
                var i71 = ii(e481);
                if (1 === a107) return "\n      float " + n349 + "(int index) {\n        vec2 uv = vec2(0.5, (float(index + " + i71 + ") + 0.5) / " + o156 + ".0);\n        return sampleTexture(" + e481 + ", uv);\n      }\n    ";
                if (1 === o156) return "\n      float " + n349 + "(int index) {\n        vec2 uv = vec2((float(index + " + i71 + ") + 0.5) / " + a107 + ".0, 0.5);\n        return sampleTexture(" + e481 + ", uv);\n      }\n    ";
                return "\n    float " + n349 + "(int index) {\n      vec2 uv = uvFromFlat(" + o156 + ", " + a107 + ", index + " + i71 + ");\n      return sampleTexture(" + e481 + ", uv);\n    }\n  ";
            })(t733);
        case 2:
            return (function(t736) {
                var e482 = t736.shapeInfo.logicalShape, n350 = t736.name, r254 = "get" + n350.charAt(0).toUpperCase() + n350.slice(1), o157 = t736.shapeInfo.texShape;
                if (null != o157 && S(e482, o157)) {
                    var a108 = o157[0], i72 = o157[1];
                    return "\n    float " + r254 + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + i72 + ".0, " + a108 + ".0);\n      return sampleTexture(" + n350 + ", uv);\n    }\n  ";
                }
                var s60 = M(e482), u43 = s60.newShape, c28 = s60.keptDims, l21 = u43;
                if (l21.length < e482.length) {
                    var h21 = ci(t736, l21);
                    return "\n      " + ti(h21) + "\n      float " + r254 + "(int row, int col) {\n        return " + r254 + "(" + li([
                        "row",
                        "col"
                    ], c28) + ");\n      }\n    ";
                }
                if (t736.shapeInfo.isUniform) return "\n      float " + r254 + "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(" + e482[1] + ", 1)));\n        " + si(t736) + "\n      }\n    ";
                var f18 = o157[0], d14 = o157[1], p14 = ii(n350);
                if (1 === d14) return "\n    float " + r254 + "(int row, int col) {\n      float index = dot(vec3(row, col, " + p14 + "), vec3(" + e482[1] + ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / " + f18 + ".0);\n      return sampleTexture(" + n350 + ", uv);\n    }\n  ";
                if (1 === f18) return "\n    float " + r254 + "(int row, int col) {\n      float index = dot(vec3(row, col, " + p14 + "), vec3(" + e482[1] + ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / " + d14 + ".0, 0.5);\n      return sampleTexture(" + n350 + ", uv);\n    }\n  ";
                return "\n  float " + r254 + "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * " + e482[1] + " + col + " + p14 + ";\n    vec2 uv = uvFromFlat(" + f18 + ", " + d14 + ", index);\n    return sampleTexture(" + n350 + ", uv);\n  }\n";
            })(t733);
        case 3:
            return (function(t737) {
                var e483 = t737.shapeInfo.logicalShape, n351 = t737.name, r255 = "get" + n351.charAt(0).toUpperCase() + n351.slice(1), o158 = e483[1] * e483[2], a109 = e483[2], i73 = M(e483), s61 = i73.newShape, u44 = i73.keptDims, c29 = s61;
                if (c29.length < e483.length) {
                    var l22 = ci(t737, c29);
                    return "\n        " + ti(l22) + "\n        float " + r255 + "(int row, int col, int depth) {\n          return " + r255 + "(" + li([
                        "row",
                        "col",
                        "depth"
                    ], u44) + ");\n        }\n      ";
                }
                if (t737.shapeInfo.isUniform) return "\n      float " + r255 + "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(" + o158 + ", " + a109 + ", 1)));\n        " + si(t737) + "\n      }\n    ";
                var h22 = t737.shapeInfo.texShape, f19 = h22[0], d15 = h22[1], p15 = t737.shapeInfo.flatOffset;
                if (d15 === o158 && null == p15) return "\n        float " + r255 + "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(" + a109 + ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + d15 + ".0, " + f19 + ".0);\n          return sampleTexture(" + n351 + ", uv);\n        }\n      ";
                if (d15 === a109 && null == p15) return "\n    float " + r255 + "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(" + e483[1] + ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + d15 + ".0, " + f19 + ".0);\n      return sampleTexture(" + n351 + ", uv);\n    }\n  ";
                var v12 = ii(n351);
                return "\n      float " + r255 + "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * " + o158 + " + col * " + a109 + " + depth + " + v12 + ";\n        vec2 uv = uvFromFlat(" + f19 + ", " + d15 + ", index);\n        return sampleTexture(" + n351 + ", uv);\n      }\n  ";
            })(t733);
        case 4:
            return (function(t738) {
                var e484 = t738.shapeInfo.logicalShape, n352 = t738.name, r256 = "get" + n352.charAt(0).toUpperCase() + n352.slice(1), o159 = e484[3], a110 = e484[2] * o159, i74 = e484[1] * a110, s62 = M(e484), u45 = s62.newShape, c30 = s62.keptDims;
                if (u45.length < e484.length) {
                    var l23 = ci(t738, u45);
                    return "\n      " + ti(l23) + "\n      float " + r256 + "(int row, int col, int depth, int depth2) {\n        return " + r256 + "(" + li([
                        "row",
                        "col",
                        "depth",
                        "depth2"
                    ], c30) + ");\n      }\n    ";
                }
                if (t738.shapeInfo.isUniform) return "\n      float " + r256 + "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(" + i74 + ", " + a110 + ", " + o159 + ", 1)));\n        " + si(t738) + "\n      }\n    ";
                var h23 = t738.shapeInfo.flatOffset, f20 = t738.shapeInfo.texShape, d16 = f20[0], p16 = f20[1];
                if (p16 === i74 && null == h23) return "\n      float " + r256 + "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(" + a110 + ", " + o159 + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + p16 + ".0, " + d16 + ".0);\n        return sampleTexture(" + n352 + ", uv);\n      }\n    ";
                if (p16 === o159 && null == h23) return "\n      float " + r256 + "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" + e484[1] * e484[2] + ", " + e484[2] + ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + p16 + ".0, " + d16 + ".0);\n        return sampleTexture(" + n352 + ", uv);\n      }\n    ";
                var v13 = ii(n352);
                return "\n    float " + r256 + "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + i74 + " + col * " + a110 + " +\n          depth * " + o159 + " + depth2;\n      vec2 uv = uvFromFlat(" + d16 + ", " + p16 + ", index + " + v13 + ");\n      return sampleTexture(" + n352 + ", uv);\n    }\n  ";
            })(t733);
        case 5:
            return (function(t739) {
                var e485 = t739.shapeInfo.logicalShape, n353 = t739.name, r257 = "get" + n353.charAt(0).toUpperCase() + n353.slice(1), o160 = e485[4], a111 = e485[3] * o160, i75 = e485[2] * a111, s63 = e485[1] * i75, u46 = M(e485), c31 = u46.newShape, l24 = u46.keptDims;
                if (c31.length < e485.length) {
                    var h24 = ci(t739, c31);
                    return "\n      " + ti(h24) + "\n      float " + r257 + "(int row, int col, int depth, int depth2, int depth3) {\n        return " + r257 + "(" + li([
                        "row",
                        "col",
                        "depth",
                        "depth2",
                        "depth3"
                    ], l24) + ");\n      }\n    ";
                }
                if (t739.shapeInfo.isUniform) return "\n      float " + r257 + "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + s63 + ", " + i75 + ", " + a111 + ", " + o160 + ")) +\n          depth3;\n        " + si(t739) + "\n      }\n    ";
                var f21 = t739.shapeInfo.flatOffset, d17 = t739.shapeInfo.texShape, p17 = d17[0], v14 = d17[1];
                if (v14 === s63 && null == f21) return "\n      float " + r257 + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(" + i75 + ", " + a111 + ", " + o160 + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + v14 + ".0, " + p17 + ".0);\n        return sampleTexture(" + n353 + ", uv);\n      }\n    ";
                if (v14 === o160 && null == f21) return "\n      float " + r257 + "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + e485[1] * e485[2] * e485[3] + ",\n               " + e485[2] * e485[3] + ", " + e485[3] + ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + v14 + ".0, " + p17 + ".0);\n        return sampleTexture(" + n353 + ", uv);\n      }\n    ";
                var g12 = ii(n353);
                return "\n    float " + r257 + "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + s63 + " + col * " + i75 + " + depth * " + a111 + " +\n          depth2 * " + o160 + " + depth3 + " + g12 + ";\n      vec2 uv = uvFromFlat(" + p17 + ", " + v14 + ", index);\n      return sampleTexture(" + n353 + ", uv);\n    }\n  ";
            })(t733);
        case 6:
            return (function(t740) {
                var e486 = t740.shapeInfo.logicalShape, n354 = t740.name, r258 = "get" + n354.charAt(0).toUpperCase() + n354.slice(1), o161 = M(e486), a112 = o161.newShape, i76 = o161.keptDims;
                if (a112.length < e486.length) {
                    var s64 = ci(t740, a112);
                    return "\n      " + ti(s64) + "\n      float " + r258 + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return " + r258 + "(" + li([
                        "row",
                        "col",
                        "depth",
                        "depth2",
                        "depth3",
                        "depth4"
                    ], i76) + ");\n      }\n    ";
                }
                var u47 = e486[5], c32 = e486[4] * u47, l25 = e486[3] * c32, h25 = e486[2] * l25, f22 = e486[1] * h25;
                if (t740.shapeInfo.isUniform) return "\n      float " + r258 + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + f22 + ", " + h25 + ", " + l25 + ", " + c32 + ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(" + u47 + ", 1)));\n        " + si(t740) + "\n      }\n    ";
                var d18 = t740.shapeInfo.flatOffset, p18 = t740.shapeInfo.texShape, v15 = p18[0], g13 = p18[1];
                if (g13 === f22 && null == d18) return "\n      float " + r258 + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(" + h25 + ", " + l25 + ", " + c32 + ", " + u47 + ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + g13 + ".0, " + v15 + ".0);\n        return sampleTexture(" + n354 + ", uv);\n      }\n    ";
                if (g13 === u47 && null == d18) return "\n      float " + r258 + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(" + e486[1] * e486[2] * e486[3] * e486[4] + ",\n               " + e486[2] * e486[3] * e486[4] + ",\n               " + e486[3] * e486[4] + ",\n               " + e486[4] + ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + g13 + ".0, " + v15 + ".0);\n        return sampleTexture(" + n354 + ", uv);\n      }\n    ";
                var m11 = ii(n354);
                return "\n    float " + r258 + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + f22 + " + col * " + h25 + " + depth * " + l25 + " +\n          depth2 * " + c32 + " + depth3 * " + u47 + " + depth4 + " + m11 + ";\n      vec2 uv = uvFromFlat(" + v15 + ", " + g13 + ", index);\n      return sampleTexture(" + n354 + ", uv);\n    }\n  ";
            })(t733);
        default:
            throw new Error(e479.length + "-D input sampling is not yet supported");
    }
}
function ei(t741) {
    var e487, n355, r259;
    switch(t741.shapeInfo.logicalShape.length){
        case 0:
            return e487 = t741.name, n355 = "get" + e487.charAt(0).toUpperCase() + e487.slice(1), r259 = Ya(), "\n    vec4 " + n355 + "() {\n      return " + r259.texture2D + "(" + e487 + ", halfCR);\n    }\n  ";
        case 1:
            return (function(t742) {
                var e488 = t742.name, n356 = "get" + e488.charAt(0).toUpperCase() + e488.slice(1), r260 = t742.shapeInfo.texShape, o162 = [
                    Math.ceil(r260[0] / 2),
                    Math.ceil(r260[1] / 2)
                ], a113 = Ya();
                return "\n    vec4 " + n356 + "(int index) {\n      vec2 uv = packedUVfrom1D(\n        " + o162[0] + ", " + o162[1] + ", index);\n      return " + a113.texture2D + "(" + e488 + ", uv);\n    }\n  ";
            })(t741);
        case 2:
            return (function(t743) {
                var e489 = t743.shapeInfo.logicalShape, n357 = t743.name, r261 = "get" + n357.charAt(0).toUpperCase() + n357.slice(1), o163 = t743.shapeInfo.texShape, a114 = o163[0], i77 = o163[1], s65 = Ya();
                if (null != o163 && S(e489, o163)) return "\n      vec4 " + r261 + "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + i77 + ".0, " + a114 + ".0);\n\n        return " + s65.texture2D + "(" + n357 + ", uv);\n      }\n    ";
                var u48 = [
                    Math.ceil(o163[0] / 2),
                    Math.ceil(o163[1] / 2)
                ], c33 = Math.ceil(e489[1] / 2);
                return "\n    vec4 " + r261 + "(int row, int col) {\n      vec2 uv = packedUVfrom2D(" + c33 + ", " + u48[0] + ", " + u48[1] + ", row, col);\n      return " + s65.texture2D + "(" + n357 + ", uv);\n    }\n  ";
            })(t741);
        case 3:
            return (function(t744) {
                var e490 = t744.shapeInfo.logicalShape, n358 = t744.name, r262 = "get" + n358.charAt(0).toUpperCase() + n358.slice(1), o164 = t744.shapeInfo.texShape, a115 = [
                    Math.ceil(o164[0] / 2),
                    Math.ceil(o164[1] / 2)
                ];
                if (1 === e490[0]) {
                    var i78 = e490.slice(1), s66 = ci(t744, i78);
                    return "\n        " + ei(s66) + "\n        vec4 " + r262 + "(int b, int row, int col) {\n          return " + r262 + "(" + li([
                        "b",
                        "row",
                        "col"
                    ], [
                        1,
                        2
                    ]) + ");\n        }\n      ";
                }
                var u49 = a115[0], c34 = a115[1], l26 = Math.ceil(e490[2] / 2), h26 = l26 * Math.ceil(e490[1] / 2), f23 = Ya();
                return "\n    vec4 " + r262 + "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        " + u49 + ", " + c34 + ", " + h26 + ", " + l26 + ", b, row, col);\n      return " + f23.texture2D + "(" + n358 + ", uv);\n    }\n  ";
            })(t741);
        default:
            return (function(t745) {
                for(var e491 = t745.shapeInfo.logicalShape, n359 = e491.length, r263 = t745.name, o165 = "get" + r263.charAt(0).toUpperCase() + r263.slice(1), a116 = t745.shapeInfo.texShape, i79 = [
                    Math.ceil(a116[0] / 2),
                    Math.ceil(a116[1] / 2)
                ], s67 = i79[0], u50 = i79[1], c35 = Math.ceil(e491[n359 - 1] / 2), l27 = c35 * Math.ceil(e491[n359 - 2] / 2), h27 = "int b, int row, int col", f24 = "b * " + l27 + " + (row / 2) * " + c35 + " + (col / 2)", d19 = 2; d19 < n359 - 1; d19++)h27 = "int b" + d19 + ", " + h27, l27 *= e491[n359 - d19 - 1], f24 = "b" + d19 + " * " + l27 + " + " + f24;
                var p19 = Ya();
                return "\n    vec4 " + o165 + "(" + h27 + ") {\n      int index = " + f24 + ";\n      int texR = index / " + u50 + ";\n      int texC = index - texR * " + u50 + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + u50 + ", " + s67 + ");\n      return " + p19.texture2D + "(" + r263 + ", uv);\n    }\n  ";
            })(t741);
    }
}
var ni = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n", ri = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n", oi = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n", ai = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";
function ii(t746) {
    return "offset" + t746;
}
function si(t747) {
    var e492 = t747.name, n360 = k(t747.shapeInfo.logicalShape);
    return n360 < 2 ? "return " + e492 + ";" : "\n    for (int i = 0; i < " + n360 + "; i++) {\n      if (i == index) {\n        return " + e492 + "[i];\n      }\n    }\n  ";
}
function ui(t748) {
    if (t748 <= 1) return "int";
    if (2 === t748) return "ivec2";
    if (3 === t748) return "ivec3";
    if (4 === t748) return "ivec4";
    if (5 === t748) return "ivec5";
    if (6 === t748) return "ivec6";
    throw Error("GPU for rank " + t748 + " is not yet supported");
}
function ci(t749, e493) {
    var n361 = JSON.parse(JSON.stringify(t749));
    return n361.shapeInfo.logicalShape = e493, n361;
}
function li(t750, e494) {
    return e494.map(function(e) {
        return t750[e];
    }).join(", ");
}
var hi = function(t751, e495, n362, r264) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !0, this.packedOutput = !0, C(t751.length > 2, function() {
        return "Packed arg" + (n362.charAt(0).toUpperCase() + n362.slice(1)) + " supports only inputs with rank above 2.";
    });
    var o166 = t751[t751.length - 1], a117 = Math.ceil(o166 / e495);
    this.outputShape = t751.slice(0, -1), a117 > 1 && this.outputShape.push(a117), r264 || this.variableNames.push("bestIndicesA");
    var i80, s68, u51 = this.outputShape, c36 = u51.length, l28 = ui(c36), h28 = Xa("coords", c36);
    if (1 === a117) {
        var f25 = ui(s68 = c36 + 1);
        i80 = "\n        " + f25 + " sourceLocR = " + f25 + "(" + h28.join() + ", 0);\n        ++" + h28[c36 - 1] + ";\n        " + f25 + " sourceLocG = " + f25 + "(" + h28.join() + ", 0);\n        ++" + h28[c36 - 2] + ";\n        " + f25 + " sourceLocA = " + f25 + "(" + h28.join() + ", 0);\n        --" + h28[c36 - 1] + ";\n        " + f25 + " sourceLocB = " + f25 + "(" + h28.join() + ", 0);\n        --" + h28[c36 - 2] + ";";
    } else s68 = c36, i80 = "\n        " + l28 + " sourceLocR = coords;\n        ++" + h28[c36 - 1] + ";\n        " + l28 + " sourceLocG = coords;\n        ++" + h28[c36 - 2] + ";\n        " + l28 + " sourceLocA = coords;\n        --" + h28[c36 - 1] + ";\n        " + l28 + " sourceLocB = coords;\n        --" + h28[c36 - 2] + ";";
    var d20 = [
        "x",
        "y",
        "z",
        "w",
        "u",
        "v"
    ].slice(0, s68), p20 = "." + d20[s68 - 1], v16 = d20.map(function(t752) {
        return "int " + t752;
    }), g14 = Xa("sourceLocR", s68 - 1).concat("inIdx.r"), m12 = Xa("sourceLocG", s68 - 1).concat("inIdx.g"), y8 = Xa("sourceLocB", s68 - 1).concat("inIdx.b"), x8 = Xa("sourceLocA", s68 - 1).concat("inIdx.a"), b5 = "max" === n362 ? "greaterThan" : "lessThan", w5 = r264 ? "" : "\n          inIdx = round(vec4(getBestIndicesAChannel(" + g14.join() + "),\n                             getBestIndicesAChannel(" + m12.join() + "),\n                             getBestIndicesAChannel(" + y8.join() + "),\n                             getBestIndicesAChannel(" + x8.join() + ")));", E4 = "vec4(\n            getAChannel(" + g14.join() + "),\n            hasNextCol ? getAChannel(" + m12.join() + ") : 0.,\n            hasNextRow ? getAChannel(" + y8.join() + ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(" + x8.join() + ") : 0.)", R4 = r264 ? "" : "\n      float getBestIndicesAChannel(" + v16.join() + ") {\n        return getChannel(getBestIndicesA(" + d20.join() + "),\n                                          vec2(" + d20.slice(-2).join() + "));\n      }";
    this.userCode = "\n      float getAChannel(" + v16.join() + ") {\n        return getChannel(getA(" + d20.join() + "),\n                               vec2(" + d20.slice(-2).join() + "));\n      }\n      " + R4 + "\n      void main() {\n        " + l28 + " coords = getOutputCoords();\n        bool hasNextCol = " + h28[c36 - 1] + " < " + (u51[c36 - 1] - 1) + ";\n        bool hasNextRow = " + h28[c36 - 2] + " < " + (u51[c36 - 2] - 1) + ";\n        " + i80 + "\n        ivec4 srcIdx = ivec4(sourceLocR" + p20 + ", sourceLocG" + p20 + ",\n          sourceLocB" + p20 + ", sourceLocA" + p20 + ") * " + e495 + ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = " + E4 + ";\n\n        for (int i = 0; i < " + e495 + "; i++) {\n          inIdx = srcIdx;\n          " + w5 + "\n          vec4 candidate = " + E4 + ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(" + b5 + "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ";
}, fi = function(t753) {
    this.variableNames = [
        "dy"
    ], this.outputShape = t753.inShape;
    var e496 = t753.filterHeight, n363 = t753.filterWidth, r265 = t753.strideHeight, o167 = t753.strideWidth, a118 = t753.dilationHeight, i81 = t753.dilationWidth, s69 = t753.effectiveFilterHeight, u52 = t753.effectiveFilterWidth, c37 = s69 - 1 - t753.padInfo.top, l29 = u52 - 1 - t753.padInfo.left, h29 = 1 / (e496 * n363);
    this.userCode = "\n      const ivec2 pads = ivec2(" + c37 + ", " + l29 + ");\n      const float avgMultiplier = float(" + h29 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + s69 + ";\n            wR += " + a118 + ") {\n          float dyR = float(dyRCorner + wR) / " + r265 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t753.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + u52 + ";\n            wC+= " + i81 + ") {\n            float dyC = float(dyCCorner + wC) / " + o167 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t753.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, di = function(t754) {
    this.variableNames = [
        "dy"
    ], this.outputShape = t754.inShape;
    var e497 = t754.filterDepth, n364 = t754.filterHeight, r266 = t754.filterWidth, o168 = t754.strideDepth, a119 = t754.strideHeight, i82 = t754.strideWidth, s70 = t754.dilationDepth, u53 = t754.dilationHeight, c38 = t754.dilationWidth, l30 = t754.effectiveFilterDepth, h30 = t754.effectiveFilterHeight, f26 = t754.effectiveFilterWidth, d21 = l30 - 1 - t754.padInfo.front, p21 = h30 - 1 - t754.padInfo.top, v17 = f26 - 1 - t754.padInfo.left, g15 = 1 / (e497 * n364 * r266);
    this.userCode = "\n      const ivec3 pads = ivec3(" + d21 + ", " + p21 + ", " + v17 + ");\n      const float avgMultiplier = float(" + g15 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + l30 + ";\n            wD += " + s70 + ") {\n          float dyD = float(dyDCorner + wD) / " + o168 + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t754.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + h30 + ";\n              wR += " + u53 + ") {\n            float dyR = float(dyRCorner + wR) / " + a119 + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t754.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + f26 + ";\n                wC += " + c38 + ") {\n              float dyC = float(dyCCorner + wC) / " + i82 + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t754.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, pi = function(t755, e498, n365, r267, o169, a120) {
    this.outputShape = [], this.variableNames = [
        "x",
        "mean",
        "variance"
    ], Pr(t755, e498), Pr(t755, n365);
    var i83 = "0.0";
    null != r267 && (Pr(t755, r267), this.variableNames.push("offset"), i83 = "getOffsetAtOutCoords()");
    var s71 = "1.0";
    null != o169 && (Pr(t755, o169), this.variableNames.push("scale"), s71 = "getScaleAtOutCoords()"), this.outputShape = t755, this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + i83 + ";\n        float scale = " + s71 + ";\n        float inv = scale * inversesqrt(variance + float(" + a120 + "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ";
}, vi = function(t756, e499, n366, r268, o170, a121) {
    this.packedInputs = !0, this.packedOutput = !0, this.variableNames = [
        "x",
        "mean",
        "variance"
    ], Pr(t756, e499), Pr(t756, n366);
    var i84 = "vec4(0.0)";
    null != r268 && (Pr(t756, r268), this.variableNames.push("offset"), i84 = "getOffsetAtOutCoords()");
    var s72 = "vec4(1.0)";
    null != o170 && (Pr(t756, o170), this.variableNames.push("scale"), s72 = "getScaleAtOutCoords()"), this.outputShape = t756, this.userCode = "\n      void main() {\n        vec4 offset = " + i84 + ";\n        vec4 scale = " + s72 + ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(" + a121 + "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ";
}, gi = "return areal * breal - aimag * bimag;", mi = "return areal * bimag + aimag * breal;", yi = function(t757, e500, n367) {
    this.variableNames = [
        "AReal",
        "AImag",
        "BReal",
        "BImag"
    ], this.outputShape = Pr(e500, n367), this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        " + t757 + "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ";
}, xi = "return a + b;", bi = "return a - b;", wi = "return a * b;", Ci = "\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;", Ei = "return (a < 0.) ? b * a : a;", Ri = function(t758, e501, n368) {
    this.variableNames = [
        "A",
        "B"
    ], this.outputShape = Pr(e501, n368), this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + t758 + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
}, Ii = "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n", ki = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n", Si = function(t759, e502, n369, r269) {
    void 0 === r269 && (r269 = !1), this.variableNames = [
        "A",
        "B"
    ], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = Pr(e502, n369);
    var o171 = this.outputShape.length, a122 = "";
    if (r269) {
        if (0 === o171 || 1 === k(this.outputShape)) a122 = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
        else if (a122 = "\n          " + ui(o171) + " coords = getOutputCoords();\n        ", 1 === o171) a122 += "\n            result.y = (coords + 1) >= " + this.outputShape[0] + " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";
        else {
            var i85 = Xa("coords", o171);
            a122 += "\n            bool nextRowOutOfBounds =\n              (" + i85[o171 - 2] + " + 1) >= " + this.outputShape[o171 - 2] + ";\n            bool nextColOutOfBounds =\n              (" + i85[o171 - 1] + " + 1) >= " + this.outputShape[o171 - 1] + ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ";
        }
    }
    this.userCode = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        " + t759 + "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        " + a122 + "\n\n        setOutput(result);\n      }\n    ";
}, Ai = function() {
    function t760(t761) {
        this.variableNames = [
            "A"
        ], this.outputShape = t761, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ";
    }
    return t760.prototype.getCustomSetupFunc = function(t762, e503) {
        var n370 = this;
        return function(r270, o172) {
            null == n370.minLoc && (n370.minLoc = r270.getUniformLocationNoThrow(o172, "minVal"), n370.maxLoc = r270.getUniformLocationNoThrow(o172, "maxVal")), r270.gl.uniform1f(n370.minLoc, t762), r270.gl.uniform1f(n370.maxLoc, e503);
        };
    }, t760;
}(), Ti = function() {
    function t763(t764) {
        this.variableNames = [
            "A"
        ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t764, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ";
    }
    return t763.prototype.getCustomSetupFunc = function(t765, e504) {
        var n371 = this;
        return function(r271, o173) {
            null == n371.minLoc && (n371.minLoc = r271.getUniformLocationNoThrow(o173, "minVal"), n371.maxLoc = r271.getUniformLocationNoThrow(o173, "maxVal")), r271.gl.uniform1f(n371.minLoc, t765), r271.gl.uniform1f(n371.maxLoc, e504);
        };
    }, t763;
}(), Di = function(t766) {
    this.variableNames = [
        "real",
        "imag"
    ], this.outputShape = t766, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    ";
}, Ni = function(t767) {
    this.outputShape = [], this.outputShape = Sn(t767, 1), this.variableNames = t767.map(function(t, e506) {
        return "T" + e506;
    });
    var e505 = new Array(t767.length - 1);
    e505[0] = t767[0][1];
    for(var n372 = 1; n372 < e505.length; n372++)e505[n372] = e505[n372 - 1] + t767[n372][1];
    var r272 = [
        "if (yC < " + e505[0] + ") setOutput(getT0(yR, yC));"
    ];
    for(n372 = 1; n372 < e505.length; n372++){
        var o174 = e505[n372 - 1];
        r272.push("else if (yC < " + e505[n372] + ") setOutput(getT" + n372 + "(yR, yC-" + o174 + "));");
    }
    var a123 = e505.length, i86 = e505[e505.length - 1];
    r272.push("else setOutput(getT" + a123 + "(yR, yC-" + i86 + "));"), this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        " + r272.join("\n        ") + "\n      }\n    ";
}, Fi = function(t768, e507) {
    this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = Sn(t768, e507);
    var n373 = this.outputShape, r273 = n373.length, o175 = ui(r273), a124 = Xa("coords", r273), i87 = [
        "x",
        "y",
        "z",
        "w",
        "u",
        "v"
    ].slice(0, r273);
    this.variableNames = t768.map(function(t, e508) {
        return "T" + e508;
    });
    var s73 = new Array(t768.length - 1);
    s73[0] = t768[0][e507];
    for(var u54 = 1; u54 < s73.length; u54++)s73[u54] = s73[u54 - 1] + t768[u54][e507];
    var c39 = i87[e507], l31 = i87.slice(-2), h31 = i87.join(), f27 = "if (" + c39 + " < " + s73[0] + ") {\n        return getChannel(\n            getT0(" + h31 + "), vec2(" + l31.join() + "));\n        }";
    for(u54 = 1; u54 < s73.length; u54++){
        var d22 = s73[u54 - 1];
        f27 += "\n        if (" + c39 + " < " + s73[u54] + "  && " + c39 + " >= " + s73[u54 - 1] + ") {\n          return getChannel(\n            getT" + u54 + "(" + _i(i87, c39, d22) + "),\n            vec2(" + _i(l31, c39, d22) + "));\n        }";
    }
    var p22 = s73.length, v18 = s73[s73.length - 1];
    f27 += "\n        return getChannel(\n          getT" + p22 + "(" + _i(i87, c39, v18) + "),\n          vec2(" + _i(l31, c39, v18) + "));", this.userCode = "\n      float getValue(" + i87.map(function(t769) {
        return "int " + t769;
    }) + ") {\n        " + f27 + "\n      }\n\n      void main() {\n        " + o175 + " coords = getOutputCoords();\n        vec4 result = vec4(getValue(" + a124 + "), 0., 0., 0.);\n\n        " + a124[r273 - 1] + " = " + a124[r273 - 1] + " + 1;\n        if (" + a124[r273 - 1] + " < " + n373[r273 - 1] + ") {\n          result.g = getValue(" + a124 + ");\n        }\n\n        " + a124[r273 - 2] + " = " + a124[r273 - 2] + " + 1;\n        if (" + a124[r273 - 2] + " < " + n373[r273 - 2] + ") {\n          result.a = getValue(" + a124 + ");\n        }\n\n        " + a124[r273 - 1] + " = " + a124[r273 - 1] + " - 1;\n        if (" + a124[r273 - 2] + " < " + n373[r273 - 2] + " &&\n            " + a124[r273 - 1] + " < " + n373[r273 - 1] + ") {\n          result.b = getValue(" + a124 + ");\n        }\n        setOutput(result);\n      }\n    ";
};
function _i(t770, e509, n374) {
    var r274 = t770.indexOf(e509);
    return t770.map(function(t771, e510) {
        return e510 === r274 ? t771 + " - " + n374 : t771;
    }).join();
}
var Oi = function(t772) {
    this.variableNames = [
        "x",
        "dy"
    ], this.outputShape = t772.filterShape;
    var e511 = t772.strideHeight, n375 = t772.strideWidth, r275 = t772.padInfo.top, o176 = t772.padInfo.left, a125 = "channelsLast" === t772.dataFormat;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t772.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t772.outHeight + "; yR++) {\n            int xR = wR + yR * " + e511 + " - " + r275 + ";\n\n            if (xR < 0 || xR >= " + t772.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t772.outWidth + "; yC++) {\n              int xC = wC + yC * " + n375 + " - " + o176 + ";\n\n              if (xC < 0 || xC >= " + t772.inWidth + ") {\n                continue;\n              }\n\n              if (" + a125 + ") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, Mi = function(t773) {
    this.variableNames = [
        "dy",
        "W"
    ], this.outputShape = t773.inShape;
    var e512 = t773.filterHeight, n376 = t773.filterWidth, r276 = t773.strideHeight, o177 = t773.strideWidth, a126 = "channelsLast" === t773.dataFormat, i88 = e512 - 1 - t773.padInfo.top, s74 = n376 - 1 - t773.padInfo.left, u55 = a126 ? 1 : 2, c40 = a126 ? 2 : 3, l32 = a126 ? 3 : 1;
    this.userCode = "\n      const ivec2 pads = ivec2(" + i88 + ", " + s74 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[" + l32 + "];\n\n        ivec2 dyCorner = ivec2(coords[" + u55 + "], coords[" + c40 + "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + e512 + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r276 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t773.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e512 + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n376 + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + o177 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t773.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n376 + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + t773.outChannels + "; d2++) {\n\n              if (" + a126 + ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, Bi = function(t774) {
    this.variableNames = [
        "x",
        "dy"
    ], this.outputShape = t774.filterShape;
    var e513 = t774.strideDepth, n377 = t774.strideHeight, r277 = t774.strideWidth, o178 = t774.padInfo.front, a127 = t774.padInfo.top, i89 = t774.padInfo.left;
    this.userCode = "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t774.batchSize + "; b++) {\n          for (int yF = 0; yF < " + t774.outDepth + "; yF++) {\n            int xF = wF + yF * " + e513 + " - " + o178 + ";\n\n            if (xF < 0 || xF >= " + t774.inDepth + ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < " + t774.outHeight + "; yR++) {\n              int xR = wR + yR * " + n377 + " - " + a127 + ";\n\n              if (xR < 0 || xR >= " + t774.inHeight + ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < " + t774.outWidth + "; yC++) {\n                int xC = wC + yC * " + r277 + " - " + i89 + ";\n\n                if (xC < 0 || xC >= " + t774.inWidth + ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, Pi = function(t775) {
    this.variableNames = [
        "dy",
        "W"
    ], this.outputShape = t775.inShape;
    var e514 = t775.filterDepth, n378 = t775.filterHeight, r278 = t775.filterWidth, o179 = t775.strideDepth, a128 = t775.strideHeight, i90 = t775.strideWidth, s75 = e514 - 1 - t775.padInfo.front, u56 = n378 - 1 - t775.padInfo.top, c41 = r278 - 1 - t775.padInfo.left;
    this.userCode = "\n      const ivec3 pads = ivec3(" + s75 + ", " + u56 + ", " + c41 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + e514 + "; wF++) {\n          float dyF = float(dyFCorner + wF) / " + o179 + ".0;\n\n          if (dyF < 0.0 || dyF >= " + t775.outDepth + ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = " + e514 + " - 1 - wF;\n\n          for (int wR = 0; wR < " + n378 + "; wR++) {\n            float dyR = float(dyRCorner + wR) / " + a128 + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t775.outHeight + ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = " + n378 + " - 1 - wR;\n\n            for (int wC = 0; wC < " + r278 + "; wC++) {\n              float dyC = float(dyCCorner + wC) / " + i90 + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t775.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = " + r278 + " - 1 - wC;\n\n              for (int d2 = 0; d2 < " + t775.outChannels + "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, Li = function(t776) {
    this.variableNames = [
        "x",
        "dy"
    ], this.outputShape = t776.filterShape;
    var e515 = t776.strideHeight, n379 = t776.strideWidth, r279 = t776.padInfo.top, o180 = t776.padInfo.left, a129 = t776.outChannels / t776.inChannels;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * " + a129 + " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < " + t776.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t776.outHeight + "; yR++) {\n            int xR = wR + yR * " + e515 + " - " + r279 + ";\n\n            if (xR < 0 || xR >= " + t776.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t776.outWidth + "; yC++) {\n              int xC = wC + yC * " + n379 + " - " + o180 + ";\n\n              if (xC < 0 || xC >= " + t776.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, Wi = function(t777) {
    this.variableNames = [
        "dy",
        "W"
    ], this.outputShape = t777.inShape;
    var e516 = t777.filterHeight, n380 = t777.filterWidth, r280 = t777.strideHeight, o181 = t777.strideWidth, a130 = e516 - 1 - t777.padInfo.top, i91 = n380 - 1 - t777.padInfo.left, s76 = t777.outChannels / t777.inChannels;
    this.userCode = "\n      const ivec2 pads = ivec2(" + a130 + ", " + i91 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < " + e516 + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r280 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t777.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e516 + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n380 + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + o181 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t777.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n380 + " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < " + s76 + "; dm++) {\n              int d2 = d1 * " + s76 + " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, Ui = function(t778, e517, n381, r281) {
    void 0 === e517 && (e517 = !1), void 0 === n381 && (n381 = null), void 0 === r281 && (r281 = !1), this.variableNames = [
        "x",
        "W"
    ], this.outputShape = t778.outShape;
    var o182 = t778.padInfo.top, a131 = t778.padInfo.left, i92 = t778.strideHeight, s77 = t778.strideWidth, u57 = t778.dilationHeight, c42 = t778.dilationWidth, l33 = t778.filterHeight, h32 = t778.filterWidth, f28 = 4 * Math.floor(t778.inChannels / 4), d23 = t778.inChannels % 4, p23 = "channelsLast" === t778.dataFormat, v19 = p23 ? 1 : 2, g16 = p23 ? 2 : 3, m13 = p23 ? 3 : 1, y9 = "", x9 = "";
    n381 && (y9 = r281 ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n381 + "\n        }" : "\n          float activation(float x) {\n            " + n381 + "\n          }\n        ", x9 = "result = activation(result);");
    var b6 = e517 ? "result += getBiasAtOutCoords();" : "";
    e517 && this.variableNames.push("bias"), r281 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + y9 + "\n\n      const ivec2 strides = ivec2(" + i92 + ", " + s77 + ");\n      const ivec2 pads = ivec2(" + o182 + ", " + a131 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[" + m13 + "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[" + v19 + "], coords[" + g16 + "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + l33 + "; wR++) {\n          int xR = xRCorner + wR * " + u57 + ";\n\n          if (xR < 0 || xR >= " + t778.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + h32 + "; wC++) {\n            int xC = xCCorner + wC * " + c42 + ";\n\n            if (xC < 0 || xC >= " + t778.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + f28 + "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (" + p23 + ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (" + (1 === d23) + ") {\n\n              if (" + p23 + ") {\n                dotProd +=\n                    getX(batch, xR, xC, " + f28 + ") *\n                    getW(wR, wC, " + f28 + ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, " + f28 + ", xR, xC) *\n                    getW(wR, wC, " + f28 + ", d2);\n              }\n\n            } else if (" + (2 === d23) + ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, " + f28 + ", d2),\n                getW(wR, wC, " + f28 + " + 1, d2)\n              );\n\n              if (" + p23 + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, " + f28 + "),\n                  getX(batch, xR, xC, " + f28 + " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, " + f28 + ", xR, xC),\n                  getX(batch, " + f28 + " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (" + (3 === d23) + ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, " + f28 + ", d2),\n                getW(wR, wC, " + f28 + " + 1, d2),\n                getW(wR, wC, " + f28 + " + 2, d2)\n              );\n\n              if (" + p23 + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, " + f28 + "),\n                  getX(batch, xR, xC, " + f28 + " + 1),\n                  getX(batch, xR, xC, " + f28 + " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, " + f28 + ", xR, xC),\n                  getX(batch, " + f28 + " + 1, xR, xC),\n                  getX(batch, " + f28 + " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        " + b6 + "\n        " + x9 + "\n        setOutput(result);\n      }\n    ";
}, Vi = function(t779) {
    this.variableNames = [
        "x",
        "W"
    ], this.outputShape = t779.outShape;
    var e518 = t779.padInfo.front, n382 = t779.padInfo.top, r282 = t779.padInfo.left, o183 = t779.strideDepth, a132 = t779.strideHeight, i93 = t779.strideWidth, s78 = t779.dilationDepth, u58 = t779.dilationHeight, c43 = t779.dilationWidth, l34 = t779.filterDepth, h33 = t779.filterHeight, f29 = t779.filterWidth, d24 = 4 * Math.floor(t779.inChannels / 4), p24 = t779.inChannels % 4;
    this.userCode = "\n      const ivec3 strides = ivec3(" + o183 + ", " + a132 + ", " + i93 + ");\n      const ivec3 pads = ivec3(" + e518 + ", " + n382 + ", " + r282 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + l34 + "; wF++) {\n          int xF = xFCorner + wF * " + s78 + ";\n\n          if (xF < 0 || xF >= " + t779.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h33 + "; wR++) {\n            int xR = xRCorner + wR * " + u58 + ";\n\n            if (xR < 0 || xR >= " + t779.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + f29 + "; wC++) {\n              int xC = xCCorner + wC * " + c43 + ";\n\n              if (xC < 0 || xC >= " + t779.inWidth + ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < " + d24 + "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (" + (1 === p24) + ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, " + d24 + ") *\n                  getW(wF, wR, wC, " + d24 + ", d2);\n              } else if (" + (2 === p24) + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, " + d24 + "),\n                  getX(batch, xF, xR, xC, " + d24 + " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, " + d24 + ", d2),\n                  getW(wF, wR, wC, " + d24 + " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (" + (3 === p24) + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, " + d24 + "),\n                  getX(batch, xF, xR, xC, " + d24 + " + 1),\n                  getX(batch, xF, xR, xC, " + d24 + " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, " + d24 + ", d2),\n                  getW(wF, wR, wC, " + d24 + " + 1, d2),\n                  getW(wF, wR, wC, " + d24 + " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, zi = function(t780, e519, n383, r283) {
    void 0 === e519 && (e519 = !1), void 0 === n383 && (n383 = null), void 0 === r283 && (r283 = !1), this.variableNames = [
        "x",
        "W"
    ], this.outputShape = t780.outShape;
    var o184 = t780.inHeight, a133 = t780.inWidth, i94 = t780.padInfo.top, s79 = t780.padInfo.left, u59 = t780.strideHeight, c44 = t780.strideWidth, l35 = t780.dilationHeight, h34 = t780.dilationWidth, f30 = t780.filterHeight, d25 = t780.filterWidth, p25 = t780.outChannels / t780.inChannels, v20 = "", g17 = "";
    n383 && (v20 = r283 ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n383 + "\n        }" : "\n          float activation(float x) {\n            " + n383 + "\n          }\n        ", g17 = "result = activation(result);");
    var m14 = e519 ? "result += getBiasAtOutCoords();" : "";
    e519 && this.variableNames.push("bias"), r283 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + v20 + "\n\n      const ivec2 strides = ivec2(" + u59 + ", " + c44 + ");\n      const ivec2 pads = ivec2(" + i94 + ", " + s79 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + p25 + ";\n        int q = d2 - d1 * " + p25 + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + f30 + "; wR++) {\n          int xR = xRCorner + wR * " + l35 + ";\n\n          if (xR < 0 || xR >= " + o184 + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + d25 + "; wC++) {\n            int xC = xCCorner + wC * " + h34 + ";\n\n            if (xC < 0 || xC >= " + a133 + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        " + m14 + "\n        " + g17 + "\n        setOutput(result);\n      }\n    ";
}, Gi = function(t781, e520, n384, r284) {
    void 0 === e520 && (e520 = !1), void 0 === n384 && (n384 = null), void 0 === r284 && (r284 = !1), this.variableNames = [
        "x",
        "W"
    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t781.outShape;
    for(var o185 = t781.inHeight, a134 = t781.inWidth, i95 = t781.padInfo.top, s80 = t781.padInfo.left, u60 = t781.strideHeight, c45 = t781.strideWidth, l36 = t781.dilationHeight, h35 = t781.dilationWidth, f31 = t781.filterHeight, d26 = t781.filterWidth, p26 = d26, v21 = "int xR; int xC; int xCOffset;", g18 = 0; g18 < f31; g18++)for(var m15 = 0; m15 < d26; m15++)v21 += "\n          vec4 xTexelR" + g18 + "C" + 2 * m15 + " = vec4(0.);\n          vec4 wR" + g18 + "C" + m15 + " = vec4(0.);\n          vec4 xR" + g18 + "C" + m15 + " = vec4(0.);";
    for(g18 = 0; g18 < f31; g18++)for(var y10 = 0; y10 < p26; y10++){
        if (v21 += "\n          xR = xRCorner + " + g18 * l36 + ";\n          xC = xCCorner + " + (m15 = 2 * y10) * h35 + ";\n        ", 1 === c45) {
            if (m15 < d26 && (v21 += s80 % 2 == 1 ? "\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < " + o185 + " && xCOffset >= 0 && xCOffset < " + a134 + ") {\n                  xTexelR" + g18 + "C" + m15 + " = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= " + a134 + ") {\n                    xTexelR" + g18 + "C" + m15 + ".zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR" + g18 + "C" + m15 + " = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < " + o185 + " && xCOffset >= 0 && xCOffset < " + a134 + ") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= " + a134 + ") {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR" + g18 + "C" + m15 + " = vec4(previous.zw, xTexelR" + g18 + "C" + m15 + ".xy);\n                } else {\n                  xR" + g18 + "C" + m15 + " = vec4(0, 0, xTexelR" + g18 + "C" + m15 + ".xy);\n                }\n              " : "\n                if(xR >= 0 && xR < " + o185 + " && xC >= 0 && xC < " + a134 + ") {\n                  xTexelR" + g18 + "C" + m15 + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + g18 + "C" + m15 + " = vec4(0.);\n                }\n\n                xR" + g18 + "C" + m15 + " = xTexelR" + g18 + "C" + m15 + ";\n              ", m15 + 1 < d26)) {
                var x10 = s80 % 2 == 0 ? b(h35) : h35;
                h35 % 2 == 0 && s80 % 2 == 1 || h35 % 2 != 0 && s80 % 2 != 1 ? (v21 += "\n                  xCOffset = xC + " + s80 % 2 + " + " + x10 + ";\n\n                  if(xR >= 0 && xR < " + o185 + " &&\n                    xCOffset >= 0 && xCOffset < " + a134 + ") {\n                    xTexelR" + g18 + "C" + (m15 + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n                ", h35 > 1 && (v21 += "\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < " + o185 + " &&\n                      xCOffset >= 0 && xCOffset < " + a134 + ") {\n                      xTexelR" + g18 + "C" + m15 + " = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR" + g18 + "C" + m15 + " = vec4(0.);\n                    }\n                  "), v21 += "\n                  xR" + g18 + "C" + (m15 + 1) + " = vec4(\n                    xTexelR" + g18 + "C" + m15 + ".zw, xTexelR" + g18 + "C" + (m15 + 2) + ".xy);\n                ") : v21 += "\n                  xCOffset = xC + " + x10 + ";\n\n                  if(xR >= 0 && xR < " + o185 + " &&\n                    xCOffset >= 0 && xCOffset < " + a134 + ") {\n                    xTexelR" + g18 + "C" + (m15 + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR" + g18 + "C" + (m15 + 1) + " = xTexelR" + g18 + "C" + (m15 + 2) + ";\n                ";
            }
        } else m15 < d26 && (v21 += "\n              if(xR >= 0 && xR < " + o185 + ") {\n            ", s80 % 2 == 1 ? (v21 += "\n                xCOffset = xC + 1 - " + c45 + ";\n                if(xCOffset >= 0 && xCOffset < " + a134 + ") {\n                  xTexelR" + g18 + "C" + m15 + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + g18 + "C" + m15 + " = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < " + a134 + ") {\n                  xTexelR" + g18 + "C" + (m15 + 2) + " = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR" + g18 + "C" + (m15 + 2) + " = vec4(0.);\n                }\n\n                xR" + g18 + "C" + m15 + " = vec4(\n                  xTexelR" + g18 + "C" + m15 + ".zw, xTexelR" + g18 + "C" + (m15 + 2) + ".zw);\n              ", m15 + 1 < d26 && (v21 += "\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + " + c45 + ";\n                  if(xCOffset >= 0 && xCOffset < " + a134 + ") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR" + g18 + "C" + (m15 + 1) + " = vec4(xTexelR" + g18 + "C" + (m15 + 2) + ".xy, final.xy);\n                ")) : (v21 += "\n                if(xC >= 0 && xC < " + a134 + ") {\n                  xTexelR" + g18 + "C" + m15 + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + g18 + "C" + m15 + " = vec4(0.);\n                }\n\n                xCOffset = xC + " + c45 + ";\n                if(xCOffset >= 0 && xCOffset < " + a134 + ") {\n                  xTexelR" + g18 + "C" + (m15 + 2) + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + g18 + "C" + (m15 + 2) + " = vec4(0.);\n                }\n\n                xR" + g18 + "C" + m15 + " = vec4(\n                  xTexelR" + g18 + "C" + m15 + ".xy, xTexelR" + g18 + "C" + (m15 + 2) + ".xy);\n              ", m15 + 1 < d26 && (v21 += "\n                  xR" + g18 + "C" + (m15 + 1) + " = vec4(\n                    xTexelR" + g18 + "C" + m15 + ".zw, xTexelR" + g18 + "C" + (m15 + 2) + ".zw);\n                ")), v21 += "}");
        m15 < d26 && (v21 += "\n            vec4 wTexelR" + g18 + "C" + m15 + " = getW(" + g18 + ", " + m15 + ", d1, q);\n            wR" + g18 + "C" + m15 + " = vec4(wTexelR" + g18 + "C" + m15 + ".xz, wTexelR" + g18 + "C" + m15 + ".xz);\n          ", m15 + 1 < d26 && (v21 += "\n              vec4 wTexelR" + g18 + "C" + (m15 + 1) + " = getW(" + g18 + ", " + (m15 + 1) + ", d1, q);\n              wR" + g18 + "C" + (m15 + 1) + " =\n                vec4(wTexelR" + g18 + "C" + (m15 + 1) + ".xz, wTexelR" + g18 + "C" + (m15 + 1) + ".xz);"));
    }
    for(g18 = 0; g18 < f31; g18++)for(m15 = 0; m15 < d26; m15++)v21 += "dotProd += xR" + g18 + "C" + m15 + " * wR" + g18 + "C" + m15 + ";";
    var w6 = "", C1 = "";
    n384 && (w6 = r284 ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + n384 + "\n        }" : "vec4 activation(vec4 x) {\n          " + n384 + "\n        }", C1 = "result = activation(result);");
    var E5 = e520 ? "result += getBiasAtOutCoords();" : "";
    e520 && this.variableNames.push("bias"), r284 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + w6 + "\n\n      const ivec2 strides = ivec2(" + u60 + ", " + c45 + ");\n      const ivec2 pads = ivec2(" + i95 + ", " + s80 + ");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        " + v21 + "\n\n        vec4 result = dotProd;\n        " + E5 + "\n        " + C1 + "\n        setOutput(result);\n      }\n    ";
}, Hi = function(t782, e521, n385, r285, o186) {
    this.variableNames = [
        "Image",
        "Boxes",
        "BoxInd"
    ], this.outputShape = [];
    var a135 = t782[0], i96 = t782[1], s81 = t782[2], u61 = t782[3], c46 = e521[0], l37 = n385[0], h36 = n385[1];
    this.outputShape = [
        c46,
        l37,
        h36,
        u61
    ];
    var f32 = "bilinear" === r285 ? 1 : 0, d27 = [
        i96 - 1 + ".0",
        s81 - 1 + ".0"
    ], p27 = d27[0], v22 = d27[1], g19 = l37 > 1 ? [
        "" + (i96 - 1) / (l37 - 1),
        "(y2-y1) * height_ratio",
        "y1*" + p27 + " + float(y)*(height_scale)"
    ] : [
        "0.0",
        "0.0",
        "0.5 * (y1+y2) * " + p27
    ], m16 = g19[0], y11 = g19[1], x11 = g19[2], b7 = h36 > 1 ? [
        "" + (s81 - 1) / (h36 - 1),
        "(x2-x1) * width_ratio",
        "x1*" + v22 + " + float(x)*(width_scale)"
    ] : [
        "0.0",
        "0.0",
        "0.5 * (x1+x2) * " + v22
    ], w7 = b7[0], C2 = b7[1], E6 = b7[2];
    this.userCode = "\n      const float height_ratio = float(" + m16 + ");\n      const float width_ratio = float(" + w7 + ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= " + a135 + ") {\n          return;\n        }\n\n        float height_scale = " + y11 + ";\n        float width_scale = " + C2 + ";\n\n        float in_y = " + x11 + ";\n        if( in_y < 0.0 || in_y > " + p27 + " ) {\n          setOutput(float(" + o186 + "));\n          return;\n        }\n        float in_x = " + E6 + ";\n        if( in_x < 0.0 || in_x > " + v22 + " ) {\n          setOutput(float(" + o186 + "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(" + f32 + " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ";
}, qi = function(t783, e522, n386) {
    this.variableNames = [
        "x"
    ], this.outputShape = t783;
    var r286 = t783.length, o187 = t783[t783.length - 1], a136 = n386 ? "<" : ">";
    this.userCode = "\n      int getIndex(int i) {\n        " + (n386 ? "return " + o187 + " -i - 1;" : "return i;") + "\n      }\n\n      void main() {\n        " + ui(r286) + " coords = getOutputCoords();\n        int end = " + Ki(r286, "coords") + ";\n        float val = 0.0;\n        for (int i = " + o187 + " - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx " + a136 + " end) {\n            continue;\n          }\n          if (idx == end && " + e522 + ") {\n            continue;\n          }\n          " + Ki(r286, "coords") + " = idx;\n          val += getX(" + (function(t784, e523) {
        if (1 === t784) return "" + e523;
        if (2 === t784) return e523 + ".x, " + e523 + ".y";
        if (3 === t784) return e523 + ".x, " + e523 + ".y, " + e523 + ".z";
        if (4 === t784) return e523 + ".x, " + e523 + ".y, " + e523 + ".z, " + e523 + ".w";
        throw Error("Cumulative sum for rank " + t784 + " is not yet supported");
    })(r286, "coords") + ");\n        }\n        setOutput(val);\n      }\n    ";
};
function Ki(t785, e524) {
    if (1 === t785) return "" + e524;
    if (2 === t785) return e524 + ".y";
    if (3 === t785) return e524 + ".z";
    if (4 === t785) return e524 + ".w";
    throw Error("Cumulative sum for rank " + t785 + " is not yet supported");
}
var ji = function(t786) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = Vt.DENSE;
    var e525 = Yt(t786), n387 = Ya();
    this.outputShape = t786, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + $a([
        "r",
        "c",
        "d"
    ], t786) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e525[0] + ", " + e525[1] + "));\n        int index = 4 * (resTexRC.x * " + e525[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        " + n387.output + " = result;\n      }\n    ";
}, Xi = function(t787) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = Vt.DENSE;
    var e526 = Yt(t787), n388 = Ya();
    this.outputShape = t787, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + $a([
        "r",
        "c",
        "d"
    ], t787) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e526[0] + ", " + e526[1] + "));\n        int index = 4 * (resTexRC.x * " + e526[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        " + n388.output + " = result;\n      }\n    ";
}, Yi = function() {
    function t788(t789, e527, n389) {
        this.variableNames = [
            "x"
        ], this.outputShape = [], this.outputShape = t789, this.blockSize = e527, this.dataFormat = n389, this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = " + this.getHeightCoordString() + ";\n      int w = " + this.getWidthCoordString() + ";\n      int d = " + this.getDepthCoordString() + ";\n\n      int in_h = h / " + e527 + ";\n      int offset_h = imod(h, " + e527 + ");\n      int in_w = w / " + e527 + ";\n      int offset_w = imod(w, " + e527 + ");\n      int offset_d = (offset_h * " + e527 + " + offset_w) *\n        " + this.getOutputDepthSize() + ";\n      int in_d = d + offset_d;\n\n      float result = " + this.getInputSamplingString() + ";\n      setOutput(result);\n    }\n  ";
    }
    return t788.prototype.getHeightCoordString = function() {
        return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]";
    }, t788.prototype.getWidthCoordString = function() {
        return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]";
    }, t788.prototype.getDepthCoordString = function() {
        return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]";
    }, t788.prototype.getOutputDepthSize = function() {
        return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];
    }, t788.prototype.getInputSamplingString = function() {
        return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
    }, t788;
}(), $i = function(t790) {
    this.variableNames = [
        "X"
    ], this.outputShape = [
        t790,
        t790
    ], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    ";
}, Qi = function(t791) {
    this.variableNames = [
        "A"
    ], this.outTexUsage = zt.DOWNLOAD;
    var e528 = Ya();
    this.outputShape = t791, this.userCode = "\n      " + Ja + "\n\n      void main() {\n        float x = getAAtOutCoords();\n        " + e528.output + " = encode_float(x);\n      }\n    ";
}, Ji = function(t792) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = zt.DOWNLOAD;
    var e529 = Ya();
    this.outputShape = t792, this.userCode = "\n      " + Ja + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        " + e529.output + " = encode_float(x);\n      }\n    ";
}, Zi = function(t793, e530, n390) {
    void 0 === n390 && (n390 = !1), this.variableNames = [
        "A"
    ];
    var r287 = Ya(), o188 = e530[0], a137 = e530[1];
    this.outputShape = t793;
    var i97 = "result";
    n390 && (i97 = "floor(result * 255. + 0.5)"), this.userCode = "\n      " + Qa(t793) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / " + a137 + ";\n        int c = imod(flatIndex, " + a137 + ");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(" + a137 + ".0, " + o188 + ".0);\n        vec4 values = " + r287.texture2D + "(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        " + r287.output + " = vec4(" + i97 + ", 0., 0., 0.);\n      }\n    ";
}, ts = function(t794, e531, n391) {
    void 0 === n391 && (n391 = !1), this.variableNames = [
        "A"
    ], this.packedInputs = !1, this.packedOutput = !0;
    var r288 = Ya(), o189 = e531[0], a138 = e531[1];
    this.outputShape = t794;
    var i98 = "", s82 = "result";
    n391 && (s82 = "floor(result * 255. + 0.5)");
    for(var u62 = 0; u62 <= 1; u62++)for(var c47 = 0; c47 <= 1; c47++){
        var l38 = 2 * u62 + c47;
        i98 += "\n          localCoords = coords;\n          if(localCoords[2] + " + c47 + " < " + t794[2] + ") {\n            localCoords[2] += " + c47 + ";\n            if(localCoords[1] + " + u62 + " < " + t794[1] + ") {\n              localCoords[1] += " + u62 + ";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / " + a138 + ";\n              c = imod(flatIndex, " + a138 + ");\n              uv = (vec2(c, r) + halfCR) / vec2(" + a138 + ".0, " + o189 + ".0);\n              values = " + r288.texture2D + "(A, uv);\n\n              if(offset == 0) {\n                result[" + l38 + "] = values[0];\n              } else if(offset == 1) {\n                result[" + l38 + "] = values[1];\n              } else if(offset == 2) {\n                result[" + l38 + "] = values[2];\n              } else {\n                result[" + l38 + "] = values[3];\n              }\n            }\n          }\n        ";
    }
    this.userCode = "\n      " + Qa(t794) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        " + i98 + "\n\n        " + r288.output + " = " + s82 + ";\n      }\n    ";
}, es = "return real * expR - imag * expI;", ns = "return real * expI + imag * expR;", rs = function(t795, e532, n392) {
    this.variableNames = [
        "real",
        "imag"
    ];
    var r289 = e532[1];
    this.outputShape = e532;
    var o190 = n392 ? "2.0 * " + Math.PI : "-2.0 * " + Math.PI, a139 = n392 ? r289 + ".0" : "1.0";
    this.userCode = "\n      const float exponentMultiplier = " + o190 + ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        " + t795 + "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(" + r289 + ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < " + r289 + "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / " + a139 + ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ";
}, os = function() {
    function t796(t797, e) {
        this.outputShape = [], this.variableNames = [
            "x"
        ], this.outputShape = t797, this.userCode = "\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ";
    }
    return t796.prototype.getCustomSetupFunc = function(t798) {
        var e533 = this;
        return function(n393, r290) {
            null == e533.valueLoc && (e533.valueLoc = n393.getUniformLocationNoThrow(r290, "value")), n393.gl.uniform1f(e533.valueLoc, t798);
        };
    }, t796;
}(), as = function(t799, e534, n394) {
    this.variableNames = [
        "A",
        "indices"
    ];
    var r291 = t799.slice();
    r291[n394] = e534, this.outputShape = r291, this.rank = r291.length;
    var o191 = ui(this.rank), a140 = function(t800, e535) {
        var n395 = t800.length;
        if (n395 > 4) throw Error("Gather for rank " + n395 + " is not yet supported");
        if (1 === n395) return "int(getIndices(resRC))";
        for(var r292 = [
            "resRC.x",
            "resRC.y",
            "resRC.z",
            "resRC.w"
        ], o192 = [], a141 = 0; a141 < t800.length; a141++)a141 === e535 ? o192.push("int(getIndices(" + r292[a141] + "))") : o192.push("" + r292[a141]);
        return o192.join();
    }(t799, n394);
    this.userCode = "\n      void main() {\n        " + o191 + " resRC = getOutputCoords();\n        setOutput(getA(" + a140 + "));\n      }\n    ";
};
var is = function(t801, e536, n396) {
    this.sliceDim = t801, this.strides = e536, this.variableNames = [
        "x",
        "indices"
    ], this.outputShape = n396;
    var r293 = ui(e536.length), o193 = ui(n396.length), a142 = this.sliceDim > 1 ? "strides[j]" : "strides";
    this.userCode = "\n        " + r293 + " strides = " + r293 + "(" + this.strides + ");\n         void main() {\n          " + o193 + " coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < " + this.sliceDim + "; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * " + a142 + ";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      ";
};
function ss(t802, e537) {
    var n397 = Ya();
    return oe(t802, e537, n397.version + "\n    precision highp float;\n    " + n397.attribute + " vec3 clipSpacePos;\n    " + n397.attribute + " vec2 uv;\n    " + n397.varyingVs + " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }");
}
function us(t803, e538) {
    return fe(t803, e538, new Float32Array([
        -1,
        1,
        0,
        0,
        1,
        -1,
        -1,
        0,
        0,
        0,
        1,
        1,
        0,
        1,
        1,
        1,
        -1,
        0,
        1,
        0
    ]));
}
function cs(t804, e539) {
    return de(t804, e539, new Uint16Array([
        0,
        1,
        2,
        2,
        1,
        3
    ]));
}
function ls(t805, e540, n398, r294, o194, a143, i99) {
    ve(n398, r294);
    var s83 = pe(t805, e540), u63 = t805.TEXTURE_2D;
    return Jt(t805, e540, function() {
        return t805.bindTexture(u63, s83);
    }), Jt(t805, e540, function() {
        return t805.texParameteri(u63, t805.TEXTURE_WRAP_S, t805.CLAMP_TO_EDGE);
    }), Jt(t805, e540, function() {
        return t805.texParameteri(u63, t805.TEXTURE_WRAP_T, t805.CLAMP_TO_EDGE);
    }), Jt(t805, e540, function() {
        return t805.texParameteri(u63, t805.TEXTURE_MIN_FILTER, t805.NEAREST);
    }), Jt(t805, e540, function() {
        return t805.texParameteri(u63, t805.TEXTURE_MAG_FILTER, t805.NEAREST);
    }), Jt(t805, e540, function() {
        return t805.texImage2D(u63, 0, o194, n398, r294, 0, a143, i99, null);
    }), Jt(t805, e540, function() {
        return t805.bindTexture(t805.TEXTURE_2D, null);
    }), s83;
}
function hs(t806, e541, n399, r295, o195) {
    var a144 = Xt(n399, r295);
    return ls(t806, e541, a144[0], a144[1], o195.internalFormatFloat, o195.textureFormatFloat, t806.FLOAT);
}
function fs(t807, e542, n400, r296, o196) {
    var a145 = Xt(n400, r296);
    return ls(t807, e542, a145[0], a145[1], o196.internalFormatHalfFloat, o196.textureFormatFloat, o196.textureTypeHalfFloat);
}
function ds(t808, e543, n401, r297, o) {
    var a146 = Xt(n401, r297);
    return ls(t808, e543, a146[0], a146[1], t808.RGBA, t808.RGBA, t808.UNSIGNED_BYTE);
}
function ps(t809, e544, n402, r298, o197) {
    var a147 = $t(n402, r298);
    return ls(t809, e544, a147[0], a147[1], o197.internalFormatPackedFloat, t809.RGBA, t809.FLOAT);
}
function vs(t810, e545, n403, r299, o198) {
    var a148 = $t(n403, r299);
    return ls(t810, e545, a148[0], a148[1], o198.internalFormatPackedHalfFloat, t810.RGBA, o198.textureTypeHalfFloat);
}
function gs(t811, e546, n404, r300) {
    return Jt(t811, e546, function() {
        return t811.bindBuffer(t811.ARRAY_BUFFER, r300);
    }), me(t811, e546, n404, "clipSpacePos", r300, 3, 20, 0) && me(t811, e546, n404, "uv", r300, 2, 20, 12);
}
function ms(t812, e547, n405, r301, o199, a149, i100) {
    var s84, u64, c48;
    Jt(t812, e547, function() {
        return t812.bindTexture(t812.TEXTURE_2D, n405);
    }), a149 instanceof Uint8Array ? (s84 = new Uint8Array(r301 * o199 * 4), u64 = t812.UNSIGNED_BYTE, c48 = t812.RGBA) : (s84 = new Float32Array(r301 * o199 * 4), u64 = t812.FLOAT, c48 = i100.internalFormatPackedFloat), s84.set(a149), Jt(t812, e547, function() {
        return t812.texImage2D(t812.TEXTURE_2D, 0, c48, r301, o199, 0, t812.RGBA, u64, s84);
    }), Jt(t812, e547, function() {
        return t812.bindTexture(t812.TEXTURE_2D, null);
    });
}
function ys(t813, e548, n406, r302) {
    Jt(t813, e548, function() {
        return t813.bindTexture(t813.TEXTURE_2D, n406);
    }), r302.data instanceof Uint8Array ? Jt(t813, e548, function() {
        return t813.texImage2D(t813.TEXTURE_2D, 0, t813.RGBA, r302.width, r302.height, 0, t813.RGBA, t813.UNSIGNED_BYTE, r302.data);
    }) : Jt(t813, e548, function() {
        return t813.texImage2D(t813.TEXTURE_2D, 0, t813.RGBA, t813.RGBA, t813.UNSIGNED_BYTE, r302);
    }), Jt(t813, e548, function() {
        return t813.bindTexture(t813.TEXTURE_2D, null);
    });
}
function xs(t814, e549, n407, r303, o) {
    var a150 = t814.createBuffer();
    Jt(t814, e549, function() {
        return t814.bindBuffer(t814.PIXEL_PACK_BUFFER, a150);
    });
    var i101 = 16 * n407 * r303;
    return Jt(t814, e549, function() {
        return t814.bufferData(t814.PIXEL_PACK_BUFFER, i101, t814.STREAM_READ);
    }), Jt(t814, e549, function() {
        return t814.readPixels(0, 0, r303, n407, t814.RGBA, t814.FLOAT, 0);
    }), Jt(t814, e549, function() {
        return t814.bindBuffer(t814.PIXEL_PACK_BUFFER, null);
    }), a150;
}
function bs(t815, e550, n408) {
    var r304 = t815, o200 = new Float32Array(n408);
    return r304.bindBuffer(r304.PIXEL_PACK_BUFFER, e550), r304.getBufferSubData(r304.PIXEL_PACK_BUFFER, 0, o200), r304.bindBuffer(r304.PIXEL_PACK_BUFFER, null), o200;
}
function ws(t816, e551, n409, r305, o201) {
    var a151 = Xt(n409, r305), i102 = a151[0], s85 = a151[1], u65 = new Uint8Array(n409 * r305 * 4);
    return Jt(t816, e551, function() {
        return t816.readPixels(0, 0, i102, s85, o201.downloadTextureFormat, t816.UNSIGNED_BYTE, u65);
    }), new Float32Array(u65.buffer);
}
function Cs(t817, e552, n410, r, o, a152, i103, s) {
    var u66 = t817, c49 = new Float32Array(function(t818, e553) {
        var n411 = $t(t818, e553);
        return n411[0] * n411[1] * 4;
    }(a152, i103));
    return u66.bindBuffer(u66.PIXEL_PACK_BUFFER, e552), u66.getBufferSubData(u66.PIXEL_PACK_BUFFER, 0, c49), u66.bindBuffer(u66.PIXEL_PACK_BUFFER, null), c49;
}
function Es(t819, e554, n412, r306) {
    var o202 = new Float32Array(n412 * r306 * 4);
    return Jt(t819, e554, function() {
        return t819.readPixels(0, 0, r306, n412, t819.RGBA, t819.FLOAT, o202);
    }), o202;
}
var Rs = Object.freeze({
    createVertexShader: ss,
    createVertexBuffer: us,
    createIndexBuffer: cs,
    createFloat32MatrixTexture: hs,
    createFloat16MatrixTexture: fs,
    createUnsignedBytesMatrixTexture: ds,
    createPackedMatrixTexture: ps,
    createFloat16PackedMatrixTexture: vs,
    bindVertexProgramAttributeStreams: gs,
    uploadDenseMatrixToTexture: ms,
    uploadPixelDataToTexture: ys,
    createBufferFromOutputTexture: xs,
    downloadFloat32MatrixFromBuffer: bs,
    downloadByteEncodedFloatMatrixFromOutputTexture: ws,
    downloadPackedMatrixFromBuffer: Cs,
    downloadMatrixFromPackedOutputTexture: Es
}), Is = function() {
    function t820(t821) {
        this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];
        var e555 = i().getNumber("WEBGL_VERSION");
        null != t821 ? (this.gl = t821, Kt(e555, t821)) : this.gl = jt(e555);
        var n413 = "WEBGL_color_buffer_float";
        if (1 === i().getNumber("WEBGL_VERSION")) {
            if (this.textureFloatExtension = re(this.gl, this.debug, "OES_texture_float"), Pe(this.gl, "OES_texture_half_float")) this.textureHalfFloatExtension = re(this.gl, this.debug, "OES_texture_half_float");
            else if (i().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
            if (this.colorBufferFloatExtension = this.gl.getExtension(n413), Pe(this.gl, "EXT_color_buffer_half_float")) this.colorBufferHalfFloatExtension = re(this.gl, this.debug, "EXT_color_buffer_half_float");
            else if (i().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
        } else if (n413 = "EXT_color_buffer_float", Pe(this.gl, n413)) this.colorBufferFloatExtension = this.gl.getExtension(n413);
        else {
            if (!Pe(this.gl, "EXT_color_buffer_half_float")) throw new Error("GL context does not support color renderable floats");
            this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float");
        }
        this.vertexBuffer = us(this.gl, this.debug), this.indexBuffer = cs(this.gl, this.debug), this.framebuffer = ge(this.gl, this.debug), this.textureConfig = Qt(this.gl, this.textureHalfFloatExtension);
    }
    return Object.defineProperty(t820.prototype, "debug", {
        get: function() {
            return i().getBool("DEBUG");
        },
        enumerable: !0,
        configurable: !0
    }), t820.prototype.dispose = function() {
        var t822 = this;
        if (!this.disposed) {
            null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
            var e556 = this.gl;
            Jt(e556, this.debug, function() {
                return e556.finish();
            }), Jt(e556, this.debug, function() {
                return e556.bindFramebuffer(e556.FRAMEBUFFER, null);
            }), Jt(e556, this.debug, function() {
                return e556.deleteFramebuffer(t822.framebuffer);
            }), Jt(e556, this.debug, function() {
                return e556.bindBuffer(e556.ARRAY_BUFFER, null);
            }), Jt(e556, this.debug, function() {
                return e556.bindBuffer(e556.ELEMENT_ARRAY_BUFFER, null);
            }), Jt(e556, this.debug, function() {
                return e556.deleteBuffer(t822.indexBuffer);
            }), this.disposed = !0;
        }
    }, t820.prototype.createFloat32MatrixTexture = function(t823, e557) {
        return this.throwIfDisposed(), hs(this.gl, this.debug, t823, e557, this.textureConfig);
    }, t820.prototype.createFloat16MatrixTexture = function(t824, e558) {
        return this.throwIfDisposed(), fs(this.gl, this.debug, t824, e558, this.textureConfig);
    }, t820.prototype.createUnsignedBytesMatrixTexture = function(t825, e559) {
        return this.throwIfDisposed(), ds(this.gl, this.debug, t825, e559, this.textureConfig);
    }, t820.prototype.uploadPixelDataToTexture = function(t826, e560) {
        this.throwIfDisposed(), ys(this.gl, this.debug, t826, e560);
    }, t820.prototype.uploadDenseMatrixToTexture = function(t827, e561, n414, r307) {
        this.throwIfDisposed(), ms(this.gl, this.debug, t827, e561, n414, r307, this.textureConfig);
    }, t820.prototype.createFloat16PackedMatrixTexture = function(t828, e562) {
        return this.throwIfDisposed(), vs(this.gl, this.debug, t828, e562, this.textureConfig);
    }, t820.prototype.createPackedMatrixTexture = function(t829, e563) {
        return this.throwIfDisposed(), ps(this.gl, this.debug, t829, e563, this.textureConfig);
    }, t820.prototype.deleteMatrixTexture = function(t830) {
        var e564 = this;
        this.throwIfDisposed(), this.outputTexture === t830 && (Ee(this.gl, this.debug, this.framebuffer), this.outputTexture = null), Jt(this.gl, this.debug, function() {
            return e564.gl.deleteTexture(t830);
        });
    }, t820.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function(t831, e565, n415) {
        var r308 = this;
        return this.downloadMatrixDriver(t831, function() {
            return ws(r308.gl, r308.debug, e565, n415, r308.textureConfig);
        });
    }, t820.prototype.downloadPackedMatrixFromBuffer = function(t832, e, n, r, o203, a153) {
        return Cs(this.gl, t832, 0, 0, 0, o203, a153, this.textureConfig);
    }, t820.prototype.downloadFloat32MatrixFromBuffer = function(t833, e566) {
        return bs(this.gl, t833, e566);
    }, t820.prototype.createBufferFromTexture = function(t834, e567, n416) {
        this.bindTextureToFrameBuffer(t834);
        var r309 = xs(this.gl, this.debug, e567, n416, this.textureConfig);
        return this.unbindTextureToFrameBuffer(), r309;
    }, t820.prototype.createAndWaitForFence = function() {
        var t835 = this.createFence(this.gl);
        return this.pollFence(t835);
    }, t820.prototype.createFence = function(t836) {
        var e568, n417, r310 = this;
        if (i().getBool("WEBGL_FENCE_API_ENABLED")) {
            var o204 = t836, a154 = o204.fenceSync(o204.SYNC_GPU_COMMANDS_COMPLETE, 0);
            t836.flush(), n417 = function() {
                var t837 = o204.clientWaitSync(a154, 0, 0);
                return t837 === o204.ALREADY_SIGNALED || t837 === o204.CONDITION_SATISFIED;
            }, e568 = a154;
        } else i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (e568 = this.beginQuery(), this.endQuery(), n417 = function() {
            return r310.isQueryAvailable(e568, i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
        }) : n417 = function() {
            return !0;
        };
        return {
            query: e568,
            isFencePassed: n417
        };
    }, t820.prototype.downloadMatrixFromPackedTexture = function(t838, e569, n418) {
        var r311 = this;
        return this.downloadMatrixDriver(t838, function() {
            return Es(r311.gl, r311.debug, e569, n418);
        });
    }, t820.prototype.createProgram = function(t839) {
        this.throwIfDisposed();
        var e570 = this.gl, n419 = ae(e570, this.debug, t839), r312 = ss(e570, this.debug), o205 = ce(e570, this.debug);
        return Jt(e570, this.debug, function() {
            return e570.attachShader(o205, r312);
        }), Jt(e570, this.debug, function() {
            return e570.attachShader(o205, n419);
        }), le(e570, this.debug, o205), this.debug && he(e570, this.debug, o205), this.vertexAttrsAreBound || (this.setProgram(o205), this.vertexAttrsAreBound = gs(e570, this.debug, this.program, this.vertexBuffer)), o205;
    }, t820.prototype.deleteProgram = function(t840) {
        var e571 = this;
        this.throwIfDisposed(), t840 === this.program && (this.program = null), null != t840 && Jt(this.gl, this.debug, function() {
            return e571.gl.deleteProgram(t840);
        });
    }, t820.prototype.setProgram = function(t841) {
        var e572 = this;
        this.throwIfDisposed(), this.program = t841, null != this.program && this.debug && he(this.gl, this.debug, this.program), Jt(this.gl, this.debug, function() {
            return e572.gl.useProgram(t841);
        });
    }, t820.prototype.getUniformLocation = function(t842, e573, n420) {
        return void 0 === n420 && (n420 = !0), this.throwIfDisposed(), n420 ? xe(this.gl, this.debug, t842, e573) : be(this.gl, t842, e573);
    }, t820.prototype.getAttributeLocation = function(t843, e574) {
        var n421 = this;
        return this.throwIfDisposed(), Jt(this.gl, this.debug, function() {
            return n421.gl.getAttribLocation(t843, e574);
        });
    }, t820.prototype.getUniformLocationNoThrow = function(t844, e575) {
        return this.throwIfDisposed(), this.gl.getUniformLocation(t844, e575);
    }, t820.prototype.setInputMatrixTexture = function(t845, e576, n422) {
        this.throwIfDisposed(), this.throwIfNoProgram(), we(this.gl, this.debug, this.program, t845, e576, n422);
    }, t820.prototype.setOutputMatrixTexture = function(t846, e577, n423) {
        this.setOutputMatrixTextureDriver(t846, n423, e577);
    }, t820.prototype.setOutputPackedMatrixTexture = function(t847, e578, n424) {
        this.throwIfDisposed();
        var r313 = $t(e578, n424), o206 = r313[0], a155 = r313[1];
        this.setOutputMatrixTextureDriver(t847, o206, a155);
    }, t820.prototype.setOutputMatrixWriteRegion = function(t848, e579, n425, r314) {
        this.setOutputMatrixWriteRegionDriver(n425, t848, r314, e579);
    }, t820.prototype.setOutputPackedMatrixWriteRegion = function(t, e, n, r) {
        throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
    }, t820.prototype.debugValidate = function() {
        null != this.program && he(this.gl, this.debug, this.program), Re(this.gl);
    }, t820.prototype.executeProgram = function() {
        this.throwIfDisposed(), this.throwIfNoProgram();
        var t849 = this.gl;
        this.debug && this.debugValidate(), Jt(t849, this.debug, function() {
            return t849.drawElements(t849.TRIANGLES, 6, t849.UNSIGNED_SHORT, 0);
        });
    }, t820.prototype.blockUntilAllProgramsCompleted = function() {
        var t850 = this;
        this.throwIfDisposed(), Jt(this.gl, this.debug, function() {
            return t850.gl.finish();
        });
    }, t820.prototype.getQueryTimerExtension = function() {
        return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = re(this.gl, this.debug, 2 === i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
    }, t820.prototype.getQueryTimerExtensionWebGL2 = function() {
        return this.getQueryTimerExtension();
    }, t820.prototype.getQueryTimerExtensionWebGL1 = function() {
        return this.getQueryTimerExtension();
    }, t820.prototype.beginQuery = function() {
        if (2 === i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
            var t851 = this.gl, e580 = this.getQueryTimerExtensionWebGL2(), n426 = t851.createQuery();
            return t851.beginQuery(e580.TIME_ELAPSED_EXT, n426), n426;
        }
        var r315 = this.getQueryTimerExtensionWebGL1(), o207 = r315.createQueryEXT();
        return r315.beginQueryEXT(r315.TIME_ELAPSED_EXT, o207), o207;
    }, t820.prototype.endQuery = function() {
        if (2 !== i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
            var t852 = this.getQueryTimerExtensionWebGL1();
            t852.endQueryEXT(t852.TIME_ELAPSED_EXT);
        } else {
            var e581 = this.gl, n427 = this.getQueryTimerExtensionWebGL2();
            e581.endQuery(n427.TIME_ELAPSED_EXT);
        }
    }, t820.prototype.waitForQueryAndGetTime = function(t853) {
        return n(this, void 0, void 0, function() {
            var e582 = this;
            return r(this, function(n428) {
                switch(n428.label){
                    case 0:
                        return [
                            4,
                            F(function() {
                                return e582.disposed || e582.isQueryAvailable(t853, i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
                            })
                        ];
                    case 1:
                        return n428.sent(), [
                            2,
                            this.getQueryTime(t853, i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))
                        ];
                }
            });
        });
    }, t820.prototype.getQueryTime = function(t854, e583) {
        if (0 === e583) return null;
        if (2 === e583) {
            var n429 = this.gl;
            return n429.getQueryParameter(t854, n429.QUERY_RESULT) / 1000000;
        }
        var r316 = this.getQueryTimerExtensionWebGL1();
        return r316.getQueryObjectEXT(t854, r316.QUERY_RESULT_EXT) / 1000000;
    }, t820.prototype.isQueryAvailable = function(t855, e584) {
        if (0 === e584) return !0;
        if (2 === e584) {
            var n430 = this.gl, r317 = this.getQueryTimerExtensionWebGL2(), o208 = n430.getQueryParameter(t855, n430.QUERY_RESULT_AVAILABLE);
            return null == this.disjoint && (this.disjoint = this.gl.getParameter(r317.GPU_DISJOINT_EXT)), o208 && !this.disjoint;
        }
        o208 = (r317 = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t855, r317.QUERY_RESULT_AVAILABLE_EXT);
        return null == this.disjoint && (this.disjoint = this.gl.getParameter(r317.GPU_DISJOINT_EXT)), o208 && !this.disjoint;
    }, t820.prototype.pollFence = function(t856) {
        var e585 = this;
        return new Promise(function(n431) {
            e585.addItemToPoll(function() {
                return t856.isFencePassed();
            }, function() {
                return n431();
            });
        });
    }, t820.prototype.pollItems = function() {
        for(var t857 = function(t858) {
            for(var e587 = 0; e587 < t858.length; ++e587){
                if (!t858[e587]()) break;
            }
            return e587 - 1;
        }(this.itemsToPoll.map(function(t859) {
            return t859.isDoneFn;
        })), e586 = 0; e586 <= t857; ++e586)(0, this.itemsToPoll[e586].resolveFn)();
        this.itemsToPoll = this.itemsToPoll.slice(t857 + 1);
    }, t820.prototype.addItemToPoll = function(t860, e588) {
        var n432 = this;
        this.itemsToPoll.push({
            isDoneFn: t860,
            resolveFn: e588
        }), this.itemsToPoll.length > 1 || F(function() {
            return n432.pollItems(), 0 === n432.itemsToPoll.length;
        });
    }, t820.prototype.bindTextureToFrameBuffer = function(t861) {
        this.throwIfDisposed(), Ce(this.gl, this.debug, t861, this.framebuffer), this.debug && Re(this.gl);
    }, t820.prototype.unbindTextureToFrameBuffer = function() {
        null != this.outputTexture ? (Ce(this.gl, this.debug, this.outputTexture, this.framebuffer), this.debug && Re(this.gl)) : Ee(this.gl, this.debug, this.framebuffer);
    }, t820.prototype.downloadMatrixDriver = function(t862, e589) {
        this.bindTextureToFrameBuffer(t862);
        var n433 = e589();
        return this.unbindTextureToFrameBuffer(), n433;
    }, t820.prototype.setOutputMatrixTextureDriver = function(t863, e590, n434) {
        this.throwIfDisposed();
        var r318 = this.gl;
        Ce(r318, this.debug, t863, this.framebuffer), this.debug && Re(r318), this.outputTexture = t863, Jt(r318, this.debug, function() {
            return r318.viewport(0, 0, e590, n434);
        }), Jt(r318, this.debug, function() {
            return r318.scissor(0, 0, e590, n434);
        });
    }, t820.prototype.setOutputMatrixWriteRegionDriver = function(t864, e591, n435, r319) {
        var o209 = this;
        this.throwIfDisposed(), Jt(this.gl, this.debug, function() {
            return o209.gl.scissor(t864, e591, n435, r319);
        });
    }, t820.prototype.throwIfDisposed = function() {
        if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.");
    }, t820.prototype.throwIfNoProgram = function() {
        if (null == this.program) throw new Error("No GPU program is currently set.");
    }, t820;
}();
function ks(t865, e592) {
    if (t865.length !== e592.length) throw Error("Binary was compiled with " + t865.length + " inputs, but was executed with " + e592.length + " inputs");
    t865.forEach(function(t866, n) {
        var r320 = t866.logicalShape, o210 = e592[n], a156 = o210.shape;
        if (!S(r320, a156)) throw Error("Binary was compiled with different shapes than the current args. Shapes " + r320 + " and " + a156 + " must match");
        if (!t866.isUniform || !o210.isUniform) {
            var i104 = t866.texShape, s86 = o210.isUniform ? null : o210.texData.texShape;
            if (!S(i104, s86)) throw Error("Binary was compiled with different texture shapes than the current args. Shape " + i104 + " and " + s86 + " must match");
        }
    });
}
var Ss = function(t867, e593, n436) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t867;
    for(var r321 = n436.filterWidth, o211 = n436.inChannels, a157 = n436.strideWidth, i105 = n436.strideHeight, s87 = n436.padInfo, u67 = n436.outWidth, c50 = n436.dilationWidth, l39 = n436.dilationHeight, h37 = n436.dataFormat, f33 = s87.left, d28 = s87.top, p28 = o211 * r321, v23 = Ya(), g20 = "channelsLast" === h37, m = g20 ? 0 : 1, y = g20 ? 1 : 2, x12 = "", b8 = 0; b8 <= 1; b8++)for(var w8 = 0; w8 <= 1; w8++)x12 += "\n          blockIndex = rc.y + " + w8 + ";\n          pos = rc.x + " + b8 + ";\n\n          if(blockIndex < " + t867[1] + " && pos < " + t867[0] + ") {\n            offsetY = int(blockIndex / (" + u67 + ")) * " + i105 + " - " + d28 + ";\n            d0 = offsetY + " + l39 + " * (pos / " + p28 + ");\n\n            if(d0 < " + e593[m] + " && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), " + u67 + ".) * " + a157 + ". - " + f33 + ".);\n              d1 = offsetX + " + c50 + " * (int(mod(float(pos), " + p28 + ".) / " + o211 + ".));\n\n              if(d1 < " + e593[y] + " && d1 >= 0) {\n\n                ch = int(mod(float(pos), " + o211 + ".));\n\n                if (" + g20 + ") {\n                  innerDims = vec2(d1, ch);\n                  result[" + (2 * b8 + w8) + "] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[" + (2 * b8 + w8) + "] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";
    this.userCode = "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        " + x12 + "\n\n        " + v23.output + " = result;\n      }\n    ";
}, As = function(t868, e594, n437, r322, o212) {
    this.variableNames = [
        "x"
    ], this.outputShape = [];
    var a158, i106 = e594, s88 = t868[3] - 1;
    this.outputShape = t868;
    var u68 = "float(" + n437 + ") + float(" + r322 + ") * sum";
    a158 = 0.5 === o212 ? "inversesqrt(" + u68 + ")" : 1 === o212 ? "1.0/(" + u68 + ")" : "exp(log(" + u68 + ") * float(-" + o212 + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" + i106 + "; j <= " + i106 + "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " + s88 + ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " + a158 + ";\n        setOutput(val);\n      }\n    ";
}, Ts = function(t869, e595, n438, r323, o213) {
    this.variableNames = [
        "inputImage",
        "outputImage",
        "dy"
    ], this.outputShape = [], this.outputShape = t869, this.depth = t869[3], this.depthRadius = e595, this.bias = n438, this.alpha = r323, this.beta = o213, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < " + this.depth + "; ++d) {\n          int depthBegin = int(max(0.0, float(d - " + e595 + ")));\n          int depthEnd = int(min(float(" + this.depth + "),\n              float(d + " + e595 + " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = " + this.depth + ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(" + r323 + ") * norm + float(" + n438 + ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(" + r323 + ")\n                * float(" + o213 + ")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * " + o213 + ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ";
}, Ds = function(t870, e596, n439, r324, o214) {
    this.variableNames = [
        "x"
    ], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;
    var a159, i107 = e596, s89 = t870[3] - 1;
    this.outputShape = t870;
    var u69 = "float(" + n439 + ") + float(" + r324 + ") * sum";
    a159 = 0.5 === o214 ? "inversesqrt(" + u69 + ")" : 1 === o214 ? "1.0/(" + u69 + ")" : "exp(log(" + u69 + ") * float(-" + o214 + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < " + this.outputShape[3] + ";\n        bool hasNextRow = c < " + this.outputShape[2] + ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - " + i107 + ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - " + i107 + "; j <= " + i107 + "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(" + s89 + "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * " + a159 + ";\n        setOutput(result);\n      }\n    ";
}, Ns = function(t871) {
    this.variableNames = [
        "dy",
        "maxPos"
    ], this.outputShape = t871.inShape;
    var e597 = t871.strideHeight, n440 = t871.strideWidth, r325 = t871.dilationHeight, o215 = t871.effectiveFilterHeight, a160 = t871.effectiveFilterWidth, i108 = o215 - 1 - t871.padInfo.top, s90 = a160 - 1 - t871.padInfo.left, u70 = o215 * a160 - 1;
    this.userCode = "\n      const ivec2 pads = ivec2(" + i108 + ", " + s90 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + o215 + ";\n          wR += " + r325 + ") {\n          float dyR = float(dyRCorner + wR) / " + e597 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t871.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + a160 + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + n440 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t871.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + u70 + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + a160 + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, Fs = function(t872) {
    this.variableNames = [
        "dy",
        "maxPos"
    ], this.outputShape = t872.inShape;
    var e598 = t872.strideDepth, n441 = t872.strideHeight, r326 = t872.strideWidth, o216 = t872.dilationDepth, a161 = t872.dilationHeight, i109 = t872.dilationWidth, s91 = t872.effectiveFilterDepth, u71 = t872.effectiveFilterHeight, c51 = t872.effectiveFilterWidth, l40 = s91 - 1 - t872.padInfo.front, h38 = u71 - 1 - t872.padInfo.top, f34 = c51 - 1 - t872.padInfo.left, d29 = s91 * u71 * c51 - 1;
    this.userCode = "\n      const ivec3 pads = ivec3(" + l40 + ", " + h38 + ", " + f34 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + s91 + ";\n           wD += " + o216 + ") {\n          float dyD = float(dyDCorner + wD) / " + e598 + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t872.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + u71 + ";\n              wR += " + a161 + ") {\n            float dyR = float(dyRCorner + wR) / " + n441 + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t872.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + c51 + ";\n                wC += " + i109 + ") {\n              float dyC = float(dyCCorner + wC) / " + r326 + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t872.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = " + d29 + " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * " + u71 + " * " + c51 + " +\n                  wR * " + c51 + " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
}, _s = function(t873, e599, n442, r327, o217, a162, i110) {
    void 0 === n442 && (n442 = !1), void 0 === r327 && (r327 = !1), void 0 === o217 && (o217 = !1), void 0 === a162 && (a162 = null), void 0 === i110 && (i110 = !1), this.variableNames = [
        "matrixA",
        "matrixB"
    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e599;
    var s92 = n442 ? t873[1] : t873[2], u72 = Math.ceil(s92 / 2), c52 = n442 ? "i * 2, rc.y" : "rc.y, i * 2", l41 = r327 ? "rc.z, i * 2" : "i * 2, rc.z", h39 = n442 ? [
        "a.xxyy",
        "a.zzww"
    ] : [
        "a.xxzz",
        "a.yyww"
    ], f35 = r327 ? [
        "b.xzxz",
        "b.ywyw"
    ] : [
        "b.xyxy",
        "b.zwzw"
    ], d30 = "", p29 = "";
    a162 && (d30 = i110 ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + a162 + "\n        }" : "vec4 activation(vec4 x) {\n          " + a162 + "\n        }", p29 = "result = activation(result);");
    var v24 = o217 ? "result += getBiasAtOutCoords();" : "";
    o217 && this.variableNames.push("bias"), i110 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + d30 + "\n\n      const float sharedDimension = " + u72 + ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < " + u72 + "; i++) {\n          vec4 a = getMatrixA(rc.x, " + c52 + ");\n          vec4 b = getMatrixB(rc.x, " + l41 + ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (" + h39[0] + " * " + f35[0] + ");\n          result += (" + h39[1] + " * " + f35[1] + ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        " + v24 + "\n\n        " + p29 + "\n\n        setOutput(result);\n      }\n    ";
}, Os = function() {
    function t874(t875, e600, n443) {
        this.variableNames = [
            "probs"
        ], this.outputShape = [
            t875,
            n443
        ], this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (e600 - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (e600 - 1) + "));\n      }\n    ";
    }
    return t874.prototype.getCustomSetupFunc = function(t876) {
        var e601 = this;
        return function(n444, r328) {
            null == e601.seedLoc && (e601.seedLoc = n444.getUniformLocation(r328, "seed")), n444.gl.uniform1f(e601.seedLoc, t876);
        };
    }, t874;
}(), Ms = function(t877, e602, n445, r329) {
    this.variableNames = [
        "indices"
    ], this.outputShape = [
        t877,
        e602
    ], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + r329 + "), float(" + n445 + "),\n                      float(index == coords.y)));\n      }\n    ";
}, Bs = function(t878) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = t878;
    var e603 = t878.length;
    if (0 === e603) this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
    else {
        var n446 = Xa("rc", e603), r330 = ui(e603), o218 = function(t879, e604, n448) {
            if (1 === t879) return "rc > " + e604[0];
            for(var r332 = "", o220 = t879 - 2; o220 < t879; o220++)r332 += n448[o220] + " >= " + e604[o220], o220 < t879 - 1 && (r332 += "||");
            return r332;
        }(e603, t878, n446), a163 = function(t880, e605, n449, r333) {
            if (1 === t880) return "";
            var o221 = r333.slice(-2);
            return "\n    int r = " + o221[0] + ";\n    int c = " + o221[1] + ";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= " + e605 + ";\n    bool rEdge = rp1 >= " + n449 + ";\n  ";
        }(e603, t878[t878.length - 1], t878[t878.length - 2], n446), i111 = function(t881, e606) {
            var n450 = t881.length, r334 = function(t882, e607) {
                for(var n451 = [], r335 = 0; r335 <= 1; r335++)for(var o222 = 0; o222 <= 1; o222++){
                    for(var a165 = (0 === r335 ? "r" : "rp1") + ", " + (0 === o222 ? "c" : "cp1"), i113 = 2; i113 < t882; i113++)a165 = e607[e607.length - 1 - i113] + "," + a165;
                    n451.push(a165);
                }
                return n451;
            }(n450, e606);
            return 1 === n450 ? "getA(rc),\n            rc + 1 >= " + t881[0] + " ? 0. : getA(rc + 1),\n            0, 0" : "getA(" + r334[0] + "),\n          cEdge ? 0. : getA(" + r334[1] + "),\n          rEdge ? 0. : getA(" + r334[2] + "),\n          rEdge || cEdge ? 0. : getA(" + r334[3] + ")";
        }(t878, n446);
        this.userCode = "\n        void main() {\n          " + r330 + " rc = getOutputCoords();\n\n          if(" + o218 + ") {\n            setOutput(vec4(0));\n          } else {\n            " + a163 + "\n\n            setOutput(vec4(" + i111 + "));\n          }\n        }\n      ";
    }
};
var Ps = function(t883, e608, n452) {
    this.variableNames = [
        "x"
    ], this.outputShape = e608.map(function(e609, n) {
        return e609[0] + t883[n] + e609[1];
    });
    var r336 = t883.length, o223 = ui(r336), a166 = e608.map(function(t884) {
        return t884[0];
    }).join(","), i114 = e608.map(function(e610, n) {
        return e610[0] + t883[n];
    }).join(","), s93 = [
        "coords[0]",
        "coords[1]",
        "coords[2]",
        "coords[3]"
    ].slice(0, r336);
    this.userCode = 1 !== r336 ? "\n      " + o223 + " start = " + o223 + "(" + a166 + ");\n      " + o223 + " end = " + o223 + "(" + i114 + ");\n\n      void main() {\n        " + o223 + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(" + n452 + "));\n        } else {\n          " + o223 + " coords = outC - start;\n          setOutput(getX(" + s93 + "));\n        }\n      }\n    " : "\n        int start = " + a166 + ";\n        int end = " + i114 + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(" + n452 + "));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ";
}, Ls = function(t885, e611, n453) {
    this.variableNames = [
        "x"
    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e611.map(function(e612, n) {
        return e612[0] + t885[n] + e612[1];
    });
    for(var r337 = t885.length, o224 = ui(r337), a167 = e611.map(function(t886) {
        return t886[0];
    }).join(","), i115 = e611.map(function(e613, n) {
        return e613[0] + t885[n];
    }).join(","), s94 = Xa("rc", r337), u73 = Xa("source", r337), c53 = s94[r337 - 1] + " < " + this.outputShape[r337 - 1], l42 = 1 === r337 ? "source" : "vec2(" + u73.slice(-2).join() + ")", h40 = [
        o224 + " rc = outputLoc;",
        s94[r337 - 1] + " += 1;\n       if(" + c53 + ") {\n      ",
        1 === r337 ? "" : "}\n       rc = outputLoc;\n       " + s94[r337 - 2] + " += 1;\n       if(" + s94[r337 - 2] + " < " + this.outputShape[r337 - 2] + ") {",
        1 === r337 ? "" : "  " + s94[r337 - 1] + " += 1;\n         if(" + c53 + ") {"
    ], f36 = 1 === r337 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", d31 = "", p30 = 0, v25 = 1 === r337 ? 2 : 4; p30 < v25; p30++)d31 += "\n        " + h40[p30] + "\n        if (" + f36 + ") {\n          result[" + p30 + "] = float(" + n453 + ");\n        } else {\n          " + o224 + " source = rc - start;\n          result[" + p30 + "] = getChannel(getX(" + u73.join() + "), " + l42 + ");\n        }\n      ";
    d31 += 1 === r337 ? "} " : "}}", this.userCode = "\n      const " + o224 + " start = " + o224 + "(" + a167 + ");\n      const " + o224 + " end = " + o224 + "(" + i115 + ");\n\n      void main() {\n        " + o224 + " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        " + d31 + "\n        setOutput(result);\n      }\n    ";
}, Ws = function(t887, e614, n454, r338, o225) {
    if (void 0 === r338 && (r338 = !1), void 0 === o225 && (o225 = !1), this.variableNames = [
        "x"
    ], "avg" === e614 && n454) throw new Error("Cannot compute positions for average pool.");
    var a168 = t887.filterWidth, i116 = t887.strideHeight, s95 = t887.strideWidth, u74 = t887.dilationHeight, c54 = t887.dilationWidth, l43 = t887.effectiveFilterHeight, h41 = t887.effectiveFilterWidth, f37 = t887.padInfo.top, d32 = t887.padInfo.left;
    this.outputShape = t887.outShape;
    var p31 = "avg" === e614, v26 = "((batch  * " + t887.inHeight + " + xR) * " + t887.inWidth + " + xC) * " + t887.inChannels + " + d", g21 = "(xR * " + t887.inWidth + " + xC) * " + t887.inChannels + " + d", m17 = "0.0";
    if (p31 || (m17 = "-1.0 / 1e-20"), n454) this.userCode = "\n        const ivec2 strides = ivec2(" + i116 + ", " + s95 + ");\n        const ivec2 pads = ivec2(" + f37 + ", " + d32 + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + l43 + ";\n              wR += " + u74 + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t887.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + h41 + ";\n                wC += " + c54 + ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + t887.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = " + (r338 ? o225 ? v26 : g21 : "wR * " + h41 + " + wC") + ";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
    else {
        var y12 = e614 + "(" + e614 + "(" + e614 + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
        "avg" === e614 && (y12 = "avgValue / count");
        var x13 = 4 * Math.floor(a168 / 4), b9 = a168 % 4, w9 = "\n      if (" + p31 + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec2 strides = ivec2(" + i116 + ", " + s95 + ");\n      const ivec2 pads = ivec2(" + f37 + ", " + d32 + ");\n      const float initializationValue = " + m17 + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + t887.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + m17 + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " + l43 + ";\n            wR += " + u74 + ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + t887.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + x13 + "; wC += 4) {\n            int xC = xCCorner + wC * " + c54 + ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + c54 + ", d),\n              getValue(batch, xR, xC + 2 * " + c54 + ", d),\n              getValue(batch, xR, xC + 3 * " + c54 + ", d)\n            );\n\n            " + w9 + "\n          }\n\n          int xC = xCCorner + " + x13 + ";\n          if (" + (1 === b9) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " + w9 + "\n          } else if (" + (2 === b9) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + c54 + ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + w9 + "\n          } else if (" + (3 === b9) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + c54 + ", d),\n              getValue(batch, xR, xC + 2 * " + c54 + ", d),\n              initializationValue\n            );\n\n            " + w9 + "\n          }\n        }\n        setOutput(" + y12 + ");\n      }\n    ";
    }
}, Us = function(t888, e615, n455, r339, o226) {
    if (void 0 === r339 && (r339 = !1), void 0 === o226 && (o226 = !1), this.variableNames = [
        "x"
    ], "avg" === e615 && n455) throw new Error("Cannot compute positions for average pool.");
    var a169 = t888.filterWidth, i117 = t888.strideDepth, s96 = t888.strideHeight, u75 = t888.strideWidth, c55 = t888.dilationDepth, l44 = t888.dilationHeight, h42 = t888.dilationWidth, f38 = t888.effectiveFilterDepth, d33 = t888.effectiveFilterHeight, p32 = t888.effectiveFilterWidth, v27 = t888.padInfo.front, g22 = t888.padInfo.top, m18 = t888.padInfo.left;
    this.outputShape = t888.outShape;
    var y13 = "avg" === e615, x14 = "0.0";
    if (y13 || (x14 = "-1.0 / 1e-20"), n455) this.userCode = "\n        const ivec3 strides =\n            ivec3(" + i117 + ", " + s96 + ", " + u75 + ");\n        const ivec3 pads = ivec3(" + v27 + ", " + g22 + ", " + m18 + ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < " + f38 + ";\n              wD += " + c55 + ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= " + t888.inDepth + ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < " + d33 + ";\n                wR += " + l44 + ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= " + t888.inHeight + ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < " + p32 + ";\n                  wC += " + h42 + ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= " + t888.inWidth + ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = " + (r339 ? o226 ? "(((batch * " + t888.inDepth + " + xD) * " + t888.inHeight + " + xR) * " + t888.inWidth + " + xC) * " + t888.inChannels + " + ch" : "((xD * " + t888.inHeight + " + xR) * " + t888.inWidth + " + xC) * " + t888.inChannels + " + ch" : "wD * " + d33 + " * " + p32 + " +\n                      wR * " + p32 + " + wC") + ";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
    else {
        var b10 = e615 + "(" + e615 + "(" + e615 + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
        "avg" === e615 && (b10 = "avgValue / count");
        var w10 = 4 * Math.floor(a169 / 4), C3 = a169 % 4, E7 = "\n      if (" + y13 + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec3 strides =\n        ivec3(" + i117 + ", " + s96 + ", " + u75 + ");\n      const ivec3 pads = ivec3(" + v27 + ", " + g22 + ", " + m18 + ");\n      const float initializationValue = " + x14 + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= " + t888.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + x14 + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < " + f38 + ";\n            wD += " + c55 + ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= " + t888.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + d33 + ";\n            wR += " + l44 + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t888.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + w10 + "; wC += 4) {\n              int xC = xCCorner + wC * " + h42 + ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + h42 + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + h42 + ", ch),\n                getValue(batch, xD, xR, xC + 3 * " + h42 + ", ch)\n              );\n\n              " + E7 + "\n            }\n\n            int xC = xCCorner + " + w10 + ";\n            if (" + (1 === C3) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              " + E7 + "\n            } else if (" + (2 === C3) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + h42 + ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              " + E7 + "\n            } else if (" + (3 === C3) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + h42 + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + h42 + ", ch),\n                initializationValue\n              );\n\n              " + E7 + "\n            }\n          }\n          setOutput(" + b10 + ");\n        }\n      }\n    ";
    }
}, Vs = function(t889, e616) {
    this.variableNames = [
        "x"
    ];
    var n456 = t889.windowSize, r340 = t889.batchSize, o227 = t889.inSize, a170 = Math.ceil(o227 / n456);
    this.outputShape = [
        r340,
        a170
    ];
    var i118 = "0.0", s97 = "";
    "prod" === e616 ? i118 = "1.0" : "min" === e616 ? (i118 = "1.0 / 1e-20", s97 = "min") : "max" === e616 && (i118 = "-1.0 / 1e-20", s97 = "max");
    var u76 = e616 + "(" + e616 + "(" + e616 + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
    "sum" === e616 ? u76 = "sumValue" : "prod" === e616 ? u76 = "prodValue" : "all" === e616 ? u76 = "allValue" : "any" === e616 && (u76 = "anyValue");
    var c56 = 4 * Math.floor(n456 / 4), l45 = n456 % 4, h43 = "\n      if (" + ("sum" === e616) + ") {\n        sumValue += dot(values, ones);\n      } else if (" + ("prod" === e616) + ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = " + s97 + "(values, minMaxValue);\n      }\n    ", f39 = "vec4";
    "all" === e616 ? (i118 = "1.0", h43 = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", f39 = "bvec4") : "any" === e616 && (i118 = "0.0", h43 = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", f39 = "bvec4");
    var d34 = "";
    o227 % n456 > 0 && (d34 = "\n        if (inIdx < 0 || inIdx >= " + o227 + ") {\n          return initializationValue;\n        }\n      "), this.userCode = "\n      const float initializationValue = " + i118 + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + d34 + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + n456 + ";\n\n        vec4 minMaxValue = vec4(" + i118 + ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < " + c56 + "; i += 4) {\n          int inIdx = inOffset + i;\n          " + f39 + " values = " + f39 + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + h43 + "\n        }\n\n        int inIdx = inOffset + " + c56 + ";\n        if (" + (1 === l45) + ") {\n          " + f39 + " values = " + f39 + "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          " + h43 + "\n        } else if (" + (2 === l45) + ") {\n          " + f39 + " values = " + f39 + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          " + h43 + "\n        } else if (" + (3 === l45) + ") {\n          " + f39 + " values = " + f39 + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          " + h43 + "\n        }\n        setOutput(" + u76 + ");\n      }\n    ";
}, zs = function(t890, e617) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t890;
    for(var n457 = "", r341 = 0; r341 < 4; r341++){
        var o228 = "thisRC = rc;";
        r341 % 2 == 1 && (o228 += "thisRC.z += 1;"), r341 > 1 && (o228 += "thisRC.y += 1;"), n457 += "\n        " + o228 + "\n        " + (r341 > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "") + "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[" + r341 + "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        " + (r341 > 0 ? "}" : "") + "\n      ";
    }
    this.userCode = "\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      " + $a([
        "r",
        "c",
        "d"
    ], e617) + "\n      return ivec3(r, c, d);\n    }\n  \n      " + Qa(t890) + "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = " + t890[1] + ";\n        int cols = " + t890[2] + ";\n\n        " + n457 + "\n\n        setOutput(result);\n      }\n    ";
};
var Gs = function(t891, e618, n458) {
    this.variableNames = [
        "dy"
    ], this.outputShape = [], this.outputShape = e618.shape;
    var r342 = e618.shape, o229 = r342[1], a171 = r342[2], i119 = t891.shape, s98 = i119[1], u77 = i119[2], c57 = [
        n458 && s98 > 1 ? o229 - 1 : o229,
        n458 && u77 > 1 ? a171 - 1 : a171
    ], l46 = [
        n458 && s98 > 1 ? s98 - 1 : s98,
        n458 && u77 > 1 ? u77 - 1 : u77
    ], h44 = c57[0] / l46[0], f40 = c57[1] / l46[1], d35 = 1 / h44, p33 = 1 / f40, v28 = 2 * Math.ceil(d35) + 2, g23 = 2 * Math.ceil(p33) + 2;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h44 + ");\n        const float widthScale = float(" + f40 + ");\n\n        const float invHeightScale = float(" + d35 + ");\n        const float invWidthScale = float(" + p33 + ");\n\n        const int winHeight = int(" + v28 + ");\n        const int winWidth = int(" + g23 + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + s98 + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + u77 + ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " + (o229 - 1) + ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " + (a171 - 1) + ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
}, Hs = function(t892, e619, n459, r343) {
    this.variableNames = [
        "A"
    ], this.outputShape = [];
    var o230 = t892[0], a172 = t892[1], i120 = t892[2], s99 = t892[3];
    this.outputShape = [
        o230,
        e619,
        n459,
        s99
    ];
    var u78 = [
        r343 && e619 > 1 ? a172 - 1 : a172,
        r343 && n459 > 1 ? i120 - 1 : i120
    ], c58 = [
        r343 && e619 > 1 ? e619 - 1 : e619,
        r343 && n459 > 1 ? n459 - 1 : n459
    ];
    this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + u78[0] / c58[0] + ",\n          " + u78[1] / c58[1] + ");\n      const vec2 inputShapeRC = vec2(" + a172 + ".0, " + i120 + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
}, qs = function(t893, e620, n460, r344) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
    var o231 = t893[0], a173 = t893[1], i121 = t893[2], s100 = t893[3];
    this.outputShape = [
        o231,
        e620,
        n460,
        s100
    ];
    var u79 = [
        r344 && e620 > 1 ? a173 - 1 : a173,
        r344 && n460 > 1 ? i121 - 1 : i121
    ], c59 = [
        r344 && e620 > 1 ? e620 - 1 : e620,
        r344 && n460 > 1 ? n460 - 1 : n460
    ];
    this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          " + u79[0] / c59[0] + ",\n          " + u79[1] / c59[1] + ",\n          " + u79[1] / c59[1] + ");\n      const vec3 inputShapeRC = vec3(" + a173 + ".0, " + i121 + ".0,\n                                     " + i121 + ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < " + (s100 - 1) + ";\n        bool hasNextRow = coords.z < " + (n460 - 1) + ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ";
}, Ks = function(t894, e621, n461) {
    this.variableNames = [
        "dy"
    ], this.outputShape = [], this.outputShape = e621.shape;
    var r345 = e621.shape, o232 = r345[1], a174 = r345[2], i122 = t894.shape, s101 = i122[1], u80 = i122[2], c60 = [
        n461 && s101 > 1 ? o232 - 1 : o232,
        n461 && u80 > 1 ? a174 - 1 : a174
    ], l47 = [
        n461 && s101 > 1 ? s101 - 1 : s101,
        n461 && u80 > 1 ? u80 - 1 : u80
    ], h45 = c60[0] / l47[0], f41 = c60[1] / l47[1], d36 = 1 / h45, p34 = 1 / f41, v29 = 2 * Math.ceil(d36) + 2, g24 = 2 * Math.ceil(p34) + 2;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h45 + ");\n        const float widthScale = float(" + f41 + ");\n\n        const float invHeightScale = float(" + d36 + ");\n        const float invWidthScale = float(" + p34 + ");\n\n        const int winHeight = int(" + v29 + ");\n        const int winWidth = int(" + g24 + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + s101 + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + u80 + ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(" + c60[0] + ") *\n                (float(dyR) / float(" + l47[0] + "));\n\n            float sourceFracCol =\n                float(" + c60[1] + ") *\n                  (float(dyC) / float(" + l47[1] + "));\n\n            int sourceNearestRow = int(min(\n                float(int(" + o232 + ") - 1),\n                " + n461 + " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(" + a174 + ") - 1),\n                " + n461 + " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
}, js = function(t895, e622, n462, r346) {
    this.variableNames = [
        "A"
    ], this.outputShape = [];
    var o233 = t895[0], a175 = t895[1], i123 = t895[2], s102 = t895[3];
    this.outputShape = [
        o233,
        e622,
        n462,
        s102
    ];
    var u81 = [
        r346 && e622 > 1 ? a175 - 1 : a175,
        r346 && n462 > 1 ? i123 - 1 : i123
    ], c61 = [
        r346 && e622 > 1 ? e622 - 1 : e622,
        r346 && n462 > 1 ? n462 - 1 : n462
    ], l48 = r346 ? "0.5" : "0.0";
    this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + u81[0] / c61[0] + ",\n          " + u81[1] / c61[1] + ");\n      const vec2 inputShapeRC = vec2(" + a175 + ".0, " + i123 + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " + l48 + ")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ";
}, Xs = function(t896, e623) {
    this.variableNames = [
        "x"
    ];
    var n463 = t896.length;
    if (n463 > 4) throw new Error("WebGL backend: Reverse of rank-" + n463 + " tensor is not yet supported");
    if (this.outputShape = t896, 1 !== n463) {
        var r347 = t896.map(function(n464, r349) {
            return (function(n465) {
                return -1 !== e623.indexOf(n465) && 1 !== t896[n465] ? t896[n465] + " - coords[" + n465 + "] - 1" : "coords[" + n465 + "]";
            })(r349);
        }).join(","), o234 = ui(n463);
        this.userCode = "\n      void main() {\n        " + o234 + " coords = getOutputCoords();\n        setOutput(getX(" + r347 + "));\n      }\n    ";
    } else this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" + t896[0] + " - coord - 1));\n        }\n      ";
}, Ys = function(t897, e624) {
    this.variableNames = [
        "x"
    ], this.packedInputs = !0, this.packedOutput = !0;
    var n466 = t897.length;
    if (n466 > 4) throw new Error("WebGL backend: Reverse of rank-" + n466 + " tensor is not yet supported");
    this.outputShape = t897;
    var r350 = Xa("rc", n466), o235 = r350[n466 - 1] + " + 1 < " + this.outputShape[n466 - 1], a176 = r350[n466 - 2] + " + 1 < " + this.outputShape[n466 - 2], i124 = ui(n466);
    function s103(n467) {
        var r351 = t897.map(function(r352, o236) {
            return (function(n468, r353) {
                return -1 !== e624.indexOf(n468) && 1 !== t897[n468] ? t897[n468] + " - " + r353[n468] + " - 1" : "" + r353[n468];
            })(o236, n467);
        });
        return "getChannel(getX(" + r351.join(",") + "), vec2(" + r351.slice(-2).join(",") + "))";
    }
    this.userCode = 1 === n466 ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(" + t897[0] + " - rc - 1),\n            " + t897[0] + " - rc - 1);\n          if(" + o235 + "){\n              result.g = getChannel(getX(" + t897[0] + " - (rc  + 1) - 1),\n                " + t897[0] + " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      " : "\n        void main() {\n          " + i124 + " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = " + (function(t898) {
        return s103(t898);
    })(r350.slice()) + ";\n          if(" + o235 + "){\n            result.g = " + (function(t899) {
        return t899[n466 - 1] = "(" + t899[n466 - 1] + " + 1)", s103(t899);
    })(r350.slice()) + ";\n          }\n          if(" + a176 + ") {\n            result.b = " + (function(t900) {
        return t900[n466 - 2] = "(" + t900[n466 - 2] + " + 1)", s103(t900);
    })(r350.slice()) + ";\n            if(" + o235 + ") {\n              result.a = " + (function(t901) {
        return t901[n466 - 1] = "(" + t901[n466 - 1] + " + 1)", t901[n466 - 2] = "(" + t901[n466 - 2] + " + 1)", s103(t901);
    })(r350.slice()) + ";\n            }\n          }\n          setOutput(result);\n        }\n    ";
}, $s = function(t902, e625, n469, r354, o237, a177, i125) {
    void 0 === i125 && (i125 = !0), this.variableNames = [
        "updates",
        "indices",
        "defaultValue"
    ], this.outputShape = a177;
    var s104 = ui(o237.length), u82 = ui(a177.length), c62 = "";
    1 === n469 ? c62 = "i" : 2 === n469 && (c62 = "i, j");
    var l49 = "getIndices(" + c62 + ")", h46 = "";
    1 === r354 ? h46 = "i" : 2 === r354 && (h46 = "i, coords[1]");
    var f42 = "getUpdates(" + h46 + ")", d37 = e625 > 1 ? "strides[j]" : "strides";
    this.userCode = "\n        " + s104 + " strides = " + s104 + "(" + o237 + ");\n\n        void main() {\n          " + u82 + " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < " + t902 + "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < " + e625 + "; j++) {\n              int index = round(" + l49 + ");\n              flattenedIndex += index * " + d37 + ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += " + f42 + ";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ";
}, Qs = function(t903, e) {
    this.variableNames = [
        "x",
        "segmentIds"
    ];
    var n470 = t903.windowSize, r355 = t903.batchSize, o238 = t903.inSize, a178 = t903.numSegments, i126 = a178 * Math.ceil(o238 / n470);
    this.outputShape = [
        r355,
        i126
    ];
    var s105 = 4 * Math.floor(n470 / 4), u83 = n470 % 4, c63 = "\n        sumValue += dot(values, segFilter);\n    ", l50 = "";
    o238 % n470 > 0 && (l50 = "\n        if (inIdx < 0 || inIdx >= " + o238 + ") {\n          return initializationValue;\n        }\n      ");
    var h47 = "";
    o238 % n470 > 0 && (h47 = "\n        if (inIdx < 0 || inIdx >= " + o238 + ") {\n          return -1.0;\n        }\n      "), this.userCode = "\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        " + l50 + "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        " + h47 + "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          " + a178 + ")) * float(" + n470 + "));\n        int currentSeg = int(mod(float(outIdx), float(" + a178 + ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + s105 + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          " + c63 + "\n        }\n\n        int inIdx = inOffset + " + s105 + ";\n        if (" + (1 === u83) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          " + c63 + "\n        } else if (" + (2 === u83) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          " + c63 + "\n        } else if (" + (3 === u83) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          " + c63 + "\n        }\n        setOutput(sumValue);\n      }\n    ";
}, Js = function(t904, e626, n471) {
    var r356, o239;
    if (this.variableNames = [
        "c",
        "a",
        "b"
    ], this.outputShape = e626, n471 > 4) throw Error("Where for rank " + n471 + " is not yet supported");
    if (1 === n471) o239 = "resRC", r356 = "resRC";
    else {
        for(var a179 = [
            "resRC.x",
            "resRC.y",
            "resRC.z",
            "resRC.w"
        ], i127 = [], s106 = [], u84 = 0; u84 < e626.length; u84++)s106.push("" + a179[u84]), u84 < t904 && i127.push("" + a179[u84]);
        r356 = i127.join(), o239 = s106.join();
    }
    var c64 = ui(n471);
    this.userCode = "\n      void main() {\n        " + c64 + " resRC = getOutputCoords();\n        float cVal = getC(" + r356 + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + o239 + "));\n        } else {\n          setOutput(getB(" + o239 + "));\n        }\n      }\n    ";
}, Zs = function() {
    function t905(t906) {
        this.variableNames = [
            "source"
        ], this.outputShape = t906, this.rank = t906.length;
        var e627, n472 = ui(this.rank), r357 = "uniform int start[" + this.rank + "];", o240 = function(t907) {
            if (1 === t907) return "sourceLoc";
            if (t907 <= 6) return tu.slice(0, t907).map(function(t908) {
                return "sourceLoc." + t908;
            }).join(",");
            throw Error("Slicing for rank " + t907 + " is not yet supported");
        }(this.rank);
        e627 = "\n        " + n472 + " sourceLoc;\n        " + n472 + " coords = getOutputCoords();\n        " + t906.map(function(t, e628) {
            return "sourceLoc." + tu[e628] + " = start[" + e628 + "] + coords." + tu[e628] + ";";
        }).join("\n") + "\n      ", this.userCode = "\n      " + r357 + "\n      void main() {\n        " + e627 + "\n        setOutput(getSource(" + o240 + "));\n      }\n    ";
    }
    return t905.prototype.getCustomSetupFunc = function(t909) {
        var e629 = this;
        if (t909.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t909.length + ")");
        return function(n473, r358) {
            null == e629.startLoc && (e629.startLoc = n473.getUniformLocationNoThrow(r358, "start"), null == e629.startLoc) || n473.gl.uniform1iv(e629.startLoc, t909);
        };
    }, t905;
}(), tu = [
    "x",
    "y",
    "z",
    "w",
    "u",
    "v"
];
var eu = function() {
    function t910(t911) {
        this.variableNames = [
            "source"
        ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t911, this.rank = t911.length;
        var e630 = ui(this.rank), n474 = Xa("coords", this.rank), r359 = Xa("sourceLoc", this.rank), o241 = 1 === this.rank ? "sourceLoc" : "vec2(" + r359.slice(-2).join() + ")", a180 = "getChannel(getSource(" + r359.join() + "), " + o241 + ")", i128 = "\n      result.x = " + a180 + ";\n      if (++" + n474[this.rank - 1] + " < " + t911[this.rank - 1] + ") {\n        ++" + r359[this.rank - 1] + ";\n        result.y = " + a180 + ";\n        --" + r359[this.rank - 1] + ";\n      }\n    ", s107 = 1 === this.rank ? "" : "\n      --" + n474[this.rank - 1] + ";\n      if (++" + n474[this.rank - 2] + " < " + t911[this.rank - 2] + ") {\n        ++" + r359[this.rank - 2] + ";\n        result.z = " + a180 + ";\n        if (++" + n474[this.rank - 1] + " < " + t911[this.rank - 1] + ") {\n          ++" + r359[this.rank - 1] + ";\n          result.w = " + a180 + ";\n        }\n      }\n    ", u85 = this.rank <= 4 ? "sourceLoc = coords +\n            " + e630 + "(" + t911.map(function(t, e631) {
            return "start[" + e631 + "]";
        }).join() + ");" : t911.map(function(t, e632) {
            return r359[e632] + " = " + n474[e632] + " + start[" + e632 + "];";
        }).join("\n");
        this.userCode = "\n      uniform int start[" + this.rank + "];\n      void main() {\n        " + e630 + " coords = getOutputCoords();\n        " + e630 + " sourceLoc;\n        " + u85 + "\n        vec4 result = vec4(0.);\n        " + i128 + "\n        " + s107 + "\n        setOutput(result);\n      }\n    ";
    }
    return t910.prototype.getCustomSetupFunc = function(t912) {
        var e633 = this;
        if (t912.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t912.length + ")");
        return function(n475, r360) {
            null == e633.startLoc && (e633.startLoc = n475.getUniformLocationNoThrow(r360, "start"), null == e633.startLoc) || n475.gl.uniform1iv(e633.startLoc, t912);
        };
    }, t910;
}(), nu = function(t913, e634, n476) {
    this.variableNames = [
        "x"
    ], this.outputShape = n476;
    var r361 = n476.length, o242 = ui(n476.length), a181 = ui(n476.length), i129 = "";
    if (1 === r361) i129 = "coords * strides + begin";
    else {
        var s108 = 0;
        i129 = n476.map(function(t, e635) {
            return s108++, 1 === n476.length ? "coords * strides[" + e635 + "] + begin[" + e635 + "]" : "coords[" + (s108 - 1) + "] * strides[" + e635 + "] + begin[" + e635 + "]";
        }).join(",");
    }
    this.userCode = "\n      " + o242 + " begin = " + o242 + "(" + t913 + ");\n      " + o242 + " strides = " + o242 + "(" + e634 + ");\n\n      void main() {\n        " + a181 + " coords = getOutputCoords();\n        setOutput(getX(" + i129 + "));\n      }\n    ";
}, ru = function() {
    function t914(t915) {
        this.gpgpu = t915, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {
        }, this.logEnabled = !1, this.usedTextures = {
        };
    }
    return t914.prototype.acquireTexture = function(t916, e636, n477) {
        var r362, o243 = ou(e636, n477), a182 = au(t916, o243, n477);
        if (a182 in this.freeTextures || (this.freeTextures[a182] = []), a182 in this.usedTextures || (this.usedTextures[a182] = []), this.freeTextures[a182].length > 0) {
            this.numFreeTextures--, this.numUsedTextures++, this.log();
            var i130 = this.freeTextures[a182].shift();
            return this.usedTextures[a182].push(i130), i130;
        }
        return this.numUsedTextures++, this.log(), o243 === Gt.PACKED_2X2_FLOAT32 ? r362 = this.gpgpu.createPackedMatrixTexture(t916[0], t916[1]) : o243 === Gt.PACKED_2X2_FLOAT16 ? r362 = this.gpgpu.createFloat16PackedMatrixTexture(t916[0], t916[1]) : o243 === Gt.UNPACKED_FLOAT32 ? r362 = this.gpgpu.createFloat32MatrixTexture(t916[0], t916[1]) : o243 === Gt.UNPACKED_FLOAT16 ? r362 = this.gpgpu.createFloat16MatrixTexture(t916[0], t916[1]) : o243 === Gt.PACKED_4X1_UNSIGNED_BYTE && (r362 = this.gpgpu.createUnsignedBytesMatrixTexture(t916[0], t916[1])), this.usedTextures[a182].push(r362), r362;
    }, t914.prototype.releaseTexture = function(t917, e637, n478, r363) {
        if (null != this.freeTextures) {
            var o244 = au(e637, ou(n478, r363), r363);
            o244 in this.freeTextures || (this.freeTextures[o244] = []), this.freeTextures[o244].push(t917), this.numFreeTextures++, this.numUsedTextures--;
            var a183 = this.usedTextures[o244], i131 = a183.indexOf(t917);
            if (i131 < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
            a183.splice(i131, 1), this.log();
        }
    }, t914.prototype.log = function() {
        if (this.logEnabled) {
            var t918 = this.numFreeTextures + this.numUsedTextures;
            console.log("Free/Used", this.numFreeTextures + " / " + this.numUsedTextures, "(" + t918 + ")");
        }
    }, t914.prototype.getNumUsedTextures = function() {
        return this.numUsedTextures;
    }, t914.prototype.getNumFreeTextures = function() {
        return this.numFreeTextures;
    }, t914.prototype.dispose = function() {
        var t919 = this;
        if (null != this.freeTextures) {
            for(var e638 in this.freeTextures)this.freeTextures[e638].forEach(function(e640) {
                t919.gpgpu.deleteMatrixTexture(e640);
            });
            for(var e638 in this.usedTextures)this.usedTextures[e638].forEach(function(e641) {
                t919.gpgpu.deleteMatrixTexture(e641);
            });
            this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0;
        }
    }, t914;
}();
function ou(t920, e642) {
    if (t920 === zt.UPLOAD) return Gt.PACKED_2X2_FLOAT32;
    if (t920 === zt.RENDER || null == t920) return (function(t921) {
        return i().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? t921 ? Gt.PACKED_2X2_FLOAT32 : Gt.UNPACKED_FLOAT32 : t921 ? Gt.PACKED_2X2_FLOAT16 : Gt.UNPACKED_FLOAT16;
    })(e642);
    if (t920 === zt.DOWNLOAD || t920 === zt.PIXELS) return Gt.PACKED_4X1_UNSIGNED_BYTE;
    throw new Error("Unknown logical texture type " + t920);
}
function au(t922, e643, n479) {
    return t922[0] + "_" + t922[1] + "_" + e643 + "_" + n479;
}
var iu = function(t923, e644) {
    this.variableNames = [
        "A"
    ];
    for(var n480 = new Array(t923.length), r364 = 0; r364 < n480.length; r364++)n480[r364] = t923[r364] * e644[r364];
    this.outputShape = n480, this.rank = n480.length;
    var o245 = ui(this.rank), a184 = function(t924) {
        var e645 = t924.length;
        if (e645 > 5) throw Error("Tile for rank " + e645 + " is not yet supported");
        if (1 === e645) return "imod(resRC, " + t924[0] + ")";
        for(var n481 = [
            "resRC.x",
            "resRC.y",
            "resRC.z",
            "resRC.w",
            "resRC.u"
        ], r365 = [], o246 = 0; o246 < t924.length; o246++)r365.push("imod(" + n481[o246] + ", " + t924[o246] + ")");
        return r365.join();
    }(t923);
    this.userCode = "\n      void main() {\n        " + o245 + " resRC = getOutputCoords();\n        setOutput(getA(" + a184 + "));\n      }\n    ";
};
var su = 1.7580993408473768, uu = 1.0507009873554805, cu = function(t925, e646) {
    this.variableNames = [
        "A"
    ], this.outputShape = t925, this.userCode = "\n      float unaryOperation(float x) {\n        " + e646 + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
}, lu = "if (isnan(x)) return x;", hu = "return x;", fu = "return abs(x);", du = lu + "\n  return (x < 0.0) ? 0.0 : x;\n", pu = lu + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n", vu = "return (x >= 0.0) ? x : (exp(x) - 1.0);", gu = "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = " + su + ";\n  float scale = " + uu + ";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";
var mu = "return -x;", yu = "return ceil(x);", xu = "return floor(x);", bu = "return exp(x);", wu = "return exp(x) - 1.0;", Cu = lu + "\n  return sin(x);\n", Eu = lu + "\n  return cos(x);\n", Ru = lu + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n", Iu = lu + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n", ku = lu + "\n  return atan(x);\n", Su = lu + "return log(x + sqrt(x * x + 1.0));", Au = lu + "\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));", Tu = lu + "\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;", Du = "return x;", Nu = "return x;", Fu = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n", _u = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n", Ou = "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n", Mu = function(t926, e647) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t926, this.userCode = "\n      vec4 unaryOperation(vec4 x) {\n        " + e647 + "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
}, Bu = function(t927) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = t927;
    var e648 = t927.length, n482 = Xa("rc", e648), r366 = ui(e648), o247 = function(t928, e649) {
        if (1 === t928) return "rc";
        for(var n483 = "", r367 = 0; r367 < t928; r367++)n483 += e649[r367], r367 < t928 - 1 && (n483 += ",");
        return n483;
    }(e648, n482), a185 = n482.slice(-2), i132 = e648 <= 1 ? "rc" : "vec2(" + a185.join(",") + ")";
    this.userCode = "\n      void main() {\n        " + r366 + " rc = getOutputCoords();\n        vec4 packedInput = getA(" + o247 + ");\n\n        setOutput(getChannel(packedInput, " + i132 + "));\n      }\n    ";
}, Pu = {
};
function Lu(t929, e650) {
    if (void 0 === e650 && (e650 = !1), "linear" === t929) return e650 ? Nu : hu;
    if ("relu" === t929) return e650 ? Fu : du;
    if ("elu" === t929) return e650 ? Ou : vu;
    if ("relu6" === t929) return e650 ? _u : pu;
    if ("prelu" === t929) return e650 ? ki : Ei;
    throw new Error("Activation " + t929 + " has not been implemented for the WebGL backend.");
}
var Wu = 600;
var Uu = function(t930) {
    function o248(e651) {
        var n484, r368 = t930.call(this) || this;
        if (r368.pendingRead = new WeakMap, r368.pendingDisposal = new WeakSet, r368.dataRefCount = new WeakMap, r368.numBytesInGPU = 0, r368.uploadWaitMs = 0, r368.downloadWaitMs = 0, r368.warnedAboutMemory = !1, r368.pendingDeletes = 0, r368.disposed = !1, !i().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");
        if (null == e651) {
            var o249 = jt(i().getNumber("WEBGL_VERSION"));
            r368.binaryCache = (n484 = i().getNumber("WEBGL_VERSION")) in Pu ? Pu[n484] : (Pu[n484] = {
            }, Pu[n484]), r368.gpgpu = new Is(o249), r368.canvas = o249.canvas, r368.gpgpuCreatedLocally = !0;
        } else r368.gpgpu = e651, r368.binaryCache = {
        }, r368.gpgpuCreatedLocally = !1, r368.canvas = e651.gl.canvas;
        return r368.textureManager = new ru(r368.gpgpu), r368.numMBBeforeWarning = null == i().global.screen ? 1024 : i().global.screen.height * i().global.screen.width * window.devicePixelRatio * Wu / 1024 / 1024, r368.texData = new ca(r368, Lt), r368;
    }
    return e(o248, t930), o248.prototype.numDataIds = function() {
        return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes;
    }, o248.prototype.write = function(t931, e652, n485) {
        if (i().getBool("DEBUG") && this.checkNumericalProblems(t931), "complex64" === n485 && null != t931) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
        var r369 = {
        };
        return this.texData.set(r369, {
            shape: e652,
            dtype: n485,
            values: t931,
            usage: zt.UPLOAD
        }), r369;
    }, o248.prototype.move = function(t932, e653, n486, r370) {
        if (i().getBool("DEBUG") && this.checkNumericalProblems(e653), "complex64" === r370) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
        this.texData.set(t932, {
            shape: n486,
            dtype: r370,
            values: e653,
            usage: zt.UPLOAD
        });
    }, o248.prototype.readSync = function(t933) {
        var e654 = this.texData.get(t933), n487 = e654.values, r371 = e654.dtype, o250 = e654.complexTensors, a186 = e654.slice, i133 = e654.shape, s109 = e654.isPacked;
        if (null != a186) {
            var u86 = void 0;
            u86 = s109 ? new Mu(i133, Du) : new cu(i133, Du);
            var c65 = this.runWebGLProgram(u86, [
                {
                    dataId: t933,
                    shape: i133,
                    dtype: r371
                }
            ], r371), l51 = this.readSync(c65.dataId);
            return this.disposeData(c65.dataId), l51;
        }
        if (null != n487) return this.convertAndCacheOnCPU(t933);
        if ("string" === r371) return n487;
        var h48, f43, d38 = null != this.activeTimers;
        (d38 && (h48 = et()), "complex64" === r371) ? f43 = Aa(o250.real.dataSync(), o250.imag.dataSync()) : f43 = this.getValuesFromTexture(t933);
        return d38 && (this.downloadWaitMs += et() - h48), this.convertAndCacheOnCPU(t933, f43);
    }, o248.prototype.read = function(t934) {
        return n(this, void 0, void 0, function() {
            var e655, n488, o251, a187, s110, u87, c66, l52, h49, f44, d39, p35, v30, g25, m19, y14, x15, b11, w11, C4, E8, R5;
            return r(this, function(r372) {
                switch(r372.label){
                    case 0:
                        if (this.pendingRead.has(t934)) return e655 = this.pendingRead.get(t934), [
                            2,
                            new Promise(function(t935) {
                                return e655.push(t935);
                            })
                        ];
                        if (n488 = this.texData.get(t934), o251 = n488.values, a187 = n488.shape, s110 = n488.slice, u87 = n488.dtype, c66 = n488.complexTensors, l52 = n488.isPacked, null != s110) return h49 = void 0, h49 = l52 ? new Mu(a187, Du) : new cu(a187, Du), f44 = this.runWebGLProgram(h49, [
                            {
                                dataId: t934,
                                shape: a187,
                                dtype: u87
                            }
                        ], u87), d39 = this.read(f44.dataId), this.disposeData(f44.dataId), [
                            2,
                            d39
                        ];
                        if (null != o251) return [
                            2,
                            this.convertAndCacheOnCPU(t934)
                        ];
                        if (!i().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === i().getNumber("WEBGL_VERSION")) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
                        return p35 = null, "complex64" !== u87 && i().get("WEBGL_BUFFER_SUPPORTED") && (v30 = this.decode(t934), g25 = this.texData.get(v30.dataId), p35 = (R5 = this.gpgpu).createBufferFromTexture.apply(R5, [
                            g25.texture
                        ].concat(Yt(a187)))), this.pendingRead.set(t934, []), "complex64" === u87 ? [
                            3,
                            2
                        ] : [
                            4,
                            this.gpgpu.createAndWaitForFence()
                        ];
                    case 1:
                        r372.sent(), r372.label = 2;
                    case 2:
                        return "complex64" !== u87 ? [
                            3,
                            4
                        ] : [
                            4,
                            Promise.all([
                                c66.real.data(),
                                c66.imag.data()
                            ])
                        ];
                    case 3:
                        return y14 = r372.sent(), x15 = y14[0], b11 = y14[1], m19 = Aa(x15, b11), [
                            3,
                            5
                        ];
                    case 4:
                        null == p35 ? m19 = this.getValuesFromTexture(t934) : (w11 = k(a187), m19 = this.gpgpu.downloadFloat32MatrixFromBuffer(p35, w11)), r372.label = 5;
                    case 5:
                        return null != v30 && this.disposeData(v30.dataId), C4 = this.convertAndCacheOnCPU(t934, m19), E8 = this.pendingRead.get(t934), this.pendingRead.delete(t934), E8.forEach(function(t936) {
                            return t936(C4);
                        }), this.pendingDisposal.has(t934) && (this.pendingDisposal.delete(t934), this.disposeData(t934), this.pendingDeletes--), [
                            2,
                            C4
                        ];
                }
            });
        });
    }, o248.prototype.checkNumericalProblems = function(t937) {
        if (null != t937) for(var e656 = 0; e656 < t937.length; e656++){
            var n489 = t937[e656];
            if (!ee(n489)) {
                if (i().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) throw Error("The value " + n489 + " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");
                throw Error("The value " + n489 + " cannot be represented on this device.");
            }
        }
    }, o248.prototype.getValuesFromTexture = function(t938) {
        var e657, n490 = this.texData.get(t938), r373 = n490.shape, o252 = n490.dtype, a188 = n490.isPacked, s111 = k(r373);
        if (i().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
            var u88 = this.decode(t938), c67 = this.texData.get(u88.dataId), l53 = (e657 = this.gpgpu).downloadMatrixFromPackedTexture.apply(e657, [
                c67.texture
            ].concat(Yt(r373))).subarray(0, s111);
            return this.disposeData(u88.dataId), l53;
        }
        var h50 = i().getBool("WEBGL_PACK") && !0 === a188, f45 = h50 ? De(r373) : r373, d40 = h50 ? new Ji(f45) : new Qi(f45), p36 = this.runWebGLProgram(d40, [
            {
                shape: f45,
                dtype: o252,
                dataId: t938
            }
        ], "float32"), v31 = this.texData.get(p36.dataId), g26 = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v31.texture, v31.texShape[0], v31.texShape[1]).subarray(0, s111);
        return this.disposeData(p36.dataId), g26;
    }, o248.prototype.time = function(t939) {
        return n(this, void 0, void 0, function() {
            var e658, n491, o253, a189, s112, u89, c68;
            return r(this, function(r374) {
                switch(r374.label){
                    case 0:
                        return e658 = this.activeTimers, n491 = [], o253 = !1, null == this.programTimersStack ? (this.programTimersStack = n491, o253 = !0) : this.activeTimers.push(n491), this.activeTimers = n491, t939(), a189 = I(this.activeTimers.map(function(t940) {
                            return t940.query;
                        })).filter(function(t941) {
                            return null != t941;
                        }), s112 = I(this.activeTimers.map(function(t942) {
                            return t942.name;
                        })).filter(function(t943) {
                            return null != t943;
                        }), this.activeTimers = e658, o253 && (this.programTimersStack = null), u89 = {
                            uploadWaitMs: this.uploadWaitMs,
                            downloadWaitMs: this.downloadWaitMs,
                            kernelMs: null,
                            wallMs: null
                        }, i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? [
                            4,
                            Promise.all(a189)
                        ] : [
                            3,
                            2
                        ];
                    case 1:
                        return c68 = r374.sent(), u89.kernelMs = w(c68), u89.getExtraProfileInfo = function() {
                            return c68.map(function(t944, e) {
                                return {
                                    name: s112[e],
                                    ms: t944
                                };
                            }).map(function(t945) {
                                return t945.name + ": " + t945.ms;
                            }).join(", ");
                        }, [
                            3,
                            3
                        ];
                    case 2:
                        u89.kernelMs = {
                            error: "WebGL query timers are not supported in this environment."
                        }, r374.label = 3;
                    case 3:
                        return this.uploadWaitMs = 0, this.downloadWaitMs = 0, [
                            2,
                            u89
                        ];
                }
            });
        });
    }, o248.prototype.memory = function() {
        return {
            unreliable: !1,
            numBytesInGPU: this.numBytesInGPU
        };
    }, o248.prototype.startTimer = function() {
        return i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : {
            startMs: et(),
            endMs: null
        };
    }, o248.prototype.endTimer = function(t946) {
        return i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), t946) : (t946.endMs = et(), t946);
    }, o248.prototype.getQueryTime = function(t947) {
        return n(this, void 0, void 0, function() {
            var e659;
            return r(this, function(n) {
                return i().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? [
                    2,
                    this.gpgpu.waitForQueryAndGetTime(t947)
                ] : [
                    2,
                    (e659 = t947).endMs - e659.startMs
                ];
            });
        });
    }, o248.prototype.disposeData = function(t948) {
        if (!this.pendingDisposal.has(t948)) {
            if (this.pendingRead.has(t948)) return this.pendingDisposal.add(t948), void this.pendingDeletes++;
            if (this.texData.has(t948)) {
                this.releaseGPUData(t948);
                var e660 = this.texData.get(t948).complexTensors;
                null != e660 && (e660.real.dispose(), e660.imag.dispose()), this.texData.delete(t948);
            }
        }
    }, o248.prototype.releaseGPUData = function(t949) {
        var e661 = this.texData.get(t949), n492 = e661.texture, r375 = e661.dtype, o254 = e661.texShape, a190 = e661.usage, i134 = e661.isPacked, s113 = e661.slice, u90 = s113 && s113.origDataId || t949, c69 = this.dataRefCount.get(u90);
        c69 > 1 ? this.dataRefCount.set(u90, c69 - 1) : (this.dataRefCount.delete(u90), null != n492 && (this.numBytesInGPU -= this.computeBytes(o254, r375), this.textureManager.releaseTexture(n492, o254, a190, i134)));
        var l54 = this.texData.get(t949);
        l54.texture = null, l54.texShape = null, l54.isPacked = !1, l54.slice = null;
    }, o248.prototype.getTexture = function(t950) {
        return this.uploadToGPU(t950), this.texData.get(t950).texture;
    }, o248.prototype.getDataInfo = function(t951) {
        return this.texData.get(t951);
    }, o248.prototype.getCPUBackend = function() {
        return i().getBool("WEBGL_CPU_FORWARD") ? (null == this.cpuBackend && (this.cpuBackend = Lt.findBackend("cpu")), this.cpuBackend) : null;
    }, o248.prototype.shouldExecuteOnCPU = function(t952, e662) {
        var n493 = this;
        return void 0 === e662 && (e662 = 128), null != this.getCPUBackend() && t952.every(function(t953) {
            return null == n493.texData.get(t953.dataId).texture && k(t953.shape) < e662;
        });
    }, o248.prototype.getGPGPUContext = function() {
        return this.gpgpu;
    }, o248.prototype.complex = function(t954, e663) {
        var n494 = this.makeOutput(t954.shape, "complex64");
        return this.texData.get(n494.dataId).complexTensors = {
            real: Lt.keep(t954.clone()),
            imag: Lt.keep(e663.clone())
        }, n494;
    }, o248.prototype.real = function(t955) {
        return this.texData.get(t955.dataId).complexTensors.real.clone();
    }, o248.prototype.imag = function(t956) {
        return this.texData.get(t956.dataId).complexTensors.imag.clone();
    }, o248.prototype.slice = function(t957, e664, n495) {
        if (this.shouldExecuteOnCPU([
            t957
        ])) return this.cpuBackend.slice(t957, e664, n495);
        if (0 === k(n495)) return Fn([], n495, t957.dtype);
        var r376 = this.texData.get(t957.dataId).isPacked, o255 = $o(t957.shape, e664, n495);
        if (r376 || !o255) {
            var a191 = i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new eu(n495) : new Zs(n495), s114 = a191.getCustomSetupFunc(e664);
            return this.compileAndRun(a191, [
                t957
            ], null, s114);
        }
        return this.uploadToGPU(t957.dataId), this.shallowSlice(t957, e664, n495);
    }, o248.prototype.shallowSlice = function(t958, e665, n496) {
        var r377 = this.texData.get(t958.dataId), o256 = this.makeOutput(n496, t958.dtype), a192 = this.texData.get(o256.dataId);
        Object.assign(a192, r377), a192.shape = n496, a192.dtype = t958.dtype;
        var i135 = Qo(e665, t958.strides);
        r377.slice && (i135 += r377.slice.flatOffset), a192.slice = {
            flatOffset: i135,
            origDataId: r377.slice && r377.slice.origDataId || t958.dataId
        };
        var s115 = this.dataRefCount.get(a192.slice.origDataId) || 1;
        return this.dataRefCount.set(a192.slice.origDataId, s115 + 1), o256;
    }, o248.prototype.stridedSlice = function(t959, e666, n497, r378) {
        if (this.shouldExecuteOnCPU([
            t959
        ])) return this.cpuBackend.stridedSlice(t959, e666, n497, r378);
        var o257 = jo(e666, n497, r378);
        if (o257.some(function(t960) {
            return 0 === t960;
        })) return Fn([], o257);
        var a193 = new nu(e666, r378, o257);
        return this.compileAndRun(a193, [
            t959
        ]);
    }, o248.prototype.reverse = function(t961, e667) {
        var n498 = i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Ys(t961.shape, e667) : new Xs(t961.shape, e667);
        return this.compileAndRun(n498, [
            t961
        ]);
    }, o248.prototype.concat = function(t962, e668) {
        if ("complex64" === t962[0].dtype) {
            var n499 = t962.map(function(t963) {
                return Dn(t963);
            }), r379 = t962.map(function(t964) {
                return Nn(t964);
            });
            return Tn(this.concat(n499, e668), this.concat(r379, e668));
        }
        if (this.shouldExecuteOnCPU(t962)) return this.cpuBackend.concat(t962, e668);
        if (1 === t962.length) return t962[0];
        if (t962.length > i().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
            var o258 = Math.floor(t962.length / 2), a194 = this.concat(t962.slice(0, o258), e668), s116 = this.concat(t962.slice(o258), e668);
            return this.concat([
                a194,
                s116
            ], e668);
        }
        if (i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && t962[0].rank > 1) {
            var u91 = new Fi(t962.map(function(t965) {
                return t965.shape;
            }), e668);
            return this.compileAndRun(u91, t962);
        }
        var c70 = Sn(t962.map(function(t966) {
            return t966.shape;
        }), e668), l55 = t962.map(function(t967) {
            return t967.as2D(-1, k(t967.shape.slice(e668)));
        }), h51 = new Ni(l55.map(function(t968) {
            return t968.shape;
        }));
        return this.compileAndRun(h51, l55).reshape(c70);
    }, o248.prototype.neg = function(t969) {
        if (this.shouldExecuteOnCPU([
            t969
        ])) return this.cpuBackend.neg(t969);
        if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t969, mu, t969.dtype);
        var e669 = new cu(t969.shape, mu);
        return this.compileAndRun(e669, [
            t969
        ]);
    }, o248.prototype.batchMatMul = function(t970, e670, n500, r380) {
        var o259 = n500 ? t970.shape[2] : t970.shape[1], a195 = r380 ? e670.shape[1] : e670.shape[2], i136 = n500 ? t970.shape[1] : t970.shape[2], s117 = t970.shape[0];
        if ((1 === o259 || 1 === a195) && i136 > 1000) {
            n500 && (t970 = ua(t970, [
                0,
                2,
                1
            ])), r380 && (e670 = ua(e670, [
                0,
                2,
                1
            ]));
            var u92 = 1 === a195 ? t970 : t970.as3D(s117, i136, 1), c71 = 1 === a195 ? 2 : 1, l56 = 1 === a195 ? e670.as3D(s117, 1, i136) : e670;
            return this.multiply(u92, l56).sum(c71, !0);
        }
        var h52 = Tt(t970.dtype, e670.dtype), f46 = new _s(t970.shape, [
            s117,
            o259,
            a195
        ], n500, r380);
        return this.compileAndRun(f46, [
            t970,
            e670
        ], h52);
    }, o248.prototype.fusedBatchMatMul = function(t971) {
        var e671 = t971.a, n501 = t971.b, r381 = t971.transposeA, o260 = t971.transposeB, a196 = t971.bias, i137 = t971.activation, s118 = t971.preluActivationWeights, u93 = r381 ? e671.shape[2] : e671.shape[1], c72 = o260 ? n501.shape[1] : n501.shape[2], l57 = e671.shape[0], h53 = Tt(e671.dtype, n501.dtype), f47 = null != a196, d41 = null != s118, p37 = i137 ? Lu(i137, !0) : null, v32 = new _s(e671.shape, [
            l57,
            u93,
            c72
        ], r381, o260, f47, p37, d41), g27 = [
            e671,
            n501
        ];
        return a196 && g27.push(a196), s118 && g27.push(s118), this.compileAndRun(v32, g27, h53);
    }, o248.prototype.multiply = function(t972, e672) {
        if ("complex64" === t972.dtype) {
            var n502 = this.texData.get(t972.dataId), r382 = this.texData.get(e672.dataId), o261 = new yi(gi, t972.shape, e672.shape), a197 = new yi(mi, t972.shape, e672.shape), s119 = [
                this.makeComplexComponentTensorInfo(t972, n502.complexTensors.real),
                this.makeComplexComponentTensorInfo(t972, n502.complexTensors.imag),
                this.makeComplexComponentTensorInfo(e672, r382.complexTensors.real),
                this.makeComplexComponentTensorInfo(e672, r382.complexTensors.imag)
            ], u94 = this.compileAndRun(o261, s119), c73 = this.compileAndRun(a197, s119), l58 = this.complex(u94, c73);
            return u94.dispose(), c73.dispose(), l58;
        }
        if (this.shouldExecuteOnCPU([
            t972,
            e672
        ])) return this.cpuBackend.multiply(t972, e672);
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t972, e672, wi, t972.dtype);
        var h54 = new Ri(wi, t972.shape, e672.shape);
        return this.compileAndRun(h54, [
            t972,
            e672
        ], t972.dtype);
    }, o248.prototype.batchNormalization = function(t973, e673, n503, r383, o262, a198) {
        var s120 = [
            t973,
            e673,
            n503
        ], u95 = null;
        null != a198 && (u95 = a198.shape, s120.push(a198));
        var c74 = null;
        if (null != o262 && (c74 = o262.shape, s120.push(o262)), i().getBool("WEBGL_PACK_NORMALIZATION")) {
            var l59 = new vi(t973.shape, e673.shape, n503.shape, u95, c74, r383);
            return this.compileAndRun(l59, s120);
        }
        var h55 = new pi(t973.shape, e673.shape, n503.shape, u95, c74, r383);
        return this.compileAndRun(h55, s120);
    }, o248.prototype.localResponseNormalization4D = function(t974, e674, n504, r384, o263) {
        var a199 = i().getBool("WEBGL_PACK_NORMALIZATION") ? new Ds(t974.shape, e674, n504, r384, o263) : new As(t974.shape, e674, n504, r384, o263);
        return this.compileAndRun(a199, [
            t974
        ]);
    }, o248.prototype.LRNGrad = function(t975, e675, n505, r385, o264, a200, i138) {
        var s121 = new Ts(e675.shape, r385, o264, a200, i138);
        return this.compileAndRun(s121, [
            e675,
            n505,
            t975
        ]);
    }, o248.prototype.tile = function(t976, e676) {
        if ("string" === t976.dtype) {
            var n506 = this.readSync(t976.dataId).map(function(t977) {
                return ot(t977);
            });
            return Va(er(t976.shape, t976.dtype, n506), e676);
        }
        var r386 = new iu(t976.shape, e676);
        return this.compileAndRun(r386, [
            t976
        ]);
    }, o248.prototype.pad = function(t978, e677, n507) {
        var r387 = i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Ls(t978.shape, e677, n507) : new Ps(t978.shape, e677, n507);
        return this.compileAndRun(r387, [
            t978
        ]);
    }, o248.prototype.gather = function(t979, e678, n508) {
        if (this.shouldExecuteOnCPU([
            t979,
            e678
        ])) return this.cpuBackend.gather(t979, e678, n508);
        var r388 = new as(t979.shape, e678.size, n508);
        return this.compileAndRun(r388, [
            t979,
            e678
        ]);
    }, o248.prototype.batchToSpaceND = function(t980, e679, n509) {
        C(t980.rank <= 4, function() {
            return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet";
        });
        var r389 = e679.reduce(function(t981, e680) {
            return t981 * e680;
        }), o265 = pr(t980.shape, e679, r389), a201 = vr(o265.length, e679.length), i139 = gr(t980.shape, e679, r389), s122 = mr(n509, e679.length), u96 = yr(i139, n509, e679.length);
        return ua(t980.reshape(o265), a201).reshape(i139).slice(s122, u96);
    }, o248.prototype.spaceToBatchND = function(t982, e681, n510) {
        C(t982.rank <= 4, function() {
            return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet";
        });
        var r390 = e681.reduce(function(t983, e682) {
            return t983 * e682;
        }), o266 = [
            [
                0,
                0
            ]
        ];
        o266.push.apply(o266, n510);
        for(var a202 = 1 + e681.length; a202 < t982.shape.length; ++a202)o266.push([
            0,
            0
        ]);
        var i140 = t982.pad(o266), s123 = pr(i140.shape, e681, r390, !1), u97 = vr(s123.length, e681.length, !1), c75 = gr(i140.shape, e681, r390, !1);
        return ua(i140.reshape(s123), u97).reshape(c75);
    }, o248.prototype.reduce = function(t984, e683, n511) {
        var r391 = t984.shape[0], o267 = t984.shape[1], a203 = Uo(o267), i141 = new Vs({
            windowSize: a203,
            inSize: o267,
            batchSize: r391
        }, e683), s124 = this.compileAndRun(i141, [
            t984
        ], n511);
        return 1 === s124.shape[1] ? s124 : this.reduce(s124, e683, n511);
    }, o248.prototype.argReduce = function(t985, e684, n512) {
        void 0 === n512 && (n512 = null);
        var r392 = t985.shape[0], o268 = t985.shape[1];
        null != n512 && (r392 = n512.shape[0], o268 = n512.shape[1]);
        var a204 = Uo(o268), i142 = new Ka({
            windowSize: a204,
            inSize: o268,
            batchSize: r392
        }, e684, null == n512), s125 = [
            t985
        ];
        null != n512 && s125.push(n512);
        var u98 = this.compileAndRun(i142, s125, "int32");
        return 1 === u98.shape[1] ? u98 : this.argReduce(t985, e684, u98);
    }, o248.prototype.argReducePacked = function(t986, e685, n513) {
        void 0 === n513 && (n513 = null);
        var r393 = null != n513 ? n513.shape : t986.shape, o269 = Uo(r393[r393.length - 1]), a205 = new hi(r393, o269, e685, null == n513), i143 = null == n513 ? [
            t986
        ] : [
            t986,
            n513
        ], s126 = this.compileAndRun(a205, i143, "int32");
        return s126.rank === t986.rank ? this.argReducePacked(t986, e685, s126) : s126;
    }, o248.prototype.sum = function(t987, e686) {
        Cn("sum", e686, t987.rank);
        var n514 = bn(t987.shape, e686), r394 = n514[0], o270 = k(n514[1]), a206 = t987.as2D(-1, o270), i144 = Dt(t987.dtype);
        return this.reduce(a206, "sum", i144).reshape(r394);
    }, o248.prototype.prod = function(t988, e687) {
        if (this.shouldExecuteOnCPU([
            t988
        ])) return this.cpuBackend.prod(t988, e687);
        var n515 = bn(t988.shape, e687), r395 = n515[0], o271 = k(n515[1]), a207 = t988.as2D(-1, o271), i145 = Dt(t988.dtype);
        return this.reduce(a207, "prod", i145).reshape(r395);
    }, o248.prototype.unsortedSegmentSum = function(t989, e688, n516) {
        var r396 = 0, o272 = En([
            r396
        ], t989.rank), a208 = t989;
        null != o272 && (a208 = ua(t989, o272), r396 = In(1, t989.rank)[0]);
        var i146 = function(t990, e689, n517) {
            for(var r397 = [], o273 = t990.length, a209 = 0; a209 < o273; a209++)a209 !== e689 ? r397.push(t990[a209]) : r397.push(n517);
            return r397;
        }(a208.shape, r396, n516), s127 = k([
            a208.shape[r396]
        ]), u99 = a208.as2D(-1, s127), c76 = Dt(t989.dtype), l60 = this.segOpCompute(u99, "unsortedSegmentSum", e688, c76, n516).reshape(i146);
        return null != o272 && (l60 = ua(l60, Rn(o272))), l60;
    }, o248.prototype.segOpCompute = function(t991, e690, n518, r398, o274) {
        var a210 = t991.shape[0], i147 = t991.shape[1], s128 = function(t992, e691) {
            var n519, r399 = !1;
            for(t992 <= Wo ? (n519 = t992, r399 = !0) : n519 = Y(t992, Math.floor(Math.sqrt(t992))); !r399;)n519 > e691 || n519 === t992 ? r399 = !0 : n519 = Y(t992, n519 + 1);
            return n519;
        }(i147, o274), u100 = new Qs({
            windowSize: s128,
            inSize: i147,
            batchSize: a210,
            numSegments: o274
        }, e690), c77 = this.compileAndRun(u100, [
            t991,
            n518
        ], r398);
        return c77.shape[1] === o274 ? c77 : (n518 = Kn(0, o274).tile([
            i147 / s128
        ]), this.segOpCompute(c77, e690, n518, r398, o274));
    }, o248.prototype.argMinMaxReduce = function(t993, e692, n520) {
        var r400 = [
            e692
        ];
        if (Cn("arg" + n520.charAt(0).toUpperCase() + n520.slice(1), r400, t993.rank), !i().getBool("WEBGL_PACK_REDUCE") || t993.rank <= 2) {
            var o275 = bn(t993.shape, r400), a211 = o275[0], s129 = k(o275[1]), u101 = t993.as2D(-1, s129);
            return this.argReduce(u101, n520).reshape(a211);
        }
        return this.argReducePacked(t993, n520);
    }, o248.prototype.argMin = function(t994, e693) {
        return this.argMinMaxReduce(t994, e693, "min");
    }, o248.prototype.argMax = function(t995, e694) {
        return this.argMinMaxReduce(t995, e694, "max");
    }, o248.prototype.cumsum = function(t996, e695, n521, r401) {
        if (e695 !== t996.rank - 1) throw new Error("WebGL cumsum shader expects an inner-most axis=" + (t996.rank - 1) + " but got axis=" + e695);
        var o276 = new qi(t996.shape, n521, r401);
        return this.compileAndRun(o276, [
            t996
        ]);
    }, o248.prototype.equal = function(t997, e696) {
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t997, e696, "\n  return vec4(equal(a, b));\n", "bool");
        var n522 = new Ri("return float(a == b);", t997.shape, e696.shape);
        return this.compileAndRun(n522, [
            t997,
            e696
        ], "bool");
    }, o248.prototype.notEqual = function(t998, e697) {
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t998, e697, "\n  return vec4(notEqual(a, b));\n", "bool");
        var n523 = new Ri("return float(a != b);", t998.shape, e697.shape);
        return this.compileAndRun(n523, [
            t998,
            e697
        ], "bool");
    }, o248.prototype.less = function(t999, e698) {
        if (this.shouldExecuteOnCPU([
            t999,
            e698
        ])) return this.cpuBackend.less(t999, e698);
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t999, e698, "\n  return vec4(lessThan(a, b));\n", "bool");
        var n524 = new Ri("return float(a < b);", t999.shape, e698.shape);
        return this.compileAndRun(n524, [
            t999,
            e698
        ], "bool");
    }, o248.prototype.lessEqual = function(t1000, e699) {
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t1000, e699, "\n  return vec4(lessThanEqual(a, b));\n", "bool");
        var n525 = new Ri("return float(a <= b);", t1000.shape, e699.shape);
        return this.compileAndRun(n525, [
            t1000,
            e699
        ], "bool");
    }, o248.prototype.greater = function(t1001, e700) {
        if (this.shouldExecuteOnCPU([
            t1001,
            e700
        ])) return this.cpuBackend.greater(t1001, e700);
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t1001, e700, "\n  return vec4(greaterThan(a, b));\n", "bool");
        var n526 = new Ri("return float(a > b);", t1001.shape, e700.shape);
        return this.compileAndRun(n526, [
            t1001,
            e700
        ], "bool");
    }, o248.prototype.greaterEqual = function(t1002, e701) {
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t1002, e701, "\n  return vec4(greaterThanEqual(a, b));\n", "bool");
        var n527 = new Ri("return float(a >= b);", t1002.shape, e701.shape);
        return this.compileAndRun(n527, [
            t1002,
            e701
        ], "bool");
    }, o248.prototype.logicalNot = function(t1003) {
        var e702 = new cu(t1003.shape, "return float(!(x >= 1.0));");
        return this.compileAndRun(e702, [
            t1003
        ]);
    }, o248.prototype.logicalAnd = function(t1004, e703) {
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t1004, e703, "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n", "bool");
        var n528 = new Ri("return float(a >= 1.0 && b >= 1.0);", t1004.shape, e703.shape);
        return this.compileAndRun(n528, [
            t1004,
            e703
        ], "bool");
    }, o248.prototype.logicalOr = function(t1005, e704) {
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t1005, e704, "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n", "bool");
        var n529 = new Ri("return float(a >= 1.0 || b >= 1.0);", t1005.shape, e704.shape);
        return this.compileAndRun(n529, [
            t1005,
            e704
        ], "bool");
    }, o248.prototype.select = function(t1006, e705, n530) {
        var r402 = new Js(t1006.rank, e705.shape, e705.rank);
        return this.compileAndRun(r402, [
            t1006,
            e705,
            n530
        ], Tt(e705.dtype, n530.dtype));
    }, o248.prototype.where = function(t1007) {
        dn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
        var e706 = t1007.dataSync();
        return Ga(t1007.shape, e706);
    }, o248.prototype.topk = function(t1008, e707, n) {
        return za(t1008.dataSync(), t1008.shape, t1008.dtype, e707);
    }, o248.prototype.min = function(t1009, e708) {
        Cn("min", e708, t1009.rank);
        var n531 = bn(t1009.shape, e708), r403 = n531[0], o277 = k(n531[1]), a212 = t1009.as2D(-1, o277);
        return this.reduce(a212, "min", a212.dtype).reshape(r403);
    }, o248.prototype.minimum = function(t1010, e709) {
        if (this.shouldExecuteOnCPU([
            t1010,
            e709
        ])) return this.cpuBackend.minimum(t1010, e709);
        var n532 = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Si("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t1010.shape, e709.shape) : new Ri("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n", t1010.shape, e709.shape);
        return this.compileAndRun(n532, [
            t1010,
            e709
        ]);
    }, o248.prototype.mod = function(t1011, e710) {
        var n533 = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Si("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t1011.shape, e710.shape) : new Ri("if (b == 0.0) return NAN;\n  return mod(a, b);", t1011.shape, e710.shape);
        return this.compileAndRun(n533, [
            t1011,
            e710
        ]);
    }, o248.prototype.max = function(t1012, e711) {
        if (this.shouldExecuteOnCPU([
            t1012
        ])) return this.cpuBackend.max(t1012, e711);
        Cn("max", e711, t1012.rank);
        var n534 = bn(t1012.shape, e711), r404 = n534[0], o278 = k(n534[1]), a213 = t1012.as2D(-1, o278);
        return this.reduce(a213, "max", a213.dtype).reshape(r404);
    }, o248.prototype.maximum = function(t1013, e712) {
        if (this.shouldExecuteOnCPU([
            t1013,
            e712
        ])) return this.cpuBackend.maximum(t1013, e712);
        var n535 = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Si("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t1013.shape, e712.shape) : new Ri("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n", t1013.shape, e712.shape);
        return this.compileAndRun(n535, [
            t1013,
            e712
        ]);
    }, o248.prototype.all = function(t1014, e713) {
        Cn("all", e713, t1014.rank);
        var n536 = bn(t1014.shape, e713), r405 = n536[0], o279 = k(n536[1]), a214 = t1014.as2D(-1, o279);
        return this.reduce(a214, "all", a214.dtype).reshape(r405);
    }, o248.prototype.any = function(t1015, e714) {
        Cn("any", e714, t1015.rank);
        var n537 = bn(t1015.shape, e714), r406 = n537[0], o280 = k(n537[1]), a215 = t1015.as2D(-1, o280);
        return this.reduce(a215, "any", a215.dtype).reshape(r406);
    }, o248.prototype.floorDiv = function(t1016, e715) {
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t1016, e715, "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n", "int32");
        var n538 = new Ri("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n", t1016.shape, e715.shape);
        return this.compileAndRun(n538, [
            t1016,
            e715
        ], "int32");
    }, o248.prototype.add = function(t1017, e716) {
        if ("complex64" === t1017.dtype && "complex64" === e716.dtype) return this.complexSeparableBinaryOp(t1017, e716, xi);
        if (this.shouldExecuteOnCPU([
            t1017,
            e716
        ])) return this.cpuBackend.add(t1017, e716);
        var n539 = Tt(t1017.dtype, e716.dtype);
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t1017, e716, xi, n539);
        var r407 = new Ri(xi, t1017.shape, e716.shape);
        return this.compileAndRun(r407, [
            t1017,
            e716
        ], n539);
    }, o248.prototype.packedUnaryOp = function(t1018, e717, n540) {
        var r408 = new Mu(t1018.shape, e717);
        return this.compileAndRun(r408, [
            t1018
        ], n540);
    }, o248.prototype.packedBinaryOp = function(t1019, e718, n541, r409, o281) {
        void 0 === o281 && (o281 = !1);
        var a216 = new Si(n541, t1019.shape, e718.shape, o281);
        return this.compileAndRun(a216, [
            t1019,
            e718
        ], r409);
    }, o248.prototype.complexSeparableBinaryOp = function(t1020, e719, n542) {
        var r410 = this, o282 = this.texData.get(t1020.dataId), a217 = this.texData.get(e719.dataId), i148 = [
            [
                o282.complexTensors.real,
                a217.complexTensors.real
            ],
            [
                o282.complexTensors.imag,
                a217.complexTensors.imag
            ]
        ].map(function(o283) {
            var a218 = o283[0], i149 = o283[1], s131 = r410.makeComplexComponentTensorInfo(t1020, a218), u103 = r410.makeComplexComponentTensorInfo(e719, i149), c79 = new Ri(n542, t1020.shape, e719.shape);
            return r410.compileAndRun(c79, [
                s131,
                u103
            ], Tt(a218.dtype, i149.dtype));
        }), s130 = i148[0], u102 = i148[1], c78 = this.complex(s130, u102);
        return s130.dispose(), u102.dispose(), c78;
    }, o248.prototype.makeComplexComponentTensorInfo = function(t1021, e720) {
        return {
            dataId: e720.dataId,
            dtype: e720.dtype,
            shape: t1021.shape
        };
    }, o248.prototype.addN = function(t1022) {
        if (1 === t1022.length) return t1022[0];
        if (t1022.length > i().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
            var e721 = Math.floor(t1022.length / 2), n543 = this.addN(t1022.slice(0, e721)), r411 = this.addN(t1022.slice(e721));
            return this.addN([
                n543,
                r411
            ]);
        }
        var o284 = t1022.map(function(t1023) {
            return t1023.dtype;
        }).reduce(function(t1024, e722) {
            return Tt(t1024, e722);
        }), a219 = t1022.map(function(t1025) {
            return t1025.shape;
        }), s132 = i().getBool("WEBGL_PACK") ? new qa(t1022[0].shape, a219) : new Ha(t1022[0].shape, a219);
        return this.compileAndRun(s132, t1022, o284);
    }, o248.prototype.subtract = function(t1026, e723) {
        if ("complex64" === t1026.dtype && "complex64" === e723.dtype) return this.complexSeparableBinaryOp(t1026, e723, bi);
        if (this.shouldExecuteOnCPU([
            t1026,
            e723
        ])) return this.cpuBackend.subtract(t1026, e723);
        var n544 = Tt(t1026.dtype, e723.dtype);
        if (i().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t1026, e723, bi, t1026.dtype);
        var r412 = new Ri(bi, t1026.shape, e723.shape);
        return this.compileAndRun(r412, [
            t1026,
            e723
        ], n544);
    }, o248.prototype.pow = function(t1027, e724) {
        var n545 = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Si("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t1027.shape, e724.shape) : new Ri("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n", t1027.shape, e724.shape), r413 = Tt(t1027.dtype, e724.dtype);
        return this.compileAndRun(n545, [
            t1027,
            e724
        ], r413);
    }, o248.prototype.ceil = function(t1028) {
        if (this.shouldExecuteOnCPU([
            t1028
        ])) return this.cpuBackend.ceil(t1028);
        if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t1028, yu, t1028.dtype);
        var e725 = new cu(t1028.shape, yu);
        return this.compileAndRun(e725, [
            t1028
        ]);
    }, o248.prototype.floor = function(t1029) {
        if (this.shouldExecuteOnCPU([
            t1029
        ])) return this.cpuBackend.floor(t1029);
        if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t1029, xu, t1029.dtype);
        var e726 = new cu(t1029.shape, xu);
        return this.compileAndRun(e726, [
            t1029
        ]);
    }, o248.prototype.sign = function(t1030) {
        var e727 = new cu(t1030.shape, "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");
        return this.compileAndRun(e727, [
            t1030
        ]);
    }, o248.prototype.isNaN = function(t1031) {
        var e728 = new cu(t1031.shape, "return float(isnan(x));");
        return this.compileAndRun(e728, [
            t1031
        ], "bool");
    }, o248.prototype.isInf = function(t1032) {
        var e729 = new cu(t1032.shape, "return float(isinf(x));");
        return this.compileAndRun(e729, [
            t1032
        ], "bool");
    }, o248.prototype.isFinite = function(t1033) {
        var e730 = new cu(t1033.shape, "return float(!isnan(x) && !isinf(x));");
        return this.compileAndRun(e730, [
            t1033
        ], "bool");
    }, o248.prototype.round = function(t1034) {
        var e731 = new cu(t1034.shape, "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");
        return this.compileAndRun(e731, [
            t1034
        ]);
    }, o248.prototype.exp = function(t1035) {
        if (this.shouldExecuteOnCPU([
            t1035
        ])) return this.cpuBackend.exp(t1035);
        if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t1035, bu, t1035.dtype);
        var e732 = new cu(t1035.shape, bu);
        return this.compileAndRun(e732, [
            t1035
        ]);
    }, o248.prototype.expm1 = function(t1036) {
        if (this.shouldExecuteOnCPU([
            t1036
        ])) return this.cpuBackend.expm1(t1036);
        if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t1036, wu, t1036.dtype);
        var e733 = new cu(t1036.shape, wu);
        return this.compileAndRun(e733, [
            t1036
        ]);
    }, o248.prototype.softmax = function(t1037, e734) {
        var n546 = O([
            e734
        ], t1037.shape), r414 = this.max(t1037, n546), o285 = wn(r414.shape, n546), a220 = this.subtract(t1037, r414.reshape(o285)), i150 = this.exp(a220), s133 = this.sum(i150, n546).reshape(o285);
        return Bo(i150, s133);
    }, o248.prototype.log = function(t1038) {
        if (this.shouldExecuteOnCPU([
            t1038
        ])) return this.cpuBackend.log(t1038);
        if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t1038, "\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n", t1038.dtype);
        var e735 = new cu(t1038.shape, "if (x < 0.0) return NAN;\n  return log(x);");
        return this.compileAndRun(e735, [
            t1038
        ]);
    }, o248.prototype.log1p = function(t1039) {
        var e736 = new cu(t1039.shape, "return log(1.0 + x);");
        return this.compileAndRun(e736, [
            t1039
        ]);
    }, o248.prototype.sqrt = function(t1040) {
        var e737 = new cu(t1040.shape, "return sqrt(x);");
        return this.compileAndRun(e737, [
            t1040
        ]);
    }, o248.prototype.rsqrt = function(t1041) {
        if (this.shouldExecuteOnCPU([
            t1041
        ])) return this.cpuBackend.rsqrt(t1041);
        var e738 = new cu(t1041.shape, "return inversesqrt(x);");
        return this.compileAndRun(e738, [
            t1041
        ]);
    }, o248.prototype.reciprocal = function(t1042) {
        var e739 = new cu(t1042.shape, "return 1.0 / x;");
        return this.compileAndRun(e739, [
            t1042
        ]);
    }, o248.prototype.relu = function(t1043) {
        var e740;
        return e740 = i().getBool("WEBGL_PACK") ? new Mu(t1043.shape, Fu) : new cu(t1043.shape, du), this.compileAndRun(e740, [
            t1043
        ]);
    }, o248.prototype.relu6 = function(t1044) {
        var e741;
        return e741 = i().getBool("WEBGL_PACK") ? new Mu(t1044.shape, _u) : new cu(t1044.shape, pu), this.compileAndRun(e741, [
            t1044
        ]);
    }, o248.prototype.prelu = function(t1045, e742) {
        var n547 = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Si(ki, t1045.shape, e742.shape) : new Ri(Ei, t1045.shape, e742.shape);
        return this.compileAndRun(n547, [
            t1045,
            e742
        ]);
    }, o248.prototype.elu = function(t1046) {
        if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t1046, Ou, t1046.dtype);
        var e743 = new cu(t1046.shape, vu);
        return this.compileAndRun(e743, [
            t1046
        ]);
    }, o248.prototype.eluDer = function(t1047, e744) {
        var n548 = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Si("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", t1047.shape, e744.shape) : new Ri("return (b >= 1.0) ? a : a * (b + 1.0);", t1047.shape, e744.shape);
        return this.compileAndRun(n548, [
            t1047,
            e744
        ]);
    }, o248.prototype.selu = function(t1048) {
        var e745 = new cu(t1048.shape, gu);
        return this.compileAndRun(e745, [
            t1048
        ]);
    }, o248.prototype.int = function(t1049) {
        var e746 = new cu(t1049.shape, "return float(int(x));");
        return this.compileAndRun(e746, [
            t1049
        ], "int32");
    }, o248.prototype.clip = function(t1050, e747, n549) {
        var r415, o286 = (r415 = i().getBool("WEBGL_PACK_CLIP") ? new Ti(t1050.shape) : new Ai(t1050.shape)).getCustomSetupFunc(e747, n549);
        return this.compileAndRun(r415, [
            t1050
        ], null, o286);
    }, o248.prototype.abs = function(t1051) {
        if (this.shouldExecuteOnCPU([
            t1051
        ])) return this.cpuBackend.abs(t1051);
        if (i().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t1051, fu, t1051.dtype);
        var e748 = new cu(t1051.shape, fu);
        return this.compileAndRun(e748, [
            t1051
        ]);
    }, o248.prototype.complexAbs = function(t1052) {
        var e749 = this.texData.get(t1052.dataId), n550 = new Di(t1052.shape), r416 = [
            this.makeComplexComponentTensorInfo(t1052, e749.complexTensors.real),
            this.makeComplexComponentTensorInfo(t1052, e749.complexTensors.imag)
        ];
        return this.compileAndRun(n550, r416);
    }, o248.prototype.sigmoid = function(t1053) {
        var e750 = new cu(t1053.shape, "return 1.0 / (1.0 + exp(-1.0 * x));");
        return this.compileAndRun(e750, [
            t1053
        ]);
    }, o248.prototype.softplus = function(t1054) {
        var e751 = new cu(t1054.shape, "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");
        return this.compileAndRun(e751, [
            t1054
        ]);
    }, o248.prototype.sin = function(t1055) {
        var e752 = new cu(t1055.shape, Cu);
        return this.compileAndRun(e752, [
            t1055
        ]);
    }, o248.prototype.cos = function(t1056) {
        var e753 = new cu(t1056.shape, Eu);
        return this.compileAndRun(e753, [
            t1056
        ]);
    }, o248.prototype.tan = function(t1057) {
        var e754 = new cu(t1057.shape, "return tan(x);");
        return this.compileAndRun(e754, [
            t1057
        ]);
    }, o248.prototype.asin = function(t1058) {
        var e755 = new cu(t1058.shape, Ru);
        return this.compileAndRun(e755, [
            t1058
        ]);
    }, o248.prototype.acos = function(t1059) {
        var e756 = new cu(t1059.shape, Iu);
        return this.compileAndRun(e756, [
            t1059
        ]);
    }, o248.prototype.atan = function(t1060) {
        var e757 = new cu(t1060.shape, ku);
        return this.compileAndRun(e757, [
            t1060
        ]);
    }, o248.prototype.atan2 = function(t1061, e758) {
        var n551 = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Si("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t1061.shape, e758.shape) : new Ri("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n", t1061.shape, e758.shape);
        return this.compileAndRun(n551, [
            t1061,
            e758
        ]);
    }, o248.prototype.sinh = function(t1062) {
        var e759 = new cu(t1062.shape, "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");
        return this.compileAndRun(e759, [
            t1062
        ]);
    }, o248.prototype.cosh = function(t1063) {
        var e760 = new cu(t1063.shape, "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");
        return this.compileAndRun(e760, [
            t1063
        ]);
    }, o248.prototype.tanh = function(t1064) {
        var e761 = new cu(t1064.shape, "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");
        return this.compileAndRun(e761, [
            t1064
        ]);
    }, o248.prototype.asinh = function(t1065) {
        var e762 = new cu(t1065.shape, Su);
        return this.compileAndRun(e762, [
            t1065
        ]);
    }, o248.prototype.acosh = function(t1066) {
        var e763 = new cu(t1066.shape, Au);
        return this.compileAndRun(e763, [
            t1066
        ]);
    }, o248.prototype.atanh = function(t1067) {
        var e764 = new cu(t1067.shape, Tu);
        return this.compileAndRun(e764, [
            t1067
        ]);
    }, o248.prototype.erf = function(t1068) {
        var e765 = new cu(t1068.shape, '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n');
        return this.compileAndRun(e765, [
            t1068
        ]);
    }, o248.prototype.step = function(t1069, e766) {
        var n552 = new cu(t1069.shape, function(t1070) {
            return void 0 === t1070 && (t1070 = 0), lu + "\n    return x > 0.0 ? 1.0 : float(" + t1070 + ");\n  ";
        }(e766));
        return this.compileAndRun(n552, [
            t1069
        ]);
    }, o248.prototype.conv2dByMatMul = function(t1071, e767, n553, r417, o287, a221) {
        var s134 = t1071.shape, u104 = this.texData.get(t1071.dataId), c80 = n553.inChannels, l61 = s134[0] * s134[1] * s134[2], h56 = n553.outChannels, f48 = "channelsLast" === n553.dataFormat, d42 = (1 === l61 || 1 === h56) && c80 > 1000, p38 = s134[2] % 2 != 0 && !!u104.isPacked;
        if (d42 || !i().getBool("WEBGL_LAZILY_UNPACK") || !i().getBool("WEBGL_PACK_BINARY_OPERATIONS") || !p38) {
            var v33 = f48 ? s134[0] * s134[1] * s134[2] : s134[0] * s134[2] * s134[3], g28 = this.reshape(t1071, [
                1,
                v33,
                n553.inChannels
            ]), m20 = this.reshape(e767, [
                1,
                n553.inChannels,
                n553.outChannels
            ]);
            return this.reshape(this.fusedBatchMatMul({
                a: g28,
                b: m20,
                transposeA: !1,
                transposeB: !1,
                bias: r417,
                activation: o287,
                preluActivationWeights: a221
            }), n553.outShape);
        }
        var y15 = f48 ? s134[0] * s134[1] * (s134[2] + 1) : s134[0] * s134[2] * (s134[3] + 1), x16 = {
            dataId: t1071.dataId,
            shape: [
                1,
                y15,
                n553.inChannels
            ],
            dtype: t1071.dtype
        }, b12 = u104.shape;
        u104.shape = u104.shape.slice(), u104.shape[u104.shape.length - 2]++, C(_e(u104.shape, x16.shape), function() {
            return "packed reshape " + u104.shape + " to " + x16.shape + " isn't free";
        });
        var w12 = this.reshape(e767, [
            1,
            n553.inChannels,
            n553.outChannels
        ]), E9 = this.fusedBatchMatMul({
            a: x16,
            b: w12,
            transposeA: !1,
            transposeB: !1,
            bias: r417,
            activation: o287,
            preluActivationWeights: a221
        }), R6 = this.texData.get(E9.dataId);
        return C(R6.isPacked, function() {
            return "batchMatMul result is expected to be packed";
        }), u104.shape = b12, R6.shape = n553.outShape, Lt.makeTensorFromDataId(E9.dataId, n553.outShape, E9.dtype);
    }, o248.prototype.conv2dWithIm2Row = function(t1072, e768, n554, r418, o288, a222) {
        var i151 = n554.filterWidth, s135 = n554.filterHeight, u105 = n554.inChannels, c81 = n554.outWidth, l62 = n554.outHeight, h57 = "channelsLast" === n554.dataFormat, f49 = i151 * s135 * u105, d43 = l62 * c81, p39 = [
            f49,
            d43
        ], v34 = t1072.squeeze([
            0
        ]), g29 = e768.reshape([
            1,
            f49,
            -1
        ]), m21 = new Ss(p39, v34.shape, n554), y16 = this.compileAndRun(m21, [
            v34
        ]).reshape([
            1,
            p39[0],
            p39[1]
        ]), x17 = null != r418, b13 = null != a222, w13 = o288 ? Lu(o288, !0) : null, C5 = new _s(y16.shape, [
            1,
            d43,
            n554.outChannels
        ], !0, !1, x17, w13, b13), E10 = [
            y16,
            g29
        ];
        r418 && E10.push(r418), b13 && E10.push(a222);
        var R7 = this.compileAndRun(C5, E10);
        return h57 ? R7.reshape([
            1,
            l62,
            c81,
            n554.outChannels
        ]) : R7.reshape([
            1,
            n554.outChannels,
            l62,
            c81
        ]);
    }, o248.prototype.fusedConv2d = function(t1073) {
        var e769 = t1073.input, n555 = t1073.filter, r419 = t1073.convInfo, o289 = t1073.bias, a223 = t1073.activation, s136 = t1073.preluActivationWeights;
        if (1 === r419.filterHeight && 1 === r419.filterWidth && 1 === r419.dilationHeight && 1 === r419.dilationWidth && 1 === r419.strideHeight && 1 === r419.strideWidth && ("SAME" === r419.padInfo.type || "VALID" === r419.padInfo.type)) return this.conv2dByMatMul(e769, n555, r419, o289, a223, s136);
        if (i().getBool("WEBGL_CONV_IM2COL") && 1 === e769.shape[0]) return this.conv2dWithIm2Row(e769, n555, r419, o289, a223, s136);
        var u106 = null != o289, c82 = null != s136, l63 = a223 ? Lu(a223, !1) : null, h58 = new Ui(r419, u106, l63, c82), f50 = [
            e769,
            n555
        ];
        return o289 && f50.push(o289), s136 && f50.push(s136), this.compileAndRun(h58, f50);
    }, o248.prototype.conv2d = function(t1074, e770, n556) {
        if (1 === n556.filterHeight && 1 === n556.filterWidth && 1 === n556.dilationHeight && 1 === n556.dilationWidth && 1 === n556.strideHeight && 1 === n556.strideWidth && ("SAME" === n556.padInfo.type || "VALID" === n556.padInfo.type)) return this.conv2dByMatMul(t1074, e770, n556);
        if (i().getBool("WEBGL_CONV_IM2COL") && 1 === t1074.shape[0]) return this.conv2dWithIm2Row(t1074, e770, n556);
        var r420 = new Ui(n556);
        return this.compileAndRun(r420, [
            t1074,
            e770
        ]);
    }, o248.prototype.conv2dDerInput = function(t1075, e771, n557) {
        var r421 = new Mi(n557);
        return this.compileAndRun(r421, [
            t1075,
            e771
        ]);
    }, o248.prototype.conv2dDerFilter = function(t1076, e772, n558) {
        var r422 = new Oi(n558);
        return this.compileAndRun(r422, [
            t1076,
            e772
        ]);
    }, o248.prototype.fusedDepthwiseConv2D = function(t1077) {
        var e773, n559 = t1077.input, r423 = t1077.filter, o290 = t1077.convInfo, a224 = t1077.bias, s137 = t1077.activation, u107 = t1077.preluActivationWeights, c83 = i().getBool("WEBGL_PACK_DEPTHWISECONV") && o290.strideWidth <= 2 && o290.outChannels / o290.inChannels == 1, l64 = s137 ? Lu(s137, c83) : null, h59 = [
            n559,
            r423
        ], f51 = null != a224, d44 = null != u107;
        return f51 && h59.push(a224), d44 && h59.push(u107), c83 ? (e773 = new Gi(o290, f51, l64, d44), this.compileAndRun(e773, h59)) : (e773 = new zi(o290, f51, l64, d44), this.compileAndRun(e773, h59));
    }, o248.prototype.depthwiseConv2D = function(t1078, e774, n560) {
        var r424;
        return i().getBool("WEBGL_PACK_DEPTHWISECONV") && n560.strideWidth <= 2 && n560.outChannels / n560.inChannels == 1 ? (r424 = new Gi(n560), this.compileAndRun(r424, [
            t1078,
            e774
        ])) : (r424 = new zi(n560), this.compileAndRun(r424, [
            t1078,
            e774
        ]));
    }, o248.prototype.depthwiseConv2DDerInput = function(t1079, e775, n561) {
        var r425 = new Wi(n561);
        return this.compileAndRun(r425, [
            t1079,
            e775
        ]);
    }, o248.prototype.depthwiseConv2DDerFilter = function(t1080, e776, n562) {
        var r426 = new Li(n562);
        return this.compileAndRun(r426, [
            t1080,
            e776
        ]);
    }, o248.prototype.conv3d = function(t1081, e777, n563) {
        var r427 = new Vi(n563);
        return this.compileAndRun(r427, [
            t1081,
            e777
        ]);
    }, o248.prototype.conv3dDerInput = function(t1082, e778, n564) {
        var r428 = new Pi(n564);
        return this.compileAndRun(r428, [
            t1082,
            e778
        ]);
    }, o248.prototype.conv3dDerFilter = function(t1083, e779, n565) {
        var r429 = new Bi(n565);
        return this.compileAndRun(r429, [
            t1083,
            e779
        ]);
    }, o248.prototype.maxPool = function(t1084, e780) {
        var n566 = new Ws(e780, "max", !1);
        return this.compileAndRun(n566, [
            t1084
        ]);
    }, o248.prototype.avgPool = function(t1085, e781) {
        var n567 = new Ws(e781, "avg", !1);
        return this.compileAndRun(n567, [
            t1085
        ], "float32");
    }, o248.prototype.maxPoolBackprop = function(t1086, e782, n, r430) {
        var o291 = new Ws(r430, "max", !0), a225 = this.compileAndRun(o291, [
            e782
        ]), i152 = new Ns(r430), s138 = this.compileAndRun(i152, [
            t1086,
            a225
        ], e782.dtype);
        return a225.dispose(), s138;
    }, o248.prototype.avgPoolBackprop = function(t1087, e783, n568) {
        var r431 = new fi(n568);
        return this.compileAndRun(r431, [
            t1087
        ], e783.dtype);
    }, o248.prototype.cast = function(t1088, e784) {
        return Ra(t1088, e784, this);
    }, o248.prototype.unstack = function(t1089, e785) {
        for(var n569 = t1089.shape[e785], r432 = new Array(t1089.rank - 1), o = 0, a226 = 0; a226 < t1089.rank; a226++)a226 !== e785 && (r432[o++] = t1089.shape[a226]);
        var i153 = new Array(t1089.rank).fill(0), s139 = t1089.shape.slice();
        s139[e785] = 1;
        var u108 = new Array(n569);
        for(a226 = 0; a226 < u108.length; a226++)i153[e785] = a226, u108[a226] = this.slice(t1089, i153, s139).reshape(r432);
        return u108;
    }, o248.prototype.avgPool3d = function(t1090, e786) {
        var n570 = new Us(e786, "avg", !1);
        return this.compileAndRun(n570, [
            t1090
        ], "float32");
    }, o248.prototype.avgPool3dBackprop = function(t1091, e787, n571) {
        var r433 = new di(n571);
        return this.compileAndRun(r433, [
            t1091
        ], e787.dtype);
    }, o248.prototype.maxPool3d = function(t1092, e788) {
        var n572 = new Us(e788, "max", !1);
        return this.compileAndRun(n572, [
            t1092
        ], "float32");
    }, o248.prototype.maxPool3dBackprop = function(t1093, e789, n, r434) {
        var o292 = new Us(r434, "max", !0), a227 = this.compileAndRun(o292, [
            e789
        ]), i154 = new Fs(r434), s140 = this.compileAndRun(i154, [
            t1093,
            a227
        ], e789.dtype);
        return a227.dispose(), s140;
    }, o248.prototype.reshape = function(t1094, e790) {
        var n573 = this.texData.get(t1094.dataId);
        if (n573.isPacked && !_e(t1094.shape, e790) && (null === n573.texture || !_e(n573.shape, e790))) {
            var r435 = this.packedReshape(t1094, e790);
            return Lt.makeTensorFromDataId(r435.dataId, r435.shape, r435.dtype);
        }
        return Ia(t1094, e790);
    }, o248.prototype.resizeBilinear = function(t1095, e791, n574, r436) {
        var o293 = i().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new qs(t1095.shape, e791, n574, r436) : new Hs(t1095.shape, e791, n574, r436);
        return this.compileAndRun(o293, [
            t1095
        ], "float32");
    }, o248.prototype.resizeBilinearBackprop = function(t1096, e792, n575) {
        var r437 = new Gs(t1096, e792, n575);
        return this.compileAndRun(r437, [
            t1096
        ]);
    }, o248.prototype.resizeNearestNeighbor = function(t1097, e793, n576, r438) {
        var o294 = new js(t1097.shape, e793, n576, r438);
        return this.compileAndRun(o294, [
            t1097
        ]);
    }, o248.prototype.resizeNearestNeighborBackprop = function(t1098, e794, n577) {
        var r439 = new Ks(t1098, e794, n577);
        return this.compileAndRun(r439, [
            t1098
        ]);
    }, o248.prototype.multinomial = function(t1099, e795, n578, r440) {
        var o295 = e795 ? t1099 : ia(t1099), a228 = o295.shape[0], i155 = o295.shape[1], s141 = new Os(a228, i155, n578), u109 = s141.getCustomSetupFunc(r440);
        return this.compileAndRun(s141, [
            o295
        ], "int32", u109);
    }, o248.prototype.oneHot = function(t1100, e796, n579, r441) {
        var o296 = new Ms(t1100.size, e796, n579, r441);
        return this.compileAndRun(o296, [
            t1100
        ]);
    }, o248.prototype.diag = function(t1101) {
        var e797 = new $i(t1101.size);
        return this.compileAndRun(e797, [
            t1101
        ]);
    }, o248.prototype.nonMaxSuppression = function(t1102, e798, n580, r442, o297) {
        return dn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"), Oa(t1102.dataSync(), e798.dataSync(), n580, r442, o297);
    }, o248.prototype.cropAndResize = function(t1103, e799, n581, r443, o298, a229) {
        var i156 = new Hi(t1103.shape, e799.shape, r443, o298, a229);
        return this.compileAndRun(i156, [
            t1103,
            e799,
            n581
        ], "float32");
    }, o248.prototype.depthToSpace = function(t1104, e800, n582) {
        C(e800 > 1, function() {
            return "blockSize should be > 1 for depthToSpace, but was: " + e800;
        });
        var r444 = t1104.shape[0], o299 = "NHWC" === n582 ? t1104.shape[1] : t1104.shape[2], a230 = "NHWC" === n582 ? t1104.shape[2] : t1104.shape[3], i157 = "NHWC" === n582 ? t1104.shape[3] : t1104.shape[1], s142 = o299 * e800, u110 = a230 * e800, c84 = i157 / (e800 * e800), l65 = new Yi("NHWC" === n582 ? [
            r444,
            s142,
            u110,
            c84
        ] : [
            r444,
            c84,
            s142,
            u110
        ], e800, n582);
        return this.compileAndRun(l65, [
            t1104
        ]);
    }, o248.prototype.split = function(t1105, e801, n583) {
        return Ua(t1105, e801, n583);
    }, o248.prototype.scatterND = function(t1106, e802, n584) {
        var r445 = Go(0, t1106, n584), o300 = r445.sliceRank, a231 = r445.numUpdates, i158 = r445.sliceSize, s143 = r445.strides, u111 = r445.outputSize, c85 = [
            u111 / i158,
            i158
        ], l66 = t1106.reshape([
            a231,
            o300
        ]), h60 = e802.reshape([
            a231,
            i158
        ]);
        if (0 === u111) return Ia(Fn([]), n584);
        var f52 = On(0), d45 = new $s(a231, o300, l66.rank, h60.rank, s143, c85);
        return this.compileAndRun(d45, [
            h60,
            l66,
            f52
        ]).reshape(n584);
    }, o248.prototype.sparseToDense = function(t1107, e803, n585, r446) {
        var o301 = Go(0, t1107, n585), a232 = o301.sliceRank, i159 = o301.numUpdates, s144 = o301.strides, u112 = o301.outputSize, c86 = new $s(i159, a232, t1107.rank, e803.rank, s144, [
            u112,
            1
        ], !1);
        return this.compileAndRun(c86, [
            e803,
            t1107,
            r446
        ]).reshape(n585);
    }, o248.prototype.fft = function(t1108) {
        return this.fftImpl(t1108, !1);
    }, o248.prototype.ifft = function(t1109) {
        return this.fftImpl(t1109, !0);
    }, o248.prototype.fftImpl = function(t1110, e804) {
        var n586 = this.texData.get(t1110.dataId), r447 = new rs(es, t1110.shape, e804), o302 = new rs(ns, t1110.shape, e804), a233 = [
            this.makeComplexComponentTensorInfo(t1110, n586.complexTensors.real),
            this.makeComplexComponentTensorInfo(t1110, n586.complexTensors.imag)
        ], i160 = this.compileAndRun(r447, a233), s145 = this.compileAndRun(o302, a233), u113 = this.complex(i160, s145).as2D(t1110.shape[0], t1110.shape[1]);
        return i160.dispose(), s145.dispose(), u113;
    }, o248.prototype.gatherND = function(t1111, e805) {
        var n587 = e805.shape, r448 = n587[n587.length - 1], o303 = Po(t1111, e805), a234 = o303[0], i161 = o303[1], s146 = o303[2], u114 = o303[3], c87 = e805.reshape([
            i161,
            r448
        ]), l67 = t1111.reshape([
            t1111.size / s146,
            s146
        ]), h61 = new is(r448, u114, [
            i161,
            s146
        ]);
        return this.compileAndRun(h61, [
            l67,
            c87
        ]).reshape(a234);
    }, o248.prototype.fill = function(t1112, e806, n588) {
        if ("string" === (n588 = n588 || j(e806))) {
            var r449 = P(n588, k(t1112));
            return r449.fill(e806), Lt.makeTensor(r449, t1112, n588, this);
        }
        var o304 = new os(t1112, e806), a235 = o304.getCustomSetupFunc(e806);
        return this.compileAndRun(o304, [], n588, a235);
    }, o248.prototype.onesLike = function(t1113) {
        if ("string" === t1113.dtype) throw new Error("onesLike is not supported under string dtype");
        return this.fill(t1113.shape, 1, t1113.dtype);
    }, o248.prototype.zerosLike = function(t1114) {
        return this.fill(t1114.shape, "string" === t1114.dtype ? "" : 0, t1114.dtype);
    }, o248.prototype.linspace = function(t1115, e807, n589) {
        return ka(t1115, e807, n589);
    }, o248.prototype.makeTensorInfo = function(t1116, e808) {
        var n590 = this.write(null, t1116, e808);
        return this.texData.get(n590).usage = null, {
            dataId: n590,
            shape: t1116,
            dtype: e808
        };
    }, o248.prototype.makeOutput = function(t1117, e809) {
        var n591 = this.makeTensorInfo(t1117, e809).dataId;
        return Lt.makeTensorFromDataId(n591, t1117, e809, this);
    }, o248.prototype.unpackTensor = function(t1118) {
        var e810 = new Bu(t1118.shape);
        return this.runWebGLProgram(e810, [
            t1118
        ], t1118.dtype);
    }, o248.prototype.packTensor = function(t1119) {
        var e811 = new Bs(t1119.shape);
        return this.runWebGLProgram(e811, [
            t1119
        ], t1119.dtype, null, !0);
    }, o248.prototype.packedReshape = function(t1120, e812) {
        var n592 = [
            Ae(t1120.shape)
        ].concat(Te(t1120.shape)), r450 = {
            dtype: t1120.dtype,
            shape: n592,
            dataId: t1120.dataId
        }, o305 = [
            Ae(e812)
        ].concat(Te(e812)), a236 = new zs(o305, n592), i162 = this.runWebGLProgram(a236, [
            r450
        ], t1120.dtype, null, !0);
        return {
            dataId: i162.dataId,
            shape: e812,
            dtype: i162.dtype
        };
    }, o248.prototype.decode = function(t1121) {
        var e813, n593 = this.texData.get(t1121), r451 = n593.isPacked, o306 = n593.shape, a237 = n593.dtype, i163 = De(o306);
        e813 = r451 ? new Xi(i163) : new ji(i163);
        return {
            dtype: a237,
            shape: o306,
            dataId: this.runWebGLProgram(e813, [
                {
                    shape: i163,
                    dtype: a237,
                    dataId: t1121
                }
            ], a237, null, !0).dataId
        };
    }, o248.prototype.runWebGLProgram = function(t1122, e814, n594, r452, o307) {
        var a238 = this;
        void 0 === o307 && (o307 = !1);
        var s147 = this.makeTensorInfo(t1122.outputShape, n594), u115 = this.texData.get(s147.dataId);
        if (t1122.packedOutput && (u115.isPacked = !0), t1122.outPackingScheme === Vt.DENSE) {
            var c88 = Yt(t1122.outputShape);
            u115.texShape = c88.map(function(t1123) {
                return 2 * t1123;
            });
        }
        if (null != t1122.outTexUsage && (u115.usage = t1122.outTexUsage), 0 === k(s147.shape)) return u115.values = B(s147.dtype, 0), s147;
        var l68 = [], h62 = e814.map(function(e815) {
            if ("complex64" === e815.dtype) throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
            var n595 = a238.texData.get(e815.dataId);
            if (null == n595.texture) {
                if (!t1122.packedInputs && k(e815.shape) <= i().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return {
                    shape: e815.shape,
                    texData: null,
                    isUniform: !0,
                    uniformValues: n595.values
                };
                t1122.packedInputs && (n595.isPacked = !0, n595.shape = e815.shape);
            } else if (!!n595.isPacked != !!t1122.packedInputs) e815 = n595.isPacked ? a238.unpackTensor(e815) : a238.packTensor(e815), l68.push(e815), n595 = a238.texData.get(e815.dataId);
            else if (n595.isPacked && !_e(n595.shape, e815.shape)) {
                var r453 = e815, o308 = e815.shape;
                e815.shape = n595.shape, e815 = a238.packedReshape(e815, o308), l68.push(e815), n595 = a238.texData.get(e815.dataId), r453.shape = o308;
            }
            return a238.uploadToGPU(e815.dataId), {
                shape: e815.shape,
                texData: n595,
                isUniform: !1
            };
        });
        this.uploadToGPU(s147.dataId);
        var f53, d46 = {
            shape: s147.shape,
            texData: u115,
            isUniform: !1
        }, p40 = function(t1124, e816, n596) {
            var r454 = "";
            e816.concat(n596).forEach(function(t1125) {
                var e817 = null != t1125.texData && null != t1125.texData.slice && t1125.texData.slice.flatOffset > 0, n597 = t1125.isUniform ? "uniform" : t1125.texData.texShape;
                r454 += t1125.shape + "_" + n597 + "_" + e817;
            });
            var o309 = t1124.userCode, a239 = t1124.constructor.name;
            return a239 += "_" + r454 + "_" + o309;
        }(t1122, h62, d46), v35 = this.getAndSaveBinary(p40, function() {
            return (function(t1126, e818, n598, r455) {
                var o310 = e818.userCode, a240 = n598.map(function(t1127, n) {
                    var r456 = {
                        logicalShape: t1127.shape,
                        texShape: t1127.isUniform ? null : t1127.texData.texShape,
                        isUniform: t1127.isUniform,
                        isPacked: !t1127.isUniform && t1127.texData.isPacked,
                        flatOffset: null
                    };
                    return null != t1127.texData && null != t1127.texData.slice && t1127.texData.slice.flatOffset > 0 && (r456.flatOffset = t1127.texData.slice.flatOffset), {
                        name: e818.variableNames[n],
                        shapeInfo: r456
                    };
                }), s148 = a240.map(function(t1128) {
                    return t1128.shapeInfo;
                }), u116 = {
                    logicalShape: r455.shape,
                    texShape: r455.texData.texShape,
                    isUniform: !1,
                    isPacked: r455.texData.isPacked,
                    flatOffset: null
                }, c89 = Za(a240, u116, o310, e818.packedInputs), l69 = t1126.createProgram(c89), h63 = null, f54 = t1126.getUniformLocation(l69, "NAN", !1);
                1 === i().getNumber("WEBGL_VERSION") && (h63 = t1126.getUniformLocation(l69, "INFINITY", !1));
                for(var d47 = {
                }, p41 = 0; p41 < e818.variableNames.length; p41++){
                    var v36 = e818.variableNames[p41];
                    d47[v36] = t1126.getUniformLocation(l69, v36, !1), d47["offset" + v36] = t1126.getUniformLocation(l69, "offset" + v36, !1);
                }
                return {
                    program: e818,
                    source: c89,
                    webGLProgram: l69,
                    uniformLocations: d47,
                    inShapeInfos: s148,
                    outShapeInfo: u116,
                    infLoc: h63,
                    nanLoc: f54
                };
            })(a238.gpgpu, t1122, h62, d46);
        }), g30 = null != this.activeTimers;
        if (g30 && (f53 = this.startTimer()), (function(t1129, e819, n599, r457, o311) {
            ks(e819.inShapeInfos, n599), ks([
                e819.outShapeInfo
            ], [
                r457
            ]);
            var a241 = r457.texData.texture, s149 = r457.texData.texShape;
            r457.texData.isPacked ? t1129.setOutputPackedMatrixTexture(a241, s149[0], s149[1]) : t1129.setOutputMatrixTexture(a241, s149[0], s149[1]), t1129.setProgram(e819.webGLProgram), 1 === i().getNumber("WEBGL_VERSION") && null !== e819.infLoc && t1129.gl.uniform1f(e819.infLoc, 1 / 0), null !== e819.nanLoc && t1129.gl.uniform1f(e819.nanLoc, NaN), n599.forEach(function(n600, r458) {
                var o = e819.program.variableNames[r458], a242 = e819.uniformLocations[o], i164 = e819.uniformLocations["offset" + o];
                if (null != a242) {
                    if (n600.isUniform) {
                        if (k(n600.shape) < 2) t1129.gl.uniform1f(a242, n600.uniformValues[0]);
                        else {
                            var s150 = n600.uniformValues;
                            s150 instanceof Float32Array || (s150 = new Float32Array(s150)), t1129.gl.uniform1fv(a242, s150);
                        }
                    } else null != n600.texData.slice && null != i164 && t1129.gl.uniform1i(i164, n600.texData.slice.flatOffset), t1129.setInputMatrixTexture(n600.texData.texture, a242, r458);
                }
            }), null != o311 && o311(t1129, e819.webGLProgram), t1129.executeProgram();
        })(this.gpgpu, v35, h62, d46, r452), l68.forEach(function(t1130) {
            return a238.disposeData(t1130.dataId);
        }), g30 && (f53 = this.endTimer(f53), this.activeTimers.push({
            name: t1122.constructor.name,
            query: this.getQueryTime(f53)
        })), !i().getBool("WEBGL_LAZILY_UNPACK") && u115.isPacked && !1 === o307) {
            var m22 = this.unpackTensor(s147);
            return this.disposeData(s147.dataId), m22;
        }
        return s147;
    }, o248.prototype.compileAndRun = function(t1131, e820, n601, r459, o312) {
        void 0 === o312 && (o312 = !1), n601 = n601 || e820[0].dtype;
        var a243 = this.runWebGLProgram(t1131, e820, n601, r459, o312);
        return Lt.makeTensorFromDataId(a243.dataId, a243.shape, a243.dtype);
    }, o248.prototype.getAndSaveBinary = function(t1132, e821) {
        return t1132 in this.binaryCache || (this.binaryCache[t1132] = e821()), this.binaryCache[t1132];
    }, o248.prototype.getTextureManager = function() {
        return this.textureManager;
    }, o248.prototype.dispose = function() {
        var t1133 = this;
        if (!this.disposed) {
            if (!i().getBool("IS_TEST")) Object.keys(this.binaryCache).forEach(function(e) {
                t1133.gpgpu.deleteProgram(t1133.binaryCache[e].webGLProgram), delete t1133.binaryCache[e];
            });
            this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0;
        }
    }, o248.prototype.floatPrecision = function() {
        var t1134 = this;
        return null == this.floatPrecisionValue && (this.floatPrecisionValue = Ze(function() {
            if (!i().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
                var e822 = i().getBool("DEBUG");
                i().set("DEBUG", !1);
                var n602 = t1134.abs(On(0.00000001)).dataSync()[0];
                if (i().set("DEBUG", e822), n602 > 0) return 32;
            }
            return 16;
        })), this.floatPrecisionValue;
    }, o248.prototype.epsilon = function() {
        return 32 === this.floatPrecision() ? 0.0000001 : 0.0001;
    }, o248.prototype.uploadToGPU = function(t1135) {
        var e823, n603 = this.texData.get(t1135), r460 = n603.shape, o313 = n603.dtype, a244 = n603.values, i165 = n603.texture, s151 = n603.usage, u117 = n603.isPacked;
        if (null == i165) {
            var c90, l70 = null != this.activeTimers;
            l70 && (c90 = et());
            var h64 = n603.texShape;
            if (null == h64 && (h64 = Ne(r460, u117), n603.texShape = h64), null != a244) {
                var f55 = De(r460), d48 = void 0, p42 = h64[1], v37 = h64[0], g31 = a244 instanceof Uint8Array;
                u117 ? (p42 = (e823 = $t(h64[0], h64[1]))[0], v37 = e823[1], d48 = new ts(f55, [
                    v37,
                    p42
                ], g31)) : d48 = new Zi(f55, [
                    v37,
                    p42
                ], g31);
                var m23 = this.makeTensorInfo([
                    v37,
                    p42
                ], o313);
                this.texData.get(m23.dataId).usage = g31 ? zt.PIXELS : zt.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(m23.dataId), p42, v37, a244);
                var y17 = this.runWebGLProgram(d48, [
                    m23
                ], o313, null, !0), x18 = this.texData.get(y17.dataId);
                n603.texture = x18.texture, n603.texShape = x18.texShape, n603.isPacked = x18.isPacked, n603.usage = x18.usage, this.disposeData(m23.dataId), this.texData.delete(y17.dataId), n603.values = null, l70 && (this.uploadWaitMs += et() - c90);
            } else {
                var b14 = this.acquireTexture(h64, s151, o313, u117);
                n603.texture = b14;
            }
        }
    }, o248.prototype.convertAndCacheOnCPU = function(t1136, e824) {
        var n604 = this.texData.get(t1136), r461 = n604.dtype;
        return this.releaseGPUData(t1136), null != e824 && (n604.values = (function(t1137, e825) {
            if ("float32" === e825 || "complex64" === e825) return t1137;
            if ("int32" === e825 || "bool" === e825) {
                for(var n605 = "int32" === e825 ? new Int32Array(t1137.length) : new Uint8Array(t1137.length), r462 = 0; r462 < n605.length; ++r462)n605[r462] = Math.round(t1137[r462]);
                return n605;
            }
            throw new Error("Unknown dtype " + e825);
        })(e824, r461)), n604.values;
    }, o248.prototype.acquireTexture = function(t1138, e826, n606, r463) {
        if (this.numBytesInGPU += this.computeBytes(t1138, n606), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
            var o314 = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
            this.warnedAboutMemory = !0, console.warn("High memory usage in GPU: " + o314 + " MB, most likely due to a memory leak");
        }
        return this.textureManager.acquireTexture(t1138, e826, r463);
    }, o248.prototype.computeBytes = function(t1139, e827) {
        return t1139[0] * t1139[1] * z(e827);
    }, o248;
}(la);
Wt() && Lt.registerBackend("webgl", function() {
    return new Uu;
}, 2);
"undefined" != typeof globalThis || "undefined" != typeof window || "undefined" != typeof global || "undefined";
function Vu(t1140, e828) {
    return t1140(e828 = {
        exports: {
        }
    }, e828.exports), e828.exports;
}
var zu = Vu(function(t1141) {
    !function(t1142, e829, n607) {
        function r464(t1143) {
            var e830, n608 = this, r465 = (e830 = 4022871197, function(t1144) {
                t1144 = t1144.toString();
                for(var n609 = 0; n609 < t1144.length; n609++){
                    var r466 = 0.02519603282416938 * (e830 += t1144.charCodeAt(n609));
                    r466 -= e830 = r466 >>> 0, e830 = (r466 *= e830) >>> 0, e830 += 4294967296 * (r466 -= e830);
                }
                return 0.00000000023283064365386963 * (e830 >>> 0);
            });
            n608.next = function() {
                var t1145 = 2091639 * n608.s0 + 0.00000000023283064365386963 * n608.c;
                return n608.s0 = n608.s1, n608.s1 = n608.s2, n608.s2 = t1145 - (n608.c = 0 | t1145);
            }, n608.c = 1, n608.s0 = r465(" "), n608.s1 = r465(" "), n608.s2 = r465(" "), n608.s0 -= r465(t1143), n608.s0 < 0 && (n608.s0 += 1), n608.s1 -= r465(t1143), n608.s1 < 0 && (n608.s1 += 1), n608.s2 -= r465(t1143), n608.s2 < 0 && (n608.s2 += 1), r465 = null;
        }
        function o315(t1146, e831) {
            return e831.c = t1146.c, e831.s0 = t1146.s0, e831.s1 = t1146.s1, e831.s2 = t1146.s2, e831;
        }
        function a245(t1147, e832) {
            var n610 = new r464(t1147), a246 = e832 && e832.state, i166 = n610.next;
            return i166.int32 = function() {
                return 4294967296 * n610.next() | 0;
            }, i166.double = function() {
                return i166() + 0.00000000000000011102230246251565 * (2097152 * i166() | 0);
            }, i166.quick = i166, a246 && ("object" == typeof a246 && o315(a246, n610), i166.state = function() {
                return o315(n610, {
                });
            }), i166;
        }
        e829 && e829.exports ? e829.exports = a245 : n607 && n607.amd ? n607(function() {
            return a245;
        }) : this.alea = a245;
    }(0, t1141, !1);
}), Gu = Vu(function(t1148) {
    !function(t1149, e833, n611) {
        function r467(t1150) {
            var e834 = this, n612 = "";
            e834.x = 0, e834.y = 0, e834.z = 0, e834.w = 0, e834.next = function() {
                var t1151 = e834.x ^ e834.x << 11;
                return e834.x = e834.y, e834.y = e834.z, e834.z = e834.w, e834.w ^= e834.w >>> 19 ^ t1151 ^ t1151 >>> 8;
            }, t1150 === (0 | t1150) ? e834.x = t1150 : n612 += t1150;
            for(var r468 = 0; r468 < n612.length + 64; r468++)e834.x ^= 0 | n612.charCodeAt(r468), e834.next();
        }
        function o316(t1152, e835) {
            return e835.x = t1152.x, e835.y = t1152.y, e835.z = t1152.z, e835.w = t1152.w, e835;
        }
        function a247(t1153, e836) {
            var n613 = new r467(t1153), a248 = e836 && e836.state, i167 = function() {
                return (n613.next() >>> 0) / 4294967296;
            };
            return i167.double = function() {
                do var t1154 = ((n613.next() >>> 11) + (n613.next() >>> 0) / 4294967296) / 2097152;
                while (0 === t1154)
                return t1154;
            }, i167.int32 = n613.next, i167.quick = i167, a248 && ("object" == typeof a248 && o316(a248, n613), i167.state = function() {
                return o316(n613, {
                });
            }), i167;
        }
        e833 && e833.exports ? e833.exports = a247 : n611 && n611.amd ? n611(function() {
            return a247;
        }) : this.xor128 = a247;
    }(0, t1148, !1);
}), Hu = Vu(function(t1155) {
    !function(t1156, e837, n614) {
        function r469(t1157) {
            var e838 = this, n615 = "";
            e838.next = function() {
                var t1158 = e838.x ^ e838.x >>> 2;
                return e838.x = e838.y, e838.y = e838.z, e838.z = e838.w, e838.w = e838.v, (e838.d = e838.d + 362437 | 0) + (e838.v = e838.v ^ e838.v << 4 ^ t1158 ^ t1158 << 1) | 0;
            }, e838.x = 0, e838.y = 0, e838.z = 0, e838.w = 0, e838.v = 0, t1157 === (0 | t1157) ? e838.x = t1157 : n615 += t1157;
            for(var r470 = 0; r470 < n615.length + 64; r470++)e838.x ^= 0 | n615.charCodeAt(r470), r470 == n615.length && (e838.d = e838.x << 10 ^ e838.x >>> 4), e838.next();
        }
        function o317(t1159, e839) {
            return e839.x = t1159.x, e839.y = t1159.y, e839.z = t1159.z, e839.w = t1159.w, e839.v = t1159.v, e839.d = t1159.d, e839;
        }
        function a249(t1160, e840) {
            var n616 = new r469(t1160), a250 = e840 && e840.state, i168 = function() {
                return (n616.next() >>> 0) / 4294967296;
            };
            return i168.double = function() {
                do var t1161 = ((n616.next() >>> 11) + (n616.next() >>> 0) / 4294967296) / 2097152;
                while (0 === t1161)
                return t1161;
            }, i168.int32 = n616.next, i168.quick = i168, a250 && ("object" == typeof a250 && o317(a250, n616), i168.state = function() {
                return o317(n616, {
                });
            }), i168;
        }
        e837 && e837.exports ? e837.exports = a249 : n614 && n614.amd ? n614(function() {
            return a249;
        }) : this.xorwow = a249;
    }(0, t1155, !1);
}), qu = Vu(function(t1162) {
    !function(t1163, e841, n617) {
        function r471(t1164) {
            var e842 = this;
            e842.next = function() {
                var t1165, n618, r472 = e842.x, o319 = e842.i;
                return t1165 = r472[o319], n618 = (t1165 ^= t1165 >>> 7) ^ t1165 << 24, n618 ^= (t1165 = r472[o319 + 1 & 7]) ^ t1165 >>> 10, n618 ^= (t1165 = r472[o319 + 3 & 7]) ^ t1165 >>> 3, n618 ^= (t1165 = r472[o319 + 4 & 7]) ^ t1165 << 7, t1165 = r472[o319 + 7 & 7], n618 ^= (t1165 ^= t1165 << 13) ^ t1165 << 9, r472[o319] = n618, e842.i = o319 + 1 & 7, n618;
            }, (function(t1166, e843) {
                var n619, r473 = [];
                if (e843 === (0 | e843)) r473[0] = e843;
                else for(e843 = "" + e843, n619 = 0; n619 < e843.length; ++n619)r473[7 & n619] = r473[7 & n619] << 15 ^ e843.charCodeAt(n619) + r473[n619 + 1 & 7] << 13;
                for(; r473.length < 8;)r473.push(0);
                for(n619 = 0; n619 < 8 && 0 === r473[n619]; ++n619);
                for(8 == n619 ? r473[7] = -1 : r473[n619], t1166.x = r473, t1166.i = 0, n619 = 256; n619 > 0; --n619)t1166.next();
            })(e842, t1164);
        }
        function o318(t1167, e844) {
            return e844.x = t1167.x.slice(), e844.i = t1167.i, e844;
        }
        function a251(t1168, e845) {
            null == t1168 && (t1168 = +new Date);
            var n620 = new r471(t1168), a252 = e845 && e845.state, i169 = function() {
                return (n620.next() >>> 0) / 4294967296;
            };
            return i169.double = function() {
                do var t1169 = ((n620.next() >>> 11) + (n620.next() >>> 0) / 4294967296) / 2097152;
                while (0 === t1169)
                return t1169;
            }, i169.int32 = n620.next, i169.quick = i169, a252 && (a252.x && o318(a252, n620), i169.state = function() {
                return o318(n620, {
                });
            }), i169;
        }
        e841 && e841.exports ? e841.exports = a251 : n617 && n617.amd ? n617(function() {
            return a251;
        }) : this.xorshift7 = a251;
    }(0, t1162, !1);
}), Ku = Vu(function(t1170) {
    !function(t1171, e846, n621) {
        function r474(t1172) {
            var e847 = this;
            e847.next = function() {
                var t1173, n622, r475 = e847.w, o321 = e847.X, a254 = e847.i;
                return e847.w = r475 = r475 + 1640531527 | 0, n622 = o321[a254 + 34 & 127], t1173 = o321[a254 = a254 + 1 & 127], n622 ^= n622 << 13, t1173 ^= t1173 << 17, n622 ^= n622 >>> 15, t1173 ^= t1173 >>> 12, n622 = o321[a254] = n622 ^ t1173, e847.i = a254, n622 + (r475 ^ r475 >>> 16) | 0;
            }, (function(t1174, e848) {
                var n623, r476, o322, a255, i170, s152 = [], u118 = 128;
                for(e848 === (0 | e848) ? (r476 = e848, e848 = null) : (e848 += "\0", r476 = 0, u118 = Math.max(u118, e848.length)), o322 = 0, a255 = -32; a255 < u118; ++a255)e848 && (r476 ^= e848.charCodeAt((a255 + 32) % e848.length)), 0 === a255 && (i170 = r476), r476 ^= r476 << 10, r476 ^= r476 >>> 15, r476 ^= r476 << 4, r476 ^= r476 >>> 13, a255 >= 0 && (i170 = i170 + 1640531527 | 0, o322 = 0 == (n623 = s152[127 & a255] ^= r476 + i170) ? o322 + 1 : 0);
                for(o322 >= 128 && (s152[127 & (e848 && e848.length || 0)] = -1), o322 = 127, a255 = 512; a255 > 0; --a255)r476 = s152[o322 + 34 & 127], n623 = s152[o322 = o322 + 1 & 127], r476 ^= r476 << 13, n623 ^= n623 << 17, r476 ^= r476 >>> 15, n623 ^= n623 >>> 12, s152[o322] = r476 ^ n623;
                t1174.w = i170, t1174.X = s152, t1174.i = o322;
            })(e847, t1172);
        }
        function o320(t1175, e849) {
            return e849.i = t1175.i, e849.w = t1175.w, e849.X = t1175.X.slice(), e849;
        }
        function a253(t1176, e850) {
            null == t1176 && (t1176 = +new Date);
            var n624 = new r474(t1176), a256 = e850 && e850.state, i171 = function() {
                return (n624.next() >>> 0) / 4294967296;
            };
            return i171.double = function() {
                do var t1177 = ((n624.next() >>> 11) + (n624.next() >>> 0) / 4294967296) / 2097152;
                while (0 === t1177)
                return t1177;
            }, i171.int32 = n624.next, i171.quick = i171, a256 && (a256.X && o320(a256, n624), i171.state = function() {
                return o320(n624, {
                });
            }), i171;
        }
        e846 && e846.exports ? e846.exports = a253 : n621 && n621.amd ? n621(function() {
            return a253;
        }) : this.xor4096 = a253;
    }(0, t1170, !1);
}), ju = Vu(function(t1178) {
    !function(t1179, e851, n625) {
        function r477(t1180) {
            var e852 = this, n626 = "";
            e852.next = function() {
                var t1181 = e852.b, n627 = e852.c, r479 = e852.d, o324 = e852.a;
                return t1181 = t1181 << 25 ^ t1181 >>> 7 ^ n627, n627 = n627 - r479 | 0, r479 = r479 << 24 ^ r479 >>> 8 ^ o324, o324 = o324 - t1181 | 0, e852.b = t1181 = t1181 << 20 ^ t1181 >>> 12 ^ n627, e852.c = n627 = n627 - r479 | 0, e852.d = r479 << 16 ^ n627 >>> 16 ^ o324, e852.a = o324 - t1181 | 0;
            }, e852.a = 0, e852.b = 0, e852.c = -1640531527, e852.d = 1367130551, t1180 === Math.floor(t1180) ? (e852.a = t1180 / 4294967296 | 0, e852.b = 0 | t1180) : n626 += t1180;
            for(var r478 = 0; r478 < n626.length + 20; r478++)e852.b ^= 0 | n626.charCodeAt(r478), e852.next();
        }
        function o323(t1182, e853) {
            return e853.a = t1182.a, e853.b = t1182.b, e853.c = t1182.c, e853.d = t1182.d, e853;
        }
        function a257(t1183, e854) {
            var n628 = new r477(t1183), a258 = e854 && e854.state, i172 = function() {
                return (n628.next() >>> 0) / 4294967296;
            };
            return i172.double = function() {
                do var t1184 = ((n628.next() >>> 11) + (n628.next() >>> 0) / 4294967296) / 2097152;
                while (0 === t1184)
                return t1184;
            }, i172.int32 = n628.next, i172.quick = i172, a258 && ("object" == typeof a258 && o323(a258, n628), i172.state = function() {
                return o323(n628, {
                });
            }), i172;
        }
        e851 && e851.exports ? e851.exports = a257 : n625 && n625.amd ? n625(function() {
            return a257;
        }) : this.tychei = a257;
    }(0, t1178, !1);
}), Xu = Vu(function(t1185) {
    !function(e855, n629) {
        var r480, o325 = this, a259 = 256, i173 = 6, s153 = "random", u119 = n629.pow(a259, i173), c91 = n629.pow(2, 52), l71 = 2 * c91, h65 = a259 - 1;
        function f56(t1186, h66, f57) {
            var m24 = [], y18 = v38(function t1187(e856, n630) {
                var r481, o326 = [], a260 = typeof e856;
                if (n630 && "object" == a260) for(r481 in e856)try {
                    o326.push(t1187(e856[r481], n630 - 1));
                } catch (t) {
                }
                return o326.length ? o326 : "string" == a260 ? e856 : e856 + "\0";
            }((h66 = 1 == h66 ? {
                entropy: !0
            } : h66 || {
            }).entropy ? [
                t1186,
                g32(e855)
            ] : null == t1186 ? function() {
                try {
                    var t1188;
                    return r480 && (t1188 = r480.randomBytes) ? t1188 = t1188(a259) : (t1188 = new Uint8Array(a259), (o325.crypto || o325.msCrypto).getRandomValues(t1188)), g32(t1188);
                } catch (t) {
                    var n631 = o325.navigator, i174 = n631 && n631.plugins;
                    return [
                        +new Date,
                        o325,
                        i174,
                        o325.screen,
                        g32(e855)
                    ];
                }
            }() : t1186, 3), m24), x19 = new d49(m24), b15 = function() {
                for(var t1189 = x19.g(i173), e857 = u119, n632 = 0; t1189 < c91;)t1189 = (t1189 + n632) * a259, e857 *= a259, n632 = x19.g(1);
                for(; t1189 >= l71;)t1189 /= 2, e857 /= 2, n632 >>>= 1;
                return (t1189 + n632) / e857;
            };
            return b15.int32 = function() {
                return 0 | x19.g(4);
            }, b15.quick = function() {
                return x19.g(4) / 4294967296;
            }, b15.double = b15, v38(g32(x19.S), e855), (h66.pass || f57 || function(t1190, e858, r482, o327) {
                return o327 && (o327.S && p43(o327, x19), t1190.state = function() {
                    return p43(x19, {
                    });
                }), r482 ? (n629[s153] = t1190, e858) : t1190;
            })(b15, y18, "global" in h66 ? h66.global : this == n629, h66.state);
        }
        function d49(t1191) {
            var e859, n633 = t1191.length, r483 = this, o328 = 0, i175 = r483.i = r483.j = 0, s154 = r483.S = [];
            for(n633 || (t1191 = [
                n633++
            ]); o328 < a259;)s154[o328] = o328++;
            for(o328 = 0; o328 < a259; o328++)s154[o328] = s154[i175 = h65 & i175 + t1191[o328 % n633] + (e859 = s154[o328])], s154[i175] = e859;
            (r483.g = function(t1192) {
                for(var e860, n634 = 0, o329 = r483.i, i176 = r483.j, s155 = r483.S; t1192--;)e860 = s155[o329 = h65 & o329 + 1], n634 = n634 * a259 + s155[h65 & (s155[o329] = s155[i176 = h65 & i176 + e860]) + (s155[i176] = e860)];
                return r483.i = o329, r483.j = i176, n634;
            })(a259);
        }
        function p43(t1193, e861) {
            return e861.i = t1193.i, e861.j = t1193.j, e861.S = t1193.S.slice(), e861;
        }
        function v38(t1194, e862) {
            for(var n635, r484 = t1194 + "", o330 = 0; o330 < r484.length;)e862[h65 & o330] = h65 & (n635 ^= 19 * e862[h65 & o330]) + r484.charCodeAt(o330++);
            return g32(e862);
        }
        function g32(t1195) {
            return String.fromCharCode.apply(0, t1195);
        }
        if (n629["seed" + s153] = f56, v38(n629.random(), e855), t1185.exports) {
            t1185.exports = f56;
            try {
                r480 = require("crypto");
            } catch (t) {
            }
        }
    }([], Math);
});
Xu.alea = zu, Xu.xor128 = Gu, Xu.xorwow = Hu, Xu.xorshift7 = qu, Xu.xor4096 = Ku, Xu.tychei = ju;
var Yu = Xu.alea;
var $u = An({
    addN_: function(t1196) {
        C(Array.isArray(t1196), function() {
            return "The argument passed to tf.addN() must be a list of tensors";
        }), C(t1196.length >= 1, function() {
            return "Must pass at least one tensor to tf.addN(), but got " + t1196.length;
        });
        var e863 = t1196.map(function(t1197, e864) {
            return gn(t1197, "tensors" + e864, "addN");
        }), n636 = e863[0];
        e863.forEach(function(t1198) {
            if (t1198.dtype !== n636.dtype) throw new Error("All tensors passed to tf.addN() must have the same dtype");
        }), e863.forEach(function(t1199) {
            if (!S(t1199.shape, n636.shape)) throw new Error("All tensors passed to tf.addN() must have the same shape");
        });
        var r485 = e863;
        return Lt.runKernelFunc(function(t1200, n) {
            return t1200.addN(e863);
        }, r485, null, "AddN");
    }
});
function Qu() {
    Xe("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon");
}
function Ju(t1201) {
    return 0 === t1201.rank || 1 === t1201.rank ? t1201.as4D(1, 1, 1, t1201.size) : 2 === t1201.rank ? t1201.as4D(1, 1, t1201.shape[0], t1201.shape[1]) : 3 === t1201.rank ? t1201.as4D(1, t1201.shape[0], t1201.shape[1], t1201.shape[2]) : t1201;
}
function Zu(t1202, e865, n637, r486, o331, a261) {
    null == a261 && (a261 = 0.001);
    var i177, s156, u120 = gn(t1202, "x", "batchNorm"), c92 = gn(e865, "mean", "batchNorm"), l72 = gn(n637, "variance", "batchNorm");
    null != o331 && (i177 = gn(o331, "scale", "batchNorm")), null != r486 && (s156 = gn(r486, "offset", "batchNorm")), C(c92.rank === l72.rank, function() {
        return "Batch normalization gradient requires mean and variance to have equal ranks.";
    }), C(null == s156 || c92.rank === s156.rank, function() {
        return "Batch normalization gradient requires mean and offset to have equal ranks.";
    }), C(null == i177 || c92.rank === i177.rank, function() {
        return "Batch normalization gradient requires mean and scale to have equal ranks.";
    });
    var h67 = {
        x: u120,
        scale: i177,
        offset: s156,
        mean: c92,
        variance: l72
    }, f58 = {
        varianceEpsilon: a261
    };
    return Lt.runKernelFunc(function(t1203, e866) {
        var n638 = Ju(u120), r487 = t1203.batchNormalization(n638, tc(c92), tc(l72), a261, tc(i177), tc(s156));
        return e866([
            u120,
            c92,
            l72,
            i177
        ]), r487;
    }, h67, null, "FusedBatchNorm", f58).reshape(u120.shape);
}
function tc(t1204) {
    return null == t1204 ? null : 0 === t1204.rank ? t1204.as1D() : 1 === t1204.rank ? t1204 : 2 === t1204.rank ? t1204.as4D(1, 1, t1204.shape[0], t1204.shape[1]) : 3 === t1204.rank ? t1204.as4D(1, t1204.shape[0], t1204.shape[1], t1204.shape[2]) : t1204;
}
var ec = An({
    batchNormalization_: function(t1205, e867, n639, r488, o332, a262) {
        return void 0 === r488 && (r488 = 0.001), Qu(), Zu(t1205, e867, n639, a262, o332, r488);
    }
}), nc = An({
    batchNorm_: Zu
});
function rc(t1206, e868, n640, r489, o333, a263) {
    var i178, s157, u121 = gn(t1206, "x", "batchNorm"), c93 = gn(e868, "mean", "batchNorm"), l73 = gn(n640, "variance", "batchNorm");
    return null != o333 && (i178 = gn(o333, "scale", "batchNorm")), null != r489 && (s157 = gn(r489, "offset", "batchNorm")), C(2 === u121.rank, function() {
        return "Error in batchNorm3D: x must be rank 3 but got rank " + u121.rank + ".";
    }), C(2 === c93.rank || 1 === c93.rank, function() {
        return "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank " + c93.rank + ".";
    }), C(2 === l73.rank || 1 === l73.rank, function() {
        return "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank " + l73.rank + ".";
    }), null != i178 && C(2 === i178.rank || 1 === i178.rank, function() {
        return "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank " + i178.rank + ".";
    }), null != s157 && C(2 === s157.rank || 1 === s157.rank, function() {
        return "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank " + s157.rank + ".";
    }), nc(u121, c93, l73, s157, i178, a263);
}
var oc = An({
    batchNormalization2d_: function(t1207, e869, n641, r490, o334, a264) {
        return void 0 === r490 && (r490 = 0.001), Qu(), rc(t1207, e869, n641, a264, o334, r490);
    }
}), ac = An({
    batchNorm2d_: rc
});
function ic(t1208, e870, n642, r491, o335, a265) {
    var i179, s158, u122 = gn(t1208, "x", "batchNorm"), c94 = gn(e870, "mean", "batchNorm"), l74 = gn(n642, "variance", "batchNorm");
    return null != o335 && (i179 = gn(o335, "scale", "batchNorm")), null != r491 && (s158 = gn(r491, "offset", "batchNorm")), C(3 === u122.rank, function() {
        return "Error in batchNorm3D: x must be rank 3 but got rank " + u122.rank + ".";
    }), C(3 === c94.rank || 1 === c94.rank, function() {
        return "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank " + c94.rank + ".";
    }), C(3 === l74.rank || 1 === l74.rank, function() {
        return "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank " + l74.rank + ".";
    }), null != i179 && C(3 === i179.rank || 1 === i179.rank, function() {
        return "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank " + i179.rank + ".";
    }), null != s158 && C(3 === s158.rank || 1 === s158.rank, function() {
        return "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank " + s158.rank + ".";
    }), nc(u122, c94, l74, s158, i179, a265);
}
var sc = An({
    batchNormalization3d_: function(t1209, e871, n643, r492, o336, a266) {
        return void 0 === r492 && (r492 = 0.001), Qu(), ic(t1209, e871, n643, a266, o336, r492);
    }
}), uc = An({
    batchNorm3d_: ic
});
function cc(t1210, e872, n644, r493, o337, a267) {
    var i180, s159, u123 = gn(t1210, "x", "batchNorm"), c95 = gn(e872, "mean", "batchNorm"), l75 = gn(n644, "variance", "batchNorm");
    return null != o337 && (i180 = gn(o337, "scale", "batchNorm")), null != r493 && (s159 = gn(r493, "offset", "batchNorm")), C(4 === u123.rank, function() {
        return "Error in batchNorm4D: x must be rank 4 but got rank " + u123.rank + ".";
    }), C(4 === c95.rank || 1 === c95.rank, function() {
        return "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank " + c95.rank + ".";
    }), C(4 === l75.rank || 1 === l75.rank, function() {
        return "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank " + l75.rank + ".";
    }), null != i180 && C(4 === i180.rank || 1 === i180.rank, function() {
        return "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank " + i180.rank + ".";
    }), null != s159 && C(4 === s159.rank || 1 === s159.rank, function() {
        return "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank " + s159.rank + ".";
    }), nc(u123, c95, l75, s159, i180, a267);
}
var lc = An({
    batchNormalization4d_: function(t1211, e873, n645, r494, o338, a268) {
        return void 0 === r494 && (r494 = 0.001), Qu(), cc(t1211, e873, n645, a268, o338, r494);
    }
}), hc = An({
    batchNorm4d_: cc
});
var fc = An({
    broadcastTo_: function(t1212, e874) {
        var n646 = gn(t1212, "broadcastTo", "x"), r495 = n646.shape;
        if (e874.some(function(t1213) {
            return !(t1213 > 0) || t1213 % 1 != 0;
        })) throw new Error("broadcastTo(): Invalid broadcast shape [" + e874 + "].");
        if (e874.length < n646.rank) throw new Error("broadcastTo(): shape.length=" + e874.length + " < input.rank=" + n646.rank + ".");
        if (e874.length > n646.rank) {
            for(var o339 = n646.shape.slice(); o339.length < e874.length;)o339.unshift(1);
            n646 = n646.reshape(o339);
        }
        for(var a269 = n646.shape, i181 = Array.from(e874), s160 = e874.length - 1; s160 >= 0; s160--)if (a269[s160] === e874[s160]) i181[s160] = 1;
        else if (1 !== n646.shape[s160]) throw new Error("broadcastTo(): [" + r495 + "] cannot be broadcast to [" + e874 + "].");
        var u124 = i181.map(function(t1214, e875) {
            return t1214 > 1 ? e875 : -1;
        }).filter(function(t1215) {
            return t1215 >= 0;
        });
        if (0 === u124.length) return n646.clone();
        var c96 = {
            x: n646
        }, l76 = {
            shape: e874,
            inputShape: a269
        };
        return Lt.runKernelFunc(function(t1216) {
            return t1216.tile(n646, i181);
        }, c96, function(t1217) {
            return {
                x: function() {
                    return t1217.sum(u124, !0);
                }
            };
        }, Sr, l76);
    }
});
var dc = An({
    clone_: function(t1218) {
        var e876 = gn(t1218, "x", "clone", null);
        return Lt.runKernelFunc(function() {
            return Lt.makeTensorFromDataId(e876.dataId, e876.shape, e876.dtype);
        }, {
            x: e876
        }, null, Tr);
    }
});
var pc = An({
    logicalAnd_: function(t1219, e877) {
        var n647 = gn(t1219, "a", "logicalAnd", "bool"), r496 = gn(e877, "b", "logicalAnd", "bool");
        return Pr(n647.shape, r496.shape), Lt.runKernelFunc(function(t1220) {
            return t1220.logicalAnd(n647, r496);
        }, {
            a: n647,
            b: r496
        }, null, "LogicalAnd");
    }
}), vc = An({
    logicalNot_: function(t1221) {
        var e878 = gn(t1221, "x", "logicalNot", "bool");
        return Lt.runKernelFunc(function(t1222) {
            return t1222.logicalNot(e878);
        }, {
            $x: e878
        });
    }
}), gc = An({
    logicalOr_: function(t1223, e879) {
        var n648 = gn(t1223, "a", "logicalOr", "bool"), r497 = gn(e879, "b", "logicalOr", "bool");
        return Pr(n648.shape, r497.shape), Lt.runKernelFunc(function(t1224) {
            return t1224.logicalOr(n648, r497);
        }, {
            $a: n648,
            $b: r497
        });
    }
}), mc = An({
    logicalXor_: function(t1225, e880) {
        var n649 = gn(t1225, "a", "logicalXor", "bool"), r498 = gn(e880, "b", "logicalXor", "bool");
        return Pr(n649.shape, r498.shape), gc(t1225, e880).logicalAnd(pc(t1225, e880).logicalNot());
    }
}), yc = An({
    where_: function(t1226, e881, n650) {
        var r499 = gn(e881, "a", "where"), o340 = gn(n650, "b", "where"), a270 = gn(t1226, "condition", "where", "bool");
        return E(r499.shape, o340.shape, "Error in where: "), 1 === a270.rank ? C(a270.shape[0] === r499.shape[0], function() {
            return "The first dimension of `a` must match the size of `condition`.";
        }) : E(a270.shape, o340.shape, "Error in where: "), Lt.runKernelFunc(function(t1227, e882) {
            var n651 = t1227.select(a270, r499, o340);
            return e882([
                a270
            ]), n651;
        }, {
            $condition: a270,
            $a: r499,
            $b: o340
        }, function(t1228, e883) {
            var n652 = e883[0];
            return {
                $condition: function() {
                    return Xn(n652).toFloat();
                },
                $a: function() {
                    return t1228.mul(n652.cast(t1228.dtype));
                },
                $b: function() {
                    return t1228.mul(n652.logicalNot().cast(t1228.dtype));
                }
            };
        });
    }
}), xc = function(t1229) {
    return n(this, void 0, void 0, function() {
        var e884, n653, o341;
        return r(this, function(r500) {
            switch(r500.label){
                case 0:
                    return [
                        4,
                        (e884 = gn(t1229, "condition", "whereAsync", "bool")).data()
                    ];
                case 1:
                    return n653 = r500.sent(), o341 = Ga(e884.shape, n653), t1229 !== e884 && e884.dispose(), [
                        2,
                        o341
                    ];
            }
        });
    });
};
var bc = An({
    divNoNan_: function(t1230, e885) {
        var n654, r501 = gn(t1230, "a", "div"), o342 = gn(e885, "b", "div");
        r501 = (n654 = Nt(r501, o342))[0], o342 = n654[1];
        var a271 = Bo(r501, o342), i182 = Xn(a271), s161 = o342.equal(i182);
        return yc(s161, i182, a271);
    }
});
var wc = An({
    tile_: function(t1231, e886) {
        var n655 = gn(t1231, "x", "tile", null);
        C(n655.rank === e886.length, function() {
            return "Error in transpose: rank of input " + n655.rank + " must match length of reps " + e886 + ".";
        });
        var r502 = [
            n655
        ], o343 = {
            x: n655
        }, a272 = {
            reps: e886
        };
        return Lt.runKernelFunc(function(t1232, r503) {
            var o344 = t1232.tile(n655, e886);
            return r503([
                n655
            ]), o344;
        }, o343, null, Dr, a272, r502);
    }
});
var Cc = An({
    eye_: function(t1233, e887, n656, r504) {
        void 0 === r504 && (r504 = "float32"), null == e887 && (e887 = t1233);
        for(var o345 = er([
            t1233,
            e887
        ], r504), a273 = t1233 <= e887 ? t1233 : e887, i183 = 0; i183 < a273; ++i183)o345.set(1, i183, i183);
        var s162 = o345.toTensor().as2D(t1233, e887);
        if (null == n656) return s162;
        if (1 === n656.length) return wc(sr(s162, 0), [
            n656[0],
            1,
            1
        ]);
        if (2 === n656.length) return wc(sr(sr(s162, 0), 0), [
            n656[0],
            n656[1],
            1,
            1
        ]);
        if (3 === n656.length) return wc(sr(sr(sr(s162, 0), 0), 0), [
            n656[0],
            n656[1],
            n656[2],
            1,
            1
        ]);
        throw new Error("eye() currently supports only 1D and 2D batchShapes, but received " + n656.length + "D.");
    }
});
var Ec = An({
    multinomial_: function(t1234, e888, n657, r505) {
        void 0 === r505 && (r505 = !1);
        var o346 = gn(t1234, "logits", "multinomial"), a274 = o346.size, i184 = o346.rank;
        if (a274 < 2) throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + a274 + ".");
        if (i184 > 2) throw new Error("Rank of probabilities must be 1 or 2, but is " + i184);
        n657 = n657 || Math.random();
        var s163 = 1 === i184 ? o346.as2D(1, -1) : o346, u125 = Lt.runKernelFunc(function(t1235) {
            return t1235.multinomial(s163, r505, e888, n657);
        }, {
            logits2D: s163
        });
        return 1 === i184 ? u125.as1D() : u125;
    }
});
var Rc = An({
    oneHot_: function(t1236, e889, n658, r506) {
        if (void 0 === n658 && (n658 = 1), void 0 === r506 && (r506 = 0), e889 < 2) throw new Error("Error in oneHot: depth must be >=2, but it is " + e889);
        var o347 = gn(t1236, "indices", "oneHot", "int32"), a275 = o347.shape.concat([
            e889
        ]), i185 = {
            indices: o347 = o347.flatten()
        }, s164 = {
            depth: e889,
            onValue: n658,
            offValue: r506
        };
        return Lt.runKernelFunc(function(t1237, a276) {
            return a276([
                o347
            ]), t1237.oneHot(o347, e889, n658, r506);
        }, i185, null, Ar, s164).reshape(a275);
    }
});
var Ic = An({
    pad_: function(t1238, e890, n659) {
        void 0 === n659 && (n659 = 0);
        var r507 = gn(t1238, "x", "pad");
        if (0 === r507.rank) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
        var o348 = {
            paddings: e890,
            constantValue: n659
        }, a277 = {
            x: r507
        };
        return Lt.runKernelFunc(function(t1239, o349) {
            return o349([
                r507
            ]), t1239.pad(r507, e890, n659);
        }, a277, null, Nr, o348);
    }
});
var kc = An({
    pad1d_: function(t1240, e891, n660) {
        return void 0 === n660 && (n660 = 0), C(2 === e891.length, function() {
            return "Invalid number of paddings. Must be length of 2.";
        }), Ic(t1240, [
            e891
        ], n660);
    }
});
var Sc = An({
    pad2d_: function(t1241, e892, n661) {
        return void 0 === n661 && (n661 = 0), C(2 === e892.length && 2 === e892[0].length && 2 === e892[1].length, function() {
            return "Invalid number of paddings. Must be length of 2 each.";
        }), Ic(t1241, e892, n661);
    }
});
var Ac = An({
    pad3d_: function(t1242, e893, n662) {
        return void 0 === n662 && (n662 = 0), C(3 === e893.length && 2 === e893[0].length && 2 === e893[1].length && 2 === e893[2].length, function() {
            return "Invalid number of paddings. Must be length of 2 each.";
        }), Ic(t1242, e893, n662);
    }
});
var Tc = An({
    pad4d_: function(t1243, e894, n663) {
        return void 0 === n663 && (n663 = 0), C(4 === e894.length && 2 === e894[0].length && 2 === e894[1].length && 2 === e894[2].length && 2 === e894[3].length, function() {
            return "Invalid number of paddings. Must be length of 2 each.";
        }), Ic(t1243, e894, n663);
    }
});
var Dc = An({
    rand_: function(t1244, e895, n664) {
        var r508 = k(t1244), o350 = null;
        if (null == n664 || "float32" === n664) o350 = new Float32Array(r508);
        else if ("int32" === n664) o350 = new Int32Array(r508);
        else {
            if ("bool" !== n664) throw new Error("Unknown data type " + n664);
            o350 = new Uint8Array(r508);
        }
        for(var a278 = 0; a278 < r508; a278++)o350[a278] = e895();
        return Lt.makeTensor(o350, t1244, n664);
    }
}), Nc = 0.001, Fc = 0.1;
function _c() {
    return 32 === Lt.backend.floatPrecision() ? Nc : Fc;
}
function Oc(t1245, e896, n665) {
    var r509 = !0;
    if ((V(t1245) || V(e896)) && (r509 = !1), V(t1245) && V(e896) && (r509 = !0), r509) {
        var o351 = t1245.constructor.name, a279 = e896.constructor.name;
        if (o351 !== a279) throw new Error("Arrays are of different type. Actual: " + o351 + ". Expected: " + a279);
    }
    if (Array.isArray(t1245) && Array.isArray(e896)) {
        var i186 = pn(t1245), s165 = pn(e896);
        if (!S(i186, s165)) throw new Error("Arrays have different shapes. Actual: [" + i186 + "]. Expected: [" + s165 + "]");
    }
    var u126 = V(t1245) ? t1245 : I(t1245), c97 = V(e896) ? e896 : I(e896);
    if (u126.length !== c97.length) throw new Error("Arrays have different lengths actual: " + u126.length + " vs expected: " + c97.length + ".\nActual:   " + u126 + ".\nExpected: " + c97 + ".");
    for(var l77 = 0; l77 < c97.length; ++l77){
        var h68 = u126[l77], f59 = c97[l77];
        if (!n665(h68, f59)) throw new Error("Arrays differ: actual[" + l77 + "] = " + h68 + ", expected[" + l77 + "] = " + f59 + ".\nActual:   " + u126 + ".\nExpected: " + c97 + ".");
    }
}
function Mc(t1246, e897, n666) {
    return !isFinite(t1246) && !isFinite(e897) || !(isNaN(t1246) || isNaN(e897) || Math.abs(t1246 - e897) > n666);
}
var Bc = Object.freeze({
    TEST_EPSILON_FLOAT16: Fc,
    expectArraysClose: function(t1247, e898, n667) {
        return null == n667 && (n667 = _c()), Oc(t1247, e898, function(t1248, e899) {
            return Mc(t1248, e899, n667);
        });
    },
    testEpsilon: _c,
    expectPromiseToFail: function(t1249, e900) {
        t1249().then(function() {
            return e900.fail();
        }, function() {
            return e900();
        });
    },
    expectArraysEqual: function(t1250, e901) {
        var n668 = "string" == typeof e901 || "number" == typeof e901 || "boolean" == typeof e901 ? [
            e901
        ] : e901;
        return H(t1250) || H(t1250[0]) || H(e901) || H(e901[0]) ? Oc(t1250, n668, function(t1251, e902) {
            return t1251 == e902;
        }) : Oc(t1250, e901, function(t1252, e903) {
            return Mc(t1252, e903, 0);
        });
    },
    expectNumbersClose: function(t1253, e904, n669) {
        if (null == n669 && (n669 = _c()), !Mc(t1253, e904, n669)) throw new Error("Numbers differ: actual === " + t1253 + ", expected === " + e904);
    },
    expectValuesInRange: function(t1254, e905, n670) {
        for(var r510 = 0; r510 < t1254.length; r510++)if (t1254[r510] < e905 || t1254[r510] > n670) throw new Error("Value out of range:" + t1254[r510] + " low: " + e905 + ", high: " + n670);
    },
    expectArrayBuffersEqual: function(t1255, e906) {
        expect(new Float32Array(t1255)).toEqual(new Float32Array(e906));
    }
}), Pc = function() {
    function t1256(t1257, e907, n671, r511, o352) {
        this.mean = t1257, this.stdDev = e907, this.dtype = n671, this.nextVal = NaN, this.truncated = r511, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
        var a280 = o352 || Math.random();
        this.random = Yu(a280.toString());
    }
    return t1256.prototype.nextValue = function() {
        if (!isNaN(this.nextVal)) {
            var t1258 = this.nextVal;
            return this.nextVal = NaN, t1258;
        }
        for(var e908, n672, r512 = !1; !r512;){
            var o353 = void 0, a281 = void 0, i187 = void 0;
            do i187 = (o353 = 2 * this.random() - 1) * o353 + (a281 = 2 * this.random() - 1) * a281;
            while (i187 >= 1 || 0 === i187)
            var s166 = Math.sqrt(-2 * Math.log(i187) / i187);
            e908 = this.mean + this.stdDev * o353 * s166, n672 = this.mean + this.stdDev * a281 * s166, this.truncated && !this.isValidTruncated(e908) || (r512 = !0);
        }
        return this.truncated && !this.isValidTruncated(n672) || (this.nextVal = this.convertValue(n672)), this.convertValue(e908);
    }, t1256.prototype.convertValue = function(t1259) {
        return null == this.dtype || "float32" === this.dtype ? t1259 : Math.round(t1259);
    }, t1256.prototype.isValidTruncated = function(t1260) {
        return t1260 <= this.upper && t1260 >= this.lower;
    }, t1256;
}(), Lc = function() {
    function t1261(t1262, e909, n673, r513) {
        this.alpha = t1262, this.beta = 1 / e909, this.dtype = n673;
        var o354 = r513 || Math.random();
        this.randu = Yu(o354.toString()), this.randn = new Pc(0, 1, n673, !1, this.randu()), this.d = t1262 < 1 ? t1262 + 2 / 3 : t1262 - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
    }
    return t1261.prototype.nextValue = function() {
        for(var t1263, e910, n674, r514, o355, a282;;){
            do r514 = this.randn.nextValue(), a282 = 1 + this.c * r514;
            while (a282 <= 0)
            if (a282 *= a282 * a282, e910 = 1 - 0.331 * (t1263 = r514 * r514) * t1263, n674 = 0.5 * t1263 + this.d * (1 - a282 + Math.log(a282)), (o355 = this.randu()) < e910 || Math.log(o355) < n674) break;
        }
        return a282 = 1 / this.beta * this.d * a282, this.alpha < 1 && (a282 *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(a282);
    }, t1261.prototype.convertValue = function(t1264) {
        return "float32" === this.dtype ? t1264 : Math.round(t1264);
    }, t1261;
}(), Wc = function() {
    function t1265(t1266, e911, n675, r515) {
        var o356 = this;
        if (void 0 === t1266 && (t1266 = 0), void 0 === e911 && (e911 = 1), this.canReturnFloat = function() {
            return null == o356.dtype || "float32" === o356.dtype;
        }, this.min = t1266, this.range = e911 - t1266, this.dtype = n675, null == r515 && (r515 = Math.random()), "number" == typeof r515 && (r515 = r515.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error("The difference between " + t1266 + " - " + e911 + " <= 1 and dtype is not float");
        this.random = Yu(r515);
    }
    return t1265.prototype.convertValue = function(t1267) {
        return this.canReturnFloat() ? t1267 : Math.round(t1267);
    }, t1265.prototype.nextValue = function() {
        return this.convertValue(this.min + this.range * this.random());
    }, t1265;
}();
var Uc = An({
    randomGamma_: function(t1268, e912, n676, r516, o357) {
        if (void 0 === n676 && (n676 = 1), void 0 === r516 && (r516 = "float32"), null == n676 && (n676 = 1), null == r516 && (r516 = "float32"), "float32" !== r516 && "int32" !== r516) throw new Error("Unsupported data type " + r516);
        for(var a283 = new Lc(e912, n676, r516, o357), i188 = er(t1268, r516), s167 = 0; s167 < i188.values.length; s167++)i188.values[s167] = a283.nextValue();
        return i188.toTensor();
    }
});
var Vc = An({
    randomNormal_: function(t1269, e913, n677, r517, o358) {
        if (void 0 === e913 && (e913 = 0), void 0 === n677 && (n677 = 1), null != r517 && "bool" === r517) throw new Error("Unsupported data type " + r517);
        for(var a284 = new Pc(e913, n677, r517, !1, o358), i189 = er(t1269, r517), s168 = 0; s168 < i189.values.length; s168++)i189.values[s168] = a284.nextValue();
        return i189.toTensor();
    }
});
var zc = An({
    randomUniform_: function(t1270, e914, n678, r518, o359) {
        void 0 === e914 && (e914 = 0), void 0 === n678 && (n678 = 1), void 0 === r518 && (r518 = "float32");
        for(var a285 = er(t1270, r518), i190 = new Wc(e914, n678, null, o359), s169 = 0; s169 < a285.values.length; s169++)a285.values[s169] = i190.nextValue();
        return a285.toTensor();
    }
});
var Gc = An({
    square_: function(t1271) {
        var e915 = gn(t1271, "x", "square"), n679 = [
            e915
        ];
        return Lt.runKernelFunc(function(t1272, n680) {
            return n680([
                e915
            ]), t1272.square(e915);
        }, {
            x: e915
        }, null, "Square", {
        }, n679, []);
    }
});
var Hc = An({
    squaredDifference_: function(t1273, e916) {
        var n681, r519 = gn(t1273, "a", "squaredDifference"), o360 = gn(e916, "b", "squaredDifference");
        n681 = Nt(r519, o360), r519 = n681[0], o360 = n681[1], Pr(r519.shape, o360.shape);
        var a286 = {
            a: r519,
            b: o360
        }, i191 = [
            r519,
            o360
        ];
        return Lt.runKernelFunc(function(t1274, e917) {
            var n682 = t1274.squaredDifference(r519, o360);
            return e917([
                r519,
                o360
            ]), n682;
        }, a286, function(t1275, e918) {
            var n683 = e918[0], r520 = e918[1], o361 = On(2);
            return {
                a: function() {
                    return t1275.mul(n683.sub(r520).mul(o361));
                },
                b: function() {
                    return t1275.mul(r520.sub(n683).mul(o361));
                }
            };
        }, Er, {
        }, i191, []);
    }
});
var qc = An({
    truncatedNormal_: function(t1276, e919, n684, r521, o362) {
        if (void 0 === e919 && (e919 = 0), void 0 === n684 && (n684 = 1), null != r521 && "bool" === r521) throw new Error("Unsupported data type $ { dtype }");
        for(var a287 = new Pc(e919, n684, r521, !0, o362), i192 = er(t1276, r521), s170 = 0; s170 < i192.values.length; s170++)i192.values[s170] = a287.nextValue();
        return i192.toTensor();
    }
});
var Kc = An({
    equal_: function(t1277, e920) {
        var n685, r522 = gn(t1277, "a", "equal"), o363 = gn(e920, "b", "equal");
        return n685 = Nt(r522, o363), r522 = n685[0], o363 = n685[1], Pr(r522.shape, o363.shape), Lt.runKernelFunc(function(t1278) {
            return t1278.equal(r522, o363);
        }, {
            $a: r522,
            $b: o363
        });
    }
}), jc = An({
    equalStrict_: function(t1279, e921) {
        var n686 = gn(t1279, "a", "equalStrict"), r523 = gn(e921, "b", "equalStrict");
        return E(n686.shape, r523.shape, "Error in equalStrict: "), n686.equal(r523);
    }
}), Xc = An({
    greater_: function(t1280, e922) {
        var n687, r524 = gn(t1280, "a", "greater"), o364 = gn(e922, "b", "greater");
        return n687 = Nt(r524, o364), r524 = n687[0], o364 = n687[1], Pr(r524.shape, o364.shape), Lt.runKernelFunc(function(t1281) {
            return t1281.greater(r524, o364);
        }, {
            a: r524,
            b: o364
        }, null, "Greater");
    }
}), Yc = An({
    greaterEqual_: function(t1282, e923) {
        var n688, r525 = gn(t1282, "a", "greaterEqual"), o365 = gn(e923, "b", "greaterEqual");
        return n688 = Nt(r525, o365), r525 = n688[0], o365 = n688[1], Pr(r525.shape, o365.shape), Lt.runKernelFunc(function(t1283, e924) {
            var n689 = t1283.greaterEqual(r525, o365);
            return e924([
                r525,
                o365
            ]), n689;
        }, {
            a: r525,
            b: o365
        }, function(t, e925) {
            var n690 = e925[0], r526 = e925[1];
            return {
                a: function() {
                    return Xn(n690);
                },
                b: function() {
                    return Xn(r526);
                }
            };
        }, "GreaterEqual");
    }
}), $c = An({
    greaterEqualStrict_: function(t1284, e926) {
        var n691 = gn(t1284, "a", "greaterEqualStrict"), r527 = gn(e926, "b", "greaterEqualStrict");
        return E(n691.shape, r527.shape, "Error in greaterEqualStrict: "), n691.greaterEqual(r527);
    }
}), Qc = An({
    greaterStrict_: function(t1285, e927) {
        var n692 = gn(t1285, "a", "greaterStrict"), r528 = gn(e927, "b", "greaterStrict");
        return E(n692.shape, r528.shape, "Error in greaterStrict: "), n692.greater(r528);
    }
}), Jc = An({
    less_: function(t1286, e928) {
        var n693, r529 = gn(t1286, "a", "less"), o366 = gn(e928, "b", "less");
        return n693 = Nt(r529, o366), r529 = n693[0], o366 = n693[1], Pr(r529.shape, o366.shape), Lt.runKernelFunc(function(t1287) {
            return t1287.less(r529, o366);
        }, {
            a: r529,
            b: o366
        }, null, "Less");
    }
}), Zc = An({
    lessEqual_: function(t1288, e929) {
        var n694, r530 = gn(t1288, "a", "lessEqual"), o367 = gn(e929, "b", "lessEqual");
        return n694 = Nt(r530, o367), r530 = n694[0], o367 = n694[1], Pr(r530.shape, o367.shape), Lt.runKernelFunc(function(t1289, e930) {
            var n695 = t1289.lessEqual(r530, o367);
            return e930([
                r530,
                o367
            ]), n695;
        }, {
            a: r530,
            b: o367
        }, null, "LessEqual");
    }
}), tl = An({
    lessEqualStrict_: function(t1290, e931) {
        var n696 = gn(t1290, "a", "lessEqualStrict"), r531 = gn(e931, "b", "lessEqualStrict");
        return E(n696.shape, r531.shape, "Error in lessEqualStrict: "), n696.lessEqual(r531);
    }
}), el = An({
    lessStrict_: function(t1291, e932) {
        var n697 = gn(t1291, "a", "lessStrict"), r532 = gn(e932, "b", "lessStrict");
        return E(n697.shape, r532.shape, "Error in lessStrict: "), n697.less(r532);
    }
}), nl = An({
    notEqual_: function(t1292, e933) {
        var n698, r533 = gn(t1292, "a", "notEqual"), o368 = gn(e933, "b", "notEqual");
        return n698 = Nt(r533, o368), r533 = n698[0], o368 = n698[1], Pr(r533.shape, o368.shape), Lt.runKernelFunc(function(t1293) {
            return t1293.notEqual(r533, o368);
        }, {
            a: r533,
            b: o368
        }, null, "NotEqual");
    }
}), rl = An({
    notEqualStrict_: function(t1294, e934) {
        var n699 = gn(t1294, "a", "notEqualStrict"), r534 = gn(e934, "b", "notEqualStrict");
        return E(n699.shape, r534.shape, "Error in notEqualStrict: "), n699.notEqual(r534);
    }
});
function ol(t1295, e935) {
    for(var n700 = [], r535 = t1295; r535 < e935; ++r535)n700.push(r535);
    return n700;
}
function al(t1296) {
    for(var e936 = [], n701 = 0; n701 < t1296.length; ++n701)for(var r536 = 0; r536 < t1296[n701].length; ++r536)e936.push(t1296[n701][r536]);
    return e936;
}
var il = An({
    gather_: function(t1297, e937, n702) {
        void 0 === n702 && (n702 = 0);
        var r537 = gn(t1297, "x", "gather"), o369 = gn(e937, "indices", "gather", "int32");
        n702 = O(n702, r537.shape)[0];
        var a288 = function(t1298, e938, n703) {
            for(var r538 = t1298.shape[n703], o370 = [], a289 = 1, i193 = 1, s171 = 0; s171 < n703; s171++)o370.push(t1298.shape[s171]), a289 *= t1298.shape[s171];
            for(s171 = 0; s171 < e938.rank; s171++)o370.push(e938.shape[s171]);
            for(s171 = n703 + 1; s171 < t1298.rank; s171++)o370.push(t1298.shape[s171]), i193 *= t1298.shape[s171];
            return {
                batchSize: a289,
                sliceSize: i193,
                dimSize: r538,
                outputShape: o370
            };
        }(r537, o369, n702);
        return Lt.runKernelFunc(function(t1299, e939) {
            var a290 = t1299.gather(r537, o369.flatten(), n702);
            return e939([
                o369
            ]), a290;
        }, {
            x: r537,
            indices: o369
        }, function(t1300, e940) {
            var o371 = e940[0];
            return {
                x: function() {
                    var e941 = r537.shape, a291 = o371.size, i194 = e941.slice(0, n702), s172 = i194.length, u127 = e941.slice(n702, e941.length).slice(1), c98 = u127.length, l78 = ol(0, s172), h69 = ol(s172 + 1, s172 + 1 + c98), f60 = al([
                        i194,
                        [
                            a291
                        ],
                        u127
                    ]), d50 = t1300.reshape(f60), p44 = o371.reshape([
                        a291
                    ]), v39 = al([
                        [
                            s172
                        ],
                        l78,
                        h69
                    ]), g33 = d50.transpose(v39), m25 = sl(g33, p44, r537.shape[n702]), y19 = Rn(v39);
                    return m25 = m25.transpose(y19);
                },
                indices: function() {
                    return o371;
                }
            };
        }, "Gather", {
            axis: n702
        }).reshape(a288.outputShape);
    }
}), sl = An({
    unsortedSegmentSum_: function(t1301, e942, n704) {
        var r539 = gn(t1301, "x", "unsortedSegmentSum"), o372 = gn(e942, "segmentIds", "unsortedSegmentSum", "int32");
        return C(A(n704), function() {
            return "numSegments must be of dtype int";
        }), Lt.runKernelFunc(function(t1302, e943) {
            var a292 = t1302.unsortedSegmentSum(r539, o372, n704);
            return e943([
                o372
            ]), a292;
        }, {
            $x: r539
        }, function(t1303, e944) {
            var n705 = e944[0];
            return {
                $x: function() {
                    return (function(t1304, e945) {
                        for(var n706 = Eo(e945, Xn(e945)), r540 = il(t1304, n706), o373 = Yc(e945, On(0, "int32")), a293 = r540.rank - o373.rank, i195 = 0; i195 < a293; ++i195)o373 = sr(o373, i195 + 1);
                        o373 = pc(o373, zn(r540.shape, "bool"));
                        var s173 = Xn(r540);
                        return yc(o373, r540, s173);
                    })(t1303, n705);
                }
            };
        });
    }
});
var ul = function(t1305, e946, o374) {
    return n(this, void 0, void 0, function() {
        var n707, a294, i196, s174, u128, c99, l79, h70, f61, d51, p45, v40, g34;
        return r(this, function(r541) {
            switch(r541.label){
                case 0:
                    for(n707 = gn(t1305, "tensor", "boolMask"), a294 = gn(e946, "mask", "boolMask", "bool"), i196 = null == o374 ? 0 : o374, s174 = a294.rank, u128 = n707.shape, C(s174 > 0, function() {
                        return "mask cannot be scalar";
                    }), E(u128.slice(i196, i196 + s174), a294.shape, "mask's shape must match the first K dimensions of tensor's shape,"), c99 = 1, l79 = i196; l79 < i196 + s174; l79++)c99 *= u128[l79];
                    return h70 = u128.slice(0, i196).concat([
                        c99
                    ], u128.slice(i196 + s174)), f61 = n707.reshape(h70), d51 = a294.reshape([
                        -1
                    ]), [
                        4,
                        xc(d51)
                    ];
                case 1:
                    return p45 = r541.sent(), v40 = p45.squeeze([
                        1
                    ]), g34 = il(f61, v40, i196), t1305 !== n707 && n707.dispose(), e946 !== a294 && a294.dispose(), v40.dispose(), f61.dispose(), d51.dispose(), p45.dispose(), [
                        2,
                        g34
                    ];
            }
        });
    });
};
function cl(t1306, e947, n708, r542, o375, a295, i197) {
    void 0 === a295 && (a295 = "NHWC"), C(t1306.length === e947.rank, function() {
        return "Length of inShape (" + t1306.length + ") and rank of dy (" + e947.rank + ") must match";
    });
    var s175 = t1306, u129 = e947, c100 = !1;
    3 === e947.rank && (c100 = !0, u129 = e947.as4D(1, e947.shape[0], e947.shape[1], e947.shape[2]), s175 = [
        1,
        t1306[0],
        t1306[1],
        t1306[2]
    ]), C(4 === s175.length, function() {
        return "Error in conv2dDerInput: inShape must be length 4, but got length " + s175.length + ".";
    }), C(4 === u129.rank, function() {
        return "Error in conv2dDerInput: dy must be rank 4, but got rank " + u129.rank;
    }), C(4 === n708.rank, function() {
        return "Error in conv2dDerInput: filter must be rank 4, but got rank " + n708.rank;
    });
    var l80 = "NHWC" === a295 ? s175[3] : s175[1], h71 = "NHWC" === a295 ? u129.shape[3] : u129.shape[1];
    C(l80 === n708.shape[2], function() {
        return "Error in conv2dDerInput: depth of input (" + l80 + ") must match input depth for filter " + n708.shape[2] + ".";
    }), C(h71 === n708.shape[3], function() {
        return "Error in conv2dDerInput: depth of output (" + h71 + ") must match output depth for filter " + n708.shape[3] + ".";
    }), null != i197 && C(A(o375), function() {
        return "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode " + i197 + " but got pad " + o375 + ".";
    });
    var f62 = Ea(a295), d52 = pa(s175, n708.shape, r542, 1, o375, i197, !1, f62), p46 = Lt.runKernelFunc(function(t1307, e948) {
        var r543 = t1307.conv2dDerInput(u129, n708, d52);
        return e948([
            n708,
            u129
        ]), r543;
    }, {
        dy4D: u129,
        filter: n708
    }, function(t1308, e949) {
        var n709 = e949[0], s176 = e949[1];
        return {
            dy4D: function() {
                return dl(t1308, n709, r542, o375, a295, 1, i197);
            },
            filter: function() {
                return vl(t1308, s176, n709.shape, r542, o375, a295, i197);
            }
        };
    });
    return c100 ? p46.as3D(p46.shape[1], p46.shape[2], p46.shape[3]) : p46;
}
function ll(t1309) {
    var e950 = function(t1310) {
        return "number" == typeof t1310 ? [
            t1310,
            t1310,
            t1310
        ] : 2 === t1310.length ? [
            t1310[0],
            t1310[1],
            1
        ] : t1310;
    }(t1309), n710 = e950[0], r544 = e950[1], o376 = e950[2];
    return 1 === n710 && 1 === r544 && 1 === o376;
}
function hl(t1311, e951, n711, r545, o377) {
    C(t1311.length === e951.rank, function() {
        return "Length of inShape (" + t1311.length + ") and rank of dy (" + e951.rank + ") must match";
    });
    var a296 = t1311, i198 = e951, s177 = !1;
    4 === e951.rank && (s177 = !0, i198 = e951.as5D(1, e951.shape[0], e951.shape[1], e951.shape[2], e951.shape[3]), a296 = [
        1,
        t1311[0],
        t1311[1],
        t1311[2],
        t1311[3]
    ]);
    var u130 = a296[4], c101 = i198.shape[4];
    C(5 === a296.length, function() {
        return "Error in conv3dDerInput: inShape must be length 5, but got length " + a296.length + ".";
    }), C(5 === i198.rank, function() {
        return "Error in conv3dDerInput: dy must be rank 5, but got rank " + i198.rank;
    }), C(5 === n711.rank, function() {
        return "Error in conv3dDerInput: filter must be rank 5, but got rank " + n711.rank;
    }), C(u130 === n711.shape[3], function() {
        return "Error in conv3dDerInput: depth of input (" + u130 + ") must match input depth for filter " + n711.shape[3] + ".";
    }), C(c101 === n711.shape[4], function() {
        return "Error in conv3dDerInput: depth of output (" + c101 + ") must match output depth for filter " + n711.shape[4] + ".";
    });
    var l81 = va(a296, n711.shape, r545, 1, o377), h72 = Lt.runKernelFunc(function(t1312) {
        return t1312.conv3dDerInput(i198, n711, l81);
    }, {
        dy5D: i198
    });
    return s177 ? h72.as4D(h72.shape[1], h72.shape[2], h72.shape[3], h72.shape[4]) : h72;
}
var fl = An({
    conv1d_: function(t1313, e952, n712, r546, o378, a297, i199) {
        void 0 === o378 && (o378 = "NWC"), void 0 === a297 && (a297 = 1);
        var s178 = gn(t1313, "x", "conv1d"), u131 = gn(e952, "filter", "conv1d"), c102 = s178, l82 = !1;
        2 === s178.rank && (l82 = !0, c102 = s178.as3D(1, s178.shape[0], s178.shape[1])), C(3 === c102.rank, function() {
            return "Error in conv1d: input must be rank 3, but got rank " + c102.rank + ".";
        }), C(3 === u131.rank, function() {
            return "Error in conv1d: filter must be rank 3, but got rank " + u131.rank + ".";
        }), null != i199 && C(A(r546), function() {
            return "Error in conv1d: pad must be an integer when using, dimRoundingMode " + i199 + " but got pad " + r546 + ".";
        }), C(c102.shape[2] === u131.shape[1], function() {
            return "Error in conv1d: depth of input (" + c102.shape[2] + ") must match input depth for filter " + u131.shape[1] + ".";
        }), C(Ca(n712, a297), function() {
            return "Error in conv1D: Either stride or dilation must be 1. Got stride " + n712 + " and dilation '" + a297 + "'";
        }), C("NWC" === o378, function() {
            return "Error in conv1d: got dataFormat of " + o378 + " but only NWC is currently supported.";
        });
        var h73 = u131.as4D(1, u131.shape[0], u131.shape[1], u131.shape[2]), f63 = c102.as4D(c102.shape[0], 1, c102.shape[1], c102.shape[2]), d53 = dl(f63, h73, [
            1,
            n712
        ], r546, "NHWC", [
            1,
            a297
        ], i199);
        return l82 ? d53.as2D(d53.shape[2], d53.shape[3]) : d53.as3D(d53.shape[0], d53.shape[2], d53.shape[3]);
    }
}), dl = An({
    conv2d_: function(t1314, e953, n713, r547, o379, a298, i200) {
        void 0 === o379 && (o379 = "NHWC"), void 0 === a298 && (a298 = [
            1,
            1
        ]);
        var s179 = gn(t1314, "x", "conv2d"), u132 = gn(e953, "filter", "conv2d"), c103 = s179, l83 = !1;
        3 === s179.rank && (l83 = !0, c103 = s179.as4D(1, s179.shape[0], s179.shape[1], s179.shape[2])), C(4 === c103.rank, function() {
            return "Error in conv2d: input must be rank 4, but got rank " + c103.rank + ".";
        }), C(4 === u132.rank, function() {
            return "Error in conv2d: filter must be rank 4, but got rank " + u132.rank + ".";
        }), null != i200 && C(A(r547), function() {
            return "Error in conv2d: pad must be an integer when using, dimRoundingMode " + i200 + " but got pad " + r547 + ".";
        });
        var h74 = "NHWC" === o379 ? c103.shape[3] : c103.shape[1];
        C(h74 === u132.shape[2], function() {
            return "Error in conv2d: depth of input (" + h74 + ") must match input depth for filter " + u132.shape[2] + ".";
        }), C(Ca(n713, a298), function() {
            return "Error in conv2D: Either strides or dilations must be 1. Got strides " + n713 + " and dilations '" + a298 + "'";
        });
        var f64 = Ea(o379), d54 = pa(c103.shape, u132.shape, n713, a298, r547, i200, !1, f64), p47 = [
            u132,
            c103
        ], v41 = Lt.runKernelFunc(function(t1315, e954) {
            var n714 = t1315.conv2d(c103, u132, d54);
            return e954([
                u132,
                c103
            ]), n714;
        }, {
            x: c103,
            filter: u132
        }, function(t1316, e955) {
            var i201 = e955, s180 = i201[0], u133 = i201[1];
            return C(wa(a298), function() {
                return "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + a298 + "'";
            }), {
                x: function() {
                    return gl(u133.shape, t1316, s180, n713, r547, o379);
                },
                filter: function() {
                    return vl(u133, t1316, s180.shape, n713, r547, o379);
                }
            };
        }, "Conv2D", d54, p47);
        return l83 ? v41.as3D(v41.shape[1], v41.shape[2], v41.shape[3]) : v41;
    }
}), pl = An({
    conv3d_: function(t1317, e956, n715, r548, o380, a299) {
        void 0 === o380 && (o380 = "NDHWC"), void 0 === a299 && (a299 = [
            1,
            1,
            1
        ]);
        var i202 = gn(t1317, "x", "conv3d"), s181 = gn(e956, "filter", "conv3d"), u134 = i202, c104 = !1;
        4 === i202.rank && (c104 = !0, u134 = i202.as5D(1, i202.shape[0], i202.shape[1], i202.shape[2], i202.shape[3])), C(5 === u134.rank, function() {
            return "Error in conv3d: input must be rank 5, but got rank " + u134.rank + ".";
        }), C(5 === s181.rank, function() {
            return "Error in conv3d: filter must be rank 5, but got rank " + s181.rank + ".";
        }), C(u134.shape[4] === s181.shape[3], function() {
            return "Error in conv3d: depth of input (" + u134.shape[4] + ") must match input depth for filter " + s181.shape[3] + ".";
        }), C(function(t1318, e957) {
            return ll(t1318) || ll(e957);
        }(n715, a299), function() {
            return "Error in conv3D: Either strides or dilations must be 1. Got strides " + n715 + " and dilations '" + a299 + "'";
        }), C("NDHWC" === o380, function() {
            return "Error in conv3d: got dataFormat of " + o380 + " but only NDHWC is currently supported.";
        });
        var l84 = va(u134.shape, s181.shape, n715, a299, r548), h75 = Lt.runKernelFunc(function(t1319, e958) {
            var n716 = t1319.conv3d(u134, s181, l84);
            return e958([
                u134,
                s181
            ]), n716;
        }, {
            x: u134,
            $filter: s181
        }, function(t1320, e959) {
            C(ll(a299), function() {
                return "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + a299 + "'";
            });
            var o381 = e959[0], i203 = e959[1];
            return {
                x: function() {
                    return hl(o381.shape, t1320, i203, n715, r548);
                },
                $filter: function() {
                    return (function(t1321, e960, n717, r549, o382) {
                        var a300 = t1321;
                        4 === t1321.rank && (a300 = t1321.as5D(1, t1321.shape[0], t1321.shape[1], t1321.shape[2], t1321.shape[3]));
                        var i204 = e960;
                        4 === i204.rank && (i204 = e960.as5D(1, e960.shape[0], e960.shape[1], e960.shape[2], e960.shape[3]));
                        C(5 === a300.rank, function() {
                            return "Error in conv3dDerFilter: input must be rank 5, but got shape " + a300.shape + ".";
                        }), C(5 === i204.rank, function() {
                            return "Error in conv3dDerFilter: dy must be rank 5, but got shape " + i204.shape + ".";
                        }), C(5 === n717.length, function() {
                            return "Error in conv3dDerFilter: filterShape must be length 5, but got " + n717 + ".";
                        }), C(a300.shape[4] === n717[3], function() {
                            return "Error in conv3dDerFilter: depth of input " + a300.shape[4] + ") must match input depth in filter (" + n717[3] + ".";
                        }), C(i204.shape[4] === n717[4], function() {
                            return "Error in conv3dDerFilter: depth of dy (" + i204.shape[4] + ") must match output depth for filter (" + n717[4] + ").";
                        });
                        var s182 = va(a300.shape, n717, r549, 1, o382);
                        return Lt.runKernelFunc(function(t1322) {
                            return t1322.conv3dDerFilter(a300, i204, s182);
                        }, {
                            x5D: a300,
                            dy5D: i204
                        });
                    })(o381, t1320, i203.shape, n715, r548);
                }
            };
        });
        return c104 ? h75.as4D(h75.shape[1], h75.shape[2], h75.shape[3], h75.shape[4]) : h75;
    }
}), vl = An({
    conv2dDerFilter_: function(t1323, e961, n718, r550, o383, a301, i205) {
        void 0 === a301 && (a301 = "NHWC");
        var s183 = t1323;
        3 === t1323.rank && (s183 = t1323.as4D(1, t1323.shape[0], t1323.shape[1], t1323.shape[2]));
        var u135 = e961;
        3 === u135.rank && (u135 = e961.as4D(1, e961.shape[0], e961.shape[1], e961.shape[2])), C(4 === s183.rank, function() {
            return "Error in conv2dDerFilter: input must be rank 4, but got shape " + s183.shape + ".";
        }), C(4 === u135.rank, function() {
            return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + u135.shape + ".";
        }), C(4 === n718.length, function() {
            return "Error in conv2dDerFilter: filterShape must be length 4, but got " + n718 + ".";
        });
        var c105 = "NHWC" === a301 ? s183.shape[3] : s183.shape[1], l85 = "NHWC" === a301 ? u135.shape[3] : u135.shape[1];
        C(c105 === n718[2], function() {
            return "Error in conv2dDerFilter: depth of input " + c105 + ") must match input depth in filter (" + n718[2] + ".";
        }), C(l85 === n718[3], function() {
            return "Error in conv2dDerFilter: depth of dy (" + l85 + ") must match output depth for filter (" + n718[3] + ").";
        }), null != i205 && C(A(o383), function() {
            return "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode " + i205 + " but got pad " + o383 + ".";
        });
        var h76 = Ea(a301), f65 = pa(s183.shape, n718, r550, 1, o383, i205, !1, h76);
        return Lt.runKernelFunc(function(t1324) {
            return t1324.conv2dDerFilter(s183, u135, f65);
        }, {
            x4D: s183,
            dy4D: u135
        });
    }
}), gl = An({
    conv2dDerInput_: cl
}), ml = An({
    depthwiseConv2d_: function(t1325, e962, n719, r551, o384, a302, i206) {
        void 0 === o384 && (o384 = "NHWC"), void 0 === a302 && (a302 = [
            1,
            1
        ]);
        var s184 = gn(t1325, "x", "depthwiseConv2d"), u136 = gn(e962, "filter", "depthwiseConv2d"), c106 = s184, l86 = !1;
        3 === s184.rank && (l86 = !0, c106 = s184.as4D(1, s184.shape[0], s184.shape[1], s184.shape[2])), C(4 === c106.rank, function() {
            return "Error in depthwiseConv2d: input must be rank 4, but got rank " + c106.rank + ".";
        }), C(4 === u136.rank, function() {
            return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + u136.rank + ".";
        }), C(c106.shape[3] === u136.shape[2], function() {
            return "Error in depthwiseConv2d: number of input channels (" + c106.shape[3] + ") must match the inChannels dimension in filter " + u136.shape[2] + ".";
        }), null == a302 && (a302 = [
            1,
            1
        ]), C(Ca(n719, a302), function() {
            return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + n719 + " and dilations '" + a302 + "'";
        }), null != i206 && C(A(r551), function() {
            return "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode " + i206 + " but got pad " + r551 + ".";
        });
        var h77 = pa(c106.shape, u136.shape, n719, a302, r551, i206, !0), f66 = [
            c106,
            u136
        ], d55 = Lt.runKernelFunc(function(t1326, e963) {
            var n720 = t1326.depthwiseConv2D(c106, u136, h77);
            return e963([
                c106,
                u136
            ]), n720;
        }, {
            x: c106,
            filter: u136
        }, function(t1327, e964) {
            C(wa(a302), function() {
                return "Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + a302 + "'";
            });
            var n721 = e964[0], r552 = e964[1];
            return {
                x: function() {
                    return yl(n721.shape, t1327, r552, h77);
                },
                filter: function() {
                    return xl(n721, t1327, r552.shape, h77);
                }
            };
        }, "DepthwiseConv2dNative", h77, f66);
        return l86 ? d55.as3D(d55.shape[1], d55.shape[2], d55.shape[3]) : d55;
    }
}), yl = An({
    depthwiseConv2dDerInput_: function(t1328, e965, n722, r553) {
        var o385 = e965, a303 = !1;
        3 === e965.rank && (a303 = !0, o385 = e965.as4D(1, e965.shape[0], e965.shape[1], e965.shape[2]));
        var i207 = Lt.runKernelFunc(function(t1329) {
            return t1329.depthwiseConv2DDerInput(o385, n722, r553);
        }, {
            dy4D: o385
        });
        return a303 ? i207.as3D(i207.shape[1], i207.shape[2], i207.shape[3]) : i207;
    }
}), xl = An({
    depthwiseConv2dDerFilter_: function(t1330, e966, n, r554) {
        var o386 = t1330;
        3 === t1330.rank && (o386 = t1330.as4D(1, t1330.shape[0], t1330.shape[1], t1330.shape[2]));
        var a304 = e966;
        return 3 === a304.rank && (a304 = e966.as4D(1, e966.shape[0], e966.shape[1], e966.shape[2])), Lt.runKernelFunc(function(t1331) {
            return t1331.depthwiseConv2DDerFilter(o386, a304, r554);
        }, {
            x4D: o386,
            dy4D: a304
        });
    }
}), bl = An({
    separableConv2d_: function(t1332, e967, n723, r555, o387, a305, i208) {
        void 0 === a305 && (a305 = [
            1,
            1
        ]), void 0 === i208 && (i208 = "NHWC");
        var s185 = gn(t1332, "x", "separableConv2d"), u137 = gn(e967, "depthwiseFilter", "separableConv2d"), c107 = gn(n723, "pointwiseFilter", "separableConv2d"), l87 = s185, h78 = !1;
        if (3 === s185.rank && (h78 = !0, l87 = s185.as4D(1, s185.shape[0], s185.shape[1], s185.shape[2])), "NCHW" === i208) throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
        C(4 === l87.rank, function() {
            return "Error in separableConv2d: input must be rank 4, but got rank " + l87.rank + ".";
        }), C(4 === u137.rank, function() {
            return "Error in separableConv2d: depthwise filter must be rank 4, but got rank " + u137.rank + ".";
        }), C(4 === c107.rank, function() {
            return "Error in separableConv2d: pointwise filter must be rank 4, but got rank " + u137.rank + ".";
        }), C(1 === c107.shape[0], function() {
            return "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got " + c107.shape[0] + ".";
        }), C(1 === c107.shape[1], function() {
            return "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got " + c107.shape[1] + ".";
        });
        var f67 = u137.shape[2], d56 = u137.shape[3];
        C(c107.shape[2] === f67 * d56, function() {
            return "Error in separableConv2d: the third dimension of pointwise filter must be " + f67 * d56 + ", but got " + c107.shape[2] + ".";
        });
        var p48 = ml(l87, u137, r555, o387, i208, a305), v42 = dl(p48, c107, 1, "valid", i208);
        return h78 ? v42.as3D(v42.shape[1], v42.shape[2], v42.shape[3]) : v42;
    }
}), wl = An({
    conv2dTranspose_: function(t1333, e968, n724, r556, o388, a306) {
        return cl(n724, gn(t1333, "x", "conv2dTranspose"), gn(e968, "filter", "conv2dTranspose"), r556, o388, "NHWC", a306);
    }
}), Cl = An({
    conv3dTranspose_: function(t1334, e969, n725, r557, o389) {
        return hl(n725, gn(t1334, "x", "conv3dTranspose"), gn(e969, "filter", "conv3dTranspose"), r557, o389);
    }
});
var El = An({
    matMul_: function(t1335, e970, n726, r558) {
        var o390;
        void 0 === n726 && (n726 = !1), void 0 === r558 && (r558 = !1);
        var a307 = gn(t1335, "a", "matMul"), i209 = gn(e970, "b", "matMul");
        o390 = Nt(a307, i209), a307 = o390[0], i209 = o390[1];
        var s186 = n726 ? a307.shape[a307.rank - 2] : a307.shape[a307.rank - 1], u138 = r558 ? i209.shape[i209.rank - 1] : i209.shape[i209.rank - 2], c108 = n726 ? a307.shape[a307.rank - 1] : a307.shape[a307.rank - 2], l88 = r558 ? i209.shape[i209.rank - 2] : i209.shape[i209.rank - 1], h79 = a307.shape.slice(0, -2), f68 = i209.shape.slice(0, -2), d57 = k(h79), p49 = k(f68);
        C(a307.rank >= 2 && i209.rank >= 2 && a307.rank === i209.rank, function() {
            return "Error in matMul: inputs must have the same rank of at least 2, got ranks " + a307.rank + " and " + i209.rank + ".";
        }), C(S(h79, f68), function() {
            return "Error in matMul: outer dimensions (" + h79 + ") and (" + f68 + ") of Tensors with shapes " + a307.shape + " and " + i209.shape + " must match.";
        }), C(s186 === u138, function() {
            return "Error in matMul: inner shapes (" + s186 + ") and (" + u138 + ") of Tensors with shapes " + a307.shape + " and " + i209.shape + " and transposeA=" + n726 + " and transposeB=" + r558 + " must match.";
        });
        var v43 = a307.shape.slice(0, -2).concat([
            c108,
            l88
        ]), g35 = n726 ? a307.as3D(d57, s186, c108) : a307.as3D(d57, c108, s186), m26 = r558 ? i209.as3D(p49, l88, u138) : i209.as3D(p49, u138, l88), y20 = {
            transposeA: n726,
            transposeB: r558
        };
        return Lt.runKernelFunc(function(t1336, e971) {
            var o391 = t1336.batchMatMul(g35, m26, n726, r558);
            return e971([
                g35,
                m26
            ]), o391;
        }, {
            a: g35,
            b: m26
        }, function(t1337, e972) {
            var o392 = e972, a308 = o392[0], i210 = o392[1];
            return n726 || r558 ? !n726 && r558 ? {
                a: function() {
                    return t1337.matMul(i210, !1, !1);
                },
                b: function() {
                    return t1337.matMul(a308, !0, !1);
                }
            } : n726 && !r558 ? {
                a: function() {
                    return i210.matMul(t1337, !1, !0);
                },
                b: function() {
                    return a308.matMul(t1337, !1, !1);
                }
            } : {
                a: function() {
                    return i210.matMul(t1337, !0, !0);
                },
                b: function() {
                    return t1337.matMul(a308, !0, !0);
                }
            } : {
                a: function() {
                    return t1337.matMul(i210, !1, !0);
                },
                b: function() {
                    return a308.matMul(t1337, !0, !1);
                }
            };
        }, "BatchMatMul", y20).reshape(v43);
    }
}), Rl = An({
    dot_: function(t1338, e973) {
        var n727 = gn(t1338, "t1", "dot"), r559 = gn(e973, "t2", "dot");
        C(!(1 !== n727.rank && 2 !== n727.rank || 1 !== r559.rank && 2 !== r559.rank), function() {
            return "Error in dot: inputs must all be rank 1 or 2, but got ranks " + n727.rank + " and " + r559.rank + ".";
        });
        var o393 = 1 === n727.rank ? n727.size : n727.shape[1], a309 = 1 === r559.rank ? r559.size : r559.shape[0];
        return C(o393 === a309, function() {
            return "Error in dot: inner dimensions of inputs must match, but got " + o393 + " and " + a309 + ".";
        }), 1 === n727.rank && 1 === r559.rank ? n727.as2D(1, -1).matMul(r559.as2D(-1, 1)).asScalar() : 1 === n727.rank && 2 === r559.rank ? n727.as2D(1, -1).matMul(r559.as2D(r559.shape[0], r559.shape[1])).as1D() : 2 === n727.rank && 1 === r559.rank ? n727.matMul(r559.as2D(-1, 1)).as1D() : n727.matMul(r559.as2D(r559.shape[0], r559.shape[1]));
    }
}), Il = An({
    outerProduct_: function(t1339, e974) {
        var n728 = gn(t1339, "v1", "outerProduct"), r560 = gn(e974, "v2", "outerProduct");
        return C(1 === n728.rank && 1 === r560.rank, function() {
            return "Error in outerProduct: inputs must be rank 1, but got ranks " + n728.rank + " and " + r560.rank + ".";
        }), n728.as2D(-1, 1).matMul(r560.as2D(1, -1));
    }
});
var kl = An({
    reverse_: function(t1340, e975) {
        var n729 = gn(t1340, "x", "reverse");
        if (0 === n729.rank) return n729.clone();
        var r561 = O(e975, n729.shape);
        return Lt.runKernelFunc(function(t1341) {
            return t1341.reverse(n729, r561);
        }, {
            $x: n729
        }, function(t1342) {
            return {
                $x: function() {
                    return t1342.reverse(r561);
                }
            };
        }).reshapeAs(n729);
    }
}), Sl = An({
    reverse1d_: function(t1343) {
        var e976 = gn(t1343, "x", "reverse");
        return C(1 === e976.rank, function() {
            return "Error in reverse1D: x must be rank 1 but got rank " + e976.rank + ".";
        }), kl(e976, 0);
    }
}), Al = An({
    reverse2d_: function(t1344, e977) {
        var n730 = gn(t1344, "x", "reverse");
        return C(2 === n730.rank, function() {
            return "Error in reverse2D: x must be rank 2 but got rank " + n730.rank + ".";
        }), kl(n730, e977);
    }
}), Tl = An({
    reverse3d_: function(t1345, e978) {
        var n731 = gn(t1345, "x", "reverse");
        return C(3 === n731.rank, function() {
            return "Error in reverse3D: x must be rank 3 but got rank " + n731.rank + ".";
        }), kl(n731, e978);
    }
}), Dl = An({
    reverse4d_: function(t1346, e979) {
        var n732 = gn(t1346, "x", "reverse");
        return C(4 === n732.rank, function() {
            return "Error in reverse4D: x must be rank 4 but got rank " + n732.rank + ".";
        }), kl(n732, e979);
    }
});
function Nl(t1347, e980, n733, r562, o394, a310) {
    var i211 = gn(t1347, "x", "maxPool"), s187 = i211, u139 = !1;
    3 === i211.rank && (u139 = !0, s187 = i211.as4D(1, i211.shape[0], i211.shape[1], i211.shape[2])), null == r562 && (r562 = [
        1,
        1
    ]), C(4 === s187.rank, function() {
        return "Error in maxPool: input must be rank 4 but got rank " + s187.rank + ".";
    }), C(Ca(n733, r562), function() {
        return "Error in maxPool: Either strides or dilations must be 1. Got strides " + n733 + " and dilations '" + r562 + "'";
    }), null != a310 && C(A(o394), function() {
        return "Error in maxPool: pad must be an integer when using, dimRoundingMode " + a310 + " but got pad " + o394 + ".";
    });
    var c109 = fa(s187.shape, e980, n733, r562, o394, a310);
    if (1 === c109.filterWidth && 1 === c109.filterHeight && S(c109.inShape, c109.outShape)) return i211.clone();
    var l89 = [
        s187
    ], h80 = Lt.runKernelFunc(function(t1348, e981) {
        var n734 = t1348.maxPool(s187, c109);
        return e981([
            s187,
            n734
        ]), n734;
    }, {
        x: s187
    }, function(t1349, a311) {
        var i212 = a311[0], s188 = a311[1];
        return {
            x: function() {
                return (function(t1350, e982, n735, r563, o395, a312, i213, s189) {
                    var u140 = gn(t1350, "dy", "maxPoolBackprop"), c110 = gn(e982, "input", "maxPoolBackprop"), l90 = gn(n735, "output", "maxPoolBackprop");
                    C(c110.rank === u140.rank, function() {
                        return "Rank of input (" + c110.rank + ") does not match rank of dy (" + u140.rank + ")";
                    }), null == a312 && (a312 = [
                        1,
                        1
                    ]);
                    C(Ca(o395, a312), function() {
                        return "Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides " + o395 + " and dilations '" + a312 + "'";
                    }), C(4 === u140.rank, function() {
                        return "Error in maxPoolBackprop: dy must be rank 4 but got rank " + u140.rank + ".";
                    }), C(4 === c110.rank, function() {
                        return "Error in maxPoolBackprop: input must be rank 4 but got rank " + c110.rank + ".";
                    }), null != s189 && C(A(i213), function() {
                        return "Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode " + s189 + " but got pad " + i213 + ".";
                    });
                    var h81 = fa(c110.shape, r563, o395, a312, i213, s189);
                    return Lt.runKernelFunc(function(t1351) {
                        return t1351.maxPoolBackprop(u140, c110, l90, h81);
                    }, {
                        $dy: u140,
                        $input: c110
                    });
                })(t1349, i212, s188, e980, n733, r562, o394);
            }
        };
    }, "MaxPool", c109, l89);
    return u139 ? h80.as3D(h80.shape[1], h80.shape[2], h80.shape[3]) : h80;
}
function Fl(t1352, e983, n736, r564, o396, a313) {
    var i214 = gn(t1352, "x", "avgPool", "float32");
    null == r564 && (r564 = [
        1,
        1
    ]), C(Ca(n736, r564), function() {
        return "Error in avgPool: Either strides or dilations must be 1. Got strides " + n736 + " and dilations '" + r564 + "'";
    });
    var s190 = i214, u141 = !1;
    3 === i214.rank && (u141 = !0, s190 = i214.as4D(1, i214.shape[0], i214.shape[1], i214.shape[2])), C(4 === s190.rank, function() {
        return "Error in avgPool: x must be rank 4 but got rank " + s190.rank + ".";
    }), null != a313 && C(A(o396), function() {
        return "Error in avgPool: pad must be an integer when using, dimRoundingMode " + a313 + " but got pad " + o396 + ".";
    });
    var c111 = fa(s190.shape, e983, n736, r564, o396, a313);
    if (1 === c111.filterWidth && 1 === c111.filterHeight && S(c111.inShape, c111.outShape)) return i214.clone();
    var l91 = Lt.runKernelFunc(function(t1353) {
        return t1353.avgPool(s190, c111);
    }, {
        x: s190
    }, function(t1354) {
        return {
            x: function() {
                return (function(t1355, e984, n737, r565, o397, a314) {
                    var i215 = gn(t1355, "dy", "avgPoolBackprop"), s191 = gn(e984, "input", "avgPoolBackprop");
                    C(s191.rank === i215.rank, function() {
                        return "Rank of input (" + s191.rank + ") does not match rank of dy (" + i215.rank + ")";
                    }), null == o397 && (o397 = [
                        1,
                        1
                    ]);
                    C(Ca(r565, o397), function() {
                        return "Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides " + r565 + " and dilations '" + o397 + "'";
                    });
                    var u142 = s191, c112 = i215, l92 = !1;
                    3 === s191.rank && (l92 = !0, u142 = s191.as4D(1, s191.shape[0], s191.shape[1], s191.shape[2]), c112 = i215.as4D(1, i215.shape[0], i215.shape[1], i215.shape[2]));
                    C(4 === c112.rank, function() {
                        return "Error in avgPoolBackprop: dy must be rank 4 but got rank " + c112.rank + ".";
                    }), C(4 === u142.rank, function() {
                        return "Error in avgPoolBackprop: input must be rank 4 but got rank " + u142.rank + ".";
                    });
                    var h82 = fa(u142.shape, n737, r565, o397, a314), f69 = Lt.runKernelFunc(function(t1356) {
                        return t1356.avgPoolBackprop(c112, u142, h82);
                    }, {
                        dy4D: c112,
                        input4D: u142
                    });
                    if (l92) return f69.as3D(f69.shape[1], f69.shape[2], f69.shape[3]);
                    return f69;
                })(t1354, s190, e983, n736, r564, o396);
            }
        };
    }, "AvgPool", c111);
    return l91 = l91.cast(i214.dtype), u141 ? l91.as3D(l91.shape[1], l91.shape[2], l91.shape[3]) : l91;
}
var _l = An({
    maxPool_: function(t1357, e985, n738, r566, o398) {
        return Nl(t1357, e985, n738, 1, r566, o398);
    }
}), Ol = An({
    avgPool_: function(t1358, e986, n739, r567, o399) {
        return Fl(t1358, e986, n739, 1, r567, o399);
    }
}), Ml = An({
    pool_: function(t1359, e987, n740, r568, o400, a315) {
        null == o400 && (o400 = [
            1,
            1
        ]), null == a315 && (a315 = 1), 0 === r568 && (r568 = "valid");
        var i216 = gn(t1359, "x", "maxPool"), s192 = i216, u143 = !1;
        3 === i216.rank && (u143 = !0, s192 = i216.as4D(1, i216.shape[0], i216.shape[1], i216.shape[2])), C(Ca(a315, o400), function() {
            return "Error in pool: Either strides or dilations must be 1. Got strides " + a315 + " and dilations '" + o400 + "'";
        });
        var c113, l93 = fa(s192.shape, e987, a315, o400, r568), h83 = [
            l93.dilationHeight,
            l93.dilationWidth
        ];
        c113 = "same" === r568 ? (function(t1360, e988) {
            var n741 = t1360.map(function(t1361, n) {
                return t1361 + (t1361 - 1) * (e988[n] - 1);
            }).map(function(t1362) {
                return t1362 - 1;
            }), r569 = n741.map(function(t1363) {
                return Math.floor(t1363 / 2);
            }), o401 = n741.map(function(t1364, e) {
                return t1364 - r569[e];
            });
            return n741.map(function(t, e) {
                return [
                    r569[e],
                    o401[e]
                ];
            });
        })([
            l93.filterHeight,
            l93.filterWidth
        ], h83) : [
            [
                0,
                0
            ],
            [
                0,
                0
            ]
        ];
        var f70 = 1 === h83[0] && 1 === h83[1], d58 = function(t1365, e989, n742) {
            var r570 = n742.map(function(t1366) {
                return t1366[0];
            }), o402 = n742.map(function(t1367) {
                return t1367[1];
            }), a316 = t1365.concat(r570, o402), i217 = e989.map(function(t1368, e) {
                return (t1368 - a316[e] % t1368) % t1368;
            }), s193 = o402.map(function(t1369, e) {
                return t1369 + i217[e];
            }), u144 = e989.map(function(t, e) {
                return [
                    r570[e],
                    s193[e]
                ];
            }), c114 = e989.map(function(t, e) {
                return [
                    0,
                    i217[e]
                ];
            });
            return [
                u144,
                c114
            ];
        }([
            l93.inHeight,
            l93.inWidth
        ], h83, c113), p50 = d58[0], v44 = d58[1], g36 = f70 ? r568 : "valid", m27 = f70 ? s192 : cr(s192, h83, p50), y21 = ("avg" === n740 ? function() {
            return Fl(m27, e987, a315, 1, g36);
        } : function() {
            return Nl(m27, e987, a315, 1, g36);
        })(), x20 = f70 ? y21 : rr(y21, h83, v44);
        return u143 ? x20.as3D(x20.shape[1], x20.shape[2], x20.shape[3]) : x20;
    }
}), Bl = An({
    maxPool3d_: function(t1370, e990, n743, r571, o403, a317, i218) {
        void 0 === a317 && (a317 = "NDHWC");
        var s194 = gn(t1370, "x", "maxPool3d"), u145 = s194, c115 = !1;
        4 === s194.rank && (c115 = !0, u145 = s194.as5D(1, s194.shape[0], s194.shape[1], s194.shape[2], s194.shape[3])), null == i218 && (i218 = [
            1,
            1,
            1
        ]), C(5 === u145.rank, function() {
            return "Error in maxPool3d: x must be rank 5 but got rank " + u145.rank + ".";
        }), C("NDHWC" === a317, function() {
            return "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of " + a317;
        }), C(Ca(n743, i218), function() {
            return "Error in maxPool3d: Either strides or dilations must be 1. Got strides " + n743 + " and dilations '" + i218 + "'";
        }), null != o403 && C(A(r571), function() {
            return "Error in maxPool3d: pad must be an integer when using, dimRoundingMode " + o403 + " but got pad " + r571 + ".";
        });
        var l94 = da(u145.shape, e990, n743, i218, r571, o403, a317), h84 = Lt.runKernelFunc(function(t1371, e991) {
            var n744 = t1371.maxPool3d(u145, l94);
            return e991([
                u145,
                n744
            ]), n744;
        }, {
            x: u145
        }, function(t1372, a318) {
            var s195 = a318[0], u146 = a318[1];
            return {
                x: function() {
                    return (function(t1373, e992, n745, r572, o404, a319, i219, s196) {
                        var u147 = gn(t1373, "dy", "maxPool3dBackprop"), c116 = gn(e992, "input", "maxPool3dBackprop"), l95 = gn(n745, "output", "maxPool3dBackprop"), h85 = u147, f71 = c116, d59 = l95, p51 = !1;
                        4 === c116.rank && (p51 = !0, h85 = u147.as5D(1, u147.shape[0], u147.shape[1], u147.shape[2], u147.shape[3]), f71 = c116.as5D(1, c116.shape[0], c116.shape[1], c116.shape[2], c116.shape[3]), d59 = l95.as5D(1, l95.shape[0], l95.shape[1], l95.shape[2], l95.shape[3]));
                        C(5 === h85.rank, function() {
                            return "Error in maxPool3dBackprop: dy must be rank 5 but got rank " + h85.rank + ".";
                        }), C(5 === f71.rank, function() {
                            return "Error in maxPool3dBackprop: input must be rank 5 but got rank " + f71.rank + ".";
                        }), C(5 === d59.rank, function() {
                            return "Error in maxPool3dBackprop: output must be rank 5 but got rank " + d59.rank + ".";
                        }), null == a319 && (a319 = [
                            1,
                            1,
                            1
                        ]);
                        C(Ca(o404, a319), function() {
                            return "Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides " + o404 + " and dilations '" + a319 + "'";
                        }), null != s196 && C(A(i219), function() {
                            return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + s196 + " but got pad " + i219 + ".";
                        });
                        var v45 = da(f71.shape, r572, o404, a319, i219, s196), g37 = Lt.runKernelFunc(function(t1374) {
                            return t1374.maxPool3dBackprop(h85, f71, d59, v45);
                        }, {
                            dy5D: h85,
                            input5D: f71
                        });
                        if (p51) return g37.as4D(g37.shape[1], g37.shape[2], g37.shape[3], g37.shape[4]);
                        return g37;
                    })(t1372, s195, u146, e990, n743, i218, r571, o403);
                }
            };
        });
        return c115 ? h84.as4D(h84.shape[1], h84.shape[2], h84.shape[3], h84.shape[4]) : h84;
    }
}), Pl = An({
    avgPool3d_: function(t1375, e993, n746, r573, o405, a320, i220) {
        void 0 === a320 && (a320 = "NDHWC");
        var s197 = gn(t1375, "x", "avgPool3d", "float32"), u148 = s197, c117 = !1;
        4 === s197.rank && (c117 = !0, u148 = s197.as5D(1, s197.shape[0], s197.shape[1], s197.shape[2], s197.shape[3])), null == i220 && (i220 = [
            1,
            1,
            1
        ]), C(5 === u148.rank, function() {
            return "Error in avgPool3d: x must be rank 5 but got rank " + u148.rank + ".";
        }), C("NDHWC" === a320, function() {
            return "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of " + a320;
        }), C(Ca(n746, i220), function() {
            return "Error in avgPool3d: Either strides or dilations must be 1. Got strides " + n746 + " and dilations '" + i220 + "'";
        }), null != o405 && C(A(r573), function() {
            return "Error in avgPool3d: pad must be an integer when using, dimRoundingMode " + o405 + " but got pad " + r573 + ".";
        });
        var l96 = da(u148.shape, e993, n746, i220, r573, o405, a320), h86 = Lt.runKernelFunc(function(t1376) {
            return t1376.avgPool3d(u148, l96);
        }, {
            x: u148
        }, function(t1377) {
            return {
                x: function() {
                    return (function(t1378, e994, n747, r574, o406, a321, i221) {
                        var s198 = gn(t1378, "dy", "avgPool3dBackprop"), u149 = gn(e994, "input", "avgPool3dBackprop"), c118 = s198, l97 = u149, h87 = !1;
                        4 === u149.rank && (h87 = !0, c118 = s198.as5D(1, s198.shape[0], s198.shape[1], s198.shape[2], s198.shape[3]), l97 = u149.as5D(1, u149.shape[0], u149.shape[1], u149.shape[2], u149.shape[3]));
                        C(5 === c118.rank, function() {
                            return "Error in avgPool3dBackprop: dy must be rank 5 but got rank " + c118.rank + ".";
                        }), C(5 === l97.rank, function() {
                            return "Error in avgPool3dBackprop: input must be rank 5 but got rank " + l97.rank + ".";
                        }), null == o406 && (o406 = [
                            1,
                            1,
                            1
                        ]);
                        C(Ca(r574, o406), function() {
                            return "Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides " + r574 + " and dilations '" + o406 + "'";
                        }), null != i221 && C(A(a321), function() {
                            return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + i221 + " but got pad " + a321 + ".";
                        });
                        var f72 = da(l97.shape, n747, r574, o406, a321, i221), d60 = Lt.runKernelFunc(function(t1379) {
                            return t1379.avgPool3dBackprop(c118, l97, f72);
                        }, {
                            dy5D: c118,
                            input5D: l97
                        });
                        if (h87) return d60.as4D(d60.shape[1], d60.shape[2], d60.shape[3], d60.shape[4]);
                        return d60;
                    })(t1377, u148, e993, n746, i220, r573, o405);
                }
            };
        });
        return h86 = h86.cast(u148.dtype), c117 ? h86.as4D(h86.shape[1], h86.shape[2], h86.shape[3], h86.shape[4]) : h86;
    }
}), Ll = An({
    maxPoolWithArgmax_: function(t1380, e995, n748, r575, o407) {
        void 0 === o407 && (o407 = !1);
        var a322 = gn(t1380, "x", "maxPoolWithArgmax"), i222 = {
            filterSize: e995,
            strides: n748,
            pad: r575,
            includeBatchInIndex: o407
        }, s199 = Lt.runKernel("MaxPoolWithArgmax", {
            x: a322
        }, i222);
        return {
            result: s199[0],
            indexes: s199[1]
        };
    }
});
var Wl = An({
    slice_: function(t1381, e996, n749) {
        var r576, o408, a323 = gn(t1381, "x", "slice");
        if (0 === a323.rank) throw new Error("Slicing scalar is not possible");
        (r576 = "number" == typeof e996 ? [
            e996
        ].concat(new Array(a323.rank - 1).fill(0)) : e996.length < a323.rank ? e996.concat(new Array(a323.rank - e996.length).fill(0)) : e996.slice()).forEach(function(t1382) {
            C(-1 !== t1382, function() {
                return "slice() does not support negative begin indexing.";
            });
        }), o408 = (o408 = null == n749 ? new Array(a323.rank).fill(-1) : "number" == typeof n749 ? [
            n749
        ].concat(new Array(a323.rank - 1).fill(-1)) : n749.length < a323.rank ? n749.concat(new Array(a323.rank - n749.length).fill(-1)) : n749).map(function(t1383, e997) {
            return t1383 >= 0 ? t1383 : (C(-1 === t1383, function() {
                return "Negative size values should be exactly -1 but got " + t1383 + " for the slice() size at index " + e997 + ".";
            }), a323.shape[e997] - r576[e997]);
        }), qo(a323, r576, o408);
        var i223 = a323.shape, s200 = {
            begin: r576,
            size: o408
        };
        return Lt.runKernelFunc(function(t1384) {
            return t1384.slice(a323, r576, o408);
        }, {
            x: a323
        }, function(t1385) {
            for(var e998 = [], n750 = 0; n750 < t1385.rank; n750++)e998.push([
                r576[n750],
                i223[n750] - r576[n750] - o408[n750]
            ]);
            return {
                x: function() {
                    return Ic(t1385, e998);
                }
            };
        }, "Slice", s200);
    }
}), Ul = An({
    slice1d_: function(t1386, e999, n751) {
        var r577 = gn(t1386, "x", "slice1d");
        return C(1 === r577.rank, function() {
            return "slice1d expects a rank-1 tensor, but got a rank-" + r577.rank + " tensor";
        }), Wl(r577, [
            e999
        ], [
            n751
        ]);
    }
}), Vl = An({
    slice2d_: function(t1387, e1000, n752) {
        var r578 = gn(t1387, "x", "slice2d");
        return C(2 === r578.rank, function() {
            return "slice2d expects a rank-2 tensor, but got a rank-" + r578.rank + " tensor";
        }), Wl(r578, e1000, n752);
    }
}), zl = An({
    slice3d_: function(t1388, e1001, n753) {
        var r579 = gn(t1388, "x", "slice3d");
        return C(3 === r579.rank, function() {
            return "slice3d expects a rank-3 tensor, but got a rank-" + r579.rank + " tensor";
        }), Wl(r579, e1001, n753);
    }
}), Gl = An({
    slice4d_: function(t1389, e1002, n754) {
        var r580 = gn(t1389, "x", "slice4d");
        return C(4 === r580.rank, function() {
            return "slice4d expects a rank-4 tensor, but got a rank-" + r580.rank + " tensor";
        }), Wl(r580, e1002, n754);
    }
});
function Hl(t1390, e1003, n755, r581, o409) {
    return e1003.rank < n755.rank && (e1003 = e1003.reshape(wn(e1003.shape, r581))), t1390.rank < n755.rank && (t1390 = t1390.reshape(wn(t1390.shape, r581))), {
        x: function() {
            var r582 = t1390.mul(n755.equal(e1003).cast(t1390.dtype));
            return null == o409 ? r582 : r582.transpose(o409);
        }
    };
}
var ql = An({
    all_: function(t1391, e1004, n756) {
        void 0 === e1004 && (e1004 = null), void 0 === n756 && (n756 = !1);
        var r583 = gn(t1391, "x", "all", "bool"), o410 = O(e1004, r583.shape), a324 = o410, i224 = En(a324, r583.rank);
        null != i224 && (r583 = r583.transpose(i224), a324 = In(a324.length, r583.rank));
        var s201 = Lt.runKernelFunc(function(t1392) {
            return t1392.all(r583, a324);
        }, {
            $x: r583
        });
        if (n756) {
            var u150 = wn(s201.shape, o410);
            return s201.reshape(u150);
        }
        return s201;
    }
}), Kl = An({
    any_: function(t1393, e1005, n757) {
        void 0 === e1005 && (e1005 = null), void 0 === n757 && (n757 = !1);
        var r584 = gn(t1393, "x", "any", "bool"), o411 = O(e1005, r584.shape), a325 = o411, i225 = En(a325, r584.rank);
        null != i225 && (r584 = r584.transpose(i225), a325 = In(a325.length, r584.rank));
        var s202 = Lt.runKernelFunc(function(t1394) {
            return t1394.any(r584, a325);
        }, {
            $x: r584
        });
        if (n757) {
            var u151 = wn(s202.shape, o411);
            return s202.reshape(u151);
        }
        return s202;
    }
}), jl = An({
    argMax_: function(t1395, e1006) {
        void 0 === e1006 && (e1006 = 0);
        var n758 = gn(t1395, "x", "argMax");
        null == e1006 && (e1006 = 0);
        var r585 = O(e1006, n758.shape), o412 = En(r585, n758.rank);
        null != o412 && (n758 = n758.transpose(o412), r585 = In(r585.length, n758.rank));
        var a326 = {
            axis: r585[0]
        }, i226 = [
            n758
        ];
        return Lt.runKernelFunc(function(t1396, e1007) {
            var o413 = t1396.argMax(n758, r585[0]);
            return e1007([
                n758
            ]), o413;
        }, {
            x: n758
        }, function(t, e1008) {
            var n759 = e1008[0];
            return {
                x: function() {
                    return Xn(n759);
                }
            };
        }, "ArgMax", a326, i226);
    }
}), Xl = An({
    argMin_: function(t1397, e1009) {
        void 0 === e1009 && (e1009 = 0);
        var n760 = gn(t1397, "x", "argMin");
        null == e1009 && (e1009 = 0);
        var r586 = O(e1009, n760.shape), o414 = En(r586, n760.rank);
        return null != o414 && (n760 = n760.transpose(o414), r586 = In(r586.length, n760.rank)), Lt.runKernelFunc(function(t1398, e1010) {
            var o415 = t1398.argMin(n760, r586[0]);
            return e1010([
                n760
            ]), o415;
        }, {
            $x: n760
        }, function(t, e1011) {
            var n761 = e1011[0];
            return {
                $x: function() {
                    return Xn(n761);
                }
            };
        });
    }
}), Yl = An({
    logSumExp_: function(t1399, e1012, n762) {
        void 0 === e1012 && (e1012 = null), void 0 === n762 && (n762 = !1);
        var r587 = gn(t1399, "x", "logSumExp"), o416 = O(e1012, r587.shape), a327 = r587.max(o416, !0), i227 = r587.sub(a327).exp().sum(o416).log(), s203 = a327.reshape(i227.shape).add(i227);
        if (n762) {
            var u152 = wn(s203.shape, o416);
            return s203.reshape(u152);
        }
        return s203;
    }
}), $l = An({
    max_: function(t1400, e1013, n763) {
        void 0 === e1013 && (e1013 = null), void 0 === n763 && (n763 = !1);
        var r588 = gn(t1400, "x", "max"), o417 = r588, a328 = O(e1013, r588.shape), i228 = a328, s204 = En(i228, r588.rank);
        null != s204 && (r588 = r588.transpose(s204), i228 = In(i228.length, r588.rank));
        var u153 = [
            r588
        ], c119 = Lt.runKernelFunc(function(t1401, e1014) {
            var n764 = t1401.max(r588, i228);
            return e1014([
                o417,
                n764
            ]), n764;
        }, {
            x: r588
        }, function(t1402, e1015) {
            return Hl(t1402, e1015[1], e1015[0], a328, s204);
        }, "Max", {
            axes: i228
        }, u153, [
            !0
        ]);
        if (n763) {
            var l98 = wn(c119.shape, a328);
            c119 = c119.reshape(l98);
        }
        return c119;
    }
}), Ql = An({
    mean_: function(t1403, e1016, n765) {
        void 0 === e1016 && (e1016 = null), void 0 === n765 && (n765 = !1);
        var r589 = gn(t1403, "x", "mean"), o418 = O(e1016, r589.shape), a329 = k(bn(r589.shape, o418)[1]);
        return oa(function(t1404) {
            var r590 = On(a329);
            return {
                value: (r590.dtype === t1404.dtype ? t1404 : t1404.cast(r590.dtype)).div(r590).sum(e1016, n765),
                gradFunc: function(e1017) {
                    var n766 = t1404.shape.slice();
                    return o418.forEach(function(t) {
                        n766[t] = 1;
                    }), e1017.reshape(n766).mul(zn(t1404.shape, "float32")).div(a329);
                }
            };
        })(r589);
    }
}), Jl = An({
    min_: function(t1405, e1018, n767) {
        void 0 === e1018 && (e1018 = null), void 0 === n767 && (n767 = !1);
        var r591 = gn(t1405, "x", "min"), o419 = r591, a330 = O(e1018, r591.shape), i229 = a330, s205 = En(i229, r591.rank);
        null != s205 && (r591 = r591.transpose(s205), i229 = In(i229.length, r591.rank));
        var u154 = [
            r591
        ], c120 = Lt.runKernelFunc(function(t1406, e1019) {
            var n768 = t1406.min(r591, i229);
            return e1019([
                o419,
                n768
            ]), n768;
        }, {
            x: r591
        }, function(t1407, e1020) {
            return Hl(t1407, e1020[1], e1020[0], a330, s205);
        }, "Min", {
            axes: i229
        }, u154, [
            !0
        ]);
        if (n767) {
            var l99 = wn(c120.shape, a330);
            c120 = c120.reshape(l99);
        }
        return c120;
    }
}), Zl = An({
    moments_: function(t1408, e1021, n769) {
        void 0 === e1021 && (e1021 = null), void 0 === n769 && (n769 = !1);
        var r592 = O(e1021, (t1408 = gn(t1408, "x", "moments")).shape), o420 = t1408.mean(r592, n769), a331 = o420.shape;
        n769 || (a331 = wn(o420.shape, r592));
        var i230 = t1408.toFloat().sub(o420.reshape(a331)).square();
        return {
            mean: o420,
            variance: i230.mean(r592, n769)
        };
    }
}), th = An({
    sum_: function(t1409, e1022, n770) {
        void 0 === e1022 && (e1022 = null), void 0 === n770 && (n770 = !1);
        var r593 = gn(t1409, "x", "sum");
        "bool" === r593.dtype && (r593 = r593.toInt());
        var o421 = O(e1022, r593.shape);
        return oa(function(t1410) {
            var e1023 = En(o421, t1410.rank), r594 = o421, a332 = t1410;
            null != e1023 && (a332 = t1410.transpose(e1023), r594 = In(r594.length, t1410.rank));
            var i231 = function(e1024) {
                var n771 = t1410.shape.slice();
                return o421.forEach(function(t) {
                    n771[t] = 1;
                }), e1024.reshape(n771).mul(zn(t1410.shape, "float32"));
            }, s206 = {
                axes: r594
            }, u155 = Lt.runKernelFunc(function(t1411) {
                return t1411.sum(a332, r594);
            }, {
                x: a332
            }, function(t1412) {
                return {
                    x: function() {
                        return i231(t1412);
                    }
                };
            }, "Sum", s206);
            if (n770) {
                var c121 = wn(u155.shape, o421);
                u155 = u155.reshape(c121);
            }
            return {
                value: u155,
                gradFunc: i231
            };
        })(r593);
    }
}), eh = An({
    prod_: function(t1413, e1025, n772) {
        void 0 === e1025 && (e1025 = null), void 0 === n772 && (n772 = !1);
        var r595 = gn(t1413, "x", "prod");
        "bool" === r595.dtype && (r595 = r595.toInt());
        var o422 = O(e1025, r595.shape), a333 = En(o422, r595.rank), i232 = o422, s207 = r595;
        null != a333 && (s207 = r595.transpose(a333), i232 = In(i232.length, r595.rank));
        var u156 = Lt.runKernelFunc(function(t1414) {
            return t1414.prod(s207, i232);
        }, {
            permutedX: s207
        });
        if (n772) {
            var c122 = wn(u156.shape, o422);
            u156 = u156.reshape(c122);
        }
        return u156;
    }
});
var nh = An({
    elu_: function(t1415) {
        var e1026 = gn(t1415, "x", "elu");
        return Lt.runKernelFunc(function(t1416, n773) {
            var r596 = t1416.elu(e1026);
            return n773([
                r596
            ]), r596;
        }, {
            $x: e1026
        }, function(t1417, e1027) {
            var n774 = e1027[0];
            return {
                $x: function() {
                    return Lt.runKernelFunc(function(e1028) {
                        return e1028.eluDer(t1417, n774);
                    }, {
                        dy: t1417,
                        y: n774
                    });
                }
            };
        });
    }
}), rh = An({
    leakyRelu_: function(t1418, e1029) {
        void 0 === e1029 && (e1029 = 0.2);
        var n775 = gn(t1418, "x", "leakyRelu");
        return Eo(On(e1029).mul(n775), n775);
    }
}), oh = An({
    prelu_: function(t1419, e1030) {
        var n776 = gn(t1419, "x", "prelu"), r597 = gn(e1030, "alpha", "prelu");
        return Lt.runKernelFunc(function(t1420, e1031) {
            var o423 = t1420.prelu(n776, r597);
            return e1031([
                n776,
                r597
            ]), o423;
        }, {
            x: n776,
            alpha: r597
        }, function(t1421, e1032) {
            var n777 = e1032[0], r598 = e1032[1], o424 = n777.greater(0);
            return {
                x: function() {
                    return yc(o424, t1421, t1421.mul(r598));
                },
                alpha: function() {
                    var e1033 = yc(o424, Xn(t1421), t1421.mul(n777)), a334 = Br(r598.shape, t1421.shape);
                    return a334.length > 0 && (e1033 = e1033.sum(a334)), e1033.reshape(r598.shape);
                }
            };
        }, "Prelu");
    }
}), ah = An({
    relu_: function(t1422) {
        var e1034 = gn(t1422, "x", "relu");
        return "bool" === e1034.dtype ? e1034.toInt() : Lt.runKernelFunc(function(t1423, n778) {
            var r599 = t1423.relu(e1034);
            return n778([
                e1034
            ]), r599;
        }, {
            x: e1034
        }, function(t1424, e1035) {
            var n779 = e1035[0];
            return {
                x: function() {
                    return t1424.mulStrict(n779.step().toFloat());
                }
            };
        }, "Relu");
    }
}), ih = An({
    relu6_: function(t1425) {
        var e1036 = gn(t1425, "x", "relu6");
        return "bool" === e1036.dtype ? e1036.toInt() : Lt.runKernelFunc(function(t1426, n780) {
            var r600 = t1426.relu6(e1036);
            return n780([
                e1036
            ]), r600;
        }, {
            x: e1036
        }, function(t1427, e1037) {
            var n781 = e1037[0], r601 = n781.lessEqual(6).mul(n781.step());
            return {
                x: function() {
                    return t1427.mulStrict(r601.toFloat());
                }
            };
        }, "Relu6");
    }
}), sh = An({
    selu_: function(t1428) {
        var e1038 = gn(t1428, "x", "selu");
        return Lt.runKernelFunc(function(t1429, n782) {
            var r602 = t1429.selu(e1038);
            return n782([
                e1038
            ]), r602;
        }, {
            $x: e1038
        }, function(t1430, e1039) {
            var n783 = e1039[0];
            return {
                $x: function() {
                    var e1040 = n783.greater(On(0)), r603 = On(su), o425 = On(uu), a335 = t1430.mul(o425), i233 = t1430.mul(r603).mul(n783.toFloat().exp());
                    return yc(e1040, a335, i233);
                }
            };
        });
    }
});
var uh = An({
    localResponseNormalization_: function(t1431, e1041, n784, r604, o426) {
        void 0 === e1041 && (e1041 = 5), void 0 === n784 && (n784 = 1), void 0 === r604 && (r604 = 1), void 0 === o426 && (o426 = 0.5);
        var a336 = gn(t1431, "x", "localResponseNormalization");
        C(4 === a336.rank || 3 === a336.rank, function() {
            return "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + a336.rank + ".";
        }), C(A(e1041), function() {
            return "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius " + e1041 + ".";
        });
        var i234 = a336, s208 = !1;
        3 === a336.rank && (s208 = !0, i234 = a336.as4D(1, a336.shape[0], a336.shape[1], a336.shape[2]));
        var u157 = Lt.runKernelFunc(function(t1432, a337) {
            var s209 = t1432.localResponseNormalization4D(i234, e1041, n784, r604, o426);
            return a337([
                i234,
                s209
            ]), s209;
        }, {
            x4D: i234
        }, function(t1433, a338) {
            var i235 = a338[0], s210 = a338[1];
            return {
                x4D: function() {
                    return Lt.runKernelFunc(function(a339) {
                        return a339.LRNGrad(t1433, i235, s210, e1041, n784, r604, o426);
                    }, {
                    });
                }
            };
        });
        return s208 ? u157.as3D(u157.shape[1], u157.shape[2], u157.shape[3]) : u157;
    }
});
var ch = An({
    norm_: function(t1434, e1042, n785, r605) {
        void 0 === e1042 && (e1042 = "euclidean"), void 0 === n785 && (n785 = null), void 0 === r605 && (r605 = !1);
        var o427 = function t1435(e1043, n786, r606) {
            void 0 === r606 && (r606 = null);
            if (0 === e1043.rank) return e1043.abs();
            if (1 !== e1043.rank && null === r606) return t1435(e1043.reshape([
                -1
            ]), n786, r606);
            if (1 === e1043.rank || "number" == typeof r606 || Array.isArray(r606) && 1 === r606.length) {
                if (1 === n786) return e1043.abs().sum(r606);
                if (n786 === 1 / 0) return e1043.abs().max(r606);
                if (n786 === -1 / 0) return e1043.abs().min(r606);
                if ("euclidean" === n786 || 2 === n786) return e1043.abs().pow(On(2, "int32")).sum(r606).sqrt();
                throw new Error("Error in norm: invalid ord value: " + n786);
            }
            if (Array.isArray(r606) && 2 === r606.length) {
                if (1 === n786) return e1043.abs().sum(r606[0]).max(r606[1] - 1);
                if (n786 === 1 / 0) return e1043.abs().sum(r606[1]).max(r606[0]);
                if (n786 === -1 / 0) return e1043.abs().sum(r606[1]).min(r606[0]);
                if ("fro" === n786 || "euclidean" === n786) return e1043.square().sum(r606).sqrt();
                throw new Error("Error in norm: invalid ord value: " + n786);
            }
            throw new Error("Error in norm: invalid axis: " + r606);
        }(t1434 = gn(t1434, "x", "norm"), e1042, n785), a340 = o427.shape;
        if (r605) {
            var i236 = O(n785, t1434.shape);
            a340 = wn(o427.shape, i236);
        }
        return o427.reshape(a340);
    }
});
var lh = An({
    basicLSTMCell_: function(t1436, e1044, n787, r607, o428, a341) {
        var i237 = gn(t1436, "forgetBias", "basicLSTMCell"), s211 = gn(e1044, "lstmKernel", "basicLSTMCell"), u158 = gn(n787, "lstmBias", "basicLSTMCell"), c123 = gn(r607, "data", "basicLSTMCell"), l100 = gn(o428, "c", "basicLSTMCell"), h88 = gn(a341, "h", "basicLSTMCell"), f73 = c123.concat(h88, 1).matMul(s211).add(u158), d61 = f73.shape[0], p52 = f73.shape[1] / 4, v46 = [
            d61,
            p52
        ], g38 = f73.slice([
            0,
            0
        ], v46), m28 = f73.slice([
            0,
            p52
        ], v46), y22 = f73.slice([
            0,
            2 * p52
        ], v46), x21 = f73.slice([
            0,
            3 * p52
        ], v46), b16 = g38.sigmoid().mulStrict(m28.tanh()).addStrict(l100.mulStrict(i237.add(y22).sigmoid())), w14 = b16.tanh().mulStrict(x21.sigmoid());
        return [
            b16,
            w14
        ];
    }
}), hh = An({
    multiRNNCell_: function(t1437, e1045, n788, r608) {
        for(var o429 = gn(e1045, "data", "multiRNNCell"), a342 = mn(n788, "c", "multiRNNCell"), i238 = mn(r608, "h", "multiRNNCell"), s212 = o429, u159 = [], c124 = 0; c124 < t1437.length; c124++){
            var l101 = t1437[c124](s212, a342[c124], i238[c124]);
            u159.push(l101[0]), u159.push(l101[1]), s212 = l101[1];
        }
        var h89 = [], f74 = [];
        for(c124 = 0; c124 < u159.length; c124 += 2)h89.push(u159[c124]), f74.push(u159[c124 + 1]);
        return [
            h89,
            f74
        ];
    }
});
var fh = An({
    movingAverage_: function(t1438, e1046, n789, r609, o430) {
        void 0 === o430 && (o430 = !0);
        var a343 = gn(t1438, "v", "movingAverage"), i239 = gn(e1046, "x", "movingAverage"), s213 = gn(n789, "decay", "movingAverage");
        Ft(a343, i239), C(S(a343.shape, i239.shape), function() {
            return "Shape mismatch in v and x";
        });
        var u160 = On(1), c125 = u160.sub(s213), l102 = i239.sub(a343).mul(c125);
        if (o430) {
            C(null != r609, function() {
                return "When using zeroDebias: true, step is required.";
            });
            var h90 = gn(r609, "step", "movingAverage");
            l102 = l102.div(u160.sub(No(s213, h90)));
        }
        return a343.add(l102);
    }
});
var dh = An({
    stridedSlice_: function(t1439, e1047, n790, r610, o431, a344, i240, s214, u161) {
        if (void 0 === o431 && (o431 = 0), void 0 === a344 && (a344 = 0), void 0 === i240 && (i240 = 0), void 0 === s214 && (s214 = 0), void 0 === u161 && (u161 = 0), null == r610 && (r610 = new Array(e1047.length)), 0 !== i240) throw new Error("ellipsis mask is not yet supported");
        var c126 = gn(t1439, "x", "stridedSlice"), l103 = Ko(s214), h91 = c126.shape.slice();
        l103.forEach(function(t1440) {
            e1047[t1440] = 0, n790[t1440] = 1, h91.splice(t1440, 0, 1);
        }), c126 = c126.reshape(h91);
        for(var f75 = 0; f75 < c126.rank; f75++)e1047[f75] = Xo(o431, e1047, r610, c126.shape, f75), n790[f75] = Yo(a344, n790, r610, c126.shape, f75), r610[f75] = r610[f75] || 1;
        var d62 = Ko(u161);
        d62.forEach(function(t) {
            n790[t] = e1047[t] + 1, r610[t] = 1;
        });
        var p53 = jo(e1047, n790, r610), v47 = p53.filter(function(t, e1048) {
            return -1 === d62.indexOf(e1048);
        });
        return r610.every(function(t1441) {
            return 1 === t1441;
        }) ? Wl(c126, e1047, p53).reshape(v47) : Lt.runKernelFunc(function(t1442) {
            return t1442.stridedSlice(c126, e1047, n790, r610);
        }, {
            $x: c126
        }).reshape(v47);
    }
});
var ph = An({
    topk_: function(t1443, e1049, n791) {
        void 0 === e1049 && (e1049 = 1), void 0 === n791 && (n791 = !0);
        var r611 = gn(t1443, "x", "topk");
        if (0 === r611.rank) throw new Error("topk() expects the input to be of rank 1 or higher");
        var o432 = r611.shape[r611.shape.length - 1];
        if (e1049 > o432) throw new Error("'k' passed to topk() must be <= the last dimension (" + o432 + ") but got " + e1049);
        var a345 = Lt.runKernelFunc(function(t1444) {
            return t1444.topk(r611, e1049, n791);
        }, {
            $x: r611
        });
        return {
            values: a345[0],
            indices: a345[1]
        };
    }
});
var vh = An({
    scatterND_: function(t1445, e1050, n792) {
        var r612 = gn(t1445, "indices", "scatterND", "int32"), o433 = gn(e1050, "updates", "scatterND");
        return zo(o433, r612, n792), Lt.runKernelFunc(function(t1446) {
            return t1446.scatterND(r612, o433, n792);
        }, {
            indices: r612,
            updates: o433
        }, null, "ScatterNd", {
            shape: n792
        });
    }
});
var gh = An({
    fft_: function(t1447) {
        C("complex64" === t1447.dtype, function() {
            return "The dtype for tf.spectral.fft() must be complex64 but got " + t1447.dtype + ".";
        });
        var e1051 = t1447.shape[t1447.shape.length - 1], n793 = t1447.size / e1051, r613 = t1447.as2D(n793, e1051);
        return Lt.runKernelFunc(function(t1448) {
            return t1448.fft(r613);
        }, {
            input: t1447
        }).reshape(t1447.shape);
    }
}), mh = An({
    ifft_: function(t1449) {
        C("complex64" === t1449.dtype, function() {
            return "The dtype for tf.spectral.ifft() must be complex64 but got " + t1449.dtype + ".";
        });
        var e1052 = t1449.shape[t1449.shape.length - 1], n794 = t1449.size / e1052, r614 = t1449.as2D(n794, e1052);
        return Lt.runKernelFunc(function(t1450) {
            return t1450.ifft(r614);
        }, {
            input: t1449
        }).reshape(t1449.shape);
    }
}), yh = An({
    rfft_: function(t1451, e1053) {
        C("float32" === t1451.dtype, function() {
            return "The dtype for rfft() must be real value but got " + t1451.dtype;
        });
        var n795, r615 = t1451.shape[t1451.shape.length - 1], o434 = t1451.size / r615;
        if (null != e1053 && e1053 < r615) {
            var a346 = t1451.shape.map(function(t) {
                return 0;
            }), i241 = t1451.shape.map(function(t1452) {
                return t1452;
            });
            i241[t1451.shape.length - 1] = e1053, n795 = t1451.slice(a346, i241), r615 = e1053;
        } else if (null != e1053 && e1053 > r615) {
            var s215 = t1451.shape.map(function(t1453) {
                return t1453;
            });
            s215[t1451.shape.length - 1] = e1053 - r615, n795 = t1451.concat(Gn(s215), t1451.shape.length - 1), r615 = e1053;
        } else n795 = t1451;
        var u162 = n795.zerosLike(), c127 = Tn(n795, u162).as2D(o434, r615), l104 = gh(c127), h92 = Math.floor(r615 / 2) + 1, f76 = Dn(l104), d63 = Nn(l104), p54 = f76.split([
            h92,
            r615 - h92
        ], f76.shape.length - 1), v48 = d63.split([
            h92,
            r615 - h92
        ], d63.shape.length - 1), g39 = n795.shape.slice();
        return g39[n795.shape.length - 1] = h92, Tn(p54[0], v48[0]).reshape(g39);
    }
}), xh = An({
    irfft_: function(t1454) {
        var e1054 = t1454.shape[t1454.shape.length - 1], n796 = t1454.size / e1054;
        if (e1054 <= 2) {
            var r616 = t1454.as2D(n796, e1054), o435 = mh(r616);
            return Dn(o435);
        }
        var a347 = [
            n796,
            2 * (e1054 - 1)
        ], i242 = Dn(t1454).as2D(n796, e1054), s216 = Nn(t1454).as2D(n796, e1054), u163 = i242.slice([
            0,
            1
        ], [
            n796,
            e1054 - 2
        ]).reverse(1), c128 = s216.slice([
            0,
            1
        ], [
            n796,
            e1054 - 2
        ]).reverse(1).mul(On(-1)), l105 = i242.concat(u163, 1), h93 = s216.concat(c128, 1);
        return r616 = Tn(l105, h93).as2D(a347[0], a347[1]), o435 = mh(r616), Dn(o435);
    }
}), bh = Object.freeze({
    fft: gh,
    ifft: mh,
    rfft: yh,
    irfft: xh
});
var wh = An({
    sparseToDense_: function(t1455, e1055, n797, r617) {
        void 0 === r617 && (r617 = 0);
        var o436 = gn(t1455, "sparseIndices", "sparseToDense", "int32"), a348 = gn(e1055, "sparseValues", "sparseToDense"), i243 = gn(r617, "defaultValue", "sparseToDense", a348.dtype);
        return (function(t1456, e1056, n798, r618) {
            if ("int32" !== t1456.dtype) throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was " + t1456.dtype + ".");
            if (t1456.rank > 2) throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape " + t1456.shape + ".");
            var o437 = t1456.rank > 0 ? t1456.shape[0] : 1, a349 = t1456.rank > 1 ? t1456.shape[1] : 1;
            if (n798.length !== a349) throw new Error("outputShape has incorrect number of elements:, " + n798.length + ", should be: " + a349 + ".");
            var i244 = e1056.size;
            if (0 !== e1056.rank && (1 !== e1056.rank || i244 !== o437)) throw new Error("sparseValues has incorrect shape " + e1056.shape + ", should be [] or [" + o437 + "]");
            if (e1056.dtype !== r618.dtype) throw new Error("sparseValues.dtype must match defaultValues.dtype");
        })(o436, a348, n797, i243), Lt.runKernelFunc(function(t1457) {
            return t1457.sparseToDense(o436, a348, n797, i243);
        }, {
            $sparseIndices: o436,
            $sparseValues: a348,
            $defaultValue: i243
        });
    }
});
var Ch = An({
    gatherND_: function(t1458, e1057) {
        var n799 = gn(e1057, "indices", "gatherND", "int32"), r619 = gn(t1458, "x", "gatherND");
        return Lt.runKernelFunc(function(t1459) {
            return t1459.gatherND(r619, n799);
        }, {
            x: r619,
            indices: n799
        }, null, "GatherNd");
    }
});
var Eh = An({
    diag_: function(t1460) {
        var e1058 = gn(t1460, "x", "diag").flatten(), n800 = t1460.shape.concat(t1460.shape);
        return Lt.runKernelFunc(function(t1461) {
            return t1461.diag(e1058);
        }, {
            $x: e1058
        }).reshape(n800);
    }
});
var Rh = An({
    dropout_: function(t1462, e1059, n801, r620) {
        var o438 = gn(t1462, "x", "dropout");
        if (C("float32" === o438.dtype, function() {
            return "x has to be a floating point tensor since it's going to be scaled, but got a " + o438.dtype + " tensor instead.";
        }), C(e1059 >= 0 && e1059 < 1, function() {
            return "rate must be a float in the range [0, 1), but got " + e1059 + ".";
        }), 0 === e1059) return t1462 instanceof wt ? o438.clone() : o438;
        var a350 = function(t1463, e1060) {
            if (null == e1060) return t1463.shape.slice();
            if (S(t1463.shape, e1060)) return e1060;
            if (t1463.shape.length === e1060.length) {
                for(var n802 = [], r621 = 0; r621 < t1463.shape.length; r621++)null == e1060[r621] && null != t1463.shape[r621] ? n802.push(t1463.shape[r621]) : n802.push(e1060[r621]);
                return n802;
            }
            return e1060;
        }(o438, n801), i245 = 1 - e1059, s217 = zc(a350, 0, 1, "float32", r620).add(i245).floor().div(i245);
        return o438.mul(s217);
    }
});
function Ih(t1464, e1061, n803) {
    for(var r622 = 1 - t1464 % 2, o439 = new Float32Array(t1464), a351 = 0; a351 < t1464; ++a351){
        var i246 = 2 * Math.PI * a351 / (t1464 + r622 - 1);
        o439[a351] = e1061 - n803 * Math.cos(i246);
    }
    return Mn(o439, "float32");
}
var kh = An({
    hannWindow_: function(t1465) {
        return Ih(t1465, 0.5, 0.5);
    }
}), Sh = An({
    hammingWindow_: function(t1466) {
        return Ih(t1466, 0.54, 0.46);
    }
}), Ah = An({
    frame_: function(t1467, e1062, n804, r623, o440) {
        void 0 === r623 && (r623 = !1), void 0 === o440 && (o440 = 0);
        for(var a352 = 0, i247 = []; a352 + e1062 <= t1467.size;)i247.push(Wl(t1467, a352, e1062)), a352 += n804;
        if (r623) for(; a352 < t1467.size;){
            var s218 = a352 + e1062 - t1467.size, u164 = Yn([
                Wl(t1467, a352, e1062 - s218),
                Hn([
                    s218
                ], o440)
            ]);
            i247.push(u164), a352 += n804;
        }
        return 0 === i247.length ? Bn([], [
            0,
            e1062
        ]) : Yn(i247).as2D(i247.length, e1062);
    }
}), Th = An({
    stft_: function(t1468, e1063, n805, r624, o441) {
        var a353;
        void 0 === o441 && (o441 = kh), null == r624 && (a353 = e1063, r624 = Math.floor(Math.pow(2, Math.ceil(Math.log(a353) / Math.log(2)))));
        for(var i248 = Ah(t1468, e1063, n805), s219 = To(i248, o441(e1063)), u165 = [], c129 = 0; c129 < i248.shape[0]; c129++)u165.push(yh(s219.slice([
            c129,
            0
        ], [
            1,
            e1063
        ]), r624));
        return Yn(u165);
    }
}), Dh = Object.freeze({
    hannWindow: kh,
    hammingWindow: Sh,
    frame: Ah,
    stft: Th
});
var Nh, Fh = function(t1469, e1064, o442) {
    return void 0 === o442 && (o442 = 1), n(this, void 0, void 0, function() {
        var n806, a354, i249, s220, u166, c130, l106, h94, f77, d64, p55, v49, g40, m29;
        return r(this, function(r625) {
            switch(r625.label){
                case 0:
                    return n806 = gn(t1469, "predictions", "inTopK"), a354 = gn(e1064, "targets", "inTopK"), C(n806.rank > 1, function() {
                        return "inTopK() expects the predictions to be of rank 2 or higher, but got " + n806.rank;
                    }), C(n806.rank - 1 === a354.rank, function() {
                        return "predictions rank should be 1 larger than targets rank, but got predictions rank " + n806.rank + " and targets rank " + a354.rank;
                    }), E(n806.shape.slice(0, n806.shape.length - 1), a354.shape, "predictions's shape should be align with the targets' shape, except the last dimension."), i249 = n806.shape[n806.shape.length - 1], C(o442 > 0 && o442 <= i249, function() {
                        return "'k' passed to inTopK() must be > 0 && <= the predictions last dimension (" + i249 + "), but got " + o442;
                    }), [
                        4,
                        n806.data()
                    ];
                case 1:
                    return s220 = r625.sent(), [
                        4,
                        a354.data()
                    ];
                case 2:
                    for(u166 = r625.sent(), c130 = [
                        s220.length / i249,
                        i249
                    ], h94 = c130[1], f77 = B("bool", l106 = c130[0]), d64 = 0; d64 < l106; d64++){
                        for(p55 = d64 * h94, v49 = s220.subarray(p55, p55 + h94), g40 = [], m29 = 0; m29 < v49.length; m29++)g40.push({
                            value: v49[m29],
                            index: m29
                        });
                        for(g40.sort(function(t1470, e1065) {
                            return e1065.value - t1470.value;
                        }), f77[d64] = 0, m29 = 0; m29 < o442; m29++)if (g40[m29].index === u166[d64]) {
                            f77[d64] = 1;
                            break;
                        }
                    }
                    return t1469 !== n806 && n806.dispose(), e1064 !== a354 && a354.dispose(), [
                        2,
                        Fn(f77, a354.shape, "bool")
                    ];
            }
        });
    });
};
!function(t1471) {
    t1471[t1471.NONE = 0] = "NONE", t1471[t1471.MEAN = 1] = "MEAN", t1471[t1471.SUM = 2] = "SUM", t1471[t1471.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
}(Nh || (Nh = {
}));
var _h = An({
    absoluteDifference_: function(t1472, e1066, n807, r626) {
        void 0 === r626 && (r626 = Nh.SUM_BY_NONZERO_WEIGHTS);
        var o443 = gn(t1472, "labels", "absoluteDifference"), a355 = gn(e1066, "predictions", "absoluteDifference"), i250 = null;
        null != n807 && (i250 = gn(n807, "weights", "absoluteDifference")), E(o443.shape, a355.shape, "Error in absoluteDifference: ");
        var s221 = o443.sub(a355).abs();
        return Oh(s221, i250, r626);
    }
}), Oh = An({
    computeWeightedLoss_: function(t1473, e1067, n808) {
        void 0 === n808 && (n808 = Nh.SUM_BY_NONZERO_WEIGHTS);
        var r627 = gn(t1473, "losses", "computeWeightedLoss"), o444 = null;
        null != e1067 && (o444 = gn(e1067, "weights", "computeWeightedLoss"));
        var a356 = null == o444 ? r627 : r627.mul(o444);
        if (n808 === Nh.NONE) return a356;
        if (n808 === Nh.SUM) return a356.sum();
        if (n808 === Nh.MEAN) {
            if (null == o444) return a356.mean();
            var i251 = r627.size / o444.size, s222 = a356.sum().div(o444.sum());
            return i251 > 1 ? s222.div(On(i251)) : s222;
        }
        if (n808 === Nh.SUM_BY_NONZERO_WEIGHTS) {
            if (null == o444) return a356.sum().div(On(r627.size));
            var u167 = o444.mul(zn(r627.shape)).notEqual(On(0)).sum().toFloat();
            return a356.sum().div(u167);
        }
        throw Error("Unknown reduction: " + n808);
    }
}), Mh = An({
    cosineDistance_: function(t1474, e1068, n809, r628, o445) {
        void 0 === o445 && (o445 = Nh.SUM_BY_NONZERO_WEIGHTS);
        var a357 = gn(t1474, "labels", "cosineDistance"), i252 = gn(e1068, "predictions", "cosineDistance"), s223 = null;
        null != r628 && (s223 = gn(r628, "weights", "cosineDistance")), E(a357.shape, i252.shape, "Error in cosineDistance: ");
        var u168 = On(1).sub(a357.mul(i252).sum(n809, !0));
        return Oh(u168, s223, o445);
    }
}), Bh = An({
    hingeLoss_: function(t1475, e1069, n810, r629) {
        void 0 === r629 && (r629 = Nh.SUM_BY_NONZERO_WEIGHTS);
        var o446 = gn(t1475, "labels", "hingeLoss"), a358 = gn(e1069, "predictions", "hingeLoss"), i253 = null;
        null != n810 && (i253 = gn(n810, "weights", "hingeLoss")), E(o446.shape, a358.shape, "Error in hingeLoss: ");
        var s224 = On(1);
        o446 = On(2).mul(o446).sub(s224);
        var u169 = s224.sub(o446.mul(a358)).relu();
        return Oh(u169, i253, r629);
    }
}), Ph = An({
    huberLoss_: function(t1476, e1070, n811, r630, o447) {
        void 0 === r630 && (r630 = 1), void 0 === o447 && (o447 = Nh.SUM_BY_NONZERO_WEIGHTS);
        var a359 = gn(t1476, "labels", "huberLoss"), i254 = gn(e1070, "predictions", "huberLoss"), s225 = null;
        null != n811 && (s225 = gn(n811, "weights", "huberLoss")), E(a359.shape, i254.shape, "Error in huberLoss: ");
        var u170 = On(r630), c131 = i254.sub(a359).abs(), l107 = Io(c131, u170), h95 = c131.sub(l107), f78 = On(0.5).mul(l107.square()).add(u170.mul(h95));
        return Oh(f78, s225, o447);
    }
}), Lh = An({
    logLoss_: function(t1477, e1071, n812, r631, o448) {
        void 0 === r631 && (r631 = 0.0000001), void 0 === o448 && (o448 = Nh.SUM_BY_NONZERO_WEIGHTS);
        var a360 = gn(t1477, "labels", "logLoss"), i255 = gn(e1071, "predictions", "logLoss"), s226 = null;
        null != n812 && (s226 = gn(n812, "weights", "logLoss")), E(a360.shape, i255.shape, "Error in logLoss: ");
        var u171 = On(1), c132 = On(r631), l108 = a360.mul(i255.add(c132).log()).neg().sub(u171.sub(a360).mul(u171.sub(i255).add(c132).log()));
        return Oh(l108, s226, o448);
    }
}), Wh = An({
    meanSquaredError_: function(t1478, e1072, n813, r632) {
        void 0 === r632 && (r632 = Nh.SUM_BY_NONZERO_WEIGHTS);
        var o449 = gn(t1478, "labels", "meanSquaredError"), a361 = gn(e1072, "predictions", "meanSquaredError"), i256 = null;
        null != n813 && (i256 = gn(n813, "weights", "meanSquaredError")), E(o449.shape, a361.shape, "Error in meanSquaredError: ");
        var s227 = o449.squaredDifference(a361);
        return Oh(s227, i256, r632);
    }
}), Uh = An({
    sigmoidCrossEntropy_: function(t1479, e1073, n814, r633, o450) {
        void 0 === r633 && (r633 = 0), void 0 === o450 && (o450 = Nh.SUM_BY_NONZERO_WEIGHTS);
        var a362 = gn(t1479, "multiClassLabels", "sigmoidCrossEntropy"), i257 = gn(e1073, "logits", "sigmoidCrossEntropy"), s228 = null;
        if (null != n814 && (s228 = gn(n814, "weights", "sigmoidCrossEntropy")), E(a362.shape, i257.shape, "Error in sigmoidCrossEntropy: "), r633 > 0) {
            var u172 = On(r633), c133 = On(1), l109 = On(0.5);
            a362 = a362.mul(c133.sub(u172)).add(l109.mul(u172));
        }
        var h96 = function(t1480, e1074) {
            var n815 = gn(t1480, "labels", "sigmoidCrossEntropyWithLogits"), r634 = gn(e1074, "logits", "sigmoidCrossEntropyWithLogits");
            E(n815.shape, r634.shape, "Error in sigmoidCrossEntropyWithLogits: ");
            var o451 = r634.relu(), a363 = r634.mul(n815), i258 = r634.abs().neg().exp().log1p();
            return o451.sub(a363).add(i258);
        }(a362, i257);
        return Oh(h96, s228, o450);
    }
}), Vh = An({
    softmaxCrossEntropy_: function(t1481, e1075, n816, r635, o452) {
        void 0 === r635 && (r635 = 0), void 0 === o452 && (o452 = Nh.SUM_BY_NONZERO_WEIGHTS);
        var a364 = gn(t1481, "onehotLabels", "softmaxCrossEntropy"), i259 = gn(e1075, "logits", "softmaxCrossEntropy"), s229 = null;
        if (null != n816 && (s229 = gn(n816, "weights", "softmaxCrossEntropy")), E(a364.shape, i259.shape, "Error in softmaxCrossEntropy: "), r635 > 0) {
            var u173 = On(r635), c134 = On(1), l110 = On(a364.shape[1]);
            a364 = a364.mul(c134.sub(u173)).add(u173.div(l110));
        }
        var h97 = function(t1482, e1076, n817) {
            if (void 0 === n817 && (n817 = -1), -1 === n817 && (n817 = e1076.rank - 1), n817 !== e1076.rank - 1) throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank " + e1076.rank + " and dim was " + n817);
            return oa(function(t1483, e1077, r636) {
                var o453 = e1077.logSumExp([
                    n817
                ], !0), a365 = e1077.toFloat().sub(o453);
                r636([
                    t1483,
                    a365
                ]);
                return {
                    value: a365.mul(t1483).neg().sum([
                        n817
                    ]),
                    gradFunc: function(t1484, e1078) {
                        var r637 = e1078[0], o454 = e1078[1], a366 = wn(t1484.shape, [
                            n817
                        ]);
                        return [
                            t1484.reshape(a366).mul(r637.toFloat().sub(o454.exp())),
                            t1484.reshape(a366).mul(o454.exp().sub(r637.toFloat()))
                        ];
                    }
                };
            })(t1482, e1076);
        }(a364, i259);
        return Oh(h97, s229, o452);
    }
}), zh = Object.freeze({
    get Reduction () {
        return Nh;
    },
    absoluteDifference: _h,
    computeWeightedLoss: Oh,
    cosineDistance: Mh,
    hingeLoss: Bh,
    huberLoss: Ph,
    logLoss: Lh,
    meanSquaredError: Wh,
    sigmoidCrossEntropy: Uh,
    softmaxCrossEntropy: Vh
});
function Gh(t1485, e1079) {
    return void 0 === e1079 && (e1079 = !1), Lt.tidy(function() {
        if (2 !== t1485.shape.length) throw new Error("qr2d() requires a 2D Tensor, but got a " + t1485.shape.length + "D Tensor.");
        for(var n818 = t1485.shape[0], r638 = t1485.shape[1], o455 = Cc(n818), a367 = t1485.clone(), i260 = Bn([
            [
                1
            ]
        ], [
            1,
            1
        ]), s230 = i260.clone(), u174 = n818 >= r638 ? r638 : n818, c135 = function(t1486) {
            var e1080, u175 = a367, c136 = s230, l112 = o455;
            e1080 = Lt.tidy(function() {
                var e1081 = a367.slice([
                    t1486,
                    t1486
                ], [
                    n818 - t1486,
                    1
                ]), u176 = e1081.norm(), c137 = a367.slice([
                    t1486,
                    t1486
                ], [
                    1,
                    1
                ]), l113 = Bn([
                    [
                        -1
                    ]
                ]).where(c137.greater(0), Bn([
                    [
                        1
                    ]
                ])), h98 = c137.sub(l113.mul(u176)), f79 = e1081.div(h98);
                s230 = 1 === f79.shape[0] ? i260.clone() : i260.concat(f79.slice([
                    1,
                    0
                ], [
                    f79.shape[0] - 1,
                    f79.shape[1]
                ]), 0);
                var d65 = l113.matMul(h98).div(u176).neg(), p56 = a367.slice([
                    t1486,
                    0
                ], [
                    n818 - t1486,
                    r638
                ]), v50 = d65.mul(s230), g41 = s230.transpose();
                if (0 === t1486) a367 = p56.sub(v50.matMul(g41.matMul(p56)));
                else {
                    var m30 = p56.sub(v50.matMul(g41.matMul(p56)));
                    a367 = a367.slice([
                        0,
                        0
                    ], [
                        t1486,
                        r638
                    ]).concat(m30, 0);
                }
                var y23 = v50.transpose(), x22 = o455.slice([
                    0,
                    t1486
                ], [
                    n818,
                    o455.shape[1] - t1486
                ]);
                if (0 === t1486) o455 = x22.sub(x22.matMul(s230).matMul(y23));
                else {
                    var b17 = x22.sub(x22.matMul(s230).matMul(y23));
                    o455 = o455.slice([
                        0,
                        0
                    ], [
                        n818,
                        t1486
                    ]).concat(b17, 1);
                }
                return [
                    s230,
                    a367,
                    o455
                ];
            }), s230 = e1080[0], a367 = e1080[1], o455 = e1080[2], tn([
                u175,
                c136,
                l112
            ]);
        }, l111 = 0; l111 < u174; ++l111)c135(l111);
        return !e1079 && n818 > r638 && (o455 = o455.slice([
            0,
            0
        ], [
            n818,
            r638
        ]), a367 = a367.slice([
            0,
            0
        ], [
            r638,
            r638
        ])), [
            o455,
            a367
        ];
    });
}
var Hh = An({
    bandPart_: function(t1487, e1082, n819) {
        if (e1082 % 1 != 0) throw new Error("bandPart(): numLower must be an integer, got " + e1082 + ".");
        if (n819 % 1 != 0) throw new Error("bandPart(): numUpper must be an integer, got " + n819 + ".");
        var r639 = gn(t1487, "a", "bandPart");
        if (r639.rank < 2) throw new Error("bandPart(): Rank must be at least 2, got " + r639.rank + ".");
        var o456 = r639.shape, a368 = r639.shape.slice(-2), i261 = a368[0], s231 = a368[1];
        if (!(e1082 <= i261)) throw new Error("bandPart(): numLower (" + e1082 + ") must not be greater than the number of rows (" + i261 + ").");
        if (!(n819 <= s231)) throw new Error("bandPart(): numUpper (" + n819 + ") must not be greater than the number of columns (" + s231 + ").");
        e1082 < 0 && (e1082 = i261), n819 < 0 && (n819 = s231);
        var u177 = Kn(0, i261, 1, "int32").reshape([
            -1,
            1
        ]), c138 = Kn(0, s231, 1, "int32"), l114 = Oo(u177, c138), h99 = pc(l114.lessEqual(On(+e1082, "int32")), l114.greaterEqual(On(-n819, "int32"))), f80 = Gn([
            i261,
            s231
        ], r639.dtype);
        return hr(fr(r639.reshape([
            -1,
            i261,
            s231
        ])).map(function(t1488) {
            return yc(h99, t1488, f80);
        })).reshape(o456);
    }
}), qh = An({
    gramSchmidt_: function(t1489) {
        var e1083;
        if (Array.isArray(t1489)) {
            e1083 = !1, C(null != t1489 && t1489.length > 0, function() {
                return "Gram-Schmidt process: input must not be null, undefined, or empty";
            });
            for(var n820 = t1489[0].shape[0], r640 = function(e) {
                C(t1489[e].shape[0] === n820, function() {
                    return "Gram-Schmidt: Non-unique lengths found in the input vectors: (" + t1489[e].shape[0] + " vs. " + n820 + ")";
                });
            }, o457 = 1; o457 < t1489.length; ++o457)r640(o457);
        } else e1083 = !0, t1489 = tr(t1489, t1489.shape[0], 0).map(function(t1490) {
            return lr(t1490, [
                0
            ]);
        });
        C(t1489.length <= t1489[0].shape[0], function() {
            return "Gram-Schmidt: Number of vectors (" + t1489.length + ") exceeds number of dimensions (" + t1489[0].shape[0] + ").";
        });
        var a369 = [], i262 = t1489, s232 = function(t1491) {
            a369.push(Lt.tidy(function() {
                var e1084 = i262[t1491];
                if (t1491 > 0) for(var n821 = 0; n821 < t1491; ++n821){
                    var r641 = th(a369[n821].mulStrict(e1084)).mul(a369[n821]);
                    e1084 = e1084.sub(r641);
                }
                return e1084.div(ch(e1084, "euclidean"));
            }));
        };
        for(o457 = 0; o457 < t1489.length; ++o457)s232(o457);
        return e1083 ? hr(a369, 0) : a369;
    }
}), Kh = An({
    qr_: function(t1492, e1085) {
        if (void 0 === e1085 && (e1085 = !1), t1492.rank < 2) throw new Error("qr() requires input tensor to have a rank >= 2, but got rank " + t1492.rank);
        if (2 === t1492.rank) return Gh(t1492, e1085);
        var n822 = t1492.shape.slice(0, t1492.shape.length - 2).reduce(function(t1493, e1086) {
            return t1493 * e1086;
        }), r642 = fr(t1492.reshape([
            n822,
            t1492.shape[t1492.shape.length - 2],
            t1492.shape[t1492.shape.length - 1]
        ]), 0), o458 = [], a370 = [];
        return r642.forEach(function(t1494) {
            var n823 = Gh(t1494, e1085), r643 = n823[0], i263 = n823[1];
            o458.push(r643), a370.push(i263);
        }), [
            hr(o458, 0).reshape(t1492.shape),
            hr(a370, 0).reshape(t1492.shape)
        ];
    }
}), jh = Object.freeze({
    bandPart: Hh,
    gramSchmidt: qh,
    qr: Kh
});
function Xh(t1495, e1087, n824, r644, o459, a371) {
    null == r644 && (r644 = 0.5), null == o459 && (o459 = Number.NEGATIVE_INFINITY), null == a371 && (a371 = 0);
    var i264 = t1495.shape[0];
    return n824 = Math.min(n824, i264), C(0 <= r644 && r644 <= 1, function() {
        return "iouThreshold must be in [0, 1], but was '" + r644 + "'";
    }), C(2 === t1495.rank, function() {
        return "boxes must be a 2D tensor, but was of rank '" + t1495.rank + "'";
    }), C(4 === t1495.shape[1], function() {
        return "boxes must have 4 columns, but 2nd dimension was " + t1495.shape[1];
    }), C(1 === e1087.rank, function() {
        return "scores must be a 1D tensor";
    }), C(e1087.shape[0] === i264, function() {
        return "scores has incompatible shape with boxes. Expected " + i264 + ", but was " + e1087.shape[0];
    }), C(0 <= a371 && a371 <= 1, function() {
        return "softNmsSigma must be in [0, 1], but was '" + a371 + "'";
    }), {
        maxOutputSize: n824,
        iouThreshold: r644,
        scoreThreshold: o459,
        softNmsSigma: a371
    };
}
var Yh = An({
    resizeBilinear_: function(t1496, e1088, n825) {
        void 0 === n825 && (n825 = !1);
        var r645 = gn(t1496, "images", "resizeBilinear");
        C(3 === r645.rank || 4 === r645.rank, function() {
            return "Error in resizeBilinear: x must be rank 3 or 4, but got rank " + r645.rank + ".";
        }), C(2 === e1088.length, function() {
            return "Error in resizeBilinear: new shape must 2D, but got shape " + e1088 + ".";
        });
        var o460 = r645, a372 = !1;
        3 === r645.rank && (a372 = !0, o460 = r645.as4D(1, r645.shape[0], r645.shape[1], r645.shape[2]));
        var i265 = e1088[0], s233 = e1088[1], u178 = Lt.runKernelFunc(function(t1497, e1089) {
            return e1089([
                o460
            ]), t1497.resizeBilinear(o460, i265, s233, n825);
        }, {
            x: o460
        }, function(t1498, e1090) {
            return {
                x: function() {
                    return Lt.runKernelFunc(function(r646) {
                        return r646.resizeBilinearBackprop(t1498, e1090[0], n825);
                    }, {
                    });
                }
            };
        }, "ResizeBilinear", {
            alignCorners: n825,
            newHeight: i265,
            newWidth: s233
        });
        return a372 ? u178.as3D(u178.shape[1], u178.shape[2], u178.shape[3]) : u178;
    }
}), $h = An({
    resizeNearestNeighbor_: function(t1499, e1091, n826) {
        void 0 === n826 && (n826 = !1);
        var r647 = gn(t1499, "images", "resizeNearestNeighbor");
        C(3 === r647.rank || 4 === r647.rank, function() {
            return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank " + r647.rank + ".";
        }), C(2 === e1091.length, function() {
            return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + e1091 + ".";
        }), C("float32" === r647.dtype || "int32" === r647.dtype, function() {
            return "`images` must have `int32` or `float32` as dtype";
        });
        var o461 = r647, a373 = !1;
        3 === r647.rank && (a373 = !0, o461 = r647.as4D(1, r647.shape[0], r647.shape[1], r647.shape[2]));
        var i266 = e1091[0], s234 = e1091[1], u179 = Lt.runKernelFunc(function(t1500, e1092) {
            return e1092([
                o461
            ]), t1500.resizeNearestNeighbor(o461, i266, s234, n826);
        }, {
            batchImages: o461
        }, function(t1501, e1093) {
            return {
                batchImages: function() {
                    return Lt.runKernelFunc(function(r648) {
                        return r648.resizeNearestNeighborBackprop(t1501, e1093[0], n826);
                    }, {
                    });
                }
            };
        });
        return a373 ? u179.as3D(u179.shape[1], u179.shape[2], u179.shape[3]) : u179;
    }
}), Qh = An({
    nonMaxSuppression_: function(t1502, e1094, n827, r649, o462) {
        void 0 === r649 && (r649 = 0.5), void 0 === o462 && (o462 = Number.NEGATIVE_INFINITY);
        var a374 = gn(t1502, "boxes", "nonMaxSuppression"), i267 = gn(e1094, "scores", "nonMaxSuppression"), s235 = Xh(a374, i267, n827, r649, o462);
        n827 = s235.maxOutputSize, r649 = s235.iouThreshold, o462 = s235.scoreThreshold;
        var u180 = {
            maxOutputSize: n827,
            iouThreshold: r649,
            scoreThreshold: o462
        };
        return Lt.runKernelFunc(function(t1503) {
            return t1503.nonMaxSuppression(a374, i267, n827, r649, o462);
        }, {
            boxes: a374,
            scores: i267
        }, null, "NonMaxSuppressionV3", u180);
    }
}), Jh = function(t1504, e1095, o463, a375, i268) {
    return void 0 === a375 && (a375 = 0.5), void 0 === i268 && (i268 = Number.NEGATIVE_INFINITY), n(this, void 0, void 0, function() {
        var n828, s236, u181, c139, l115, h100, f81;
        return r(this, function(r650) {
            switch(r650.label){
                case 0:
                    return n828 = gn(t1504, "boxes", "nonMaxSuppressionAsync"), s236 = gn(e1095, "scores", "nonMaxSuppressionAsync"), u181 = Xh(n828, s236, o463, a375, i268), o463 = u181.maxOutputSize, a375 = u181.iouThreshold, i268 = u181.scoreThreshold, [
                        4,
                        Promise.all([
                            n828.data(),
                            s236.data()
                        ])
                    ];
                case 1:
                    return c139 = r650.sent(), l115 = c139[0], h100 = c139[1], f81 = Oa(l115, h100, o463, a375, i268), n828 !== t1504 && n828.dispose(), s236 !== e1095 && s236.dispose(), [
                        2,
                        f81
                    ];
            }
        });
    });
}, Zh = An({
    nonMaxSuppressionWithScore_: function(t1505, e1096, n829, r651, o464, a376) {
        void 0 === r651 && (r651 = 0.5), void 0 === o464 && (o464 = Number.NEGATIVE_INFINITY), void 0 === a376 && (a376 = 0);
        var i269 = gn(t1505, "boxes", "nonMaxSuppression"), s237 = gn(e1096, "scores", "nonMaxSuppression"), u182 = Xh(i269, s237, n829, r651, o464, a376), c140 = {
            maxOutputSize: n829 = u182.maxOutputSize,
            iouThreshold: r651 = u182.iouThreshold,
            scoreThreshold: o464 = u182.scoreThreshold,
            softNmsSigma: a376 = u182.softNmsSigma
        }, l116 = Lt.runKernel("NonMaxSuppressionV5", {
            boxes: i269,
            scores: s237
        }, c140);
        return {
            selectedIndices: l116[0],
            selectedScores: l116[1]
        };
    }
}), tf = function(t1506, e1097, o465, a377, i270, s238) {
    return void 0 === a377 && (a377 = 0.5), void 0 === i270 && (i270 = Number.NEGATIVE_INFINITY), void 0 === s238 && (s238 = 0), n(this, void 0, void 0, function() {
        var n830, u183, c141, l117, h101, f82, d66;
        return r(this, function(r652) {
            switch(r652.label){
                case 0:
                    return n830 = gn(t1506, "boxes", "nonMaxSuppressionAsync"), u183 = gn(e1097, "scores", "nonMaxSuppressionAsync"), c141 = Xh(n830, u183, o465, a377, i270, s238), o465 = c141.maxOutputSize, a377 = c141.iouThreshold, i270 = c141.scoreThreshold, s238 = c141.softNmsSigma, [
                        4,
                        Promise.all([
                            n830.data(),
                            u183.data()
                        ])
                    ];
                case 1:
                    return l117 = r652.sent(), h101 = l117[0], f82 = l117[1], d66 = Ma(h101, f82, o465, a377, i270, s238), n830 !== t1506 && n830.dispose(), u183 !== e1097 && u183.dispose(), [
                        2,
                        d66
                    ];
            }
        });
    });
}, ef = An({
    cropAndResize_: function(t1507, e1098, n831, r653, o466, a378) {
        var i271 = gn(t1507, "image", "cropAndResize"), s239 = gn(e1098, "boxes", "cropAndResize", "float32"), u184 = gn(n831, "boxInd", "cropAndResize", "int32");
        o466 = o466 || "bilinear", a378 = a378 || 0;
        var c142 = s239.shape[0];
        return C(4 === i271.rank, function() {
            return "Error in cropAndResize: image must be rank 4,but got rank " + i271.rank + ".";
        }), C(2 === s239.rank && 4 === s239.shape[1], function() {
            return "Error in cropAndResize: boxes must be have size [" + c142 + ",4] but had shape " + s239.shape + ".";
        }), C(1 === u184.rank && u184.shape[0] === c142, function() {
            return "Error in cropAndResize: boxInd must be have size [" + c142 + "] but had shape " + s239.shape + ".";
        }), C(2 === r653.length, function() {
            return "Error in cropAndResize: cropSize must be of length 2, but got length " + r653.length + ".";
        }), C(r653[0] >= 1 && r653[1] >= 1, function() {
            return "cropSize must be atleast [1,1], but was " + r653;
        }), C("bilinear" === o466 || "nearest" === o466, function() {
            return "method must be bilinear or nearest, but was " + o466;
        }), Lt.runKernelFunc(function(t1508, e) {
            return t1508.cropAndResize(i271, s239, u184, r653, o466, a378);
        }, {
            images: i271,
            boxes: s239,
            boxInd: u184
        }, null, "CropAndResize", {
            method: o466,
            extrapolationValue: a378,
            cropSize: r653
        });
    }
}), nf = Object.freeze({
    resizeBilinear: Yh,
    resizeNearestNeighbor: $h,
    nonMaxSuppression: Qh,
    nonMaxSuppressionAsync: Jh,
    nonMaxSuppressionWithScore: Zh,
    nonMaxSuppressionWithScoreAsync: tf,
    cropAndResize: ef
}), rf = function(t1509, e1099) {
    return !(t1509 > 0) || "linear" === e1099;
}, of = function(t1510, e1100, n832) {
    if (null == n832 || "linear" === n832) return t1510;
    if ("relu" === n832) return t1510.mul(e1100.step());
    throw new Error("Gradient for activation " + n832 + " has not been implemented yet.");
}, af = function(t1511, e1101) {
    var n833 = e1101, r654 = Br(t1511.shape, e1101.shape);
    return r654.length > 0 && (n833 = n833.sum(r654)), n833.reshape(t1511.shape);
}, sf = function(t1512, e1102, n834) {
    if ("linear" === e1102) return t1512;
    if ("relu" === e1102) return ah(t1512);
    if ("elu" === e1102) return nh(t1512);
    if ("relu6" === e1102) return ih(t1512);
    if ("prelu" === e1102) return oh(t1512, n834);
    throw new Error("Unknown fused activation " + e1102 + ".");
};
var uf = An({
    fusedMatMul_: function(t1513) {
        var e1103, n835 = t1513.a, r655 = t1513.b, o467 = t1513.transposeA, a379 = void 0 !== o467 && o467, i272 = t1513.transposeB, s240 = void 0 !== i272 && i272, u185 = t1513.bias, c143 = t1513.activation, l118 = void 0 === c143 ? "linear" : c143, h102 = t1513.preluActivationWeights;
        if (!1 === rf(Lt.state.gradientDepth, l118)) {
            var f83 = El(n835, r655, a379, s240);
            return null != u185 && (f83 = Or(f83, u185)), sf(f83, l118, h102);
        }
        var d67 = gn(n835, "a", "fused matMul"), p57 = gn(r655, "b", "fused matMul");
        e1103 = Nt(d67, p57), d67 = e1103[0], p57 = e1103[1];
        var v51 = a379 ? d67.shape[d67.rank - 2] : d67.shape[d67.rank - 1], g42 = s240 ? p57.shape[p57.rank - 1] : p57.shape[p57.rank - 2], m31 = a379 ? d67.shape[d67.rank - 1] : d67.shape[d67.rank - 2], y24 = s240 ? p57.shape[p57.rank - 2] : p57.shape[p57.rank - 1], x23 = d67.shape.slice(0, -2), b18 = p57.shape.slice(0, -2), w15 = k(x23), E11 = k(b18);
        C(d67.rank >= 2 && p57.rank >= 2 && d67.rank === p57.rank, function() {
            return "Error in fused matMul: inputs must have the same rank of at least 2, got ranks " + d67.rank + " and " + p57.rank + ".";
        }), C(S(x23, b18), function() {
            return "Error in fused matMul: outer dimensions (" + x23 + ") and (" + b18 + ") of Tensors with shapes " + d67.shape + " and " + p57.shape + " must match.";
        }), C(v51 === g42, function() {
            return "Error in fused matMul: inner shapes (" + v51 + ") and (" + g42 + ") of Tensors with shapes " + d67.shape + " and " + p57.shape + " and transposeA=" + a379 + " and transposeB=" + s240 + " must match.";
        });
        var R8, I3, A1 = d67.shape.slice(0, -2).concat([
            m31,
            y24
        ]), T3 = a379 ? d67.as3D(w15, v51, m31) : d67.as3D(w15, m31, v51), D3 = s240 ? p57.as3D(E11, y24, g42) : p57.as3D(E11, g42, y24);
        null != u185 && Pr(A1, (R8 = Nt(R8 = gn(u185, "bias", "fused matMul"), d67)[0]).shape), null != h102 && (I3 = gn(h102, "prelu weights", "fused matMul"));
        var N3 = {
            a: T3,
            b: D3
        };
        null != u185 && (N3.bias = R8), null != h102 && (N3.preluActivationWeights = I3);
        var F2 = [
            T3,
            D3
        ];
        return Lt.runKernelFunc(function(t1514, e1104) {
            var n836 = t1514.fusedBatchMatMul({
                a: T3,
                b: D3,
                transposeA: a379,
                transposeB: s240,
                bias: R8,
                activation: l118,
                preluActivationWeights: I3
            });
            return e1104([
                T3,
                D3,
                n836
            ]), n836;
        }, N3, function(t1515, e1105) {
            var n837 = e1105[0], r656 = e1105[1], o468 = e1105[2], i273 = of(t1515, o468, l118), c144 = {
            };
            return null != u185 && (c144 = {
                bias: function() {
                    return af(R8, i273);
                }
            }), a379 || s240 ? !a379 && s240 ? Object.assign({
                a: function() {
                    return i273.matMul(r656, !1, !1);
                },
                b: function() {
                    return i273.matMul(n837, !0, !1);
                }
            }, c144) : a379 && !s240 ? Object.assign({
                a: function() {
                    return r656.matMul(i273, !1, !0);
                },
                b: function() {
                    return n837.matMul(i273, !1, !1);
                }
            }, c144) : Object.assign({
                a: function() {
                    return r656.matMul(i273, !0, !0);
                },
                b: function() {
                    return i273.matMul(n837, !0, !0);
                }
            }, c144) : Object.assign({
                a: function() {
                    return i273.matMul(r656, !1, !0);
                },
                b: function() {
                    return n837.matMul(i273, !0, !1);
                }
            }, c144);
        }, "_FusedMatMul", {
            transposeA: a379,
            transposeB: s240,
            activation: l118
        }, F2, [
            !0
        ]).reshape(A1);
    }
}), cf = An({
    fusedConv2d_: function(t1516) {
        var e1106 = t1516.x, n838 = t1516.filter, r657 = t1516.strides, o469 = t1516.pad, a380 = t1516.dataFormat, i274 = void 0 === a380 ? "NHWC" : a380, s241 = t1516.dilations, u186 = void 0 === s241 ? [
            1,
            1
        ] : s241, c145 = t1516.dimRoundingMode, l119 = t1516.bias, h103 = t1516.activation, f84 = void 0 === h103 ? "linear" : h103, d68 = t1516.preluActivationWeights;
        if (f84 = f84 || "linear", !1 === rf(Lt.state.gradientDepth, f84)) {
            var p58 = dl(e1106, n838, r657, o469, i274, u186, c145);
            return null != l119 && (p58 = Or(p58, l119)), sf(p58, f84, d68);
        }
        var v52 = gn(e1106, "x", "conv2d"), g43 = gn(n838, "filter", "conv2d"), m32 = v52, y25 = !1;
        3 === v52.rank && (y25 = !0, m32 = v52.as4D(1, v52.shape[0], v52.shape[1], v52.shape[2])), C(4 === m32.rank, function() {
            return "Error in fused conv2d: input must be rank 4, but got rank " + m32.rank + ".";
        }), C(4 === g43.rank, function() {
            return "Error in fused conv2d: filter must be rank 4, but got rank " + g43.rank + ".";
        }), null != c145 && C(A(o469), function() {
            return "Error in fused conv2d: pad must be an integer when using, dimRoundingMode " + c145 + " but got pad " + o469 + ".";
        }), C(m32.shape[3] === g43.shape[2], function() {
            return "Error in conv2d: depth of input (" + m32.shape[3] + ") must match input depth for filter " + g43.shape[2] + ".";
        }), C(Ca(r657, u186), function() {
            return "Error in conv2D: Either strides or dilations must be 1. Got strides " + r657 + " and dilations '" + u186 + "'";
        }), C("NHWC" === i274, function() {
            return "Error in conv2d: got dataFormat of " + i274 + " but only NHWC is currently supported.";
        });
        var x24, b19, w16 = pa(m32.shape, g43.shape, r657, u186, o469, c145);
        null != l119 && (x24 = Nt(x24 = gn(l119, "bias", "fused conv2d"), v52)[0], Pr(w16.outShape, x24.shape)), null != d68 && (b19 = gn(d68, "prelu weights", "fused conv2d"));
        var E12 = {
            x: m32,
            filter: g43
        };
        null != l119 && (E12.bias = x24), null != d68 && (E12.preluActivationWeights = b19);
        var R9 = [
            g43,
            m32
        ], I4 = Lt.runKernelFunc(function(t1517, e1107) {
            var n839 = t1517.fusedConv2d({
                input: m32,
                filter: g43,
                convInfo: w16,
                bias: x24,
                activation: f84,
                preluActivationWeights: b19
            });
            return e1107([
                g43,
                m32,
                n839
            ]), n839;
        }, E12, function(t1518, e1108) {
            var n840 = e1108, a381 = n840[0], i275 = n840[1], s242 = n840[2], c146 = of(t1518, s242, f84);
            C(wa(u186), function() {
                return "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + u186 + "'";
            });
            var h104 = {
            };
            return null != l119 && (h104 = {
                bias: function() {
                    return af(x24, c146);
                }
            }), Object.assign({
                x: function() {
                    return gl(i275.shape, c146, a381, r657, o469);
                },
                filter: function() {
                    return vl(i275, c146, a381.shape, r657, o469);
                }
            }, h104);
        }, "FusedConv2D", {
            convInfo: w16,
            activation: f84
        }, R9, [
            !0
        ]);
        return y25 ? I4.as3D(I4.shape[1], I4.shape[2], I4.shape[3]) : I4;
    }
}), lf = An({
    fusedDepthwiseConv2d_: function(t1519) {
        var e1109 = t1519.x, n841 = t1519.filter, r658 = t1519.strides, o470 = t1519.pad, a382 = t1519.dataFormat, i276 = void 0 === a382 ? "NHWC" : a382, s243 = t1519.dilations, u187 = void 0 === s243 ? [
            1,
            1
        ] : s243, c147 = t1519.dimRoundingMode, l120 = t1519.bias, h105 = t1519.activation, f85 = void 0 === h105 ? "linear" : h105, d69 = t1519.preluActivationWeights;
        if (!1 === rf(Lt.state.gradientDepth, f85)) {
            var p59 = ml(e1109, n841, r658, o470, i276, u187, c147);
            return null != l120 && (p59 = Or(p59, l120)), sf(p59, f85, d69);
        }
        var v53 = gn(e1109, "x", "depthwiseConv2d"), g44 = gn(n841, "filter", "depthwiseConv2d"), m33 = v53, y26 = !1;
        3 === v53.rank && (y26 = !0, m33 = v53.as4D(1, v53.shape[0], v53.shape[1], v53.shape[2])), C(4 === m33.rank, function() {
            return "Error in fused depthwiseConv2d: input must be rank 4, but got rank " + m33.rank + ".";
        }), C(4 === g44.rank, function() {
            return "Error in fused depthwiseConv2d: filter must be rank 4, but got rank " + g44.rank + ".";
        }), C(m33.shape[3] === g44.shape[2], function() {
            return "Error in fused depthwiseConv2d: number of input channels (" + m33.shape[3] + ") must match the inChannels dimension in filter " + g44.shape[2] + ".";
        }), null == u187 && (u187 = [
            1,
            1
        ]), C(Ca(r658, u187), function() {
            return "Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides " + r658 + " and dilations '" + u187 + "'";
        }), null != c147 && C(A(o470), function() {
            return "Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode " + c147 + " but got pad " + o470 + ".";
        });
        var x25, b20, w17 = pa(m33.shape, g44.shape, r658, u187, o470, c147, !0);
        null != l120 && (x25 = Nt(x25 = gn(l120, "bias", "fused conv2d"), v53)[0], Pr(w17.outShape, x25.shape)), null != d69 && (b20 = gn(d69, "prelu weights", "fused depthwiseConv2d"));
        var E13 = {
            x: m33,
            filter: g44
        };
        null != l120 && (E13.bias = x25), null != d69 && (E13.preluActivationWeights = b20);
        var R10 = [
            g44,
            m33
        ], I5 = Lt.runKernelFunc(function(t1520, e1110) {
            var n842 = t1520.fusedDepthwiseConv2D({
                input: m33,
                filter: g44,
                convInfo: w17,
                bias: x25,
                activation: f85,
                preluActivationWeights: b20
            });
            return e1110([
                g44,
                m33,
                n842
            ]), n842;
        }, E13, function(t1521, e1111) {
            C(wa(u187), function() {
                return "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + u187 + "'";
            });
            var n843 = e1111[0], r659 = e1111[1], o471 = e1111[2], a383 = of(t1521, o471, f85), i277 = {
            };
            return null != l120 && (i277 = {
                bias: function() {
                    return af(x25, a383);
                }
            }), Object.assign({
                x: function() {
                    return yl(r659.shape, a383, n843, w17);
                },
                filter: function() {
                    return xl(r659, a383, n843.shape, w17);
                }
            }, i277);
        }, "FusedDepthwiseConv2D", {
            convInfo: w17,
            activation: f85
        }, R10, [
            !0
        ]);
        return y26 ? I5.as3D(I5.shape[1], I5.shape[2], I5.shape[3]) : I5;
    }
}), hf = Object.freeze({
    matMul: uf,
    conv2d: cf,
    depthwiseConv2d: lf
}), ff = Object.freeze({
    image: nf,
    linalg: jh,
    losses: zh,
    spectral: bh,
    fused: hf,
    signal: Dh,
    add: Or,
    addN: $u,
    batchNorm: nc,
    batchNormalization: ec,
    batchNorm2d: ac,
    batchNormalization2d: oc,
    batchNorm3d: uc,
    batchNormalization3d: sc,
    batchNorm4d: hc,
    batchNormalization4d: lc,
    broadcastTo: fc,
    clone: dc,
    div: Bo,
    divNoNan: bc,
    eye: Cc,
    multinomial: Ec,
    oneHot: Rc,
    pad: Ic,
    pad1d: kc,
    pad2d: Sc,
    pad3d: Ac,
    pad4d: Tc,
    rand: Dc,
    randomGamma: Uc,
    randomNormal: Vc,
    randomUniform: zc,
    square: Gc,
    squaredDifference: Hc,
    tile: wc,
    truncatedNormal: qc,
    conv1d: fl,
    conv2d: dl,
    conv3d: pl,
    depthwiseConv2d: ml,
    separableConv2d: bl,
    conv2dTranspose: wl,
    conv3dTranspose: Cl,
    op: An,
    booleanMaskAsync: ul,
    complex: Tn,
    real: Dn,
    imag: Nn,
    concat: Yn,
    concat1d: $n,
    concat2d: Qn,
    concat3d: Jn,
    concat4d: Zn,
    split: tr,
    matMul: El,
    dot: Rl,
    outerProduct: Il,
    reverse: kl,
    reverse1d: Sl,
    reverse2d: Al,
    reverse3d: Tl,
    reverse4d: Dl,
    maxPool: _l,
    avgPool: Ol,
    pool: Ml,
    maxPool3d: Bl,
    avgPool3d: Pl,
    maxPoolWithArgmax: Ll,
    slice: Wl,
    slice1d: Ul,
    slice2d: Vl,
    slice3d: zl,
    slice4d: Gl,
    abs: Lr,
    acos: Wr,
    acosh: Ur,
    asin: Vr,
    asinh: zr,
    atan: Gr,
    atanh: Hr,
    ceil: qr,
    clipByValue: Kr,
    cos: jr,
    cosh: Xr,
    erf: Yr,
    exp: $r,
    expm1: Qr,
    floor: Jr,
    log: Zr,
    log1p: to,
    logSigmoid: eo,
    neg: no,
    reciprocal: ro,
    round: oo,
    rsqrt: ao,
    sigmoid: io,
    sign: so,
    isNaN: uo,
    isInf: co,
    isFinite: lo,
    sin: ho,
    sinh: fo,
    softplus: po,
    sqrt: vo,
    step: go,
    tan: mo,
    tanh: yo,
    all: ql,
    any: Kl,
    argMax: jl,
    argMin: Xl,
    logSumExp: Yl,
    max: $l,
    mean: Ql,
    min: Jl,
    moments: Zl,
    sum: th,
    prod: eh,
    equal: Kc,
    equalStrict: jc,
    greater: Xc,
    greaterEqual: Yc,
    greaterEqualStrict: $c,
    greaterStrict: Qc,
    less: Jc,
    lessEqual: Zc,
    lessEqualStrict: tl,
    lessStrict: el,
    notEqual: nl,
    notEqualStrict: rl,
    addStrict: xo,
    atan2: bo,
    divStrict: wo,
    floorDiv: Co,
    maximum: Eo,
    maximumStrict: Ro,
    minimum: Io,
    minimumStrict: ko,
    mod: So,
    modStrict: Ao,
    mul: To,
    mulStrict: Do,
    pow: No,
    powStrict: Fo,
    squaredDifferenceStrict: _o,
    sub: Oo,
    subStrict: Mo,
    elu: nh,
    leakyRelu: rh,
    prelu: oh,
    relu: ah,
    relu6: ih,
    selu: sh,
    logicalAnd: pc,
    logicalNot: vc,
    logicalOr: gc,
    logicalXor: mc,
    where: yc,
    whereAsync: xc,
    buffer: er,
    print: nr,
    batchToSpaceND: rr,
    cast: or,
    cumsum: ar,
    depthToSpace: ir,
    expandDims: sr,
    reshape: ur,
    spaceToBatchND: cr,
    squeeze: lr,
    stack: hr,
    unstack: fr,
    setdiff1dAsync: dr,
    fill: Hn,
    linspace: qn,
    ones: zn,
    range: Kn,
    scalar: On,
    tensor: Fn,
    tensor1d: Mn,
    tensor2d: Bn,
    tensor3d: Pn,
    tensor4d: Ln,
    tensor5d: Wn,
    tensor6d: Un,
    variable: Vn,
    zeros: Gn,
    onesLike: jn,
    zerosLike: Xn,
    transpose: ua,
    softmax: ia,
    logSoftmax: sa,
    localResponseNormalization: uh,
    norm: ch,
    gather: il,
    unsortedSegmentSum: sl,
    basicLSTMCell: lh,
    multiRNNCell: hh,
    movingAverage: fh,
    stridedSlice: dh,
    topk: ph,
    scatterND: vh,
    fft: gh,
    ifft: mh,
    rfft: yh,
    irfft: xh,
    sparseToDense: wh,
    gatherND: Ch,
    diag: Eh,
    dropout: Rh,
    hannWindow: kh,
    hammingWindow: Sh,
    frame: Ah,
    stft: Th,
    inTopKAsync: Fh
});
function df(t1522, e1112) {
    Array.isArray(t1522) || (t1522 = [
        t1522
    ]), t1522.forEach(function(t1523) {
        null != t1523 && C("complex64" !== t1523.dtype, function() {
            return e1112 + " does not support complex64 tensors.";
        });
    });
}
function pf(t1524, e, n844, r660, o472, a384) {
    for(var i278 = o472.strideHeight, s244 = o472.strideWidth, u188 = o472.dilationHeight, c148 = o472.dilationWidth, l121 = o472.effectiveFilterHeight, h106 = o472.effectiveFilterWidth, f86 = o472.padInfo.top, d70 = o472.padInfo.left, p60 = "max" === a384 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, v54 = er(o472.outShape, n844), g45 = v54.values, m34 = o472.outShape[1] * o472.outShape[2] * o472.outShape[3], y27 = o472.outShape[2] * o472.outShape[3], x = o472.outShape[3], b21 = 0; b21 < o472.batchSize; ++b21)for(var w18 = b21 * m34, C6 = b21 * r660[0], E14 = 0; E14 < o472.inChannels; ++E14)for(var R11 = 0; R11 < o472.outHeight; ++R11)for(var I6 = R11 * i278 - f86, k3 = Math.max(0, I6), S3 = Math.min(o472.inHeight, l121 + I6), A = w18 + R11 * y27, T4 = 0; T4 < o472.outWidth; ++T4){
        for(var D4 = T4 * s244 - d70, N4 = Math.max(0, D4), F3 = Math.min(o472.inWidth, h106 + D4), _2 = p60, O2 = 0, M2 = 0, B2 = k3; B2 < S3; B2 += u188){
            for(var P = C6 + B2 * r660[1], L1 = N4; L1 < F3; L1 += c148){
                var W1 = t1524[P + L1 * r660[2] + E14];
                "max" === a384 && W1 > _2 ? _2 = W1 : "avg" === a384 && (O2 += W1, M2++);
            }
            if (isNaN(_2)) break;
        }
        g45[A + T4 * x + E14] = "avg" === a384 ? O2 / M2 : _2;
    }
    return v54;
}
function vf(t1525, e1113, n845, r661, o473, a385) {
    void 0 === o473 && (o473 = !1), void 0 === a385 && (a385 = !1);
    for(var i279 = er(r661.outShape, "int32"), s245 = r661.strideHeight, u189 = r661.strideWidth, c149 = r661.dilationHeight, l122 = r661.dilationWidth, h107 = r661.effectiveFilterHeight, f87 = r661.effectiveFilterWidth, d71 = r661.padInfo.top, p61 = r661.padInfo.left, v55 = er(e1113, n845, t1525), g46 = 0; g46 < r661.batchSize; ++g46)for(var m35 = 0; m35 < r661.inChannels; ++m35)for(var y28 = 0; y28 < r661.outHeight; ++y28){
        for(var x26 = y28 * s245 - d71, b22 = x26; b22 < 0;)b22 += c149;
        for(var w19 = Math.min(r661.inHeight, h107 + x26), C7 = 0; C7 < r661.outWidth; ++C7){
            for(var E15 = C7 * u189 - p61, R12 = E15; R12 < 0;)R12 += l122;
            for(var I7 = Math.min(r661.inWidth, f87 + E15), k4 = Number.NEGATIVE_INFINITY, S4 = -1, A2 = b22; A2 < w19; A2 += c149)for(var T5 = A2 - x26, D5 = R12; D5 < I7; D5 += l122){
                var N5 = D5 - E15, F4 = v55.get(g46, A2, D5, m35);
                F4 > k4 && (k4 = F4, S4 = o473 ? a385 ? ((g46 * r661.inHeight + A2) * r661.inWidth + D5) * r661.inChannels + m35 : (A2 * r661.inWidth + D5) * r661.inChannels + m35 : T5 * f87 + N5);
            }
            i279.set(S4, g46, y28, C7, m35);
        }
    }
    return i279;
}
function gf(t1526, e1114, n846, r662) {
    if ("linear" === n846) return t1526.linear(e1114);
    if ("relu" === n846) return t1526.relu(e1114);
    if ("elu" === n846) return t1526.elu(e1114);
    if ("relu6" === n846) return t1526.relu6(e1114);
    if ("prelu" === n846) return t1526.prelu(e1114, r662);
    throw new Error("Activation " + n846 + " has not been implemented for the CPU backend.");
}
var mf = function(t1527) {
    function o474() {
        var e1115 = t1527.call(this) || this;
        return e1115.blockSize = 48, e1115.firstUse = !0, e1115.data = new ca(e1115, Lt), e1115;
    }
    return e(o474, t1527), o474.prototype.write = function(t1528, e, n847) {
        this.firstUse && (this.firstUse = !1, i().get("IS_NODE") && dn("\n============================\nHi there ðŸ‘‹. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));
        var r663 = {
        };
        return this.data.set(r663, {
            values: t1528,
            dtype: n847
        }), r663;
    }, o474.prototype.move = function(t1529, e1116, n, r664) {
        this.data.set(t1529, {
            values: e1116,
            dtype: r664
        });
    }, o474.prototype.numDataIds = function() {
        return this.data.numDataIds();
    }, o474.prototype.read = function(t1530) {
        return n(this, void 0, void 0, function() {
            return r(this, function(e) {
                return [
                    2,
                    this.readSync(t1530)
                ];
            });
        });
    }, o474.prototype.readSync = function(t1531) {
        var e1117 = this.data.get(t1531), n848 = e1117.dtype, r665 = e1117.complexTensors;
        return "complex64" === n848 ? Aa(this.readSync(r665.real.dataId), this.readSync(r665.imag.dataId)) : this.data.get(t1531).values;
    }, o474.prototype.bufferSync = function(t1532) {
        var e1118 = this.readSync(t1532.dataId), n849 = e1118;
        if ("string" === t1532.dtype) try {
            n849 = e1118.map(function(t1533) {
                return ot(t1533);
            });
        } catch (t) {
            throw new Error("Failed to decode encoded string bytes into utf-8");
        }
        return er(t1532.shape, t1532.dtype, n849);
    }, o474.prototype.makeOutput = function(t1534, e1119, n850) {
        var r666 = this.write(t1534, e1119, n850);
        return Lt.makeTensorFromDataId(r666, e1119, n850, this);
    }, o474.prototype.disposeData = function(t1535) {
        if (this.data.has(t1535)) {
            var e1120 = this.data.get(t1535).complexTensors;
            null != e1120 && (e1120.real.dispose(), e1120.imag.dispose()), this.data.delete(t1535);
        }
    }, o474.prototype.time = function(t1536) {
        return n(this, void 0, void 0, function() {
            var e1121;
            return r(this, function(n) {
                return e1121 = et(), t1536(), [
                    2,
                    {
                        kernelMs: et() - e1121
                    }
                ];
            });
        });
    }, o474.prototype.memory = function() {
        return {
            unreliable: !0,
            reasons: [
                "The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."
            ]
        };
    }, o474.prototype.complex = function(t1537, e1122) {
        var n851 = this.makeOutput(null, t1537.shape, "complex64");
        return this.data.get(n851.dataId).complexTensors = {
            real: Lt.keep(t1537.clone()),
            imag: Lt.keep(e1122.clone())
        }, n851;
    }, o474.prototype.real = function(t1538) {
        return this.data.get(t1538.dataId).complexTensors.real.clone();
    }, o474.prototype.imag = function(t1539) {
        return this.data.get(t1539.dataId).complexTensors.imag.clone();
    }, o474.prototype.slice = function(t1540, e1123, n852) {
        if (df(t1540, "slice"), $o(t1540.shape, e1123, n852)) {
            var r667 = Qo(e1123, t1540.strides), o475 = k(n852);
            return Fn(this.readSync(t1540.dataId).subarray(r667, r667 + o475), n852, t1540.dtype);
        }
        for(var a386 = er(n852, t1540.dtype), i280 = this.bufferSync(t1540), s246 = 0; s246 < a386.size; ++s246){
            var u190 = a386.indexToLoc(s246).map(function(t1541, n) {
                return t1541 + e1123[n];
            });
            a386.values[s246] = i280.get.apply(i280, u190);
        }
        return a386.toTensor();
    }, o474.prototype.stridedSlice = function(t1542, e1124, n853, r668) {
        df(t1542, "stridedSlice");
        var o476 = jo(e1124, n853, r668);
        if (o476.some(function(t1543) {
            return 0 === t1543;
        })) return Fn([], o476);
        for(var a387 = er(o476, t1542.dtype), i281 = this.bufferSync(t1542), s247 = 0; s247 < a387.size; s247++){
            for(var u191 = a387.indexToLoc(s247), c150 = new Array(u191.length), l123 = 0; l123 < c150.length; l123++)c150[l123] = u191[l123] * r668[l123] + e1124[l123];
            a387.set.apply(a387, [
                i281.get.apply(i281, c150)
            ].concat(u191));
        }
        return a387.toTensor();
    }, o474.prototype.diag = function(t1544) {
        for(var e1125 = this.readSync(t1544.dataId), n854 = er([
            t1544.size,
            t1544.size
        ], t1544.dtype), r669 = n854.values, o477 = 0; o477 < e1125.length; o477++)r669[o477 * t1544.size + o477] = e1125[o477];
        return n854.toTensor();
    }, o474.prototype.unstack = function(t1545, e1126) {
        for(var n855 = t1545.shape[e1126], r670 = new Array(t1545.rank - 1), o = 0, a388 = 0; a388 < t1545.rank; a388++)a388 !== e1126 && (r670[o++] = t1545.shape[a388]);
        var i282 = new Array(t1545.rank).fill(0), s248 = t1545.shape.slice();
        s248[e1126] = 1;
        var u192 = new Array(n855);
        for(a388 = 0; a388 < u192.length; a388++)i282[e1126] = a388, u192[a388] = this.slice(t1545, i282, s248).reshape(r670);
        return u192;
    }, o474.prototype.reverse = function(t1546, e1127) {
        df(t1546, "reverse");
        for(var n856 = er(t1546.shape, t1546.dtype), r671 = this.bufferSync(t1546), o478 = function(o479) {
            var a390 = n856.indexToLoc(o479), i283 = a390.slice();
            e1127.forEach(function(e) {
                return i283[e] = t1546.shape[e] - 1 - i283[e];
            }), n856.set.apply(n856, [
                r671.get.apply(r671, i283)
            ].concat(a390));
        }, a389 = 0; a389 < n856.size; a389++)o478(a389);
        return n856.toTensor();
    }, o474.prototype.concat = function(t1547, e1128) {
        var n857 = this;
        if ("complex64" === t1547[0].dtype) {
            var r672 = t1547.map(function(t1548) {
                return Dn(t1548);
            }), o480 = t1547.map(function(t1549) {
                return Nn(t1549);
            });
            return Tn(this.concat(r672, e1128), this.concat(o480, e1128));
        }
        var a391 = t1547.map(function(t1550) {
            var n858 = k(t1550.shape.slice(e1128));
            return t1550.as2D(-1, n858);
        }), i284 = Sn(a391.map(function(t1551) {
            return t1551.shape;
        }), 1), s249 = er(i284, t1547[0].dtype).values;
        if (1 === a391[0].shape[0]) {
            var u193 = 0;
            a391.forEach(function(t1552) {
                s249.set(n857.readSync(t1552.dataId), u193), u193 += t1552.size;
            });
        } else {
            var c151 = 0;
            a391.forEach(function(t1553) {
                for(var e1129 = n857.readSync(t1553.dataId), r = 0, o481 = 0; o481 < t1553.shape[0]; ++o481)for(var a = o481 * i284[1] + c151, u194 = 0; u194 < t1553.shape[1]; ++u194)s249[a + u194] = e1129[r++];
                c151 += t1553.shape[1];
            });
        }
        var l124 = Sn(t1547.map(function(t1554) {
            return t1554.shape;
        }), e1128);
        return Fn(s249, l124, t1547[0].dtype);
    }, o474.prototype.neg = function(t1555) {
        return df(t1555, "neg"), this.multiply(On(-1), t1555);
    }, o474.prototype.add = function(t1556, e1130) {
        return "complex64" === t1556.dtype || "complex64" === e1130.dtype ? this.broadcastedBinaryComplexOp(t1556.cast("complex64"), e1130.cast("complex64"), function(t1557, e1131, n859, r673) {
            return {
                real: t1557 + n859,
                imag: e1131 + r673
            };
        }) : this.broadcastedBinaryOp(t1556, e1130, Tt(t1556.dtype, e1130.dtype), function(t1558, e1132) {
            return t1558 + e1132;
        });
    }, o474.prototype.addN = function(t1559) {
        var e1133 = this;
        df(t1559, "addN");
        for(var n860 = t1559.map(function(t1560) {
            return e1133.readSync(t1560.dataId);
        }), r674 = er(t1559[0].shape, t1559[0].dtype), o482 = r674.values, a392 = 0; a392 < t1559.length; a392++)for(var i285 = n860[a392], s250 = 0; s250 < o482.length; s250++)o482[s250] += i285[s250];
        return r674.toTensor();
    }, o474.prototype.softmax = function(t1561, e1134) {
        var n861 = O([
            e1134
        ], t1561.shape), r675 = this.max(t1561, n861), o483 = wn(r675.shape, n861), a393 = this.subtract(t1561, r675.reshape(o483)), i286 = this.exp(a393), s251 = this.sum(i286, n861).reshape(o483);
        return Bo(i286, s251);
    }, o474.prototype.subtract = function(t1562, e1135) {
        return "complex64" === t1562.dtype || "complex64" === e1135.dtype ? this.broadcastedBinaryComplexOp(t1562.cast("complex64"), e1135.cast("complex64"), function(t1563, e1136, n862, r676) {
            return {
                real: t1563 - n862,
                imag: e1136 - r676
            };
        }) : this.broadcastedBinaryOp(t1562, e1135, Tt(t1562.dtype, e1135.dtype), function(t1564, e1137) {
            return t1564 - e1137;
        });
    }, o474.prototype.pow = function(t1565, e1138) {
        return df([
            t1565,
            e1138
        ], "pow"), this.broadcastedBinaryOp(t1565, e1138, t1565.dtype, function(t1566, e1139) {
            return Math.pow(t1566, e1139);
        });
    }, o474.prototype.batchMatMul = function(t1567, e1140, n863, r677) {
        df([
            t1567,
            e1140
        ], "matMul");
        for(var o484 = n863 ? t1567.shape[1] : t1567.shape[2], a394 = n863 ? t1567.shape[2] : t1567.shape[1], i287 = r677 ? e1140.shape[1] : e1140.shape[2], s252 = t1567.shape[0], u195 = this.readSync(t1567.dataId), c152 = this.readSync(e1140.dataId), l125 = n863 ? [
            t1567.strides[0],
            1,
            t1567.strides[1]
        ] : [
            t1567.strides[0],
            t1567.strides[1],
            1
        ], h = l125[0], f = l125[1], d = l125[2], p62 = r677 ? [
            1,
            e1140.strides[1],
            e1140.strides[0]
        ] : [
            e1140.strides[1],
            1,
            e1140.strides[0]
        ], v = p62[0], g = p62[1], m = p62[2], y = a394 * i287, x27 = er([
            s252,
            a394,
            i287
        ], t1567.dtype), b23 = x27.values, w20 = this.blockSize, C8 = 0; C8 < s252; C8++)for(var E16 = 0; E16 < a394; E16 += w20)for(var R13 = 0; R13 < i287; R13 += w20)for(var I8 = 0; I8 < o484; I8 += w20)for(var k5 = Math.min(E16 + w20, a394), S5 = Math.min(R13 + w20, i287), A3 = Math.min(I8 + w20, o484), T6 = E16; T6 < k5; T6++)for(var D6 = R13; D6 < S5; D6++){
            for(var N6 = 0, F5 = I8; F5 < A3; F5++)N6 += u195[C8 * h + T6 * f + F5 * d] * c152[F5 * v + D6 * g + C8 * m];
            b23[C8 * y + (T6 * i287 + D6)] += N6;
        }
        return x27.toTensor();
    }, o474.prototype.fusedBatchMatMul = function(t1568) {
        var e1141 = t1568.a, n864 = t1568.b, r678 = t1568.transposeA, o485 = t1568.transposeB, a395 = t1568.bias, i288 = t1568.activation, s253 = t1568.preluActivationWeights, u196 = this.batchMatMul(e1141, n864, r678, o485);
        return a395 && (u196 = this.add(u196, a395)), i288 && (u196 = gf(this, u196, i288, s253)), u196;
    }, o474.prototype.multiply = function(t1569, e1142) {
        return "complex64" === t1569.dtype || "complex64" === e1142.dtype ? this.broadcastedBinaryComplexOp(t1569.cast("complex64"), e1142.cast("complex64"), function(t1570, e1143, n865, r679) {
            return {
                real: t1570 * n865 - e1143 * r679,
                imag: t1570 * r679 + e1143 * n865
            };
        }) : this.broadcastedBinaryOp(t1569, e1142, Tt(t1569.dtype, e1142.dtype), function(t1571, e1144) {
            return t1571 * e1144;
        });
    }, o474.prototype.floorDiv = function(t1572, e1145) {
        df([
            t1572,
            e1145
        ], "floorDiv");
        return this.broadcastedBinaryOp(t1572, e1145, "int32", function(t1573, e1146) {
            return Math.floor(t1573 / e1146);
        });
    }, o474.prototype.sum = function(t1574, e1147) {
        df(t1574, "sum"), Cn("sum", e1147, t1574.rank);
        for(var n866 = bn(t1574.shape, e1147), r680 = n866[0], o486 = n866[1], a396 = Gn(r680, Tt(t1574.dtype, "int32")), i289 = k(o486), s254 = this.readSync(a396.dataId), u197 = this.readSync(t1574.dataId), c153 = 0; c153 < s254.length; ++c153){
            for(var l = c153 * i289, h108 = 0, f88 = 0; f88 < i289; ++f88)h108 += u197[l + f88];
            s254[c153] = h108;
        }
        return a396;
    }, o474.prototype.prod = function(t1575, e1148) {
        df(t1575, "sum");
        for(var n867 = bn(t1575.shape, e1148), r681 = n867[0], o487 = n867[1], a397 = Gn(r681, Tt(t1575.dtype, "int32")), i290 = k(o487), s255 = this.readSync(a397.dataId), u198 = this.readSync(t1575.dataId), c154 = 0; c154 < s255.length; ++c154){
            for(var l = c154 * i290, h109 = 1, f89 = 0; f89 < i290; ++f89)h109 *= u198[l + f89];
            s255[c154] = h109;
        }
        return a397;
    }, o474.prototype.unsortedSegmentSum = function(t1576, e1149, n868) {
        df(t1576, "unsortedSegmentSum");
        for(var r682 = [], o488 = t1576.rank - e1149.rank, a398 = 0; a398 < o488; ++a398)e1149 = e1149.expandDims(a398 + 1);
        for(a398 = 0; a398 < n868; ++a398){
            var i291 = On(a398, "int32"), s256 = Kc(i291, e1149).asType("float32").mul(t1576).sum(0);
            r682.push(s256);
        }
        return hr(r682);
    }, o474.prototype.argMin = function(t1577, e1150) {
        df(t1577, "argMin");
        var n869 = [
            e1150
        ];
        Cn("argMin", n869, t1577.rank);
        for(var r683 = bn(t1577.shape, n869), o489 = r683[0], a399 = r683[1], i292 = Gn(o489, "int32"), s257 = k(a399), u199 = this.readSync(i292.dataId), c155 = this.readSync(t1577.dataId), l126 = 0; l126 < u199.length; ++l126){
            for(var h = l126 * s257, f90 = c155[h], d72 = 0, p63 = 0; p63 < s257; ++p63){
                var v56 = c155[h + p63];
                v56 < f90 && (f90 = v56, d72 = p63);
            }
            u199[l126] = d72;
        }
        return i292;
    }, o474.prototype.argMax = function(t1578, e1151) {
        df(t1578, "argMax");
        var n870 = [
            e1151
        ];
        Cn("argMax", n870, t1578.rank);
        for(var r684 = bn(t1578.shape, n870), o490 = r684[0], a400 = r684[1], i293 = Gn(o490, "int32"), s258 = k(a400), u200 = this.readSync(i293.dataId), c156 = this.readSync(t1578.dataId), l127 = 0; l127 < u200.length; ++l127){
            for(var h = l127 * s258, f91 = c156[h], d73 = 0, p64 = 0; p64 < s258; ++p64){
                var v57 = c156[h + p64];
                v57 > f91 && (f91 = v57, d73 = p64);
            }
            u200[l127] = d73;
        }
        return i293;
    }, o474.prototype.cumsum = function(t1579, e1152, n871, r685) {
        if (df(t1579, "cumsum"), e1152 !== t1579.rank - 1) throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (t1579.rank - 1) + " but got axis=" + e1152);
        for(var o491 = Tt(t1579.dtype, "int32"), a401 = Gn(t1579.shape, o491), i294 = this.readSync(a401.dataId), s259 = this.readSync(t1579.dataId), u201 = t1579.shape[t1579.rank - 1], c157 = r685 ? function(t1580, e1153) {
            return t1580 + u201 - e1153 - 1;
        } : function(t1581, e1154) {
            return t1581 + e1154;
        }, l128 = 0; l128 < s259.length; l128 += u201)for(var h110 = 0; h110 < u201; h110++){
            var f = c157(l128, h110);
            if (0 === h110) i294[f] = n871 ? 0 : s259[f];
            else {
                var d = c157(l128, h110 - 1);
                i294[f] = n871 ? s259[d] + i294[d] : s259[f] + i294[d];
            }
        }
        return a401;
    }, o474.prototype.equal = function(t1582, e1155) {
        return df([
            t1582,
            e1155
        ], "equal"), this.broadcastedBinaryOp(t1582, e1155, "bool", function(t1583, e1156) {
            return t1583 === e1156 ? 1 : 0;
        });
    }, o474.prototype.notEqual = function(t1584, e1157) {
        return df([
            t1584,
            e1157
        ], "notEqual"), this.broadcastedBinaryOp(t1584, e1157, "bool", function(t1585, e1158) {
            return t1585 !== e1158 ? 1 : 0;
        });
    }, o474.prototype.less = function(t1586, e1159) {
        return df([
            t1586,
            e1159
        ], "less"), this.broadcastedBinaryOp(t1586, e1159, "bool", function(t1587, e1160) {
            return t1587 < e1160 ? 1 : 0;
        });
    }, o474.prototype.lessEqual = function(t1588, e1161) {
        return df([
            t1588,
            e1161
        ], "lessEqual"), this.broadcastedBinaryOp(t1588, e1161, "bool", function(t1589, e1162) {
            return t1589 <= e1162 ? 1 : 0;
        });
    }, o474.prototype.greater = function(t1590, e1163) {
        return df([
            t1590,
            e1163
        ], "greater"), this.broadcastedBinaryOp(t1590, e1163, "bool", function(t1591, e1164) {
            return t1591 > e1164 ? 1 : 0;
        });
    }, o474.prototype.greaterEqual = function(t1592, e1165) {
        return df([
            t1592,
            e1165
        ], "greaterEqual"), this.broadcastedBinaryOp(t1592, e1165, "bool", function(t1593, e1166) {
            return t1593 >= e1166 ? 1 : 0;
        });
    }, o474.prototype.logicalNot = function(t1594) {
        df(t1594, "logicalNot");
        for(var e1167 = this.readSync(t1594.dataId), n872 = new Uint8Array(e1167.length), r686 = 0; r686 < e1167.length; ++r686)n872[r686] = e1167[r686] ? 0 : 1;
        return this.makeOutput(n872, t1594.shape, "bool");
    }, o474.prototype.logicalAnd = function(t1595, e1168) {
        return df([
            t1595,
            e1168
        ], "logicalAnd"), this.broadcastedBinaryOp(t1595, e1168, "bool", function(t1596, e1169) {
            return t1596 && e1169;
        });
    }, o474.prototype.logicalOr = function(t1597, e1170) {
        return df([
            t1597,
            e1170
        ], "logicalOr"), this.broadcastedBinaryOp(t1597, e1170, "bool", function(t1598, e1171) {
            return t1598 || e1171;
        });
    }, o474.prototype.select = function(t1599, e1172, n873) {
        df([
            t1599,
            e1172,
            n873
        ], "select");
        for(var r687 = this.readSync(t1599.dataId), o492 = this.readSync(e1172.dataId), a402 = this.readSync(n873.dataId), i295 = Gn(e1172.shape, Tt(e1172.dtype, n873.dtype)), s260 = this.readSync(i295.dataId), u = 0, c158 = 0 === t1599.rank || t1599.rank > 1 || 1 === e1172.rank ? 1 : k(e1172.shape.slice(1)), l129 = 0; l129 < r687.length; l129++)for(var h111 = 0; h111 < c158; h111++)1 === r687[l129] ? s260[u++] = o492[l129] : s260[u++] = a402[l129];
        return i295;
    }, o474.prototype.where = function(t1600) {
        df([
            t1600
        ], "where");
        var e1173 = this.readSync(t1600.dataId);
        return Ga(t1600.shape, e1173);
    }, o474.prototype.topk = function(t1601, e1174, n) {
        return df(t1601, "topk"), za(this.readSync(t1601.dataId), t1601.shape, t1601.dtype, e1174);
    }, o474.prototype.min = function(t1602, e1175) {
        df(t1602, "min"), Cn("min", e1175, t1602.rank);
        for(var n874 = bn(t1602.shape, e1175), r688 = n874[0], o493 = n874[1], a403 = Gn(r688, t1602.dtype), i296 = k(o493), s261 = this.readSync(a403.dataId), u202 = this.readSync(t1602.dataId), c159 = 0; c159 < s261.length; ++c159){
            for(var l = c159 * i296, h112 = u202[l], f92 = 0; f92 < i296; ++f92){
                var d74 = u202[l + f92];
                d74 < h112 && (h112 = d74);
            }
            s261[c159] = h112;
        }
        return a403;
    }, o474.prototype.minimum = function(t1603, e1176) {
        return df([
            t1603,
            e1176
        ], "minimum"), this.broadcastedBinaryOp(t1603, e1176, t1603.dtype, function(t1604, e1177) {
            return Math.min(t1604, e1177);
        });
    }, o474.prototype.mod = function(t1605, e1178) {
        return df([
            t1605,
            e1178
        ], "mod"), this.broadcastedBinaryOp(t1605, e1178, t1605.dtype, function(t1606, e1179) {
            var n875 = t1606 % e1179;
            return t1606 < 0 && e1179 < 0 || t1606 >= 0 && e1179 >= 0 ? n875 : (n875 + e1179) % e1179;
        });
    }, o474.prototype.max = function(t1607, e1180) {
        df(t1607, "max"), Cn("max", e1180, t1607.rank);
        for(var n876 = bn(t1607.shape, e1180), r689 = n876[0], o494 = n876[1], a404 = Gn(r689, t1607.dtype), i297 = k(o494), s262 = this.readSync(a404.dataId), u203 = this.readSync(t1607.dataId), c160 = 0; c160 < s262.length; ++c160){
            for(var l = c160 * i297, h113 = u203[l], f93 = 0; f93 < i297; ++f93){
                var d75 = u203[l + f93];
                d75 > h113 && (h113 = d75);
            }
            s262[c160] = h113;
        }
        return a404;
    }, o474.prototype.maximum = function(t1608, e1181) {
        return df([
            t1608,
            e1181
        ], "maximum"), this.broadcastedBinaryOp(t1608, e1181, t1608.dtype, function(t1609, e1182) {
            return Math.max(t1609, e1182);
        });
    }, o474.prototype.all = function(t1610, e1183) {
        df(t1610, "all"), Cn("all", e1183, t1610.rank);
        for(var n877 = bn(t1610.shape, e1183), r690 = n877[0], o495 = n877[1], a405 = Gn(r690, t1610.dtype), i298 = k(o495), s263 = this.readSync(a405.dataId), u204 = this.readSync(t1610.dataId), c161 = 0; c161 < s263.length; ++c161){
            for(var l = c161 * i298, h114 = u204[l], f94 = 0; f94 < i298; ++f94){
                var d76 = u204[l + f94];
                h114 = h114 && d76;
            }
            s263[c161] = h114;
        }
        return a405;
    }, o474.prototype.any = function(t1611, e1184) {
        df(t1611, "any"), Cn("any", e1184, t1611.rank);
        for(var n878 = bn(t1611.shape, e1184), r691 = n878[0], o496 = n878[1], a406 = Gn(r691, t1611.dtype), i299 = k(o496), s264 = this.readSync(a406.dataId), u205 = this.readSync(t1611.dataId), c162 = 0; c162 < s264.length; ++c162){
            for(var l = c162 * i299, h115 = u205[l], f95 = 0; f95 < i299; ++f95){
                var d77 = u205[l + f95];
                h115 = h115 || d77;
            }
            s264[c162] = h115;
        }
        return a406;
    }, o474.prototype.squaredDifference = function(t1612, e1185) {
        return df([
            t1612,
            e1185
        ], "squaredDifference"), this.broadcastedBinaryOp(t1612, e1185, t1612.dtype, function(t1613, e1186) {
            var n879 = t1613 - e1186;
            return n879 * n879;
        });
    }, o474.prototype.ceil = function(t1614) {
        df(t1614, "ceil");
        for(var e1187 = this.readSync(t1614.dataId), n880 = new Float32Array(e1187.length), r692 = 0; r692 < e1187.length; ++r692)n880[r692] = Math.ceil(e1187[r692]);
        return this.makeOutput(n880, t1614.shape, "float32");
    }, o474.prototype.floor = function(t1615) {
        df(t1615, "floor");
        for(var e1188 = this.readSync(t1615.dataId), n881 = new Float32Array(e1188.length), r693 = 0; r693 < e1188.length; ++r693)n881[r693] = Math.floor(e1188[r693]);
        return this.makeOutput(n881, t1615.shape, "float32");
    }, o474.prototype.sign = function(t1616) {
        df(t1616, "x");
        for(var e1189 = this.readSync(t1616.dataId), n882 = new Float32Array(e1189.length), r694 = 0; r694 < e1189.length; ++r694)e1189[r694] < 0 ? n882[r694] = -1 : e1189[r694] > 0 ? n882[r694] = 1 : n882[r694] = 0;
        return this.makeOutput(n882, t1616.shape, "float32");
    }, o474.prototype.isNaN = function(t1617) {
        df(t1617, "x");
        for(var e1190 = this.readSync(t1617.dataId), n883 = new Uint8Array(e1190.length), r695 = 0; r695 < e1190.length; ++r695)Number.isNaN(e1190[r695]) && (n883[r695] = 1);
        return this.makeOutput(n883, t1617.shape, "bool");
    }, o474.prototype.isInf = function(t1618) {
        df(t1618, "x");
        for(var e1191 = this.readSync(t1618.dataId), n884 = new Uint8Array(e1191.length), r696 = 0; r696 < e1191.length; ++r696)Math.abs(e1191[r696]) === 1 / 0 && (n884[r696] = 1);
        return this.makeOutput(n884, t1618.shape, "bool");
    }, o474.prototype.isFinite = function(t1619) {
        df(t1619, "x");
        for(var e1192 = this.readSync(t1619.dataId), n885 = new Uint8Array(e1192.length), r697 = 0; r697 < e1192.length; ++r697)Number.isFinite(e1192[r697]) && (n885[r697] = 1);
        return this.makeOutput(n885, t1619.shape, "bool");
    }, o474.prototype.round = function(t1620) {
        df(t1620, "round");
        for(var e1193 = this.readSync(t1620.dataId), n886 = new Float32Array(e1193.length), r698 = 0; r698 < e1193.length; ++r698){
            var o497 = Math.floor(e1193[r698]);
            e1193[r698] - o497 < 0.5 ? n886[r698] = Math.floor(e1193[r698]) : e1193[r698] - o497 > 0.5 ? n886[r698] = Math.ceil(e1193[r698]) : n886[r698] = o497 % 2 == 0 ? o497 : o497 + 1;
        }
        return this.makeOutput(n886, t1620.shape, "float32");
    }, o474.prototype.exp = function(t1621) {
        df(t1621, "exp");
        for(var e1194 = this.readSync(t1621.dataId), n887 = new Float32Array(e1194.length), r699 = 0; r699 < e1194.length; ++r699)n887[r699] = Math.exp(e1194[r699]);
        return this.makeOutput(n887, t1621.shape, "float32");
    }, o474.prototype.expm1 = function(t1622) {
        df(t1622, "expm1");
        for(var e1195 = this.readSync(t1622.dataId), n888 = new Float32Array(e1195.length), r700 = 0; r700 < e1195.length; ++r700)n888[r700] = Math.expm1(e1195[r700]);
        return this.makeOutput(n888, t1622.shape, "float32");
    }, o474.prototype.log = function(t1623) {
        df(t1623, "log");
        for(var e1196 = this.readSync(t1623.dataId), n889 = new Float32Array(e1196.length), r701 = 0; r701 < e1196.length; ++r701){
            var o498 = e1196[r701];
            n889[r701] = Math.log(o498);
        }
        return this.makeOutput(n889, t1623.shape, "float32");
    }, o474.prototype.log1p = function(t1624) {
        df(t1624, "log1p");
        for(var e1197 = this.readSync(t1624.dataId), n890 = new Float32Array(e1197.length), r702 = 0; r702 < e1197.length; ++r702){
            var o499 = e1197[r702];
            n890[r702] = Math.log1p(o499);
        }
        return this.makeOutput(n890, t1624.shape, "float32");
    }, o474.prototype.sqrt = function(t1625) {
        df(t1625, "sqrt");
        for(var e1198 = this.readSync(t1625.dataId), n891 = new Float32Array(e1198.length), r703 = 0; r703 < e1198.length; ++r703){
            var o500 = e1198[r703];
            n891[r703] = Math.sqrt(o500);
        }
        return this.makeOutput(n891, t1625.shape, "float32");
    }, o474.prototype.rsqrt = function(t1626) {
        df(t1626, "rsqrt");
        for(var e1199 = this.readSync(t1626.dataId), n892 = new Float32Array(e1199.length), r704 = 0; r704 < e1199.length; ++r704){
            var o501 = e1199[r704];
            n892[r704] = 1 / Math.sqrt(o501);
        }
        return this.makeOutput(n892, t1626.shape, "float32");
    }, o474.prototype.reciprocal = function(t1627) {
        df(t1627, "reciprocal");
        for(var e1200 = this.readSync(t1627.dataId), n893 = new Float32Array(e1200.length), r705 = 0; r705 < e1200.length; ++r705)n893[r705] = 1 / e1200[r705];
        return this.makeOutput(n893, t1627.shape, "float32");
    }, o474.prototype.linear = function(t1628) {
        return t1628;
    }, o474.prototype.relu = function(t1629) {
        df(t1629, "relu");
        for(var e1201 = Gn(t1629.shape, t1629.dtype), n894 = this.readSync(e1201.dataId), r706 = this.readSync(t1629.dataId), o502 = 0; o502 < r706.length; ++o502)n894[o502] = Math.max(0, r706[o502]);
        return e1201;
    }, o474.prototype.relu6 = function(t1630) {
        df(t1630, "relu");
        for(var e1202 = Gn(t1630.shape, t1630.dtype), n895 = this.readSync(e1202.dataId), r707 = this.readSync(t1630.dataId), o503 = 0; o503 < r707.length; ++o503)n895[o503] = Math.min(Math.max(0, r707[o503]), 6);
        return e1202;
    }, o474.prototype.prelu = function(t1631, e1203) {
        return df([
            t1631,
            e1203
        ], "prelu"), this.broadcastedBinaryOp(t1631, e1203, t1631.dtype, function(t1632, e1204) {
            return t1632 < 0 ? e1204 * t1632 : t1632;
        });
    }, o474.prototype.elu = function(t1633) {
        df(t1633, "elu");
        for(var e1205 = new Float32Array(t1633.size), n896 = this.readSync(t1633.dataId), r708 = 0; r708 < n896.length; ++r708){
            var o504 = n896[r708];
            e1205[r708] = o504 >= 0 ? o504 : Math.exp(o504) - 1;
        }
        return this.makeOutput(e1205, t1633.shape, "float32");
    }, o474.prototype.eluDer = function(t1634, e1206) {
        df([
            t1634,
            e1206
        ], "eluDer");
        for(var n897 = new Float32Array(e1206.size), r709 = this.readSync(e1206.dataId), o505 = this.readSync(t1634.dataId), a407 = 0; a407 < r709.length; ++a407){
            var i300 = r709[a407];
            n897[a407] = i300 >= 1 ? o505[a407] : o505[a407] * (i300 + 1);
        }
        return this.makeOutput(n897, e1206.shape, "float32");
    }, o474.prototype.selu = function(t1635) {
        df(t1635, "selu");
        for(var e1207 = su, n898 = uu, r710 = new Float32Array(t1635.size), o506 = this.readSync(t1635.dataId), a408 = 0; a408 < o506.length; ++a408){
            var i301 = o506[a408];
            r710[a408] = i301 >= 0 ? n898 * i301 : e1207 * (Math.exp(i301) - 1);
        }
        return this.makeOutput(r710, t1635.shape, "float32");
    }, o474.prototype.clip = function(t1636, e1208, n899) {
        df(t1636, "clip");
        for(var r711 = new Float32Array(t1636.size), o507 = this.readSync(t1636.dataId), a409 = 0; a409 < o507.length; ++a409){
            var i302 = o507[a409];
            r711[a409] = i302 > n899 ? n899 : i302 < e1208 ? e1208 : i302;
        }
        return this.makeOutput(r711, t1636.shape, "float32");
    }, o474.prototype.abs = function(t1637) {
        for(var e1209 = new Float32Array(t1637.size), n900 = this.readSync(t1637.dataId), r712 = 0; r712 < n900.length; ++r712)e1209[r712] = Math.abs(n900[r712]);
        return this.makeOutput(e1209, t1637.shape, "float32");
    }, o474.prototype.complexAbs = function(t1638) {
        for(var e1210 = new Float32Array(t1638.size), n901 = this.readSync(t1638.dataId), r713 = 0; r713 < t1638.size; ++r713){
            var o508 = n901[2 * r713], a410 = n901[2 * r713 + 1];
            e1210[r713] = Math.hypot(o508, a410);
        }
        return this.makeOutput(e1210, t1638.shape, "float32");
    }, o474.prototype.int = function(t1639) {
        df(t1639, "int");
        for(var e1211 = new Int32Array(t1639.size), n902 = this.readSync(t1639.dataId), r714 = 0; r714 < n902.length; ++r714)e1211[r714] = n902[r714];
        return this.makeOutput(e1211, t1639.shape, "int32");
    }, o474.prototype.sigmoid = function(t1640) {
        df(t1640, "sigmoid");
        for(var e1212 = new Float32Array(t1640.size), n903 = this.readSync(t1640.dataId), r715 = 0; r715 < n903.length; ++r715)e1212[r715] = 1 / (1 + Math.exp(-n903[r715]));
        return this.makeOutput(e1212, t1640.shape, "float32");
    }, o474.prototype.softplus = function(t1641) {
        df(t1641, "softplus");
        for(var e1213 = Math.log(0.00000011920928955078125) + 2, n904 = new Float32Array(t1641.size), r716 = this.readSync(t1641.dataId), o509 = 0; o509 < r716.length; ++o509){
            var a411 = r716[o509] > -e1213, i303 = r716[o509] < e1213, s265 = Math.exp(r716[o509]), u206 = void 0;
            u206 = i303 ? s265 : a411 ? r716[o509] : Math.log(1 + s265), n904[o509] = u206;
        }
        return this.makeOutput(n904, t1641.shape, "float32");
    }, o474.prototype.sin = function(t1642) {
        df(t1642, "sin");
        for(var e1214 = new Float32Array(t1642.size), n905 = this.readSync(t1642.dataId), r717 = 0; r717 < n905.length; ++r717)e1214[r717] = Math.sin(n905[r717]);
        return this.makeOutput(e1214, t1642.shape, "float32");
    }, o474.prototype.cos = function(t1643) {
        df(t1643, "cos");
        for(var e1215 = new Float32Array(t1643.size), n906 = this.readSync(t1643.dataId), r718 = 0; r718 < n906.length; ++r718)e1215[r718] = Math.cos(n906[r718]);
        return this.makeOutput(e1215, t1643.shape, "float32");
    }, o474.prototype.tan = function(t1644) {
        df(t1644, "tan");
        for(var e1216 = new Float32Array(t1644.size), n907 = this.readSync(t1644.dataId), r719 = 0; r719 < n907.length; ++r719)e1216[r719] = Math.tan(n907[r719]);
        return this.makeOutput(e1216, t1644.shape, "float32");
    }, o474.prototype.asin = function(t1645) {
        df(t1645, "asin");
        for(var e1217 = new Float32Array(t1645.size), n908 = this.readSync(t1645.dataId), r720 = 0; r720 < n908.length; ++r720)e1217[r720] = Math.asin(n908[r720]);
        return this.makeOutput(e1217, t1645.shape, "float32");
    }, o474.prototype.acos = function(t1646) {
        df(t1646, "acos");
        for(var e1218 = new Float32Array(t1646.size), n909 = this.readSync(t1646.dataId), r721 = 0; r721 < n909.length; ++r721)e1218[r721] = Math.acos(n909[r721]);
        return this.makeOutput(e1218, t1646.shape, "float32");
    }, o474.prototype.atan = function(t1647) {
        df(t1647, "atan");
        for(var e1219 = new Float32Array(t1647.size), n910 = this.readSync(t1647.dataId), r722 = 0; r722 < n910.length; ++r722)e1219[r722] = Math.atan(n910[r722]);
        return this.makeOutput(e1219, t1647.shape, "float32");
    }, o474.prototype.atan2 = function(t1648, e1220) {
        return df([
            t1648,
            e1220
        ], "atan2"), this.broadcastedBinaryOp(t1648, e1220, t1648.dtype, function(t1649, e1221) {
            return Math.atan2(t1649, e1221);
        });
    }, o474.prototype.sinh = function(t1650) {
        df(t1650, "sinh");
        for(var e1222 = new Float32Array(t1650.size), n911 = this.readSync(t1650.dataId), r723 = 0; r723 < n911.length; ++r723)e1222[r723] = Math.sinh(n911[r723]);
        return this.makeOutput(e1222, t1650.shape, "float32");
    }, o474.prototype.cosh = function(t1651) {
        df(t1651, "cosh");
        for(var e1223 = new Float32Array(t1651.size), n912 = this.readSync(t1651.dataId), r724 = 0; r724 < n912.length; ++r724)e1223[r724] = Math.cosh(n912[r724]);
        return this.makeOutput(e1223, t1651.shape, "float32");
    }, o474.prototype.tanh = function(t1652) {
        df(t1652, "tanh");
        for(var e1224 = new Float32Array(t1652.size), n913 = this.readSync(t1652.dataId), r725 = 0; r725 < n913.length; ++r725)e1224[r725] = T(n913[r725]);
        return this.makeOutput(e1224, t1652.shape, "float32");
    }, o474.prototype.asinh = function(t1653) {
        df(t1653, "asinh");
        for(var e1225 = new Float32Array(t1653.size), n914 = this.readSync(t1653.dataId), r726 = 0; r726 < n914.length; ++r726)e1225[r726] = Math.asinh(n914[r726]);
        return this.makeOutput(e1225, t1653.shape, "float32");
    }, o474.prototype.acosh = function(t1654) {
        df(t1654, "acosh");
        for(var e1226 = new Float32Array(t1654.size), n915 = this.readSync(t1654.dataId), r727 = 0; r727 < n915.length; ++r727)e1226[r727] = Math.acosh(n915[r727]);
        return this.makeOutput(e1226, t1654.shape, "float32");
    }, o474.prototype.atanh = function(t1655) {
        df(t1655, "atanh");
        for(var e1227 = new Float32Array(t1655.size), n916 = this.readSync(t1655.dataId), r728 = 0; r728 < n916.length; ++r728)e1227[r728] = Math.atanh(n916[r728]);
        return this.makeOutput(e1227, t1655.shape, "float32");
    }, o474.prototype.erf = function(t1656) {
        df(t1656, "erf");
        for(var e1228 = new Float32Array(t1656.size), n917 = this.readSync(t1656.dataId), r729 = 0; r729 < n917.length; ++r729){
            var o510 = Math.sign(n917[r729]), a412 = Math.abs(n917[r729]), i304 = 1 / (1 + 0.3275911 * a412);
            e1228[r729] = o510 * (1 - ((((1.061405429 * i304 - 1.453152027) * i304 + 1.421413741) * i304 - 0.284496736) * i304 + 0.254829592) * i304 * Math.exp(-a412 * a412));
        }
        return this.makeOutput(e1228, t1656.shape, "float32");
    }, o474.prototype.step = function(t1657, e1229) {
        void 0 === e1229 && (e1229 = 0), df(t1657, "step");
        for(var n918 = new Float32Array(t1657.size), r730 = this.readSync(t1657.dataId), o511 = 0; o511 < r730.length; ++o511){
            var a413 = r730[o511];
            isNaN(a413) ? n918[o511] = NaN : n918[o511] = a413 > 0 ? 1 : e1229;
        }
        return this.makeOutput(n918, t1657.shape, "float32");
    }, o474.prototype.fusedConv2d = function(t1658) {
        var e1230 = t1658.input, n919 = t1658.filter, r731 = t1658.convInfo, o512 = t1658.bias, a414 = t1658.activation, i305 = t1658.preluActivationWeights, s266 = this.conv2d(e1230, n919, r731);
        return o512 && (s266 = this.add(s266, o512)), a414 && (s266 = gf(this, s266, a414, i305)), s266;
    }, o474.prototype.conv2d = function(t1659, e1231, n920) {
        df([
            t1659,
            e1231
        ], "conv2d");
        for(var r732 = n920.filterHeight, o513 = n920.filterWidth, a415 = n920.dilationHeight, i306 = n920.dilationWidth, s267 = n920.padInfo.left, u207 = n920.padInfo.top, c163 = "channelsLast" === n920.dataFormat, l130 = er(n920.outShape, t1659.dtype), h116 = t1659.strides[0], f96 = c163 ? t1659.strides[1] : t1659.strides[2], d78 = c163 ? t1659.strides[2] : 1, p = c163 ? 1 : t1659.strides[1], v58 = l130.strides[0], g47 = c163 ? l130.strides[1] : l130.strides[2], m36 = c163 ? l130.strides[2] : 1, y = c163 ? 1 : l130.strides[1], x28 = this.readSync(t1659.dataId), b24 = this.readSync(e1231.dataId), w21 = l130.values, C9 = 0; C9 < n920.batchSize; ++C9)for(var E17 = C9 * h116, R14 = C9 * v58, I9 = 0; I9 < n920.outHeight; ++I9)for(var k6 = R14 + I9 * g47, S6 = I9 * n920.strideHeight - u207, A4 = 0; A4 < r732; A4++){
            var T7 = S6 + A4 * a415;
            if (!(T7 < 0 || T7 >= n920.inHeight)) for(var D7 = A4 * e1231.strides[0], N7 = E17 + T7 * f96, F6 = 0; F6 < n920.outWidth; ++F6)for(var _ = k6 + F6 * m36, O3 = F6 * n920.strideWidth - s267, M3 = 0; M3 < o513; M3++){
                var B3 = O3 + M3 * i306;
                if (!(B3 < 0 || B3 >= n920.inWidth)) for(var P = N7 + B3 * d78, L2 = D7 + M3 * e1231.strides[1], W2 = 0; W2 < n920.inChannels; ++W2){
                    for(var U1 = x28[P + W2 * p], V1 = 0; V1 < n920.outChannels; ++V1)w21[_ + V1 * y] += U1 * b24[L2 + V1];
                    L2 += n920.outChannels;
                }
            }
        }
        return l130.toTensor();
    }, o474.prototype.conv3d = function(t1660, e1232, n921) {
        for(var r733 = n921.filterDepth, o514 = n921.filterHeight, a416 = n921.filterWidth, i307 = n921.dilationDepth, s268 = n921.dilationHeight, u208 = n921.dilationWidth, c164 = n921.padInfo.front, l131 = n921.padInfo.left, h117 = n921.padInfo.top, f97 = er(n921.outShape, t1660.dtype), d79 = this.readSync(t1660.dataId), p65 = this.readSync(e1232.dataId), v59 = f97.values, g48 = 0; g48 < n921.batchSize; ++g48)for(var m37 = g48 * t1660.strides[0], y29 = g48 * f97.strides[0], x29 = 0; x29 < n921.outDepth; ++x29)for(var b25 = y29 + x29 * f97.strides[1], w22 = x29 * n921.strideDepth - c164, C10 = 0; C10 < r733; C10++){
            var E18 = w22 + C10 * i307;
            if (!(E18 < 0 || E18 >= n921.inDepth)) for(var R15 = C10 * e1232.strides[0], I10 = m37 + E18 * t1660.strides[1], k7 = 0; k7 < n921.outHeight; ++k7)for(var S7 = b25 + k7 * f97.strides[2], A5 = k7 * n921.strideHeight - h117, T8 = 0; T8 < o514; T8++){
                var D8 = A5 + T8 * s268;
                if (!(D8 < 0 || D8 >= n921.inHeight)) for(var N8 = R15 + T8 * e1232.strides[1], F7 = I10 + D8 * t1660.strides[2], _3 = 0; _3 < n921.outWidth; ++_3)for(var O = S7 + _3 * n921.outChannels, M4 = _3 * n921.strideWidth - l131, B4 = 0; B4 < a416; B4++){
                    var P2 = M4 + B4 * u208;
                    if (!(P2 < 0 || P2 >= n921.inWidth)) for(var L3 = N8 + B4 * e1232.strides[2], W = F7 + P2 * n921.inChannels, U2 = L3, V2 = 0; V2 < n921.inChannels; ++V2){
                        for(var z1 = d79[W + V2], G1 = 0; G1 < n921.outChannels; ++G1)v59[O + G1] += z1 * p65[U2 + G1];
                        U2 += n921.outChannels;
                    }
                }
            }
        }
        return f97.toTensor();
    }, o474.prototype.conv2dDerInput = function(t1661, e1233, n922) {
        df([
            t1661,
            e1233
        ], "conv2dDerInput");
        for(var r734 = er(n922.inShape, "float32"), o515 = r734.values, a417 = this.readSync(t1661.dataId), i308 = this.readSync(e1233.dataId), s269 = e1233.strides, u209 = s269[0], c165 = s269[1], l132 = s269[2], h118 = n922.batchSize, f98 = n922.filterHeight, d80 = n922.filterWidth, p66 = n922.inChannels, v60 = n922.inHeight, g49 = n922.inWidth, m38 = n922.outChannels, y30 = n922.outHeight, x30 = n922.outWidth, b26 = n922.strideHeight, w23 = n922.strideWidth, C11 = n922.dataFormat, E19 = f98 - 1 - n922.padInfo.top, R16 = d80 - 1 - n922.padInfo.left, I11 = "channelsLast" === C11, k = r734.strides[0], S = I11 ? r734.strides[1] : r734.strides[2], A = I11 ? r734.strides[2] : 1, T = I11 ? 1 : r734.strides[1], D9 = t1661.strides[0], N9 = I11 ? t1661.strides[1] : t1661.strides[2], F8 = I11 ? t1661.strides[2] : 1, _ = I11 ? 1 : t1661.strides[1], O4 = 0; O4 < h118; ++O4)for(var M5 = 0; M5 < p66; ++M5)for(var B5 = 0; B5 < v60; ++B5)for(var P3 = B5 - E19, L4 = Math.max(0, Math.ceil(P3 / b26)), W3 = Math.min(y30, (f98 + P3) / b26), U3 = 0; U3 < g49; ++U3){
            for(var V3 = U3 - R16, z2 = Math.max(0, Math.ceil(V3 / w23)), G2 = Math.min(x30, (d80 + V3) / w23), H1 = 0, q1 = L4; q1 < W3; ++q1)for(var K1 = q1 * b26 - P3, j1 = z2; j1 < G2; ++j1)for(var X = D9 * O4 + N9 * q1 + F8 * j1, Y = u209 * (f98 - 1 - K1) + c165 * (d80 - 1 - (j1 * w23 - V3)) + l132 * M5, $1 = 0; $1 < m38; ++$1)H1 += a417[X + _ * $1] * i308[Y + $1];
            o515[k * O4 + S * B5 + A * U3 + T * M5] = H1;
        }
        return r734.toTensor();
    }, o474.prototype.conv3dDerInput = function(t1662, e1234, n923) {
        for(var r735 = er(n923.inShape, "float32"), o516 = r735.values, a418 = r735.strides, i = a418[0], s = a418[1], u = a418[2], c = a418[3], l133 = this.readSync(t1662.dataId), h119 = t1662.strides, f99 = h119[0], d81 = h119[1], p67 = h119[2], v61 = h119[3], g50 = this.readSync(e1234.dataId), m39 = e1234.strides, y31 = m39[0], x31 = m39[1], b27 = m39[2], w24 = m39[3], C12 = n923.batchSize, E20 = n923.filterDepth, R17 = n923.filterHeight, I12 = n923.filterWidth, k8 = n923.inChannels, S8 = n923.inDepth, A6 = n923.inHeight, T9 = n923.inWidth, D10 = n923.outChannels, N10 = n923.outDepth, F9 = n923.outHeight, _4 = n923.outWidth, O5 = n923.strideDepth, M6 = n923.strideHeight, B6 = n923.strideWidth, P4 = E20 - 1 - n923.padInfo.front, L5 = R17 - 1 - n923.padInfo.top, W4 = I12 - 1 - n923.padInfo.left, U4 = 0; U4 < C12; ++U4)for(var V4 = 0; V4 < k8; ++V4)for(var z3 = 0; z3 < S8; ++z3)for(var G3 = z3 - P4, H2 = Math.max(0, Math.ceil(G3 / O5)), q2 = Math.min(N10, (E20 + G3) / O5), K2 = 0; K2 < A6; ++K2)for(var j2 = K2 - L5, X1 = Math.max(0, Math.ceil(j2 / M6)), Y1 = Math.min(F9, (R17 + j2) / M6), $2 = 0; $2 < T9; ++$2){
            for(var Q1 = $2 - W4, J1 = Math.max(0, Math.ceil(Q1 / B6)), Z1 = Math.min(_4, (I12 + Q1) / B6), tt1 = 0, et1 = H2; et1 < q2; ++et1)for(var nt1 = et1 * O5 - G3, rt1 = X1; rt1 < Y1; ++rt1)for(var ot1 = rt1 * M6 - j2, at1 = J1; at1 < Z1; ++at1)for(var it = f99 * U4 + d81 * et1 + p67 * rt1 + v61 * at1, st = y31 * (E20 - 1 - nt1) + x31 * (R17 - 1 - ot1) + b27 * (I12 - 1 - (at1 * B6 - Q1)) + w24 * V4, ut1 = 0; ut1 < D10; ++ut1)tt1 += l133[it + ut1] * g50[st + ut1];
            o516[i * U4 + s * z3 + u * K2 + c * $2 + V4] = tt1;
        }
        return r735.toTensor();
    }, o474.prototype.conv2dDerFilter = function(t1663, e1235, n924) {
        df([
            t1663,
            e1235
        ], "conv2dDerFilter");
        for(var r736 = n924.strideHeight, o517 = n924.strideWidth, a419 = n924.filterHeight, i309 = n924.filterWidth, s270 = "channelsLast" === n924.dataFormat, u210 = er(n924.filterShape, "float32"), c166 = n924.padInfo.left, l134 = n924.padInfo.top, h120 = this.bufferSync(t1663), f100 = this.bufferSync(e1235), d82 = 0; d82 < a419; ++d82)for(var p68 = Math.max(0, Math.ceil((l134 - d82) / r736)), v62 = Math.min(n924.outHeight, (n924.inHeight + l134 - d82) / r736), g51 = 0; g51 < i309; ++g51)for(var m40 = Math.max(0, Math.ceil((c166 - g51) / o517)), y32 = Math.min(n924.outWidth, (n924.inWidth + c166 - g51) / o517), x32 = 0; x32 < n924.inChannels; ++x32)for(var b28 = 0; b28 < n924.outChannels; ++b28){
            for(var w25 = 0, C13 = 0; C13 < n924.batchSize; ++C13)for(var E21 = p68; E21 < v62; ++E21)for(var R18 = d82 + E21 * r736 - l134, I13 = m40; I13 < y32; ++I13){
                var k9 = g51 + I13 * o517 - c166;
                w25 += s270 ? h120.get(C13, R18, k9, x32) * f100.get(C13, E21, I13, b28) : h120.get(C13, x32, R18, k9) * f100.get(C13, b28, E21, I13);
            }
            u210.set(w25, d82, g51, x32, b28);
        }
        return u210.toTensor();
    }, o474.prototype.conv3dDerFilter = function(t1664, e1236, n925) {
        for(var r737 = n925.strideDepth, o518 = n925.strideHeight, a420 = n925.strideWidth, i310 = n925.filterDepth, s271 = n925.filterHeight, u211 = n925.filterWidth, c167 = er(n925.filterShape, "float32"), l135 = c167.values, h121 = c167.strides, f101 = h121[0], d83 = h121[1], p69 = h121[2], v63 = h121[3], g52 = this.readSync(e1236.dataId), m41 = e1236.strides, y33 = m41[0], x33 = m41[1], b29 = m41[2], w26 = m41[3], C14 = this.readSync(t1664.dataId), E22 = t1664.strides, R19 = E22[0], I14 = E22[1], k10 = E22[2], S = E22[3], A7 = n925.padInfo.front, T10 = n925.padInfo.left, D11 = n925.padInfo.top, N11 = 0; N11 < i310; ++N11)for(var F10 = Math.max(0, Math.ceil((A7 - N11) / r737)), _5 = Math.min(n925.outDepth, (n925.inDepth + A7 - N11) / r737), O6 = N11 * f101, M7 = 0; M7 < s271; ++M7)for(var B7 = Math.max(0, Math.ceil((D11 - M7) / o518)), P5 = Math.min(n925.outHeight, (n925.inHeight + D11 - M7) / o518), L6 = M7 * d83 + O6, W5 = 0; W5 < u211; ++W5)for(var U5 = Math.max(0, Math.ceil((T10 - W5) / a420)), V5 = Math.min(n925.outWidth, (n925.inWidth + T10 - W5) / a420), z4 = W5 * p69 + L6, G4 = 0; G4 < n925.inChannels; ++G4)for(var H = G4 * v63 + z4, q3 = 0; q3 < n925.outChannels; ++q3){
            for(var K3 = 0, j3 = 0; j3 < n925.batchSize; ++j3)for(var X2 = j3 * R19, Y2 = j3 * y33, $3 = F10; $3 < _5; ++$3)for(var Q2 = (N11 + $3 * r737 - A7) * I14 + X2, J2 = $3 * x33 + Y2, Z2 = B7; Z2 < P5; ++Z2)for(var tt = (M7 + Z2 * o518 - D11) * k10 + Q2, et2 = Z2 * b29 + J2, nt2 = U5; nt2 < V5; ++nt2){
                var rt = nt2 * w26 + et2;
                K3 += C14[(W5 + nt2 * a420 - T10) * S + tt + G4] * g52[rt + q3];
            }
            l135[H + q3] = K3;
        }
        return c167.toTensor();
    }, o474.prototype.fusedDepthwiseConv2D = function(t1665) {
        var e1237 = t1665.input, n926 = t1665.filter, r738 = t1665.convInfo, o519 = t1665.bias, a421 = t1665.activation, i311 = t1665.preluActivationWeights, s272 = this.depthwiseConv2D(e1237, n926, r738);
        return o519 && (s272 = this.add(s272, o519)), a421 && (s272 = gf(this, s272, a421, i311)), s272;
    }, o474.prototype.depthwiseConv2D = function(t1666, e1238, n927) {
        df([
            t1666,
            e1238
        ], "depthwiseConv2D");
        for(var r739 = n927.filterHeight, o520 = n927.filterWidth, a422 = n927.dilationHeight, i312 = n927.dilationWidth, s273 = n927.padInfo.left, u212 = n927.padInfo.top, c168 = n927.outChannels / n927.inChannels, l136 = er(n927.outShape, t1666.dtype), h122 = this.readSync(t1666.dataId), f102 = this.readSync(e1238.dataId), d84 = l136.values, p70 = 0; p70 < n927.batchSize; ++p70)for(var v64 = p70 * t1666.strides[0], g53 = p70 * l136.strides[0], m42 = 0; m42 < n927.outHeight; ++m42)for(var y34 = g53 + m42 * l136.strides[1], x34 = m42 * n927.strideHeight - s273, b30 = 0; b30 < r739; ++b30){
            var w27 = x34 + b30 * a422;
            if (!(w27 < 0 || w27 >= n927.inHeight)) for(var C15 = b30 * e1238.strides[0], E23 = v64 + w27 * t1666.strides[1], R20 = 0; R20 < n927.outWidth; ++R20)for(var I15 = y34 + R20 * l136.strides[2], k11 = R20 * n927.strideWidth - u212, S9 = 0; S9 < o520; ++S9){
                var A8 = k11 + S9 * i312;
                if (!(A8 < 0 || A8 >= n927.inWidth)) for(var T11 = C15 + S9 * e1238.strides[1], D = E23 + A8 * n927.inChannels, N12 = I15, F11 = T11, _6 = 0; _6 < n927.inChannels; ++_6){
                    for(var O7 = h122[D + _6], M8 = 0; M8 < c168; ++M8)d84[N12 + M8] += O7 * f102[F11 + M8];
                    N12 += c168, F11 += c168;
                }
            }
        }
        return l136.toTensor();
    }, o474.prototype.depthwiseConv2DDerInput = function(t1667, e1239, n928) {
        df([
            t1667,
            e1239
        ], "depthwiseConv2DDerInput");
        for(var r740 = er(n928.inShape, "float32"), o521 = r740.values, a423 = r740.strides, i = a423[0], s = a423[1], u = a423[2], c169 = this.readSync(t1667.dataId), l137 = t1667.strides, h123 = l137[0], f103 = l137[1], d85 = l137[2], p71 = this.readSync(e1239.dataId), v65 = e1239.strides, g54 = v65[0], m43 = v65[1], y35 = v65[2], x35 = n928.batchSize, b31 = n928.filterHeight, w28 = n928.filterWidth, C16 = n928.inChannels, E24 = n928.inHeight, R21 = n928.inWidth, I16 = n928.outChannels, k12 = n928.outHeight, S10 = n928.outWidth, A9 = n928.strideHeight, T12 = n928.strideWidth, D12 = b31 - 1 - n928.padInfo.top, N13 = w28 - 1 - n928.padInfo.left, F12 = I16 / C16, _7 = 0; _7 < x35; ++_7)for(var O8 = 0; O8 < C16; ++O8)for(var M9 = 0; M9 < E24; ++M9)for(var B8 = M9 - D12, P6 = Math.max(0, Math.ceil(B8 / A9)), L7 = Math.min(k12, (b31 + B8) / A9), W6 = 0; W6 < R21; ++W6){
            for(var U6 = W6 - N13, V6 = Math.max(0, Math.ceil(U6 / T12)), z5 = Math.min(S10, (w28 + U6) / T12), G5 = 0, H3 = P6; H3 < L7; ++H3)for(var q4 = H3 * A9 - B8, K4 = V6; K4 < z5; ++K4)for(var j = h123 * _7 + f103 * H3 + d85 * K4, X = g54 * (b31 - 1 - q4) + m43 * (w28 - 1 - (K4 * T12 - U6)) + y35 * O8, Y3 = 0; Y3 < F12; ++Y3)G5 += c169[j + (O8 * F12 + Y3)] * p71[X + Y3];
            o521[i * _7 + s * M9 + u * W6 + O8] = G5;
        }
        return r740.toTensor();
    }, o474.prototype.depthwiseConv2DDerFilter = function(t1668, e1240, n929) {
        df([
            t1668,
            e1240
        ], "depthwiseConv2DDerFilter");
        for(var r741 = n929.strideHeight, o522 = n929.strideWidth, a424 = n929.filterHeight, i313 = n929.filterWidth, s274 = er(n929.filterShape, "float32"), u213 = n929.padInfo.left, c170 = n929.padInfo.top, l138 = n929.outChannels / n929.inChannels, h124 = this.bufferSync(t1668), f104 = this.bufferSync(e1240), d86 = 0; d86 < a424; ++d86)for(var p72 = Math.max(0, Math.ceil((c170 - d86) / r741)), v66 = Math.min(n929.outHeight, (n929.inHeight + c170 - d86) / r741), g55 = 0; g55 < i313; ++g55)for(var m44 = Math.max(0, Math.ceil((u213 - g55) / o522)), y36 = Math.min(n929.outWidth, (n929.inWidth + u213 - g55) / o522), x36 = 0; x36 < n929.outChannels; ++x36){
            for(var b32 = Math.trunc(x36 / l138), w29 = x36 % l138, C17 = 0, E25 = 0; E25 < n929.batchSize; ++E25)for(var R22 = p72; R22 < v66; ++R22)for(var I17 = d86 + R22 * r741 - c170, k13 = m44; k13 < y36; ++k13){
                var S11 = g55 + k13 * o522 - u213;
                C17 += h124.get(E25, I17, S11, b32) * f104.get(E25, R22, k13, x36);
            }
            s274.set(C17, d86, g55, b32, w29);
        }
        return s274.toTensor();
    }, o474.prototype.tile = function(t1669, e1241) {
        return df(t1669, "tile"), Va(this.bufferSync(t1669), e1241);
    }, o474.prototype.pad = function(t1670, e1242, n930) {
        df(t1670, "pad");
        var r742 = e1242.map(function(e1243, n) {
            return e1243[0] + t1670.shape[n] + e1243[1];
        }), o523 = e1242.map(function(t1671) {
            return t1671[0];
        }), a425 = this.bufferSync(t1670), i314 = er(r742, t1670.dtype);
        0 !== n930 && i314.values.fill(n930);
        for(var s275 = 0; s275 < t1670.size; s275++){
            var u214 = a425.indexToLoc(s275), c171 = u214.map(function(t1672, e) {
                return t1672 + o523[e];
            });
            i314.set.apply(i314, [
                a425.get.apply(a425, u214)
            ].concat(c171));
        }
        return i314.toTensor();
    }, o474.prototype.gather = function(t1673, e1244, n) {
        df([
            t1673,
            e1244
        ], "gather");
        var r743 = t1673.shape.slice(), o524 = this.readSync(e1244.dataId);
        r743[n] = o524.length;
        for(var a426 = er(r743, t1673.dtype), i315 = this.bufferSync(t1673), s276 = 0; s276 < a426.size; ++s276){
            var u215 = a426.indexToLoc(s276), c172 = u215.slice();
            c172[n] = o524[u215[n]];
            var l = i315.locToIndex(c172);
            a426.values[s276] = i315.values[l];
        }
        return a426.toTensor();
    }, o474.prototype.batchToSpaceND = function(t1674, e1245, n931) {
        df([
            t1674
        ], "batchToSpaceND");
        var r744 = e1245.reduce(function(t1675, e1246) {
            return t1675 * e1246;
        }), o525 = pr(t1674.shape, e1245, r744), a427 = vr(o525.length, e1245.length), i316 = gr(t1674.shape, e1245, r744), s277 = mr(n931, e1245.length), u216 = yr(i316, n931, e1245.length);
        return ua(t1674.reshape(o525), a427).reshape(i316).slice(s277, u216);
    }, o474.prototype.spaceToBatchND = function(t1676, e1247, n932) {
        df([
            t1676
        ], "spaceToBatchND");
        var r745 = e1247.reduce(function(t1677, e1248) {
            return t1677 * e1248;
        }), o526 = [
            [
                0,
                0
            ]
        ];
        o526.push.apply(o526, n932);
        for(var a428 = 1 + e1247.length; a428 < t1676.shape.length; ++a428)o526.push([
            0,
            0
        ]);
        var i317 = t1676.pad(o526), s278 = pr(i317.shape, e1247, r745, !1), u217 = vr(s278.length, e1247.length, !1), c173 = gr(i317.shape, e1247, r745, !1);
        return ua(i317.reshape(s278), u217).reshape(c173);
    }, o474.prototype.maxPool = function(t1678, e1249) {
        return df(t1678, "maxPool"), pf(this.readSync(t1678.dataId), t1678.shape, t1678.dtype, t1678.strides, e1249, "max").toTensor();
    }, o474.prototype.maxPoolBackprop = function(t1679, e1250, n933, r746) {
        df([
            e1250,
            n933
        ], "maxPoolBackprop");
        for(var o527 = this.readSync(e1250.dataId), a429 = er(r746.outShape, e1250.dtype, vf(o527, e1250.shape, e1250.dtype, r746).values), i318 = r746.strideHeight, s279 = r746.strideWidth, u218 = r746.dilationHeight, c174 = r746.dilationWidth, l139 = r746.effectiveFilterHeight, h125 = r746.effectiveFilterWidth, f105 = h125 - 1 - r746.padInfo.left, d87 = l139 - 1 - r746.padInfo.top, p73 = er(e1250.shape, "float32"), v67 = this.bufferSync(t1679), g56 = 0; g56 < r746.batchSize; ++g56)for(var m45 = 0; m45 < r746.inChannels; ++m45)for(var y37 = 0; y37 < r746.inHeight; ++y37)for(var x37 = 0; x37 < r746.inWidth; ++x37){
            for(var b33 = y37 - d87, w30 = x37 - f105, C18 = 0, E26 = 0; E26 < l139; E26 += u218){
                var R23 = (b33 + E26) / i318;
                if (!(R23 < 0 || R23 >= r746.outHeight || Math.floor(R23) !== R23)) for(var I18 = 0; I18 < h125; I18 += c174){
                    var k14 = (w30 + I18) / s279;
                    if (!(k14 < 0 || k14 >= r746.outWidth || Math.floor(k14) !== k14)) {
                        var S12 = l139 * h125 - 1 - a429.get(g56, R23, k14, m45) === E26 * h125 + I18 ? 1 : 0;
                        if (0 !== S12) C18 += v67.get(g56, R23, k14, m45) * S12;
                    }
                }
            }
            p73.set(C18, g56, y37, x37, m45);
        }
        return p73.toTensor();
    }, o474.prototype.avgPoolBackprop = function(t1680, e1251, n934) {
        df([
            t1680,
            e1251
        ], "avgPoolBackprop");
        for(var r747 = n934.strideHeight, o528 = n934.strideWidth, a430 = n934.filterHeight, i319 = n934.filterWidth, s280 = n934.dilationHeight, u219 = n934.dilationWidth, c175 = n934.effectiveFilterHeight, l140 = n934.effectiveFilterWidth, h126 = l140 - 1 - n934.padInfo.left, f106 = c175 - 1 - n934.padInfo.top, d88 = er(e1251.shape, "float32"), p74 = 1 / (a430 * i319), v68 = this.bufferSync(t1680), g57 = 0; g57 < n934.batchSize; ++g57)for(var m46 = 0; m46 < n934.inChannels; ++m46)for(var y38 = 0; y38 < n934.inHeight; ++y38)for(var x38 = 0; x38 < n934.inWidth; ++x38){
            for(var b34 = y38 - f106, w31 = x38 - h126, C19 = 0, E27 = 0; E27 < c175; E27 += s280){
                var R24 = (b34 + E27) / r747;
                if (!(R24 < 0 || R24 >= n934.outHeight || Math.floor(R24) !== R24)) for(var I19 = 0; I19 < l140; I19 += u219){
                    var k15 = (w31 + I19) / o528;
                    if (!(k15 < 0 || k15 >= n934.outWidth || Math.floor(k15) !== k15)) C19 += v68.get(g57, R24, k15, m46);
                }
            }
            d88.set(C19 * p74, g57, y38, x38, m46);
        }
        return d88.toTensor();
    }, o474.prototype.pool3d = function(t1681, e1252, n935) {
        df(t1681, "pool3d");
        for(var r748 = e1252.strideDepth, o529 = e1252.strideHeight, a431 = e1252.strideWidth, i320 = e1252.dilationDepth, s281 = e1252.dilationHeight, u220 = e1252.dilationWidth, c176 = e1252.effectiveFilterDepth, l141 = e1252.effectiveFilterHeight, h127 = e1252.effectiveFilterWidth, f107 = e1252.padInfo.front, d89 = e1252.padInfo.top, p75 = e1252.padInfo.left, v69 = "max" === n935 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, g58 = this.readSync(t1681.dataId), m47 = er(e1252.outShape, t1681.dtype), y39 = m47.values, x39 = e1252.outShape[1] * e1252.outShape[2] * e1252.outShape[3] * e1252.outShape[4], b35 = e1252.outShape[2] * e1252.outShape[3] * e1252.outShape[4], w32 = e1252.outShape[3] * e1252.outShape[4], C20 = e1252.outShape[4], E28 = 0; E28 < e1252.batchSize; ++E28)for(var R25 = E28 * x39, I20 = E28 * t1681.strides[0], k16 = 0; k16 < e1252.inChannels; ++k16)for(var S13 = 0; S13 < e1252.outDepth; ++S13){
            for(var A10 = S13 * r748 - f107, T13 = A10; T13 < 0;)T13 += i320;
            for(var D13 = Math.min(e1252.inDepth, c176 + A10), N14 = R25 + S13 * b35, F13 = 0; F13 < e1252.outHeight; ++F13){
                for(var _8 = F13 * o529 - d89, O9 = _8; O9 < 0;)O9 += s281;
                for(var M10 = Math.min(e1252.inHeight, l141 + _8), B9 = N14 + F13 * w32, P7 = 0; P7 < e1252.outWidth; ++P7){
                    for(var L8 = P7 * a431 - p75, W7 = L8; W7 < 0;)W7 += u220;
                    for(var U7 = Math.min(e1252.inWidth, h127 + L8), V = B9 + P7 * C20, z6 = v69, G6 = 0, H4 = 0, q5 = T13; q5 < D13; q5 += i320){
                        for(var K5 = I20 + q5 * t1681.strides[1], j4 = O9; j4 < M10; j4 += s281){
                            for(var X = K5 + j4 * t1681.strides[2], Y4 = W7; Y4 < U7; Y4 += u220){
                                var $4 = g58[X + Y4 * t1681.strides[3] + k16];
                                if ("max" === n935 && $4 > z6 ? z6 = $4 : "avg" === n935 && (G6 += $4, H4++), isNaN(z6)) break;
                            }
                            if (isNaN(z6)) break;
                        }
                        if (isNaN(z6)) break;
                    }
                    y39[V + k16] = "avg" === n935 ? G6 / H4 : z6;
                }
            }
        }
        return m47.toTensor();
    }, o474.prototype.avgPool3d = function(t1682, e1253) {
        return df(t1682, "avgPool3d"), this.pool3d(t1682, e1253, "avg").toFloat();
    }, o474.prototype.avgPool3dBackprop = function(t1683, e1254, n936) {
        df([
            t1683,
            e1254
        ], "avgPool3dBackprop");
        for(var r749 = n936.strideDepth, o530 = n936.strideHeight, a432 = n936.strideWidth, i321 = n936.filterDepth, s282 = n936.filterHeight, u221 = n936.filterWidth, c177 = n936.dilationDepth, l142 = n936.dilationHeight, h128 = n936.dilationWidth, f108 = n936.effectiveFilterDepth, d90 = n936.effectiveFilterHeight, p76 = n936.effectiveFilterWidth, v70 = f108 - 1 - n936.padInfo.front, g59 = p76 - 1 - n936.padInfo.left, m48 = d90 - 1 - n936.padInfo.top, y40 = er(e1254.shape, "float32"), x40 = 1 / (i321 * s282 * u221), b36 = this.bufferSync(t1683), w33 = 0; w33 < n936.batchSize; ++w33)for(var C21 = 0; C21 < n936.inChannels; ++C21)for(var E29 = 0; E29 < n936.inDepth; ++E29)for(var R26 = 0; R26 < n936.inHeight; ++R26)for(var I21 = 0; I21 < n936.inWidth; ++I21){
            for(var k17 = E29 - v70, S14 = R26 - m48, A11 = I21 - g59, T14 = 0, D14 = 0; D14 < f108; D14 += c177){
                var N15 = (k17 + D14) / r749;
                if (!(N15 < 0 || N15 >= n936.outDepth || Math.floor(N15) !== N15)) for(var F14 = 0; F14 < d90; F14 += l142){
                    var _9 = (S14 + F14) / o530;
                    if (!(_9 < 0 || _9 >= n936.outHeight || Math.floor(_9) !== _9)) for(var O10 = 0; O10 < p76; O10 += h128){
                        var M11 = (A11 + O10) / a432;
                        if (!(M11 < 0 || M11 >= n936.outWidth || Math.floor(M11) !== M11)) T14 += b36.get(w33, N15, _9, M11, C21);
                    }
                }
            }
            y40.set(T14 * x40, w33, E29, R26, I21, C21);
        }
        return y40.toTensor();
    }, o474.prototype.maxPool3d = function(t1684, e1255) {
        return df(t1684, "maxPool3d"), this.pool3d(t1684, e1255, "max").toFloat();
    }, o474.prototype.maxPool3dPositions = function(t1685, e1256) {
        for(var n937 = er(e1256.outShape, "int32"), r750 = e1256.strideDepth, o531 = e1256.strideHeight, a433 = e1256.strideWidth, i322 = e1256.dilationDepth, s283 = e1256.dilationHeight, u222 = e1256.dilationWidth, c178 = e1256.effectiveFilterDepth, l143 = e1256.effectiveFilterHeight, h129 = e1256.effectiveFilterWidth, f109 = e1256.padInfo.front, d91 = e1256.padInfo.top, p77 = e1256.padInfo.left, v71 = this.bufferSync(t1685), g60 = 0; g60 < e1256.batchSize; ++g60)for(var m49 = 0; m49 < e1256.inChannels; ++m49)for(var y41 = 0; y41 < e1256.outDepth; ++y41){
            for(var x41 = y41 * r750 - f109, b37 = x41; b37 < 0;)b37 += i322;
            for(var w34 = Math.min(e1256.inDepth, c178 + x41), C22 = 0; C22 < e1256.outHeight; ++C22){
                for(var E30 = C22 * o531 - d91, R27 = E30; R27 < 0;)R27 += s283;
                for(var I22 = Math.min(e1256.inHeight, l143 + E30), k18 = 0; k18 < e1256.outWidth; ++k18){
                    for(var S15 = k18 * a433 - p77, A12 = S15; A12 < 0;)A12 += u222;
                    for(var T15 = Math.min(e1256.inWidth, h129 + S15), D15 = Number.NEGATIVE_INFINITY, N16 = -1, F15 = b37; F15 < w34; F15 += i322)for(var _10 = F15 - x41, O11 = R27; O11 < I22; O11 += s283)for(var M12 = O11 - E30, B10 = A12; B10 < T15; B10 += u222){
                        var P8 = B10 - S15, L9 = v71.get(g60, F15, O11, B10, m49);
                        L9 >= D15 && (D15 = L9, N16 = _10 * l143 * h129 + M12 * l143 + P8);
                    }
                    n937.set(N16, g60, y41, C22, k18, m49);
                }
            }
        }
        return n937.toTensor();
    }, o474.prototype.maxPool3dBackprop = function(t1686, e1257, n938, r751) {
        df([
            e1257,
            n938
        ], "maxPool3dBackprop");
        for(var o532 = this.maxPool3dPositions(e1257, r751), a434 = r751.strideDepth, i323 = r751.strideHeight, s284 = r751.strideWidth, u223 = r751.dilationDepth, c179 = r751.dilationHeight, l144 = r751.dilationWidth, h130 = r751.effectiveFilterDepth, f110 = r751.effectiveFilterHeight, d92 = r751.effectiveFilterWidth, p78 = h130 - 1 - r751.padInfo.front, v72 = d92 - 1 - r751.padInfo.left, g61 = f110 - 1 - r751.padInfo.top, m50 = er(e1257.shape, "float32"), y42 = this.bufferSync(o532), x42 = this.bufferSync(t1686), b38 = 0; b38 < r751.batchSize; ++b38)for(var w35 = 0; w35 < r751.inChannels; ++w35)for(var C23 = 0; C23 < r751.inDepth; ++C23)for(var E31 = 0; E31 < r751.inHeight; ++E31)for(var R28 = 0; R28 < r751.inWidth; ++R28){
            for(var I23 = C23 - p78, k19 = E31 - g61, S16 = R28 - v72, A13 = 0, T16 = 0; T16 < h130; T16 += u223){
                var D16 = (I23 + T16) / a434;
                if (!(D16 < 0 || D16 >= r751.outDepth || Math.floor(D16) !== D16)) for(var N17 = 0; N17 < f110; N17 += c179){
                    var F16 = (k19 + N17) / i323;
                    if (!(F16 < 0 || F16 >= r751.outHeight || Math.floor(F16) !== F16)) for(var _11 = 0; _11 < d92; _11 += l144){
                        var O12 = (S16 + _11) / s284;
                        if (!(O12 < 0 || O12 >= r751.outWidth || Math.floor(O12) !== O12)) {
                            var M13 = h130 * f110 * d92 - 1 - y42.get(b38, D16, F16, O12, w35) === T16 * f110 * d92 + N17 * d92 + _11 ? 1 : 0;
                            if (0 !== M13) A13 += x42.get(b38, D16, F16, O12, w35) * M13;
                        }
                    }
                }
            }
            m50.set(A13, b38, C23, E31, R28, w35);
        }
        return m50.toTensor();
    }, o474.prototype.cast = function(t1687, e1258) {
        return Ra(t1687, e1258, this);
    }, o474.prototype.reshape = function(t1688, e1259) {
        return Ia(t1688, e1259);
    }, o474.prototype.avgPool = function(t1689, e1260) {
        return df(t1689, "avgPool"), df(t1689, "maxPool"), pf(this.readSync(t1689.dataId), t1689.shape, t1689.dtype, t1689.strides, e1260, "avg").toTensor().toFloat();
    }, o474.prototype.resizeBilinear = function(t1690, e1261, n939, r752) {
        df(t1690, "resizeBilinear");
        for(var o533 = t1690.shape, a435 = o533[0], i324 = o533[1], s285 = o533[2], u224 = o533[3], c180 = this.readSync(t1690.dataId), l145 = new Float32Array(k([
            a435,
            e1261,
            n939,
            u224
        ])), h131 = [
            r752 && e1261 > 1 ? i324 - 1 : i324,
            r752 && n939 > 1 ? s285 - 1 : s285
        ], f111 = [
            r752 && e1261 > 1 ? e1261 - 1 : e1261,
            r752 && n939 > 1 ? n939 - 1 : n939
        ], d = 0, p79 = h131[0] / f111[0], v73 = h131[1] / f111[1], g62 = 0; g62 < a435; g62++)for(var m51 = 0; m51 < e1261; m51++)for(var y43 = p79 * m51, x43 = Math.floor(y43), b39 = y43 - x43, w36 = Math.min(i324 - 1, Math.ceil(y43)), C24 = g62 * t1690.strides[0] + x43 * t1690.strides[1], E32 = g62 * t1690.strides[0] + w36 * t1690.strides[1], R29 = 0; R29 < n939; R29++)for(var I24 = v73 * R29, S17 = Math.floor(I24), A14 = I24 - S17, T17 = Math.min(s285 - 1, Math.ceil(I24)), D = C24 + S17 * t1690.strides[2], N = E32 + S17 * t1690.strides[2], F = C24 + T17 * t1690.strides[2], _ = E32 + T17 * t1690.strides[2], O13 = 0; O13 < u224; O13++){
            var M14 = c180[D + O13], B11 = c180[N + O13], P9 = M14 + (c180[F + O13] - M14) * A14, L10 = P9 + (B11 + (c180[_ + O13] - B11) * A14 - P9) * b39;
            l145[d++] = L10;
        }
        return Fn(l145, [
            a435,
            e1261,
            n939,
            u224
        ]);
    }, o474.prototype.resizeBilinearBackprop = function(t1691, e1262, n940) {
        df([
            t1691,
            e1262
        ], "resizeBilinearBackprop");
        for(var r753 = e1262.shape, o534 = r753[0], a436 = r753[1], i325 = r753[2], s286 = r753[3], u225 = t1691.shape, c181 = u225[1], l146 = u225[2], h132 = new Float32Array(o534 * a436 * i325 * s286), f112 = [
            n940 && c181 > 1 ? a436 - 1 : a436,
            n940 && l146 > 1 ? i325 - 1 : i325
        ], d93 = [
            n940 && c181 > 1 ? c181 - 1 : c181,
            n940 && l146 > 1 ? l146 - 1 : l146
        ], p80 = f112[0] / d93[0], v74 = f112[1] / d93[1], g63 = this.readSync(t1691.dataId), m = 0, y44 = 0; y44 < o534; y44++)for(var x44 = y44 * e1262.strides[0], b40 = 0; b40 < c181; b40++)for(var w37 = b40 * p80, C25 = Math.floor(w37), E33 = Math.min(Math.ceil(w37), a436 - 1), R30 = x44 + C25 * e1262.strides[1], I25 = x44 + E33 * e1262.strides[1], k20 = w37 - C25, S18 = 1 - k20, A15 = 0; A15 < l146; A15++)for(var T18 = A15 * v74, D17 = Math.floor(T18), N18 = Math.min(Math.ceil(T18), i325 - 1), F17 = T18 - D17, _12 = 1 - F17, O = R30 + D17 * e1262.strides[2], M = R30 + N18 * e1262.strides[2], B = I25 + D17 * e1262.strides[2], P = I25 + N18 * e1262.strides[2], L11 = S18 * _12, W8 = S18 * F17, U8 = k20 * _12, V7 = k20 * F17, z7 = 0; z7 < s286; z7++){
            var G7 = g63[m++];
            h132[O + z7] += G7 * L11, h132[M + z7] += G7 * W8, h132[B + z7] += G7 * U8, h132[P + z7] += G7 * V7;
        }
        return Ln(h132, [
            o534,
            i325,
            a436,
            s286
        ], e1262.dtype);
    }, o474.prototype.resizeNearestNeighbor = function(t1692, e1263, n941, r754) {
        df(t1692, "resizeNearestNeighbor");
        for(var o535 = t1692.shape, a437 = o535[0], i326 = o535[1], s287 = o535[2], u226 = o535[3], c182 = this.readSync(t1692.dataId), l147 = new Float32Array(a437 * e1263 * n941 * u226), h133 = [
            r754 && e1263 > 1 ? i326 - 1 : i326,
            r754 && n941 > 1 ? s287 - 1 : s287
        ], f113 = [
            r754 && e1263 > 1 ? e1263 - 1 : e1263,
            r754 && n941 > 1 ? n941 - 1 : n941
        ], d94 = h133[0] / f113[0], p81 = h133[1] / f113[1], v = 0, g64 = 0; g64 < a437; g64++)for(var m52 = g64 * t1692.strides[0], y45 = 0; y45 < e1263; y45++)for(var x45 = d94 * y45, b41 = m52 + Math.min(i326 - 1, r754 ? Math.round(x45) : Math.floor(x45)) * t1692.strides[1], w38 = 0; w38 < n941; w38++)for(var C26 = p81 * w38, E = b41 + Math.min(s287 - 1, r754 ? Math.round(C26) : Math.floor(C26)) * t1692.strides[2], R31 = 0; R31 < u226; R31++){
            var I26 = c182[E + R31];
            l147[v++] = I26;
        }
        return Fn(l147, [
            a437,
            e1263,
            n941,
            u226
        ], t1692.dtype);
    }, o474.prototype.resizeNearestNeighborBackprop = function(t1693, e1264, n942) {
        df([
            t1693,
            e1264
        ], "resizeNearestNeighborBackprop");
        for(var r755 = e1264.shape, o536 = r755[0], a438 = r755[1], i327 = r755[2], s288 = r755[3], u227 = t1693.shape, c183 = u227[1], l148 = u227[2], h134 = new Float32Array(o536 * a438 * i327 * s288), f114 = this.readSync(t1693.dataId), d95 = [
            n942 && c183 > 1 ? a438 - 1 : a438,
            n942 && l148 > 1 ? i327 - 1 : i327
        ], p82 = [
            n942 && c183 > 1 ? c183 - 1 : c183,
            n942 && l148 > 1 ? l148 - 1 : l148
        ], v75 = d95[0] / p82[0], g65 = d95[1] / p82[1], m53 = 1 / v75, y46 = 1 / g65, x46 = 2 * Math.ceil(m53) + 2, b42 = 2 * Math.ceil(y46) + 2, w39 = 0; w39 < o536; w39++)for(var C27 = w39 * e1264.strides[0], E34 = 0; E34 < a438; E34++)for(var R32 = C27 + E34 * e1264.strides[1], I27 = Math.floor(E34 * m53), k21 = Math.floor(I27 - x46 / 2), S19 = 0; S19 < i327; S19++)for(var A = R32 + S19 * e1264.strides[2], T19 = Math.floor(S19 * y46), D18 = Math.floor(T19 - b42 / 2), N19 = 0; N19 < s288; N19++){
            for(var F18 = 0, _13 = 0; _13 < x46; _13++){
                var O14 = _13 + k21;
                if (!(O14 < 0 || O14 >= c183)) {
                    var M15 = C27 + O14 * t1693.strides[1], B12 = O14 * v75;
                    if (E34 === Math.min(a438 - 1, n942 ? Math.round(B12) : Math.floor(B12))) for(var P10 = 0; P10 < b42; P10++){
                        var L12 = P10 + D18;
                        if (!(L12 < 0 || L12 >= l148)) {
                            var W = M15 + L12 * t1693.strides[2], U9 = L12 * g65;
                            S19 === Math.min(i327 - 1, n942 ? Math.round(U9) : Math.floor(U9)) && (F18 += f114[W + N19]);
                        }
                    }
                }
            }
            h134[A + N19] = F18;
        }
        return Ln(h134, e1264.shape, e1264.dtype);
    }, o474.prototype.batchNormalization = function(t1694, e1265, n943, r756, o537, a439) {
        df([
            t1694,
            e1265,
            n943,
            o537,
            a439
        ], "batchNorm");
        for(var i328 = this.readSync(t1694.dataId), s289 = this.readSync(e1265.dataId), u228 = this.readSync(n943.dataId), c184 = o537 ? this.readSync(o537.dataId) : new Float32Array([
            1
        ]), l149 = a439 ? this.readSync(a439.dataId) : new Float32Array([
            0
        ]), h135 = new Float32Array(i328.length), f115 = l149.length, d96 = c184.length, p83 = u228.length, v76 = s289.length, g66 = 0, m54 = 0, y47 = 0, x47 = 0, b43 = 0; b43 < i328.length; ++b43)h135[b43] = l149[g66++] + (i328[b43] - s289[m54++]) * c184[y47++] / Math.sqrt(u228[x47++] + r756), g66 >= f115 && (g66 = 0), m54 >= v76 && (m54 = 0), y47 >= d96 && (y47 = 0), x47 >= p83 && (x47 = 0);
        return Ln(h135, t1694.shape);
    }, o474.prototype.localResponseNormalization4D = function(t1695, e1266, n944, r757, o538) {
        df(t1695, "localResponseNormalization4D");
        var a440 = t1695.shape[3], i329 = a440 - 1, s290 = this.readSync(t1695.dataId), u229 = t1695.size, c185 = new Float32Array(u229);
        function l150(t1696) {
            for(var n945 = t1696 % a440, r758 = t1696 - n945 + Math.max(0, n945 - e1266), o539 = t1696 - n945 + Math.min(n945 + e1266, i329), u230 = 0; r758 <= o539; r758++){
                var c186 = s290[r758];
                u230 += c186 * c186;
            }
            return u230;
        }
        for(var h136 = 0; h136 < u229; h136++){
            var f116 = l150(h136), d97 = s290[h136] * Math.pow(n944 + r757 * f116, -o538);
            c185[h136] = d97;
        }
        return Ln(c185, t1695.shape);
    }, o474.prototype.LRNGrad = function(t1697, e1267, n946, r759, o540, a441, i330) {
        df(t1697, "LRNGrad");
        for(var s291 = t1697.shape[3], u231 = this.readSync(t1697.dataId), c187 = this.readSync(e1267.dataId), l151 = this.readSync(n946.dataId), h137 = new Float32Array(t1697.size), f117 = t1697.size, d98 = 0; d98 < f117; d98++){
            for(var p84 = d98 % s291, v77 = d98 - p84 + Math.max(0, p84 - r759), g67 = d98 - p84 + Math.min(s291, p84 + r759 + 1), m55 = 0, y48 = v77; y48 < g67; y48++)m55 += Math.pow(c187[y48], 2);
            m55 = a441 * m55 + o540;
            for(y48 = v77; y48 < g67; y48++){
                var x48 = -2 * a441 * i330 * c187[y48] * l151[d98] / m55;
                d98 === y48 && (x48 += Math.pow(m55, -i330)), x48 *= u231[d98], h137[y48] += x48;
            }
        }
        return Ln(h137, t1697.shape);
    }, o474.prototype.multinomial = function(t1698, e1268, n947, r760) {
        df(t1698, "multinomial");
        for(var o541 = e1268 ? t1698 : ia(t1698), a442 = o541.shape[0], i331 = o541.shape[1], s292 = Gn([
            a442,
            n947
        ], "int32"), u232 = this.readSync(s292.dataId), c188 = this.readSync(o541.dataId), l152 = 0; l152 < a442; ++l152){
            var h = l152 * i331, f118 = new Float32Array(i331 - 1);
            f118[0] = c188[h];
            for(var d99 = 1; d99 < f118.length; ++d99)f118[d99] = f118[d99 - 1] + c188[h + d99];
            for(var p85 = Yu(r760.toString()), v = l152 * n947, g68 = 0; g68 < n947; ++g68){
                var m56 = p85();
                u232[v + g68] = f118.length;
                for(var y49 = 0; y49 < f118.length; y49++)if (m56 < f118[y49]) {
                    u232[v + g68] = y49;
                    break;
                }
            }
        }
        return s292;
    }, o474.prototype.oneHot = function(t1699, e1269, n948, r761) {
        df(t1699, "oneHot");
        var o542 = new Float32Array(t1699.size * e1269);
        o542.fill(r761);
        for(var a443 = this.readSync(t1699.dataId), i332 = 0; i332 < t1699.size; ++i332)a443[i332] >= 0 && a443[i332] < e1269 && (o542[i332 * e1269 + a443[i332]] = n948);
        return Bn(o542, [
            t1699.size,
            e1269
        ], "int32");
    }, o474.prototype.nonMaxSuppression = function(t1700, e1270, n949, r762, o543) {
        return df(t1700, "nonMaxSuppression"), Oa(this.readSync(t1700.dataId), this.readSync(e1270.dataId), n949, r762, o543);
    }, o474.prototype.fft = function(t1701) {
        return this.fftBatch(t1701, !1);
    }, o474.prototype.ifft = function(t1702) {
        return this.fftBatch(t1702, !0);
    }, o474.prototype.fftBatch = function(t1703, e1271) {
        for(var n950 = t1703.shape[0], r763 = t1703.shape[1], o544 = er(t1703.shape, "float32"), a444 = er(t1703.shape, "float32"), i333 = Dn(t1703).as2D(n950, r763), s293 = Nn(t1703).as2D(n950, r763), u233 = 0; u233 < n950; u233++)for(var c189 = i333.slice([
            u233,
            0
        ], [
            1,
            r763
        ]), l153 = s293.slice([
            u233,
            0
        ], [
            1,
            r763
        ]), h138 = Tn(c189, l153), f119 = this.readSync(this.fftImpl(h138, e1271).dataId), d100 = 0; d100 < r763; d100++){
            var p86 = Ta(f119, d100);
            o544.values[u233 * r763 + d100] = p86.real, a444.values[u233 * r763 + d100] = p86.imag;
        }
        return Tn(o544.toTensor(), a444.toTensor()).as2D(n950, r763);
    }, o474.prototype.fftImpl = function(t1704, e1272) {
        var n951 = t1704.as1D(), r764 = n951.size;
        if (this.isExponentOf2(r764)) {
            var o545 = this.fftRadix2(n951, r764, e1272).as2D(t1704.shape[0], t1704.shape[1]);
            return e1272 && (o545 = Tn(Dn(o545).div(On(r764)), Nn(o545).div(On(r764)))), o545;
        }
        var a445 = this.readSync(t1704.dataId), i334 = function(t1705) {
            for(var e1273 = new Float32Array(t1705.length / 2), n952 = new Float32Array(t1705.length / 2), r765 = 0; r765 < t1705.length; r765 += 2)e1273[r765 / 2] = t1705[r765], n952[r765 / 2] = t1705[r765 + 1];
            return {
                real: e1273,
                imag: n952
            };
        }(this.fourierTransformByMatmul(a445, r764, e1272));
        return Tn(i334.real, i334.imag).as2D(t1704.shape[0], t1704.shape[1]);
    }, o474.prototype.isExponentOf2 = function(t1706) {
        return 0 == (t1706 & t1706 - 1);
    }, o474.prototype.fftRadix2 = function(t1707, e1274, n953) {
        if (1 === e1274) return t1707;
        var r766 = this.readSync(t1707.dataId), o546 = e1274 / 2, a446 = function(t1708) {
            for(var e1275 = Math.ceil(t1708.length / 4), n954 = new Float32Array(e1275), r767 = new Float32Array(e1275), o547 = 0; o547 < t1708.length; o547 += 4)n954[Math.floor(o547 / 4)] = t1708[o547], r767[Math.floor(o547 / 4)] = t1708[o547 + 1];
            return {
                real: n954,
                imag: r767
            };
        }(r766), i335 = Tn(a446.real, a446.imag).as1D(), s294 = function(t1709) {
            for(var e1276 = Math.floor(t1709.length / 4), n955 = new Float32Array(e1276), r768 = new Float32Array(e1276), o548 = 2; o548 < t1709.length; o548 += 4)n955[Math.floor(o548 / 4)] = t1709[o548], r768[Math.floor(o548 / 4)] = t1709[o548 + 1];
            return {
                real: n955,
                imag: r768
            };
        }(r766), u234 = Tn(s294.real, s294.imag).as1D();
        i335 = this.fftRadix2(i335, o546, n953), u234 = this.fftRadix2(u234, o546, n953);
        var c190 = function(t1710, e1277) {
            for(var n956 = new Float32Array(t1710 / 2), r769 = new Float32Array(t1710 / 2), o549 = 0; o549 < Math.ceil(t1710 / 2); o549++){
                var a447 = (e1277 ? 2 : -2) * Math.PI * (o549 / t1710);
                n956[o549] = Math.cos(a447), r769[o549] = Math.sin(a447);
            }
            return {
                real: n956,
                imag: r769
            };
        }(e1274, n953), l154 = Tn(c190.real, c190.imag).mul(u234), h139 = i335.add(l154), f120 = i335.sub(l154), d101 = Dn(h139).concat(Dn(f120)), p87 = Nn(h139).concat(Nn(f120));
        return Tn(d101, p87).as1D();
    }, o474.prototype.fourierTransformByMatmul = function(t1711, e1278, n957) {
        for(var r770 = new Float32Array(2 * e1278), o550 = 0; o550 < e1278; o550++){
            for(var a448 = 0, i336 = 0, s295 = 0; s295 < e1278; s295++){
                var u235 = Na(o550 * s295, e1278, n957), c191 = Ta(t1711, s295);
                a448 += c191.real * u235.real - c191.imag * u235.imag, i336 += c191.real * u235.imag + c191.imag * u235.real;
            }
            n957 && (a448 /= e1278, i336 /= e1278), Da(r770, a448, i336, o550);
        }
        return r770;
    }, o474.prototype.depthToSpace = function(t1712, e1279, n958) {
        C("NHWC" === n958, function() {
            return "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + n958;
        }), C(e1279 > 1, function() {
            return "blockSize should be > 1 for depthToSpace, but was: " + e1279;
        });
        for(var r771 = t1712.shape[0], o551 = t1712.shape[1], a449 = t1712.shape[2], i337 = t1712.shape[3], s296 = o551 * e1279, u236 = a449 * e1279, c192 = i337 / (e1279 * e1279), l155 = this.readSync(t1712.dataId), h140 = new Float32Array(r771 * s296 * u236 * c192), f = 0, d102 = 0; d102 < r771; ++d102)for(var p88 = 0; p88 < s296; ++p88)for(var v78 = Math.floor(p88 / e1279), g69 = p88 % e1279, m57 = 0; m57 < u236; ++m57)for(var y50 = Math.floor(m57 / e1279), x49 = (g69 * e1279 + m57 % e1279) * c192, b44 = 0; b44 < c192; ++b44){
            var w = b44 + x49 + i337 * (y50 + a449 * (v78 + o551 * d102));
            h140[f++] = l155[w];
        }
        return Ln(h140, [
            r771,
            s296,
            u236,
            c192
        ]);
    }, o474.prototype.broadcastedBinaryOp = function(t1713, e1280, n959, r772) {
        var o552 = Pr(t1713.shape, e1280.shape), a450 = er(o552, n959), i338 = this.readSync(t1713.dataId), s297 = this.readSync(e1280.dataId), u237 = Mr(t1713.shape, o552), c193 = Mr(e1280.shape, o552), l156 = a450.values;
        if (u237.length + c193.length === 0) for(var h141 = 0; h141 < l156.length; ++h141)l156[h141] = r772(i338[h141 % i338.length], s297[h141 % s297.length]);
        else {
            var f121 = this.bufferSync(t1713), d103 = this.bufferSync(e1280), p89 = function(n960) {
                var o553 = a450.indexToLoc(n960), h142 = o553.slice(-t1713.rank);
                u237.forEach(function(t) {
                    return h142[t] = 0;
                });
                var p = f121.locToIndex(h142), v79 = o553.slice(-e1280.rank);
                c193.forEach(function(t) {
                    return v79[t] = 0;
                });
                var g = d103.locToIndex(v79);
                l156[n960] = r772(i338[p], s297[g]);
            };
            for(h141 = 0; h141 < l156.length; ++h141)p89(h141);
        }
        return a450.toTensor();
    }, o474.prototype.broadcastedBinaryComplexOp = function(t1714, e1281, n961) {
        var r773 = Pr(t1714.shape, e1281.shape), o554 = er(r773, "float32"), a451 = er(r773, "float32"), i339 = this.readSync(t1714.dataId), s298 = this.readSync(e1281.dataId), u238 = Mr(t1714.shape, r773), c194 = Mr(e1281.shape, r773), l157 = o554.values, h143 = a451.values;
        if (u238.length + c194.length === 0) for(var f122 = 0; f122 < l157.length; f122++){
            var d = f122 % i339.length, p = f122 % s298.length, v80 = n961(i339[2 * d], i339[2 * d + 1], s298[2 * p], s298[2 * p + 1]);
            l157[f122] = v80.real, h143[f122] = v80.imag;
        }
        else {
            var g70 = this.bufferSync(this.data.get(t1714.dataId).complexTensors.real), m58 = this.bufferSync(this.data.get(e1281.dataId).complexTensors.real), y51 = function(r774) {
                var a452 = o554.indexToLoc(r774), f123 = a452.slice(-t1714.rank);
                u238.forEach(function(t) {
                    return f123[t] = 0;
                });
                var d = g70.locToIndex(f123), p90 = a452.slice(-e1281.rank);
                c194.forEach(function(t) {
                    return p90[t] = 0;
                });
                var v = m58.locToIndex(p90), y53 = n961(i339[2 * d], i339[2 * d + 1], s298[2 * v], s298[2 * v + 1]);
                l157[r774] = y53.real, h143[r774] = y53.imag;
            };
            for(f122 = 0; f122 < l157.length; f122++)y51(f122);
        }
        return this.complex(o554.toTensor(), a451.toTensor());
    }, o474.prototype.split = function(t1715, e1282, n962) {
        return Ua(t1715, e1282, n962);
    }, o474.prototype.dispose = function() {
    }, o474.prototype.floatPrecision = function() {
        return 32;
    }, o474.prototype.epsilon = function() {
        return 0.0000001;
    }, o474.prototype.cropAndResize = function(t1716, e1283, n963, r775, o555, a453) {
        for(var i340 = t1716.shape, s299 = i340[0], u239 = i340[1], c195 = i340[2], l158 = i340[3], h144 = e1283.shape[0], f124 = r775[0], d104 = r775[1], p91 = er([
            h144,
            f124,
            d104,
            l158
        ], "float32"), v81 = this.readSync(e1283.dataId), g71 = this.readSync(n963.dataId), m59 = this.readSync(t1716.dataId), y54 = t1716.strides, x50 = p91.strides, b45 = 0; b45 < h144; b45++){
            var w = 4 * b45, C28 = v81[w], E35 = v81[w + 1], R33 = v81[w + 2], I28 = v81[w + 3], k22 = g71[b45];
            if (!(k22 >= s299)) for(var S20 = f124 > 1 ? (R33 - C28) * (u239 - 1) / (f124 - 1) : 0, A16 = d104 > 1 ? (I28 - E35) * (c195 - 1) / (d104 - 1) : 0, T20 = 0; T20 < f124; T20++){
                var D19 = f124 > 1 ? C28 * (u239 - 1) + T20 * S20 : 0.5 * (C28 + R33) * (u239 - 1);
                if (D19 < 0 || D19 > u239 - 1) for(var N20 = 0; N20 < d104; N20++)for(var F19 = 0; F19 < l158; F19++){
                    var _ = F19 + N20 * x50[2] + T20 * x50[1] + b45 * x50[0];
                    p91.values[_] = a453;
                }
                else if ("bilinear" === o555) {
                    var O15 = Math.floor(D19), M = Math.ceil(D19), B13 = D19 - O15;
                    for(N20 = 0; N20 < d104; N20++){
                        if ((q6 = d104 > 1 ? E35 * (c195 - 1) + N20 * A16 : 0.5 * (E35 + I28) * (c195 - 1)) < 0 || q6 > c195 - 1) for(F19 = 0; F19 < l158; F19++){
                            _ = F19 + N20 * x50[2] + T20 * x50[1] + b45 * x50[0];
                            p91.values[_] = a453;
                        }
                        else {
                            var P11 = Math.floor(q6), L = Math.ceil(q6), W9 = q6 - P11;
                            for(F19 = 0; F19 < l158; F19++){
                                var U10 = m59[_ = F19 + P11 * y54[2] + O15 * y54[1] + k22 * y54[0]], V8 = m59[_ = F19 + L * y54[2] + O15 * y54[1] + k22 * y54[0]], z8 = m59[_ = F19 + P11 * y54[2] + M * y54[1] + k22 * y54[0]], G8 = U10 + (V8 - U10) * W9, H5 = z8 + (m59[_ = F19 + L * y54[2] + M * y54[1] + k22 * y54[0]] - z8) * W9;
                                _ = F19 + N20 * x50[2] + T20 * x50[1] + b45 * x50[0], p91.values[_] = G8 + (H5 - G8) * B13;
                            }
                        }
                    }
                } else for(N20 = 0; N20 < d104; ++N20){
                    var q6;
                    if ((q6 = d104 > 1 ? E35 * (c195 - 1) + N20 * A16 : 0.5 * (E35 + I28) * (c195 - 1)) < 0 || q6 > c195 - 1) for(F19 = 0; F19 < l158; F19++){
                        _ = F19 + N20 * x50[2] + T20 * x50[1] + b45 * x50[0];
                        p91.values[_] = a453;
                    }
                    else {
                        var K6 = Math.round(q6), j5 = Math.round(D19);
                        for(F19 = 0; F19 < l158; F19++){
                            var X = F19 + K6 * y54[2] + j5 * y54[1] + k22 * y54[0], Y = F19 + N20 * x50[2] + T20 * x50[1] + b45 * x50[0];
                            p91.values[Y] = m59[X];
                        }
                    }
                }
            }
        }
        return p91.toTensor();
    }, o474.prototype.sparseToDense = function(t1717, e1284, n964, r776) {
        var o556 = Go(0, t1717, n964), a454 = o556.sliceRank, i341 = o556.numUpdates, s300 = o556.sliceSize, u240 = o556.strides, c196 = o556.outputSize;
        return this.scatter(t1717, e1284, n964, c196, s300, i341, a454, u240, r776, !1);
    }, o474.prototype.gatherND = function(t1718, e1285) {
        var n965 = e1285.shape, r777 = n965[n965.length - 1], o557 = Po(t1718, e1285), a455 = o557[0], i342 = o557[1], s301 = o557[2], u241 = o557[3];
        if (0 === i342) return Fn([], a455, t1718.dtype);
        for(var c197 = new mt([
            i342,
            s301
        ], t1718.dtype), l159 = this.readSync(e1285.dataId), h145 = this.readSync(t1718.dataId), f125 = 0; f125 < i342; f125++){
            for(var d105 = [], p92 = 0, v82 = 0; v82 < r777; v82++){
                var g72 = l159[f125 * r777 + v82];
                p92 += g72 * u241[v82], d105.push(g72);
            }
            if (p92 < 0 || p92 >= t1718.size / s301) throw new Error("Invalid indices: " + d105 + " does not index into " + t1718.shape);
            for(var m60 = 0; m60 < s301; m60++)c197.values[f125 * s301 + m60] = h145[p92 * s301 + m60];
        }
        return c197.toTensor().reshape(a455);
    }, o474.prototype.scatterND = function(t1719, e1286, n966) {
        var r778 = Go(0, t1719, n966), o558 = r778.sliceRank, a456 = r778.numUpdates, i343 = r778.sliceSize, s302 = r778.strides, u242 = r778.outputSize, c198 = On(0);
        return this.scatter(t1719, e1286, n966, u242, i343, a456, o558, s302, c198, !0);
    }, o474.prototype.fill = function(t1720, e1287, n967) {
        var r779 = P(n967 = n967 || j(e1287), k(t1720));
        return r779.fill(e1287), Lt.makeTensor(r779, t1720, n967, this);
    }, o474.prototype.onesLike = function(t1721) {
        if ("string" === t1721.dtype) throw new Error("onesLike is not supported for string tensors");
        return this.fill(t1721.shape, 1, t1721.dtype);
    }, o474.prototype.zerosLike = function(t1722) {
        var e1288 = P(t1722.dtype, k(t1722.shape));
        return this.makeOutput(e1288, t1722.shape, t1722.dtype);
    }, o474.prototype.linspace = function(t1723, e1289, n968) {
        return ka(t1723, e1289, n968);
    }, o474.prototype.scatter = function(t1724, e1290, n969, r780, o559, a457, i344, s303, u243, c199) {
        var l160 = [
            r780 / o559,
            o559
        ], h146 = this.readSync(t1724.dataId), f126 = this.readSync(e1290.dataId);
        if (0 === r780) return Fn([], n969, e1290.dtype);
        var d106 = new mt(l160, e1290.dtype);
        d106.values.fill(this.readSync(u243.dataId)[0]);
        for(var p93 = 0; p93 < a457; p93++){
            for(var v83 = [], g73 = 0, m61 = 0; m61 < i344; m61++){
                var y55 = h146[p93 * i344 + m61];
                v83.push(y55), g73 += y55 * s303[m61];
            }
            if (g73 < 0 || g73 >= r780 / o559) throw new Error("Invalid indices: " + v83 + " does not index into " + n969);
            for(var x51 = 0; x51 < o559; x51++)c199 ? d106.values[g73 * o559 + x51] += f126[p93 * o559 + x51] : d106.values[g73 * o559 + x51] = 0 === e1290.rank ? f126[0] : f126[p93 * o559 + x51];
        }
        return d106.toTensor().reshape(n969);
    }, o474;
}(la);
function yf(t1725, e1291) {
    return {
        kernelName: t1725,
        backendName: "cpu",
        kernelFunc: function(n970) {
            var r781 = n970.inputs, o560 = n970.backend, a458 = r781, i345 = a458.a, s304 = a458.b, u244 = o560;
            df([
                i345,
                s304
            ], t1725);
            var c200 = u244.data.get(i345.dataId).values, l161 = u244.data.get(s304.dataId).values, h147 = e1291(i345.shape, s304.shape, c200, l161, i345.dtype), f127 = h147[0], d107 = h147[1];
            return {
                dataId: u244.write(f127, d107, i345.dtype),
                shape: d107,
                dtype: i345.dtype
            };
        }
    };
}
function xf(t1726) {
    return function(e1292, n971, r782, o561, a459) {
        var i346 = Pr(e1292, n971), s305 = i346.length, u245 = $(i346), c201 = B(a459, k(i346)), l162 = e1292.length, h148 = n971.length, f128 = $(e1292), d108 = $(n971), p94 = Mr(e1292, i346), v84 = Mr(n971, i346);
        if (p94.length + v84.length === 0) for(var g74 = 0; g74 < c201.length; ++g74)c201[g74] = t1726(r782[g74 % r782.length], o561[g74 % o561.length]);
        else {
            var m62 = function(e1293) {
                var n972 = it(e1293, s305, u245), a460 = n972.slice(-l162);
                p94.forEach(function(t) {
                    return a460[t] = 0;
                });
                var i = at(a460, l162, f128), g75 = n972.slice(-h148);
                v84.forEach(function(t) {
                    return g75[t] = 0;
                });
                var m = at(g75, h148, d108);
                c201[e1293] = t1726(r782[i], o561[m]);
            };
            for(g74 = 0; g74 < c201.length; ++g74)m62(g74);
        }
        return [
            c201,
            i346
        ];
    };
}
Lt.registerBackend("cpu", function() {
    return new mf;
}, 1);
var bf = xf(function(t1727, e1294) {
    return t1727 / e1294;
}), wf = yf(wr, bf);
var Cf = {
    kernelName: "MaxPoolWithArgmax",
    backendName: "cpu",
    kernelFunc: function(t1728) {
        var e1295 = t1728.inputs, n973 = t1728.attrs, r783 = t1728.backend, o562 = e1295.x, a461 = n973, i347 = a461.filterSize, s306 = a461.strides, u246 = a461.pad, c202 = a461.includeBatchInIndex, l163 = r783;
        df(o562, "MaxPoolWithArgmax");
        var h149 = l163.data.get(o562.dataId).values, f129 = fa(o562.shape, i347, s306, [
            1,
            1
        ], u246), d109 = function(t1729, e1296, n974, r784, o563) {
            var a462 = pf(t1729, 0, n974, $(e1296), o563, "max"), i348 = vf(t1729, e1296, n974, o563, !0, r784);
            return [
                a462.values,
                i348.values
            ];
        }(h149, o562.shape, o562.dtype, c202, f129), p95 = d109[0], v85 = d109[1], g76 = l163.write(p95, f129.outShape, o562.dtype), m63 = l163.write(v85, f129.outShape, o562.dtype);
        return [
            {
                dataId: g76,
                shape: f129.outShape,
                dtype: o562.dtype
            },
            {
                dataId: m63,
                shape: f129.outShape,
                dtype: "int32"
            }
        ];
    }
}, Ef = {
    kernelName: "NonMaxSuppressionV5",
    backendName: "cpu",
    kernelFunc: function(t1730) {
        var e1297 = t1730.inputs, n975 = t1730.backend, r785 = t1730.attrs, o564 = e1297, a463 = o564.boxes, i349 = o564.scores, s307 = r785, u247 = s307.maxOutputSize, c203 = s307.iouThreshold, l164 = s307.scoreThreshold, h150 = s307.softNmsSigma, f130 = n975;
        df(a463, "NonMaxSuppressionWithScore");
        var d110 = Ma(f130.data.get(a463.dataId).values, f130.data.get(i349.dataId).values, u247, c203, l164, h150);
        return [
            d110.selectedIndices,
            d110.selectedScores
        ];
    }
}, Rf = {
    kernelName: "Square",
    backendName: "cpu",
    kernelFunc: function(t1731) {
        var e1298 = t1731.inputs, n976 = t1731.backend, r786 = e1298.x, o565 = n976;
        df(r786, "square");
        for(var a464 = o565.data.get(r786.dataId).values, i350 = new Float32Array(a464.length), s308 = 0; s308 < a464.length; ++s308){
            var u248 = a464[s308];
            i350[s308] = u248 * u248;
        }
        return {
            dataId: o565.write(i350, r786.shape, r786.dtype),
            shape: r786.shape,
            dtype: r786.dtype
        };
    }
}, If = xf(function(t1732, e1299) {
    var n977 = t1732 - e1299;
    return n977 * n977;
});
function kf(t1733, e1300, n978, r, o566) {
    for(var a465 = k(e1300), i351 = e1300.length, s309 = $(e1300), u = $(o566), c204 = B(n978, k(o566)), l165 = 0; l165 < a465; ++l165){
        for(var h151 = it(l165, i351, s309), f131 = new Array(h151.length), d111 = 0; d111 < f131.length; d111++)f131[d111] = h151[r[d111]];
        c204[at(f131, i351, u)] = t1733[l165];
    }
    return c204;
}
for(var Sf = 0, Af = [
    Ef,
    Rf,
    yf(Er, If),
    wf,
    {
        kernelName: "Transpose",
        backendName: "cpu",
        kernelFunc: function(t1734) {
            var e1301 = t1734.inputs, n979 = t1734.attrs, r787 = t1734.backend, o567 = e1301.x, a466 = n979.perm, i352 = r787;
            df(o567, "transpose");
            for(var s310 = o567.shape.length, u249 = new Array(s310), c205 = 0; c205 < u249.length; c205++)u249[c205] = o567.shape[a466[c205]];
            var l166 = kf(i352.data.get(o567.dataId).values, o567.shape, o567.dtype, a466, u249);
            return {
                dataId: i352.write(l166, u249, o567.dtype),
                shape: u249,
                dtype: o567.dtype
            };
        }
    },
    Cf
]; Sf < Af.length; Sf++)d(Af[Sf]);
var Tf, Df = function(t1735) {
    this.variableNames = [
        "A"
    ];
    var e1302 = Ya(), n980 = t1735[0], r788 = t1735[1];
    this.outputShape = t1735, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + r788 + ".0, " + n980 + ".0);\n\n        vec4 values = " + e1302.texture2D + "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ";
}, Nf = function(t1736) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !1, this.packedOutput = !0;
    var e1303 = Ya(), n981 = t1736[0], r789 = t1736[1];
    this.outputShape = t1736, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(" + r789 + ".0, " + n981 + ".0);\n            vec4 values = " + e1303.texture2D + "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        " + e1303.output + " = result;\n      }\n    ";
};
var Ff = function(t1737, e1304) {
    this.variableNames = [
        "A"
    ];
    for(var n982 = new Array(t1737.length), r790 = 0; r790 < n982.length; r790++)n982[r790] = t1737[e1304[r790]];
    this.outputShape = n982, this.rank = n982.length;
    var o568 = ui(this.rank), a467 = function(t1738) {
        var e1305 = t1738.length;
        if (e1305 > 6) throw Error("Transpose for rank " + e1305 + " is not yet supported");
        for(var n983 = [
            "resRC.x",
            "resRC.y",
            "resRC.z",
            "resRC.w",
            "resRC.u",
            "resRC.v"
        ], r791 = new Array(e1305), o569 = 0; o569 < t1738.length; o569++)r791[t1738[o569]] = n983[o569];
        return r791.join();
    }(e1304);
    this.userCode = "\n    void main() {\n      " + o568 + " resRC = getOutputCoords();\n      setOutput(getA(" + a467 + "));\n    }\n    ";
};
var _f = function(t1739, e1306) {
    this.variableNames = [
        "A"
    ], this.packedInputs = !0, this.packedOutput = !0;
    for(var n984 = new Array(t1739.length), r792 = 0; r792 < n984.length; r792++)n984[r792] = t1739[e1306[r792]];
    if (this.outputShape = n984, this.rank = n984.length, this.rank > 6) throw Error("Packed transpose for rank " + this.rank + " is not yet supported.");
    var o570 = ui(this.rank), a468 = ja("rc", this.rank), i353 = new Array(this.rank);
    for(r792 = 0; r792 < e1306.length; r792++)i353[e1306[r792]] = a468[r792];
    var s311 = "vec2(" + i353.slice(-2).join() + ")", u250 = "++" + a468[this.rank - 1] + " < " + n984[this.rank - 1], c206 = "getChannel(getA(" + i353.join() + "), " + s311 + ")";
    this.userCode = "\n    void main() {\n      " + o570 + " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = " + c206 + ";\n      if(" + u250 + ") {\n        result[1] = " + c206 + ";\n      }\n      --" + a468[this.rank - 1] + ";\n      if(++" + a468[this.rank - 2] + " < " + n984[this.rank - 2] + ") {\n        result[2] = " + c206 + ";\n        if(" + u250 + ") {\n          result[3] = " + c206 + ";\n        }\n      }\n      setOutput(result);\n    }\n    ";
};
for(var Of = 0, Mf = [
    {
        kernelName: "FromPixels",
        backendName: "webgl",
        kernelFunc: function(t1740) {
            var e1307 = t1740.inputs, n985 = t1740.backend, r793 = t1740.attrs, o571 = e1307.pixels, a469 = r793.numChannels, s312 = "undefined" != typeof HTMLVideoElement && o571 instanceof HTMLVideoElement, u251 = "undefined" != typeof HTMLImageElement && o571 instanceof HTMLImageElement, c207 = s312 ? [
                o571.videoWidth,
                o571.videoHeight
            ] : [
                o571.width,
                o571.height
            ], l167 = c207[0], h152 = c207[1], f132 = [
                h152,
                l167
            ], d112 = [
                h152,
                l167,
                a469
            ];
            (u251 || s312) && (null == Tf && (Tf = document.createElement("canvas").getContext("2d")), Tf.canvas.width = l167, Tf.canvas.height = h152, Tf.drawImage(o571, 0, 0, l167, h152), o571 = Tf.canvas);
            var p96 = n985.makeTensorInfo(f132, "int32");
            n985.texData.get(p96.dataId).usage = zt.PIXELS, n985.gpgpu.uploadPixelDataToTexture(n985.getTexture(p96.dataId), o571);
            var v86 = i().getBool("WEBGL_PACK") ? new Nf(d112) : new Df(d112), g77 = n985.runWebGLProgram(v86, [
                p96
            ], "int32");
            return n985.disposeData(p96.dataId), g77;
        }
    },
    {
        kernelName: wr,
        backendName: "webgl",
        kernelFunc: function(t1741) {
            var e1308 = t1741.inputs, n986 = t1741.backend, r794 = e1308;
            return (function(t1742, e1309, n987) {
                var r795 = new Ri(Ci, t1742.shape, e1309.shape);
                return i().getBool("WEBGL_PACK_BINARY_OPERATIONS") && (r795 = new Si(Ii, t1742.shape, e1309.shape, !0)), n987.runWebGLProgram(r795, [
                    t1742,
                    e1309
                ], "float32");
            })(r794.a, r794.b, n986);
        }
    },
    {
        kernelName: "NonMaxSuppressionV5",
        backendName: "webgl",
        kernelFunc: function(t1743) {
            var e1310 = t1743.inputs, n988 = t1743.backend, r796 = t1743.attrs;
            dn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
            var o572 = e1310, a470 = o572.boxes, i354 = o572.scores, s313 = r796, u252 = s313.maxOutputSize, c208 = s313.iouThreshold, l168 = s313.scoreThreshold, h153 = s313.softNmsSigma, f133 = n988, d113 = Ma(f133.readSync(a470.dataId), f133.readSync(i354.dataId), u252, c208, l168, h153);
            return [
                d113.selectedIndices,
                d113.selectedScores
            ];
        }
    },
    {
        kernelName: "Square",
        backendName: "webgl",
        kernelFunc: function(t1744) {
            var e1311 = t1744.inputs, n989 = t1744.backend, r797 = e1311.x, o573 = n989, a471 = new cu(r797.shape, "return x * x;");
            return o573.runWebGLProgram(a471, [
                r797
            ], r797.dtype);
        }
    },
    {
        kernelName: Er,
        backendName: "webgl",
        kernelFunc: function(t1745) {
            var e1312 = t1745.inputs, n990 = t1745.backend, r798 = e1312, o574 = r798.a, a472 = r798.b, s314 = n990, u253 = i().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Si("return (a - b) * (a - b);", o574.shape, a472.shape) : new Ri("return (a - b) * (a - b);", o574.shape, a472.shape);
            return s314.compileAndRun(u253, [
                o574,
                a472
            ]);
        }
    },
    {
        kernelName: "Transpose",
        backendName: "webgl",
        kernelFunc: function(t1746) {
            for(var e1313, n991 = t1746.inputs, r799 = t1746.attrs, o575 = t1746.backend, a473 = n991.x, s315 = r799.perm, u254 = o575, c209 = a473.shape.length, l169 = new Array(c209), h154 = 0; h154 < l169.length; h154++)l169[h154] = a473.shape[s315[h154]];
            if (u254.shouldExecuteOnCPU([
                a473
            ])) {
                var f134 = kf(u254.texData.get(a473.dataId).values, a473.shape, a473.dtype, s315, l169);
                e1313 = u254.makeTensorInfo(l169, a473.dtype), u254.texData.get(e1313.dataId).values = f134;
            } else e1313 = (function(t1747, e1314, n992) {
                var r800 = i().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new _f(t1747.shape, e1314) : new Ff(t1747.shape, e1314);
                return n992.runWebGLProgram(r800, [
                    t1747
                ], t1747.dtype);
            })(a473, s315, u254);
            return e1313;
        }
    },
    {
        kernelName: "MaxPoolWithArgmax",
        backendName: "webgl",
        kernelFunc: function(t1748) {
            var e1315 = t1748.inputs, n993 = t1748.attrs, r801 = t1748.backend, o576 = e1315.x, a474 = n993, i355 = a474.filterSize, s316 = a474.strides, u255 = a474.pad, c210 = a474.includeBatchInIndex, l170 = r801;
            C(4 === o576.shape.length, function() {
                return "Error in maxPool: input must be rank 4 but got rank " + o576.shape.length + ".";
            });
            var h155 = [
                1,
                1
            ];
            C(Ca(s316, h155), function() {
                return "Error in maxPool: Either strides or dilations must be 1. Got strides " + s316 + " and dilations '" + h155 + "'";
            });
            var f135 = fa(o576.shape, i355, s316, h155, u255), d114 = function(t1749, e1316, n994, r802) {
                var o577 = new Ws(n994, "max", !1), a475 = r802.runWebGLProgram(o577, [
                    t1749
                ], "float32");
                return o577 = new Ws(n994, "max", !0, !0, e1316), [
                    a475,
                    r802.runWebGLProgram(o577, [
                        t1749
                    ], "float32")
                ];
            }(o576, c210, f135, l170);
            return [
                d114[0],
                d114[1]
            ];
        }
    }
]; Of < Mf.length; Of++)d(Mf[Of]);
for(var Bf = 0, Pf = [
    {
        kernelName: xr,
        inputsToSave: [
            "a",
            "b"
        ],
        gradFunc: function(t1750, e1317) {
            var n995 = e1317[0], r803 = e1317[1], o578 = Pr(n995.shape, r803.shape);
            return {
                a: function() {
                    var e1318 = t1750, r804 = Br(n995.shape, o578);
                    return r804.length > 0 && (e1318 = e1318.sum(r804)), e1318.reshape(n995.shape);
                },
                b: function() {
                    var e1319 = t1750, n996 = Br(r803.shape, o578);
                    return n996.length > 0 && (e1319 = e1319.sum(n996)), e1319.reshape(r803.shape);
                }
            };
        }
    },
    {
        kernelName: "AddN",
        saveAllInputs: !0,
        gradFunc: function(t1751, e1320) {
            var n997 = {
            };
            return e1320.forEach(function(e, r) {
                n997[r] = function() {
                    return t1751.clone();
                };
            }), n997;
        }
    },
    {
        kernelName: Sr,
        gradFunc: function(t1752, e, n998) {
            for(var r805 = n998, o579 = r805.inputShape, a476 = r805.shape, i356 = Array.from(a476), s317 = o579.length - 1; s317 >= 0; s317--)if (o579[s317] === a476[s317]) i356[s317] = 1;
            else if (1 !== o579[s317]) throw new Error("broadcastTo(): [" + o579 + "] cannot be broadcast to [" + a476 + "].");
            var u256 = [];
            for(s317 = 0; s317 < i356.length; s317++)i356[s317] > 1 && u256.push(s317);
            return {
                x: function() {
                    return t1752.sum(u256, !0);
                }
            };
        }
    },
    {
        kernelName: wr,
        inputsToSave: [
            "a",
            "b"
        ],
        gradFunc: function(t1753, e1321) {
            var n999 = e1321[0], r806 = e1321[1], o580 = Pr(n999.shape, r806.shape);
            return {
                a: function() {
                    var e1322 = Bo(t1753, r806.toFloat()), a477 = Br(n999.shape, o580);
                    return a477.length > 0 ? th(e1322, a477).reshape(n999.shape) : e1322;
                },
                b: function() {
                    var e1323 = t1753.mul(n999.toFloat()), a478 = Br(r806.shape, o580);
                    a478.length > 0 && (e1323 = th(e1323, a478).reshape(r806.shape));
                    var i357 = Gc(r806);
                    return no(Bo(e1323, i357.toFloat()));
                }
            };
        }
    },
    {
        kernelName: "FusedBatchNorm",
        inputsToSave: [
            "x",
            "mean",
            "variance",
            "scale"
        ],
        gradFunc: function(t1754, e1324, n1000) {
            var r807 = n1000.varianceEpsilon, o581 = e1324[0], a479 = e1324[1], i358 = e1324[2], s318 = e1324[3], u257 = Ju(o581), c211 = null == s318 ? On(1) : s318, l171 = Br(a479.shape, u257.shape), h156 = [];
            if (1 === a479.rank) {
                for(var f136 = 0; f136 < u257.shape.length - 1; ++f136)h156.push(u257.shape[f136]);
                h156.push(1);
            }
            var d115 = Oo(o581, a479), p97 = To(t1754, c211), v87 = ao(Or(i358, On(r807))), g78 = To(To(To(v87, v87), v87), On(-0.5));
            return {
                x: function() {
                    return 1 === a479.rank ? ur(To(To(t1754, wc(v87.as4D(1, 1, 1, a479.shape[0]), h156)), c211), o581.shape) : ur(To(To(t1754, v87), c211), o581.shape);
                },
                mean: function() {
                    var t1755 = To(To(v87, On(-1)), p97);
                    return 1 === a479.rank && (t1755 = th(t1755, l171)), ur(t1755, a479.shape);
                },
                variance: function() {
                    var t1756 = To(To(g78, d115), p97);
                    return 1 === a479.rank && (t1756 = th(t1756, l171)), ur(t1756, a479.shape);
                },
                scale: function() {
                    var e1325 = To(d115, v87), n1001 = To(t1754, e1325);
                    return 1 === a479.rank && (n1001 = th(n1001, l171)), ur(n1001, a479.shape);
                },
                offset: function() {
                    var e1326 = t1754;
                    return 1 === a479.rank && (e1326 = th(e1326, l171)), ur(e1326, a479.shape);
                }
            };
        }
    },
    {
        kernelName: Tr,
        gradFunc: function(t1757) {
            return {
                x: function() {
                    return t1757.toFloat();
                }
            };
        }
    },
    {
        kernelName: Ar,
        inputsToSave: [
            "indices"
        ],
        gradFunc: function(t, e1327) {
            var n1002 = e1327[0];
            return {
                indices: function() {
                    return Gn(n1002.shape, "float32");
                }
            };
        }
    },
    {
        kernelName: Nr,
        inputsToSave: [
            "x"
        ],
        gradFunc: function(t1758, e1328, n1003) {
            var r808 = e1328[0], o582 = n1003.paddings.map(function(t1759) {
                return t1759[0];
            });
            return {
                x: function() {
                    return t1758.slice(o582, r808.shape);
                }
            };
        }
    },
    {
        kernelName: "Square",
        inputsToSave: [
            "x"
        ],
        gradFunc: function(t1760, e1329) {
            var n1004 = e1329[0];
            return {
                x: function() {
                    return t1760.mul(n1004.toFloat().mul(2));
                }
            };
        }
    },
    {
        kernelName: Er,
        inputsToSave: [
            "a",
            "b"
        ],
        gradFunc: function(t1761, e1330) {
            var n1005 = e1330[0], r809 = e1330[1], o583 = On(2);
            return {
                a: function() {
                    return To(t1761, To(o583, Oo(n1005, r809)));
                },
                b: function() {
                    return To(t1761, To(o583, Oo(r809, n1005)));
                }
            };
        }
    },
    {
        kernelName: Dr,
        inputsToSave: [
            "x"
        ],
        gradFunc: function(t1762, e1331, n1006) {
            var r810 = e1331[0], o584 = n1006.reps;
            return {
                x: function() {
                    var e1332 = Xn(r810);
                    if (1 === r810.rank) for(var n1007 = 0; n1007 < o584[0]; ++n1007)e1332 = e1332.add(t1762.slice([
                        n1007 * r810.shape[0]
                    ], [
                        r810.shape[0]
                    ]));
                    else if (2 === r810.rank) for(n1007 = 0; n1007 < o584[0]; ++n1007)for(var a480 = 0; a480 < o584[1]; ++a480)e1332 = e1332.add(t1762.slice([
                        n1007 * r810.shape[0],
                        a480 * r810.shape[1]
                    ], [
                        r810.shape[0],
                        r810.shape[1]
                    ]));
                    else if (3 === r810.rank) for(n1007 = 0; n1007 < o584[0]; ++n1007)for(a480 = 0; a480 < o584[1]; ++a480)for(var i359 = 0; i359 < o584[2]; ++i359)e1332 = e1332.add(t1762.slice([
                        n1007 * r810.shape[0],
                        a480 * r810.shape[1],
                        i359 * r810.shape[2]
                    ], [
                        r810.shape[0],
                        r810.shape[1],
                        r810.shape[2]
                    ]));
                    else {
                        if (4 !== r810.rank) throw new Error("Gradient for tile operation is not implemented for rank-" + r810.rank + " tensors yet.");
                        for(n1007 = 0; n1007 < o584[0]; ++n1007)for(a480 = 0; a480 < o584[1]; ++a480)for(i359 = 0; i359 < o584[2]; ++i359)for(var s319 = 0; s319 < o584[3]; ++s319)e1332 = e1332.add(t1762.slice([
                            n1007 * r810.shape[0],
                            a480 * r810.shape[1],
                            i359 * r810.shape[2],
                            s319 * r810.shape[3]
                        ], [
                            r810.shape[0],
                            r810.shape[1],
                            r810.shape[2],
                            r810.shape[3]
                        ]));
                    }
                    return e1332;
                }
            };
        }
    },
    {
        kernelName: "Transpose",
        gradFunc: function(t1763, e, n1008) {
            var r811 = Rn(n1008.perm);
            return {
                x: function() {
                    return ua(t1763, r811);
                }
            };
        }
    }
]; Bf < Pf.length; Bf++)p(Pf[Bf]);
var Lf = function() {
    function t1764() {
    }
    return t1764.prototype.fetch = function(t1765, e1333) {
        return fetch(t1765, e1333);
    }, t1764.prototype.now = function() {
        return performance.now();
    }, t1764.prototype.encode = function(t1766, e1334) {
        if ("utf-8" !== e1334 && "utf8" !== e1334) throw new Error("Browser's encoder only supports utf-8, but got " + e1334);
        return null == this.textEncoder && (this.textEncoder = new TextEncoder), this.textEncoder.encode(t1766);
    }, t1764.prototype.decode = function(t1767, e1335) {
        return new TextDecoder(e1335).decode(t1767);
    }, t1764;
}();
i().get("IS_BROWSER") && i().setPlatform("browser", new Lf);
var Wf, Uf = function() {
    return require("node-fetch");
}, Vf = function() {
    function t1768() {
        this.util = require("util"), this.textEncoder = new this.util.TextEncoder;
    }
    return t1768.prototype.fetch = function(t1769, e1336) {
        return null != i().global.fetch ? i().global.fetch(t1769, e1336) : (null == Wf && (Wf = Uf()), Wf(t1769, e1336));
    }, t1768.prototype.now = function() {
        var t1770 = process.hrtime();
        return 1000 * t1770[0] + t1770[1] / 1000000;
    }, t1768.prototype.encode = function(t1771, e1337) {
        if ("utf-8" !== e1337 && "utf8" !== e1337) throw new Error("Node built-in encoder only supports utf-8, but got " + e1337);
        return this.textEncoder.encode(t1771);
    }, t1768.prototype.decode = function(t1772, e1338) {
        return 0 === t1772.length ? "" : new this.util.TextDecoder(e1338).decode(t1772);
    }, t1768;
}();
i().get("IS_NODE") && i().setPlatform("node", new Vf);
var zf = {
    float32: 4,
    int32: 4,
    uint16: 2,
    uint8: 1,
    bool: 1
}, Gf = 4;
function Hf(t1773, e1339) {
    for(var n1009 = {
    }, r812 = 0, o585 = function(e1340) {
        var o586 = e1340.name, a482 = e1340.dtype, i361 = e1340.shape, s320 = k(i361), u258 = void 0;
        if (("quantization" in e1340)) {
            var c212 = e1340.quantization;
            if ("uint8" !== c212.dtype && "uint16" !== c212.dtype) throw new Error("Weight " + e1340.name + " has unknown quantization dtype " + c212.dtype + ". Supported quantization dtypes are: 'uint8' and 'uint16'.");
            var l172 = zf[c212.dtype], h157 = t1773.slice(r812, r812 + s320 * l172), f137 = "uint8" === c212.dtype ? new Uint8Array(h157) : new Uint16Array(h157);
            if ("float32" === a482) u258 = Float32Array.from(f137, function(t1774) {
                return t1774 * c212.scale + c212.min;
            });
            else {
                if ("int32" !== a482) throw new Error("Unsupported dtype in weight '" + o586 + "': " + a482);
                u258 = Int32Array.from(f137, function(t1775) {
                    return Math.round(t1775 * c212.scale + c212.min);
                });
            }
            r812 += s320 * l172;
        } else if ("string" === a482) {
            var d116 = k(e1340.shape);
            u258 = [];
            for(var p98 = 0; p98 < d116; p98++){
                var v88 = new Uint32Array(t1773.slice(r812, r812 + Gf))[0];
                r812 += Gf;
                var g79 = new Uint8Array(t1773.slice(r812, r812 + v88));
                u258.push(g79), r812 += v88;
            }
        } else {
            var m64 = zf[a482];
            h157 = t1773.slice(r812, r812 + s320 * m64);
            if ("float32" === a482) u258 = new Float32Array(h157);
            else if ("int32" === a482) u258 = new Int32Array(h157);
            else {
                if ("bool" !== a482) throw new Error("Unsupported dtype in weight '" + o586 + "': " + a482);
                u258 = new Uint8Array(h157);
            }
            r812 += s320 * m64;
        }
        n1009[o586] = Fn(u258, i361, a482);
    }, a481 = 0, i360 = e1339; a481 < i360.length; a481++)o585(i360[a481]);
    return n1009;
}
function qf(t1776) {
    if (null === t1776) throw new Error("Invalid input value: " + JSON.stringify(t1776));
    var e1341 = 0, n1010 = [];
    t1776.forEach(function(t1777) {
        if (e1341 += t1777.byteLength, n1010.push(t1777.byteLength === t1777.buffer.byteLength ? t1777 : new t1777.constructor(t1777)), !(t1777 instanceof Float32Array || t1777 instanceof Int32Array || t1777 instanceof Uint8Array)) throw new Error("Unsupported TypedArray subtype: " + t1777.constructor.name);
    });
    var r813 = new Uint8Array(e1341), o587 = 0;
    return n1010.forEach(function(t1778) {
        r813.set(new Uint8Array(t1778.buffer), o587), o587 += t1778.byteLength;
    }), r813.buffer;
}
var Kf = "undefined" != typeof Buffer && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);
function jf(t1779) {
    return Kf ? Buffer.byteLength(t1779) : new Blob([
        t1779
    ]).size;
}
function Xf(t1780) {
    var e1342 = 0;
    t1780.forEach(function(t1781) {
        e1342 += t1781.byteLength;
    });
    var n1011 = new Uint8Array(e1342), r814 = 0;
    return t1780.forEach(function(t1782) {
        n1011.set(new Uint8Array(t1782), r814), r814 += t1782.byteLength;
    }), n1011.buffer;
}
function Yf(t1783) {
    for(t1783 = t1783.trim(); t1783.endsWith("/");)t1783 = t1783.slice(0, t1783.length - 1);
    var e1343 = t1783.split("/");
    return e1343[e1343.length - 1];
}
function $f(t1784) {
    if (t1784.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
    return {
        dateSaved: new Date,
        modelTopologyType: "JSON",
        modelTopologyBytes: null == t1784.modelTopology ? 0 : jf(JSON.stringify(t1784.modelTopology)),
        weightSpecsBytes: null == t1784.weightSpecs ? 0 : jf(JSON.stringify(t1784.weightSpecs)),
        weightDataBytes: null == t1784.weightData ? 0 : t1784.weightData.byteLength
    };
}
var Qf = function() {
    function t1785() {
        this.saveRouters = [], this.loadRouters = [];
    }
    return t1785.getInstance = function() {
        return null == t1785.instance && (t1785.instance = new t1785), t1785.instance;
    }, t1785.registerSaveRouter = function(e1344) {
        t1785.getInstance().saveRouters.push(e1344);
    }, t1785.registerLoadRouter = function(e1345) {
        t1785.getInstance().loadRouters.push(e1345);
    }, t1785.getSaveHandlers = function(e1346) {
        return t1785.getHandlers(e1346, "save");
    }, t1785.getLoadHandlers = function(e1347, n1012) {
        return t1785.getHandlers(e1347, "load", n1012);
    }, t1785.getHandlers = function(e1348, n1013, r815) {
        var o588 = [];
        return ("load" === n1013 ? t1785.getInstance().loadRouters : t1785.getInstance().saveRouters).forEach(function(t1786) {
            var n1014 = t1786(e1348, r815);
            null !== n1014 && o588.push(n1014);
        }), o588;
    }, t1785;
}(), Jf = "://", Zf = function() {
    function t1787() {
        this.managers = {
        };
    }
    return t1787.getInstance = function() {
        return null == t1787.instance && (t1787.instance = new t1787), t1787.instance;
    }, t1787.registerManager = function(e1349, n1015) {
        C(null != e1349, function() {
            return "scheme must not be undefined or null.";
        }), e1349.endsWith(Jf) && (e1349 = e1349.slice(0, e1349.indexOf(Jf))), C(e1349.length > 0, function() {
            return "scheme must not be an empty string.";
        });
        var r816 = t1787.getInstance();
        C(null == r816.managers[e1349], function() {
            return "A model store manager is already registered for scheme '" + e1349 + "'.";
        }), r816.managers[e1349] = n1015;
    }, t1787.getManager = function(t1788) {
        var e1350 = this.getInstance().managers[t1788];
        if (null == e1350) throw new Error("Cannot find model manager for scheme '" + t1788 + "'");
        return e1350;
    }, t1787.getSchemes = function() {
        return Object.keys(this.getInstance().managers);
    }, t1787;
}();
function td(t1789) {
    if (-1 === t1789.indexOf(Jf)) throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + Zf.getSchemes().join(","));
    return {
        scheme: t1789.split(Jf)[0],
        path: t1789.split(Jf)[1]
    };
}
function ed(t1790, e1351, o589) {
    return void 0 === o589 && (o589 = !1), n(this, void 0, void 0, function() {
        var n1016, a483, i362, s321, u259, c213, l173, h158, f138;
        return r(this, function(r817) {
            switch(r817.label){
                case 0:
                    return C(t1790 !== e1351, function() {
                        return "Old path and new path are the same: '" + t1790 + "'";
                    }), C((n1016 = Qf.getLoadHandlers(t1790)).length > 0, function() {
                        return "Copying failed because no load handler is found for source URL " + t1790 + ".";
                    }), C(n1016.length < 2, function() {
                        return "Copying failed because more than one (" + n1016.length + ") load handlers for source URL " + t1790 + ".";
                    }), a483 = n1016[0], C((i362 = Qf.getSaveHandlers(e1351)).length > 0, function() {
                        return "Copying failed because no save handler is found for destination URL " + e1351 + ".";
                    }), C(i362.length < 2, function() {
                        return "Copying failed because more than one (" + n1016.length + ") save handlers for destination URL " + e1351 + ".";
                    }), s321 = i362[0], u259 = td(t1790).scheme, c213 = td(t1790).path, l173 = u259 === td(t1790).scheme, [
                        4,
                        a483.load()
                    ];
                case 1:
                    return h158 = r817.sent(), o589 && l173 ? [
                        4,
                        Zf.getManager(u259).removeModel(c213)
                    ] : [
                        3,
                        3
                    ];
                case 2:
                    r817.sent(), r817.label = 3;
                case 3:
                    return [
                        4,
                        s321.save(h158)
                    ];
                case 4:
                    return f138 = r817.sent(), !o589 || l173 ? [
                        3,
                        6
                    ] : [
                        4,
                        Zf.getManager(u259).removeModel(c213)
                    ];
                case 5:
                    r817.sent(), r817.label = 6;
                case 6:
                    return [
                        2,
                        f138.modelArtifactsInfo
                    ];
            }
        });
    });
}
var nd = "models_store", rd = "model_info_store";
function od() {
    if (!i().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
    var t1791 = window || self, e1352 = t1791.indexedDB || t1791.mozIndexedDB || t1791.webkitIndexedDB || t1791.msIndexedDB || t1791.shimIndexedDB;
    if (null == e1352) throw new Error("The current browser does not appear to support IndexedDB.");
    return e1352;
}
function ad(t1792) {
    var e1353 = t1792.result;
    e1353.createObjectStore(nd, {
        keyPath: "modelPath"
    }), e1353.createObjectStore(rd, {
        keyPath: "modelPath"
    });
}
var id = function() {
    function t1793(t1794) {
        if (this.indexedDB = od(), null == t1794 || !t1794) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
        this.modelPath = t1794;
    }
    return t1793.prototype.save = function(t1795) {
        return n(this, void 0, void 0, function() {
            return r(this, function(e) {
                if (t1795.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
                return [
                    2,
                    this.databaseAction(this.modelPath, t1795)
                ];
            });
        });
    }, t1793.prototype.load = function() {
        return n(this, void 0, void 0, function() {
            return r(this, function(t) {
                return [
                    2,
                    this.databaseAction(this.modelPath)
                ];
            });
        });
    }, t1793.prototype.databaseAction = function(t1796, e1354) {
        var n1017 = this;
        return new Promise(function(t1797, r818) {
            var o590 = n1017.indexedDB.open("tensorflowjs", 1);
            o590.onupgradeneeded = function() {
                return ad(o590);
            }, o590.onsuccess = function() {
                var a484 = o590.result;
                if (null == e1354) {
                    var i363 = a484.transaction(nd, "readonly"), s322 = i363.objectStore(nd).get(n1017.modelPath);
                    s322.onsuccess = function() {
                        if (null == s322.result) return a484.close(), r818(new Error("Cannot find model with path '" + n1017.modelPath + "' in IndexedDB."));
                        t1797(s322.result.modelArtifacts);
                    }, s322.onerror = function(t) {
                        return a484.close(), r818(s322.error);
                    }, i363.oncomplete = function() {
                        return a484.close();
                    };
                } else {
                    var u260, c214 = $f(e1354), l174 = a484.transaction(rd, "readwrite"), h159 = l174.objectStore(rd), f139 = h159.put({
                        modelPath: n1017.modelPath,
                        modelArtifactsInfo: c214
                    });
                    f139.onsuccess = function() {
                        var o591 = (u260 = a484.transaction(nd, "readwrite")).objectStore(nd).put({
                            modelPath: n1017.modelPath,
                            modelArtifacts: e1354,
                            modelArtifactsInfo: c214
                        });
                        o591.onsuccess = function() {
                            return t1797({
                                modelArtifactsInfo: c214
                            });
                        }, o591.onerror = function(t) {
                            var e1355 = (h159 = l174.objectStore(rd)).delete(n1017.modelPath);
                            e1355.onsuccess = function() {
                                return a484.close(), r818(o591.error);
                            }, e1355.onerror = function(t) {
                                return a484.close(), r818(o591.error);
                            };
                        };
                    }, f139.onerror = function(t) {
                        return a484.close(), r818(f139.error);
                    }, l174.oncomplete = function() {
                        null == u260 ? a484.close() : u260.oncomplete = function() {
                            return a484.close();
                        };
                    };
                }
            }, o590.onerror = function(t) {
                return r818(o590.error);
            };
        });
    }, t1793.URL_SCHEME = "indexeddb://", t1793;
}(), sd = function(t1798) {
    var e1356;
    return i().getBool("IS_BROWSER") && !Array.isArray(t1798) && t1798.startsWith(id.URL_SCHEME) ? (e1356 = t1798.slice(id.URL_SCHEME.length), new id(e1356)) : null;
};
Qf.registerSaveRouter(sd), Qf.registerLoadRouter(sd);
var ud = function() {
    function t1799() {
        this.indexedDB = od();
    }
    return t1799.prototype.listModels = function() {
        return n(this, void 0, void 0, function() {
            var t1800 = this;
            return r(this, function(e1357) {
                return [
                    2,
                    new Promise(function(e1358, n1018) {
                        var r819 = t1800.indexedDB.open("tensorflowjs", 1);
                        r819.onupgradeneeded = function() {
                            return ad(r819);
                        }, r819.onsuccess = function() {
                            var t1801 = r819.result, o592 = t1801.transaction(rd, "readonly"), a485 = o592.objectStore(rd).getAll();
                            a485.onsuccess = function() {
                                for(var t1802 = {
                                }, n1019 = 0, r820 = a485.result; n1019 < r820.length; n1019++){
                                    var o593 = r820[n1019];
                                    t1802[o593.modelPath] = o593.modelArtifactsInfo;
                                }
                                e1358(t1802);
                            }, a485.onerror = function(e) {
                                return t1801.close(), n1018(a485.error);
                            }, o592.oncomplete = function() {
                                return t1801.close();
                            };
                        }, r819.onerror = function(t) {
                            return n1018(r819.error);
                        };
                    })
                ];
            });
        });
    }, t1799.prototype.removeModel = function(t1803) {
        return n(this, void 0, void 0, function() {
            var e1359 = this;
            return r(this, function(n1020) {
                var r821;
                return t1803 = (r821 = t1803).startsWith(id.URL_SCHEME) ? r821.slice(id.URL_SCHEME.length) : r821, [
                    2,
                    new Promise(function(n1021, r822) {
                        var o594 = e1359.indexedDB.open("tensorflowjs", 1);
                        o594.onupgradeneeded = function() {
                            return ad(o594);
                        }, o594.onsuccess = function() {
                            var e1360, a486 = o594.result, i364 = a486.transaction(rd, "readwrite"), s323 = i364.objectStore(rd), u261 = s323.get(t1803);
                            u261.onsuccess = function() {
                                if (null == u261.result) return a486.close(), r822(new Error("Cannot find model with path '" + t1803 + "' in IndexedDB."));
                                var o595 = s323.delete(t1803), i365 = function() {
                                    var o596 = (e1360 = a486.transaction(nd, "readwrite")).objectStore(nd).delete(t1803);
                                    o596.onsuccess = function() {
                                        return n1021(u261.result.modelArtifactsInfo);
                                    }, o596.onerror = function(t) {
                                        return r822(u261.error);
                                    };
                                };
                                o595.onsuccess = i365, o595.onerror = function(t) {
                                    return i365(), a486.close(), r822(u261.error);
                                };
                            }, u261.onerror = function(t) {
                                return a486.close(), r822(u261.error);
                            }, i364.oncomplete = function() {
                                null == e1360 ? a486.close() : e1360.oncomplete = function() {
                                    return a486.close();
                                };
                            };
                        }, o594.onerror = function(t) {
                            return r822(o594.error);
                        };
                    })
                ];
            });
        });
    }, t1799;
}();
if (i().getBool("IS_BROWSER")) try {
    Zf.registerManager(id.URL_SCHEME, new ud);
} catch (t1804) {
}
var cd = "/", ld = "tensorflowjs_models", hd = "info", fd = "model_topology", dd = "weight_specs", pd = "weight_data", vd = "model_metadata";
function gd(t1805) {
    return {
        info: [
            ld,
            t1805,
            hd
        ].join(cd),
        topology: [
            ld,
            t1805,
            fd
        ].join(cd),
        weightSpecs: [
            ld,
            t1805,
            dd
        ].join(cd),
        weightData: [
            ld,
            t1805,
            pd
        ].join(cd),
        modelMetadata: [
            ld,
            t1805,
            vd
        ].join(cd)
    };
}
function md(t1806) {
    var e1361 = t1806.split(cd);
    if (e1361.length < 3) throw new Error("Invalid key format: " + t1806);
    return e1361.slice(1, e1361.length - 1).join(cd);
}
var yd = function() {
    function t1807(t1808) {
        if (!i().getBool("IS_BROWSER") || "undefined" == typeof window || void 0 === window.localStorage) throw new Error("The current environment does not support local storage.");
        if (this.LS = window.localStorage, null == t1808 || !t1808) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
        this.modelPath = t1808, this.keys = gd(this.modelPath);
    }
    return t1807.prototype.save = function(t1809) {
        return n(this, void 0, void 0, function() {
            var e1362, n1022, o597;
            return r(this, function(r823) {
                if (t1809.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
                e1362 = JSON.stringify(t1809.modelTopology), n1022 = JSON.stringify(t1809.weightSpecs), o597 = $f(t1809);
                try {
                    return this.LS.setItem(this.keys.info, JSON.stringify(o597)), this.LS.setItem(this.keys.topology, e1362), this.LS.setItem(this.keys.weightSpecs, n1022), this.LS.setItem(this.keys.weightData, function(t1810) {
                        if (Kf) return Buffer.from(t1810).toString("base64");
                        for(var e1363 = new Uint8Array(t1810), n1023 = "", r824 = 0, o598 = e1363.length; r824 < o598; r824++)n1023 += String.fromCharCode(e1363[r824]);
                        return btoa(n1023);
                    }(t1809.weightData)), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({
                        format: t1809.format,
                        generatedBy: t1809.generatedBy,
                        convertedBy: t1809.convertedBy,
                        userDefinedMetadata: t1809.userDefinedMetadata
                    })), [
                        2,
                        {
                            modelArtifactsInfo: o597
                        }
                    ];
                } catch (t) {
                    throw this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error("Failed to save model '" + this.modelPath + "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" + o597.modelTopologyBytes + ", weightSpecsBytes=" + o597.weightSpecsBytes + ", weightDataBytes=" + o597.weightDataBytes + ".");
                }
                return [
                    2
                ];
            });
        });
    }, t1807.prototype.load = function() {
        return n(this, void 0, void 0, function() {
            var t1811, e1364, n1024, o599, a487, i366, s324;
            return r(this, function(r825) {
                if (null == (t1811 = JSON.parse(this.LS.getItem(this.keys.info)))) throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
                if ("JSON" !== t1811.modelTopologyType) throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
                if (e1364 = {
                }, null == (n1024 = JSON.parse(this.LS.getItem(this.keys.topology)))) throw new Error("In local storage, the topology of model '" + this.modelPath + "' is missing.");
                if (e1364.modelTopology = n1024, null == (o599 = JSON.parse(this.LS.getItem(this.keys.weightSpecs)))) throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' are missing.");
                if (e1364.weightSpecs = o599, null != (a487 = this.LS.getItem(this.keys.modelMetadata)) && (i366 = JSON.parse(a487), e1364.format = i366.format, e1364.generatedBy = i366.generatedBy, e1364.convertedBy = i366.convertedBy, e1364.userDefinedMetadata = i366.userDefinedMetadata), null == (s324 = this.LS.getItem(this.keys.weightData))) throw new Error("In local storage, the binary weight values of model '" + this.modelPath + "' are missing.");
                return e1364.weightData = (function(t1812) {
                    if (Kf) {
                        var e1365 = Buffer.from(t1812, "base64");
                        return e1365.buffer.slice(e1365.byteOffset, e1365.byteOffset + e1365.byteLength);
                    }
                    for(var n1025 = atob(t1812), r826 = new Uint8Array(n1025.length), o600 = 0; o600 < n1025.length; ++o600)r826.set([
                        n1025.charCodeAt(o600)
                    ], o600);
                    return r826.buffer;
                })(s324), [
                    2,
                    e1364
                ];
            });
        });
    }, t1807.URL_SCHEME = "localstorage://", t1807;
}(), xd = function(t1813) {
    var e1366;
    return i().getBool("IS_BROWSER") && !Array.isArray(t1813) && t1813.startsWith(yd.URL_SCHEME) ? (e1366 = t1813.slice(yd.URL_SCHEME.length), new yd(e1366)) : null;
};
Qf.registerSaveRouter(xd), Qf.registerLoadRouter(xd);
var bd = function() {
    function t1814() {
        C(i().getBool("IS_BROWSER"), function() {
            return "Current environment is not a web browser";
        }), C("undefined" == typeof window || void 0 !== window.localStorage, function() {
            return "Current browser does not appear to support localStorage";
        }), this.LS = window.localStorage;
    }
    return t1814.prototype.listModels = function() {
        return n(this, void 0, void 0, function() {
            var t1815, e1367, n1026, o601, a488, i367;
            return r(this, function(r) {
                for(t1815 = {
                }, e1367 = ld + cd, n1026 = cd + hd, o601 = 0; o601 < this.LS.length; ++o601)(a488 = this.LS.key(o601)).startsWith(e1367) && a488.endsWith(n1026) && (i367 = md(a488), t1815[i367] = JSON.parse(this.LS.getItem(a488)));
                return [
                    2,
                    t1815
                ];
            });
        });
    }, t1814.prototype.removeModel = function(t1816) {
        return n(this, void 0, void 0, function() {
            var e1368, n1027;
            return r(this, function(r) {
                var o602;
                if (t1816 = (o602 = t1816).startsWith(yd.URL_SCHEME) ? o602.slice(yd.URL_SCHEME.length) : o602, e1368 = gd(t1816), null == this.LS.getItem(e1368.info)) throw new Error("Cannot find model at path '" + t1816 + "'");
                return n1027 = JSON.parse(this.LS.getItem(e1368.info)), this.LS.removeItem(e1368.info), this.LS.removeItem(e1368.topology), this.LS.removeItem(e1368.weightSpecs), this.LS.removeItem(e1368.weightData), [
                    2,
                    n1027
                ];
            });
        });
    }, t1814;
}();
if (i().getBool("IS_BROWSER")) try {
    Zf.registerManager(yd.URL_SCHEME, new bd);
} catch (t1817) {
}
var wd = "model", Cd = ".json", Ed = ".weights.bin";
function Rd(t1818) {
    return new Promise(function(t1819) {
        return setTimeout(t1819);
    }).then(t1818);
}
var Id = function() {
    function t1820(e1369) {
        if (!i().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
        e1369.startsWith(t1820.URL_SCHEME) && (e1369 = e1369.slice(t1820.URL_SCHEME.length)), null != e1369 && 0 !== e1369.length || (e1369 = wd), this.modelTopologyFileName = e1369 + Cd, this.weightDataFileName = e1369 + Ed;
    }
    return t1820.prototype.save = function(t1821) {
        return n(this, void 0, void 0, function() {
            var e1370, n1028, o603, a489, i368, s325;
            return r(this, function(r827) {
                switch(r827.label){
                    case 0:
                        if ("undefined" == typeof document) throw new Error("Browser downloads are not supported in this environment since `document` is not present");
                        if (e1370 = window.URL.createObjectURL(new Blob([
                            t1821.weightData
                        ], {
                            type: "application/octet-stream"
                        })), !(t1821.modelTopology instanceof ArrayBuffer)) return [
                            3,
                            1
                        ];
                        throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
                    case 1:
                        return n1028 = [
                            {
                                paths: [
                                    "./" + this.weightDataFileName
                                ],
                                weights: t1821.weightSpecs
                            }
                        ], o603 = {
                            modelTopology: t1821.modelTopology,
                            format: t1821.format,
                            generatedBy: t1821.generatedBy,
                            convertedBy: t1821.convertedBy,
                            weightsManifest: n1028
                        }, a489 = window.URL.createObjectURL(new Blob([
                            JSON.stringify(o603)
                        ], {
                            type: "application/json"
                        })), (i368 = null == this.jsonAnchor ? document.createElement("a") : this.jsonAnchor).download = this.modelTopologyFileName, i368.href = a489, [
                            4,
                            Rd(function() {
                                return i368.dispatchEvent(new MouseEvent("click"));
                            })
                        ];
                    case 2:
                        return r827.sent(), null == t1821.weightData ? [
                            3,
                            4
                        ] : ((s325 = null == this.weightDataAnchor ? document.createElement("a") : this.weightDataAnchor).download = this.weightDataFileName, s325.href = e1370, [
                            4,
                            Rd(function() {
                                return s325.dispatchEvent(new MouseEvent("click"));
                            })
                        ]);
                    case 3:
                        r827.sent(), r827.label = 4;
                    case 4:
                        return [
                            2,
                            {
                                modelArtifactsInfo: $f(t1821)
                            }
                        ];
                }
            });
        });
    }, t1820.URL_SCHEME = "downloads://", t1820;
}(), kd = function() {
    function t1822(t1823) {
        if (null == t1823 || t1823.length < 1) throw new Error("When calling browserFiles, at least 1 file is required, but received " + t1823);
        this.files = t1823;
    }
    return t1822.prototype.load = function() {
        return n(this, void 0, void 0, function() {
            var t1824, e1371, n1029 = this;
            return r(this, function(r828) {
                return t1824 = this.files[0], e1371 = this.files.slice(1), [
                    2,
                    new Promise(function(r829, o604) {
                        var a490 = new FileReader;
                        a490.onload = function(a491) {
                            var i369 = JSON.parse(a491.target.result), s326 = i369.modelTopology;
                            if (null != s326) {
                                0 === e1371.length && r829({
                                    modelTopology: s326
                                });
                                var u262 = i369.weightsManifest;
                                if (null != u262) {
                                    var c215;
                                    try {
                                        c215 = n1029.checkManifestAndWeightFiles(u262, e1371);
                                    } catch (t1825) {
                                        return void o604(t1825);
                                    }
                                    var l175 = [], h160 = [], f140 = [];
                                    u262.forEach(function(t1826) {
                                        t1826.paths.forEach(function(t1827) {
                                            h160.push(t1827), f140.push(null);
                                        }), l175.push.apply(l175, t1826.weights);
                                    }), u262.forEach(function(t1828) {
                                        t1828.paths.forEach(function(t1829) {
                                            var e1372 = new FileReader;
                                            e1372.onload = function(e1373) {
                                                var n1030 = e1373.target.result, o = h160.indexOf(t1829);
                                                f140[o] = n1030, -1 === f140.indexOf(null) && r829({
                                                    modelTopology: s326,
                                                    weightSpecs: l175,
                                                    weightData: Xf(f140),
                                                    format: i369.format,
                                                    generatedBy: i369.generatedBy,
                                                    convertedBy: i369.convertedBy,
                                                    userDefinedMetadata: i369.userDefinedMetadata
                                                });
                                            }, e1372.onerror = function(e) {
                                                return o604("Failed to weights data from file of path '" + t1829 + "'.");
                                            }, e1372.readAsArrayBuffer(c215[t1829]);
                                        });
                                    });
                                } else o604(new Error("weightManifest field is missing from file " + t1824.name));
                            } else o604(new Error("modelTopology field is missing from file " + t1824.name));
                        }, a490.onerror = function(e) {
                            return o604("Failed to read model topology and weights manifest JSON from file '" + t1824.name + "'. BrowserFiles supports loading Keras-style tf.Model artifacts only.");
                        }, a490.readAsText(t1824);
                    })
                ];
            });
        });
    }, t1822.prototype.checkManifestAndWeightFiles = function(t1830, e1374) {
        for(var n1031 = [], r830 = e1374.map(function(t1831) {
            return Yf(t1831.name);
        }), o605 = {
        }, a492 = 0, i370 = t1830; a492 < i370.length; a492++)i370[a492].paths.forEach(function(t1832) {
            var a493 = Yf(t1832);
            if (-1 !== n1031.indexOf(a493)) throw new Error("Duplicate file basename found in weights manifest: '" + a493 + "'");
            if (n1031.push(a493), -1 === r830.indexOf(a493)) throw new Error("Weight file with basename '" + a493 + "' is not provided.");
            o605[t1832] = e1374[r830.indexOf(a493)];
        });
        if (n1031.length !== e1374.length) throw new Error("Mismatch in the number of files in weights manifest (" + n1031.length + ") and the number of weight files provided (" + e1374.length + ").");
        return o605;
    }, t1822;
}();
function Sd(t1833, e1375, n1032, r831) {
    !function(t1834) {
        C(null != t1834 && Array.isArray(t1834) && t1834.length > 0, function() {
            return "promises must be a none empty array";
        });
    }(t1833), (function(t1835, e1376) {
        C(t1835 >= 0 && t1835 <= 1, function() {
            return "Progress fraction must be in range [0, 1], but got startFraction " + t1835;
        }), C(e1376 >= 0 && e1376 <= 1, function() {
            return "Progress fraction must be in range [0, 1], but got endFraction " + e1376;
        }), C(e1376 >= t1835, function() {
            return "startFraction must be no more than endFraction, but got startFraction " + t1835 + " and endFraction " + e1376;
        });
    })(n1032 = null == n1032 ? 0 : n1032, r831 = null == r831 ? 1 : r831);
    var o606 = 0;
    return Promise.all(t1833.map(function(a494) {
        return a494.then(function(a495) {
            var i371 = n1032 + ++o606 / t1833.length * (r831 - n1032);
            return e1375(i371), a495;
        }), a494;
    }));
}
function Ad(t1836, e1377) {
    return n(this, void 0, void 0, function() {
        var n1033, o607, a496, s327, u263, c216, l176, h161, f141;
        return r(this, function(r832) {
            switch(r832.label){
                case 0:
                    return null == e1377 && (e1377 = {
                    }), n1033 = null == e1377.fetchFunc ? i().platform.fetch : e1377.fetchFunc, o607 = t1836.map(function(t1837) {
                        return n1033(t1837, e1377.requestInit, {
                            isBinary: !0
                        });
                    }), a496 = 0, s327 = 0.5, null != e1377.onProgress ? [
                        3,
                        2
                    ] : [
                        4,
                        Promise.all(o607)
                    ];
                case 1:
                    return u263 = r832.sent(), [
                        3,
                        4
                    ];
                case 2:
                    return [
                        4,
                        Sd(o607, e1377.onProgress, a496, s327)
                    ];
                case 3:
                    u263 = r832.sent(), r832.label = 4;
                case 4:
                    return c216 = u263.map(function(t1838) {
                        return t1838.arrayBuffer();
                    }), l176 = 0.5, h161 = 1, null != e1377.onProgress ? [
                        3,
                        6
                    ] : [
                        4,
                        Promise.all(c216)
                    ];
                case 5:
                    return f141 = r832.sent(), [
                        3,
                        8
                    ];
                case 6:
                    return [
                        4,
                        Sd(c216, e1377.onProgress, l176, h161)
                    ];
                case 7:
                    f141 = r832.sent(), r832.label = 8;
                case 8:
                    return [
                        2,
                        f141
                    ];
            }
        });
    });
}
function Td(t1839) {
    var e1378 = this;
    return function(o608, a497, i372) {
        return void 0 === a497 && (a497 = ""), n(e1378, void 0, void 0, function() {
            var e1379, n1034, s328, u264, c217, l177, h162, f142, d117, p99;
            return r(this, function(r833) {
                switch(r833.label){
                    case 0:
                        if (e1379 = o608.map(function() {
                            return !1;
                        }), n1034 = {
                        }, s328 = null != i372 ? i372.map(function() {
                            return !1;
                        }) : [], u264 = [], o608.forEach(function(t1840, r) {
                            var o609 = 0;
                            t1840.weights.forEach(function(t1841) {
                                var a = "quantization" in t1841 ? t1841.quantization.dtype : t1841.dtype, c218 = zf[a] * k(t1841.shape), l178 = function() {
                                    e1379[r] = !0, null == n1034[r] && (n1034[r] = []), n1034[r].push({
                                        manifestEntry: t1841,
                                        groupOffset: o609,
                                        sizeBytes: c218
                                    });
                                };
                                null != i372 ? i372.forEach(function(e1380, n) {
                                    e1380 === t1841.name && (l178(), s328[n] = !0);
                                }) : l178(), u264.push(t1841.name), o609 += c218;
                            });
                        }), !s328.every(function(t1842) {
                            return t1842;
                        })) throw c217 = i372.filter(function(t, e) {
                            return !s328[e];
                        }), new Error("Could not find weights in manifest with names: " + c217.join(", ") + ". \nManifest JSON has weights with names: " + u264.join(", ") + ".");
                        return l177 = e1379.reduce(function(t1843, e1381, n1035) {
                            return e1381 && t1843.push(n1035), t1843;
                        }, []), h162 = [], l177.forEach(function(t1844) {
                            o608[t1844].paths.forEach(function(t1845) {
                                var e1382 = a497 + (a497.endsWith("/") ? "" : "/") + t1845;
                                h162.push(e1382);
                            });
                        }), [
                            4,
                            t1839(h162)
                        ];
                    case 1:
                        return f142 = r833.sent(), d117 = {
                        }, p99 = 0, l177.forEach(function(t1846) {
                            for(var e1383 = o608[t1846].paths.length, r834 = 0, a498 = 0; a498 < e1383; a498++)r834 += f142[p99 + a498].byteLength;
                            for(var i373 = new ArrayBuffer(r834), s329 = new Uint8Array(i373), u265 = 0, c219 = 0; c219 < e1383; c219++){
                                var l179 = new Uint8Array(f142[p99 + c219]);
                                s329.set(l179, u265), u265 += l179.byteLength;
                            }
                            n1034[t1846].forEach(function(t1847) {
                                var e1384 = Hf(i373.slice(t1847.groupOffset, t1847.groupOffset + t1847.sizeBytes), [
                                    t1847.manifestEntry
                                ]);
                                for(var n in e1384)d117[n] = e1384[n];
                            }), p99 += e1383;
                        }), [
                            2,
                            d117
                        ];
                }
            });
        });
    };
}
Qf.registerSaveRouter(function(t1848) {
    return i().getBool("IS_BROWSER") && !Array.isArray(t1848) && t1848.startsWith(Id.URL_SCHEME) ? (function(t1849) {
        void 0 === t1849 && (t1849 = "model");
        return new Id(t1849);
    })(t1848.slice(Id.URL_SCHEME.length)) : null;
});
var Dd = function() {
    function t1850(t1851, e1385) {
        if (this.DEFAULT_METHOD = "POST", null == e1385 && (e1385 = {
        }), this.weightPathPrefix = e1385.weightPathPrefix, this.onProgress = e1385.onProgress, null != e1385.fetchFunc ? (C("function" == typeof e1385.fetchFunc, function() {
            return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)";
        }), this.fetch = e1385.fetchFunc) : this.fetch = i().platform.fetch, C(null != t1851 && t1851.length > 0, function() {
            return "URL path for http must not be null, undefined or empty.";
        }), Array.isArray(t1851) && C(2 === t1851.length, function() {
            return "URL paths for http must have a length of 2, (actual length is " + t1851.length + ").";
        }), this.path = t1851, null != e1385.requestInit && null != e1385.requestInit.body) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
        this.requestInit = e1385.requestInit || {
        };
    }
    return t1850.prototype.save = function(t1852) {
        return n(this, void 0, void 0, function() {
            var e1386, n1036, o610, a499;
            return r(this, function(r835) {
                switch(r835.label){
                    case 0:
                        if (t1852.modelTopology instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
                        return (e1386 = Object.assign({
                            method: this.DEFAULT_METHOD
                        }, this.requestInit)).body = new FormData, n1036 = [
                            {
                                paths: [
                                    "./model.weights.bin"
                                ],
                                weights: t1852.weightSpecs
                            }
                        ], o610 = {
                            modelTopology: t1852.modelTopology,
                            format: t1852.format,
                            generatedBy: t1852.generatedBy,
                            convertedBy: t1852.convertedBy,
                            userDefinedMetadata: t1852.userDefinedMetadata,
                            weightsManifest: n1036
                        }, e1386.body.append("model.json", new Blob([
                            JSON.stringify(o610)
                        ], {
                            type: "application/json"
                        }), "model.json"), null != t1852.weightData && e1386.body.append("model.weights.bin", new Blob([
                            t1852.weightData
                        ], {
                            type: "application/octet-stream"
                        }), "model.weights.bin"), [
                            4,
                            this.fetch(this.path, e1386)
                        ];
                    case 1:
                        if ((a499 = r835.sent()).ok) return [
                            2,
                            {
                                modelArtifactsInfo: $f(t1852),
                                responses: [
                                    a499
                                ]
                            }
                        ];
                        throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + a499.status + ".");
                }
            });
        });
    }, t1850.prototype.load = function() {
        return n(this, void 0, void 0, function() {
            var t1853, e1387, n1037, o611, a500, i374, s330, u266, c220, l180, h163, f143;
            return r(this, function(r836) {
                switch(r836.label){
                    case 0:
                        return [
                            4,
                            this.fetch(this.path, this.requestInit)
                        ];
                    case 1:
                        if (!(t1853 = r836.sent()).ok) throw new Error("Request to " + this.path + " failed with status code " + t1853.status + ". Please verify this URL points to the model JSON of the model to load.");
                        r836.label = 2;
                    case 2:
                        return r836.trys.push([
                            2,
                            4,
                            ,
                            5
                        ]), [
                            4,
                            t1853.json()
                        ];
                    case 3:
                        return e1387 = r836.sent(), [
                            3,
                            5
                        ];
                    case 4:
                        throw r836.sent(), n1037 = "Failed to parse model JSON of response from " + this.path + ".", this.path.endsWith(".pb") ? n1037 += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : n1037 += " Please make sure the server is serving valid JSON for this request.", new Error(n1037);
                    case 5:
                        if (o611 = e1387.modelTopology, a500 = e1387.weightsManifest, i374 = e1387.generatedBy, s330 = e1387.convertedBy, u266 = e1387.format, c220 = e1387.userDefinedMetadata, null == o611 && null == a500) throw new Error("The JSON from HTTP path " + this.path + " contains neither model topology or manifest for weights.");
                        return null == a500 ? [
                            3,
                            7
                        ] : [
                            4,
                            this.loadWeights(a500)
                        ];
                    case 6:
                        f143 = r836.sent(), l180 = f143[0], h163 = f143[1], r836.label = 7;
                    case 7:
                        return [
                            2,
                            {
                                modelTopology: o611,
                                weightSpecs: l180,
                                weightData: h163,
                                userDefinedMetadata: c220,
                                generatedBy: i374,
                                convertedBy: s330,
                                format: u266
                            }
                        ];
                }
            });
        });
    }, t1850.prototype.loadWeights = function(t1854) {
        return n(this, void 0, void 0, function() {
            var e1388, n1038, o612, a501, i375, s331, u267, c221, l181, h164, f144;
            return r(this, function(r837) {
                switch(r837.label){
                    case 0:
                        for(e1388 = Array.isArray(this.path) ? this.path[1] : this.path, n1038 = (function(t1855) {
                            var e1389 = t1855.lastIndexOf("/"), n1039 = t1855.lastIndexOf("?"), r838 = t1855.substring(0, e1389), o613 = n1039 > e1389 ? t1855.substring(n1039) : "";
                            return [
                                r838 + "/",
                                o613
                            ];
                        })(e1388), o612 = n1038[0], a501 = n1038[1], i375 = this.weightPathPrefix || o612, s331 = [], u267 = 0, c221 = t1854; u267 < c221.length; u267++)l181 = c221[u267], s331.push.apply(s331, l181.weights);
                        return h164 = [], t1854.forEach(function(t1856) {
                            t1856.paths.forEach(function(t1857) {
                                h164.push(i375 + t1857 + a501);
                            });
                        }), [
                            4,
                            Ad(h164, {
                                requestInit: this.requestInit,
                                fetchFunc: this.fetch,
                                onProgress: this.onProgress
                            })
                        ];
                    case 1:
                        return f144 = r837.sent(), [
                            2,
                            [
                                s331,
                                Xf(f144)
                            ]
                        ];
                }
            });
        });
    }, t1850.URL_SCHEME_REGEX = /^https?:\/\//, t1850;
}();
function Nd(t1858) {
    return null != t1858.match(Dd.URL_SCHEME_REGEX);
}
var Fd = function(t1859, e1390) {
    if ("undefined" == typeof fetch) return null;
    return (Array.isArray(t1859) ? t1859.every(function(t1860) {
        return Nd(t1860);
    }) : Nd(t1859)) ? _d(t1859, {
        onProgress: e1390
    }) : null;
};
function _d(t1861, e1391) {
    return new Dd(t1861, e1391);
}
Qf.registerSaveRouter(Fd), Qf.registerLoadRouter(Fd);
var Od = function() {
    function t1862(t1863) {
        this.modelArtifacts = t1863;
    }
    return t1862.prototype.load = function() {
        return n(this, void 0, void 0, function() {
            return r(this, function(t) {
                return [
                    2,
                    this.modelArtifacts
                ];
            });
        });
    }, t1862;
}(), Md = function() {
    function t1864(t1865) {
        this.saveHandler = t1865;
    }
    return t1864.prototype.save = function(t1866) {
        return n(this, void 0, void 0, function() {
            return r(this, function(e) {
                return [
                    2,
                    this.saveHandler(t1866)
                ];
            });
        });
    }, t1864;
}();
var Bd = Object.freeze({
    browserFiles: function(t1867) {
        return new kd(t1867);
    },
    browserHTTPRequest: function(t1868, e1392) {
        return _d(t1868, e1392);
    },
    concatenateArrayBuffers: Xf,
    decodeWeights: Hf,
    encodeWeights: function(t1869, e1393) {
        return n(this, void 0, void 0, function() {
            var o614, a502, i376, s332, u268, c222 = this;
            return r(this, function(l182) {
                switch(l182.label){
                    case 0:
                        for(o614 = [], a502 = [], i376 = Array.isArray(t1869) ? t1869.map(function(t1870) {
                            return t1870.name;
                        }) : Object.keys(t1869), s332 = function(s333) {
                            var u269 = i376[s333], l183 = Array.isArray(t1869) ? t1869[s333].tensor : t1869[u269];
                            if ("float32" !== l183.dtype && "int32" !== l183.dtype && "bool" !== l183.dtype && "string" !== l183.dtype) throw new Error("Unsupported dtype in weight '" + u269 + "': " + l183.dtype);
                            var h165 = {
                                name: u269,
                                shape: l183.shape,
                                dtype: l183.dtype
                            };
                            if ("string" === l183.dtype) {
                                var f145 = new Promise(function(t1871) {
                                    return n(c222, void 0, void 0, function() {
                                        var e1394, n1040, o615, a503, i377, s334, u270;
                                        return r(this, function(r839) {
                                            switch(r839.label){
                                                case 0:
                                                    return [
                                                        4,
                                                        l183.bytes()
                                                    ];
                                                case 1:
                                                    for(e1394 = r839.sent(), n1040 = e1394.reduce(function(t1872, e1395) {
                                                        return t1872 + e1395.length;
                                                    }, 0) + Gf * e1394.length, o615 = new Uint8Array(n1040), a503 = 0, i377 = 0; i377 < e1394.length; i377++)s334 = e1394[i377], u270 = new Uint8Array(new Uint32Array([
                                                        s334.length
                                                    ]).buffer), o615.set(u270, a503), a503 += Gf, o615.set(s334, a503), a503 += s334.length;
                                                    return t1871(o615), [
                                                        2
                                                    ];
                                            }
                                        });
                                    });
                                });
                                a502.push(f145);
                            } else a502.push(l183.data());
                            null != e1393 && (h165.group = e1393), o614.push(h165);
                        }, u268 = 0; u268 < i376.length; ++u268)s332(u268);
                        return [
                            4,
                            Promise.all(a502)
                        ];
                    case 1:
                        return [
                            2,
                            {
                                data: qf(l182.sent()),
                                specs: o614
                            }
                        ];
                }
            });
        });
    },
    fromMemory: function(t1873, e1396, n1041, r840) {
        return 1 === arguments.length ? null != t1873.modelTopology || null != t1873.weightSpecs ? new Od(t1873) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Od({
            modelTopology: t1873
        })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Od({
            modelTopology: t1873,
            weightSpecs: e1396,
            weightData: n1041,
            trainingConfig: r840
        }));
    },
    getLoadHandlers: function(t1874, e1397) {
        return Qf.getLoadHandlers(t1874, e1397);
    },
    getModelArtifactsInfoForJSON: $f,
    getSaveHandlers: function(t1875) {
        return Qf.getSaveHandlers(t1875);
    },
    http: _d,
    isHTTPScheme: Nd,
    loadWeights: function(t1876, e1398, o616, a504) {
        return void 0 === e1398 && (e1398 = ""), n(this, void 0, void 0, function() {
            return r(this, function(n) {
                return [
                    2,
                    Td(function(t1877) {
                        return Ad(t1877, {
                            requestInit: a504
                        });
                    })(t1876, e1398, o616)
                ];
            });
        });
    },
    registerLoadRouter: function(t1878) {
        return Qf.registerLoadRouter(t1878);
    },
    registerSaveRouter: function(t1879) {
        return Qf.registerSaveRouter(t1879);
    },
    weightsLoaderFactory: Td,
    withSaveHandler: function(t1880) {
        return new Md(t1880);
    },
    copyModel: function(t1881, e1399) {
        return n(this, void 0, void 0, function() {
            return r(this, function(n) {
                return [
                    2,
                    ed(t1881, e1399, !1)
                ];
            });
        });
    },
    listModels: function() {
        return n(this, void 0, void 0, function() {
            var t1882, e1400, n1042, o617, a505, i378, s335;
            return r(this, function(r841) {
                switch(r841.label){
                    case 0:
                        t1882 = Zf.getSchemes(), e1400 = {
                        }, n1042 = 0, o617 = t1882, r841.label = 1;
                    case 1:
                        return n1042 < o617.length ? (a505 = o617[n1042], [
                            4,
                            Zf.getManager(a505).listModels()
                        ]) : [
                            3,
                            4
                        ];
                    case 2:
                        for(s335 in i378 = r841.sent())e1400[a505 + Jf + s335] = i378[s335];
                        r841.label = 3;
                    case 3:
                        return n1042++, [
                            3,
                            1
                        ];
                    case 4:
                        return [
                            2,
                            e1400
                        ];
                }
            });
        });
    },
    moveModel: function(t1883, e1401) {
        return n(this, void 0, void 0, function() {
            return r(this, function(n) {
                return [
                    2,
                    ed(t1883, e1401, !0)
                ];
            });
        });
    },
    removeModel: function(t1884) {
        return n(this, void 0, void 0, function() {
            var e1402;
            return r(this, function(n) {
                return e1402 = td(t1884), [
                    2,
                    Zf.getManager(e1402.scheme).removeModel(e1402.path)
                ];
            });
        });
    }
});
var Pd, Ld = An({
    confusionMatrix_: function(t1885, e1403, n1043) {
        var r842 = gn(t1885, "labels", "confusionMatrix"), o618 = gn(e1403, "predictions", "confusionMatrix");
        C(null == n1043 || n1043 > 0 && Number.isInteger(n1043), function() {
            return "If provided, numClasses must be a positive integer, but got " + n1043;
        }), C(1 === r842.rank, function() {
            return "Expected the rank of labels to be 1, but got " + r842.rank;
        }), C(1 === o618.rank, function() {
            return "Expected the rank of predictions to be 1, but got " + o618.rank;
        }), C(r842.shape[0] === o618.shape[0], function() {
            return "Mismatch in the number of examples: " + r842.shape[0] + " vs. " + o618.shape[0] + ". Labels and predictions should have the same number of elements.";
        }), C(n1043 > 0 && Number.isInteger(n1043), function() {
            return "numClasses is required to be a positive integer, but got " + n1043;
        });
        var a506 = Rc(r842.asType("int32"), n1043), i379 = Rc(o618.asType("int32"), n1043);
        return a506.transpose().matMul(i379).asType("int32");
    }
}), Wd = Object.freeze({
    confusionMatrix: Ld
});
var Ud = An({
    fromPixels_: function(t1886, e1404) {
        if (void 0 === e1404 && (e1404 = 3), e1404 > 4) throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
        if (null == t1886) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
        var n1044 = !1, r843 = !1, o619 = !1, a507 = !1, i380 = !1;
        if (t1886.data instanceof Uint8Array) n1044 = !0;
        else if ("undefined" != typeof ImageData && t1886 instanceof ImageData) r843 = !0;
        else if ("undefined" != typeof HTMLVideoElement && t1886 instanceof HTMLVideoElement) o619 = !0;
        else if ("undefined" != typeof HTMLImageElement && t1886 instanceof HTMLImageElement) a507 = !0;
        else {
            if (null == t1886.getContext) throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " + t1886.constructor.name);
            i380 = !0;
        }
        if (o619) {
            if (o619 && t1886.readyState < 2) throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
        }
        if (null != l("FromPixels", Lt.backendName)) return Lt.runKernel("FromPixels", {
            pixels: t1886
        }, {
            numChannels: e1404
        });
        var s336, u271, c223 = o619 ? [
            t1886.videoWidth,
            t1886.videoHeight
        ] : [
            t1886.width,
            t1886.height
        ], h166 = c223[0], f146 = c223[1];
        if (i380 ? s336 = t1886.getContext("2d").getImageData(0, 0, h166, f146).data : r843 || n1044 ? s336 = t1886.data : (a507 || o619) && (null == Pd && (Pd = document.createElement("canvas").getContext("2d")), Pd.canvas.width = h166, Pd.canvas.height = f146, Pd.drawImage(t1886, 0, 0, h166, f146), s336 = Pd.getImageData(0, 0, h166, f146).data), 4 === e1404) u271 = new Int32Array(s336);
        else {
            var d118 = h166 * f146;
            u271 = new Int32Array(d118 * e1404);
            for(var p100 = 0; p100 < d118; p100++)for(var v89 = 0; v89 < e1404; ++v89)u271[p100 * e1404 + v89] = s336[4 * p100 + v89];
        }
        return Pn(u271, [
            f146,
            h166,
            e1404
        ], "int32");
    }
}), Vd = Object.freeze({
    toPixels: function(t1887, e1405) {
        return n(this, void 0, void 0, function() {
            var n1045, o620, a508, i381, s337, u272, c224, l184, h167, f147, d119, p101, v90, g80, m65, y56, x52, b46, w40, C29, E, R34, I29;
            return r(this, function(r844) {
                switch(r844.label){
                    case 0:
                        if (n1045 = gn(t1887, "img", "toPixels"), t1887 instanceof wt || (n1045 = n1045.toInt()), 2 !== n1045.rank && 3 !== n1045.rank) throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + n1045.rank + ".");
                        if (o620 = n1045.shape.slice(0, 2), a508 = o620[0], i381 = o620[1], (s337 = 2 === n1045.rank ? 1 : n1045.shape[2]) > 4 || 2 === s337) throw new Error("toPixels only supports depth of size 1, 3 or 4 but got " + s337);
                        return [
                            4,
                            n1045.data()
                        ];
                    case 1:
                        return u272 = r844.sent(), c224 = n1045.min(), l184 = n1045.max(), [
                            4,
                            Promise.all([
                                c224.data(),
                                l184.data()
                            ])
                        ];
                    case 2:
                        if (h167 = r844.sent(), f147 = h167[0], d119 = h167[1], p101 = f147[0], v90 = d119[0], c224.dispose(), l184.dispose(), "float32" === n1045.dtype) {
                            if (p101 < 0 || v90 > 1) throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [" + p101 + " - " + v90 + "].");
                        } else {
                            if ("int32" !== n1045.dtype) throw new Error("Unsupported type for toPixels: " + n1045.dtype + ". Please use float32 or int32 tensors.");
                            if (p101 < 0 || v90 > 255) throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [" + p101 + " - " + v90 + "].");
                        }
                        for(g80 = "float32" === n1045.dtype ? 255 : 1, m65 = new Uint8ClampedArray(i381 * a508 * 4), y56 = 0; y56 < a508 * i381; ++y56)x52 = void 0, b46 = void 0, w40 = void 0, C29 = void 0, 1 === s337 ? (x52 = u272[y56] * g80, b46 = u272[y56] * g80, w40 = u272[y56] * g80, C29 = 255) : 3 === s337 ? (x52 = u272[3 * y56] * g80, b46 = u272[3 * y56 + 1] * g80, w40 = u272[3 * y56 + 2] * g80, C29 = 255) : 4 === s337 && (x52 = u272[4 * y56] * g80, b46 = u272[4 * y56 + 1] * g80, w40 = u272[4 * y56 + 2] * g80, C29 = u272[4 * y56 + 3] * g80), m65[(E = 4 * y56) + 0] = Math.round(x52), m65[E + 1] = Math.round(b46), m65[E + 2] = Math.round(w40), m65[E + 3] = Math.round(C29);
                        return null != e1405 && (e1405.width = i381, e1405.height = a508, R34 = e1405.getContext("2d"), I29 = new ImageData(m65, i381, a508), R34.putImageData(I29, 0, 0)), n1045 !== t1887 && n1045.dispose(), [
                            2,
                            m65
                        ];
                }
            });
        });
    },
    fromPixels: Ud
}), zd = function() {
    function t1888() {
    }
    return t1888.prototype.getClassName = function() {
        return this.constructor.className;
    }, t1888.fromConfig = function(t1889, e1406) {
        return new t1889(e1406);
    }, t1888;
}(), Gd = function() {
    function t1890() {
        this.classNameMap = {
        };
    }
    return t1890.getMap = function() {
        return null == t1890.instance && (t1890.instance = new t1890), t1890.instance;
    }, t1890.register = function(e1407) {
        t1890.getMap().classNameMap[e1407.className] = [
            e1407,
            e1407.fromConfig
        ];
    }, t1890;
}();
function Hd(t1891) {
    C(null != t1891.className, function() {
        return "Class being registered does not have the static className property defined.";
    }), C("string" == typeof t1891.className, function() {
        return "className is required to be a string, but got type " + typeof t1891.className;
    }), C(t1891.className.length > 0, function() {
        return "Class being registered has an empty-string as its className, which is disallowed.";
    }), Gd.register(t1891);
}
var qd = Object.freeze({
    Serializable: zd,
    SerializationMap: Gd,
    registerClass: Hd
}), Kd = "1.7.4";
var jd = Object.freeze({
    gpgpu_util: Rs,
    webgl_util: Ge,
    forceHalfFloat: function() {
        i().set("WEBGL_FORCE_F16_TEXTURES", !0);
    },
    MathBackendWebGL: Uu,
    setWebGLContext: Kt,
    GPGPUContext: Is
}), Xd = function(t1892) {
    function o621() {
        return null !== t1892 && t1892.apply(this, arguments) || this;
    }
    return e(o621, t1892), o621.prototype.minimize = function(t1893, e1408, n1046) {
        void 0 === e1408 && (e1408 = !1);
        var r845 = this.computeGradients(t1893, n1046), o622 = r845.value, a509 = r845.grads;
        if (null != n1046) {
            var i382 = n1046.map(function(t1894) {
                return {
                    name: t1894.name,
                    tensor: a509[t1894.name]
                };
            });
            this.applyGradients(i382);
        } else this.applyGradients(a509);
        return tn(a509), e1408 ? o622 : (o622.dispose(), null);
    }, Object.defineProperty(o621.prototype, "iterations", {
        get: function() {
            return null == this.iterations_ && (this.iterations_ = 0), this.iterations_;
        },
        enumerable: !0,
        configurable: !0
    }), o621.prototype.incrementIterations = function() {
        this.iterations_ = this.iterations + 1;
    }, o621.prototype.computeGradients = function(t1895, e1409) {
        return ra(t1895, e1409);
    }, o621.prototype.dispose = function() {
        null != this.iterations_ && tn(this.iterations_);
    }, o621.prototype.saveIterations = function() {
        return n(this, void 0, void 0, function() {
            return r(this, function(t) {
                return null == this.iterations_ && (this.iterations_ = 0), [
                    2,
                    {
                        name: "iter",
                        tensor: On(this.iterations_, "int32")
                    }
                ];
            });
        });
    }, o621.prototype.getWeights = function() {
        return n(this, void 0, void 0, function() {
            return r(this, function(t) {
                throw new Error("getWeights() is not implemented for this optimizer yet.");
            });
        });
    }, o621.prototype.setWeights = function(t) {
        return n(this, void 0, void 0, function() {
            return r(this, function(t) {
                throw new Error("setWeights() is not implemented for this optimizer class " + this.getClassName());
            });
        });
    }, o621.prototype.extractIterations = function(t1896) {
        return n(this, void 0, void 0, function() {
            var e1410;
            return r(this, function(n1047) {
                switch(n1047.label){
                    case 0:
                        return e1410 = this, [
                            4,
                            t1896[0].tensor.data()
                        ];
                    case 1:
                        return e1410.iterations_ = n1047.sent()[0], [
                            2,
                            t1896.slice(1)
                        ];
                }
            });
        });
    }, o621;
}(zd);
Object.defineProperty(Xd, Symbol.hasInstance, {
    value: function(t1897) {
        return null != t1897.minimize && null != t1897.computeGradients && null != t1897.applyGradients;
    }
});
var Yd = function(t1898) {
    function o623(e1411, n1048, r846) {
        void 0 === r846 && (r846 = null);
        var o624 = t1898.call(this) || this;
        return o624.learningRate = e1411, o624.rho = n1048, o624.epsilon = r846, o624.accumulatedGrads = [], o624.accumulatedUpdates = [], null == r846 && (o624.epsilon = Lt.backend.epsilon()), o624;
    }
    return e(o623, t1898), o623.prototype.applyGradients = function(t1899) {
        var e1412 = this;
        (Array.isArray(t1899) ? t1899.map(function(t1900) {
            return t1900.name;
        }) : Object.keys(t1899)).forEach(function(n1049, r847) {
            var o625 = Lt.registeredVariables[n1049];
            null == e1412.accumulatedGrads[r847] && (e1412.accumulatedGrads[r847] = {
                originalName: n1049 + "/accum_grad",
                variable: Ze(function() {
                    return Xn(o625).variable(!1);
                })
            }), null == e1412.accumulatedUpdates[r847] && (e1412.accumulatedUpdates[r847] = {
                originalName: n1049 + "/accum_var",
                variable: Ze(function() {
                    return Xn(o625).variable(!1);
                })
            });
            var a510 = Array.isArray(t1899) ? t1899[r847].tensor : t1899[n1049];
            if (null != a510) {
                var i383 = e1412.accumulatedGrads[r847].variable, s338 = e1412.accumulatedUpdates[r847].variable;
                Ze(function() {
                    var t1901 = i383.mul(e1412.rho).add(a510.square().mul(1 - e1412.rho)), n1050 = s338.add(e1412.epsilon).sqrt().div(i383.add(e1412.epsilon).sqrt()).mul(a510), r848 = s338.mul(e1412.rho).add(n1050.square().mul(1 - e1412.rho));
                    i383.assign(t1901), s338.assign(r848);
                    var u273 = n1050.mul(-e1412.learningRate).add(o625);
                    o625.assign(u273);
                });
            }
        }), this.incrementIterations();
    }, o623.prototype.dispose = function() {
        null != this.accumulatedUpdates && (tn(this.accumulatedGrads.map(function(t1902) {
            return t1902.variable;
        })), tn(this.accumulatedUpdates.map(function(t1903) {
            return t1903.variable;
        })));
    }, o623.prototype.getWeights = function() {
        return n(this, void 0, void 0, function() {
            var t1904;
            return r(this, function(e1413) {
                switch(e1413.label){
                    case 0:
                        return t1904 = this.accumulatedGrads.concat(this.accumulatedUpdates), [
                            4,
                            this.saveIterations()
                        ];
                    case 1:
                        return [
                            2,
                            [
                                e1413.sent()
                            ].concat(t1904.map(function(t1905) {
                                return {
                                    name: t1905.originalName,
                                    tensor: t1905.variable
                                };
                            }))
                        ];
                }
            });
        });
    }, o623.prototype.setWeights = function(t1906) {
        return n(this, void 0, void 0, function() {
            var e1414;
            return r(this, function(n1051) {
                switch(n1051.label){
                    case 0:
                        return [
                            4,
                            this.extractIterations(t1906)
                        ];
                    case 1:
                        return t1906 = n1051.sent(), e1414 = t1906.length / 2, this.accumulatedGrads = t1906.slice(0, e1414).map(function(t1907) {
                            return {
                                originalName: t1907.name,
                                variable: t1907.tensor.variable(!1)
                            };
                        }), this.accumulatedUpdates = t1906.slice(e1414, 2 * e1414).map(function(t1908) {
                            return {
                                originalName: t1908.name,
                                variable: t1908.tensor.variable(!1)
                            };
                        }), [
                            2
                        ];
                }
            });
        });
    }, o623.prototype.getConfig = function() {
        return {
            learningRate: this.learningRate,
            rho: this.rho,
            epsilon: this.epsilon
        };
    }, o623.fromConfig = function(t1909, e1415) {
        return new t1909(e1415.learningRate, e1415.rho, e1415.epsilon);
    }, o623.className = "Adadelta", o623;
}(Xd);
Hd(Yd);
var $d = function(t1910) {
    function o626(e1416, n1052) {
        void 0 === n1052 && (n1052 = 0.1);
        var r849 = t1910.call(this) || this;
        return r849.learningRate = e1416, r849.initialAccumulatorValue = n1052, r849.accumulatedGrads = [], r849;
    }
    return e(o626, t1910), o626.prototype.applyGradients = function(t1911) {
        var e1417 = this;
        (Array.isArray(t1911) ? t1911.map(function(t1912) {
            return t1912.name;
        }) : Object.keys(t1911)).forEach(function(n1053, r) {
            var o627 = Lt.registeredVariables[n1053];
            if (null == e1417.accumulatedGrads[r]) e1417.accumulatedGrads[r] = {
                originalName: n1053 + "/accumulator",
                variable: Ze(function() {
                    return Hn(o627.shape, e1417.initialAccumulatorValue).variable(!1);
                })
            };
            var a511 = Array.isArray(t1911) ? t1911[r].tensor : t1911[n1053];
            if (null != a511) {
                var i384 = e1417.accumulatedGrads[r].variable;
                Ze(function() {
                    var t1913 = i384.add(a511.square());
                    i384.assign(t1913);
                    var n1054 = a511.div(t1913.add(Lt.backend.epsilon()).sqrt()).mul(-e1417.learningRate).add(o627);
                    o627.assign(n1054);
                });
            }
        }), this.incrementIterations();
    }, o626.prototype.dispose = function() {
        null != this.accumulatedGrads && tn(this.accumulatedGrads.map(function(t1914) {
            return t1914.variable;
        }));
    }, o626.prototype.getWeights = function() {
        return n(this, void 0, void 0, function() {
            return r(this, function(t1915) {
                switch(t1915.label){
                    case 0:
                        return [
                            4,
                            this.saveIterations()
                        ];
                    case 1:
                        return [
                            2,
                            [
                                t1915.sent()
                            ].concat(this.accumulatedGrads.map(function(t1916) {
                                return {
                                    name: t1916.originalName,
                                    tensor: t1916.variable
                                };
                            }))
                        ];
                }
            });
        });
    }, o626.prototype.setWeights = function(t1917) {
        return n(this, void 0, void 0, function() {
            return r(this, function(e1418) {
                switch(e1418.label){
                    case 0:
                        return [
                            4,
                            this.extractIterations(t1917)
                        ];
                    case 1:
                        return t1917 = e1418.sent(), this.accumulatedGrads = t1917.map(function(t1918) {
                            return {
                                originalName: t1918.name,
                                variable: t1918.tensor.variable(!1)
                            };
                        }), [
                            2
                        ];
                }
            });
        });
    }, o626.prototype.getConfig = function() {
        return {
            learningRate: this.learningRate,
            initialAccumulatorValue: this.initialAccumulatorValue
        };
    }, o626.fromConfig = function(t1919, e1419) {
        return new t1919(e1419.learningRate, e1419.initialAccumulatorValue);
    }, o626.className = "Adagrad", o626;
}(Xd);
Hd($d);
var Qd = function(t1920) {
    function o628(e1420, n1055, r850, o629) {
        void 0 === o629 && (o629 = null);
        var a512 = t1920.call(this) || this;
        return a512.learningRate = e1420, a512.beta1 = n1055, a512.beta2 = r850, a512.epsilon = o629, a512.accumulatedFirstMoment = [], a512.accumulatedSecondMoment = [], Ze(function() {
            a512.accBeta1 = On(n1055).variable(), a512.accBeta2 = On(r850).variable();
        }), null == o629 && (a512.epsilon = Lt.backend.epsilon()), a512;
    }
    return e(o628, t1920), o628.prototype.applyGradients = function(t1921) {
        var e1421 = this, n1056 = Array.isArray(t1921) ? t1921.map(function(t1922) {
            return t1922.name;
        }) : Object.keys(t1921);
        Ze(function() {
            var r851 = Oo(1, e1421.accBeta1), o630 = Oo(1, e1421.accBeta2);
            n1056.forEach(function(n1057, a) {
                var i385 = Lt.registeredVariables[n1057];
                null == e1421.accumulatedFirstMoment[a] && (e1421.accumulatedFirstMoment[a] = {
                    originalName: n1057 + "/m",
                    variable: Ze(function() {
                        return Xn(i385).variable(!1);
                    })
                }), null == e1421.accumulatedSecondMoment[a] && (e1421.accumulatedSecondMoment[a] = {
                    originalName: n1057 + "/v",
                    variable: Ze(function() {
                        return Xn(i385).variable(!1);
                    })
                });
                var s339 = Array.isArray(t1921) ? t1921[a].tensor : t1921[n1057];
                if (null != s339) {
                    var u274 = e1421.accumulatedFirstMoment[a].variable, c225 = e1421.accumulatedSecondMoment[a].variable, l185 = u274.mul(e1421.beta1).add(s339.mul(1 - e1421.beta1)), h168 = c225.mul(e1421.beta2).add(s339.square().mul(1 - e1421.beta2)), f148 = l185.div(r851), d120 = h168.div(o630);
                    u274.assign(l185), c225.assign(h168);
                    var p102 = f148.div(d120.sqrt().add(e1421.epsilon)).mul(-e1421.learningRate).add(i385);
                    i385.assign(p102);
                }
            }), e1421.accBeta1.assign(e1421.accBeta1.mul(e1421.beta1)), e1421.accBeta2.assign(e1421.accBeta2.mul(e1421.beta2));
        }), this.incrementIterations();
    }, o628.prototype.dispose = function() {
        this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && tn(this.accumulatedFirstMoment.map(function(t1923) {
            return t1923.variable;
        })), null != this.accumulatedSecondMoment && tn(this.accumulatedSecondMoment.map(function(t1924) {
            return t1924.variable;
        }));
    }, o628.prototype.getWeights = function() {
        return n(this, void 0, void 0, function() {
            var t1925;
            return r(this, function(e1422) {
                switch(e1422.label){
                    case 0:
                        return t1925 = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment), [
                            4,
                            this.saveIterations()
                        ];
                    case 1:
                        return [
                            2,
                            [
                                e1422.sent()
                            ].concat(t1925.map(function(t1926) {
                                return {
                                    name: t1926.originalName,
                                    tensor: t1926.variable
                                };
                            }))
                        ];
                }
            });
        });
    }, o628.prototype.setWeights = function(t1927) {
        return n(this, void 0, void 0, function() {
            var e1423, n1058 = this;
            return r(this, function(r852) {
                switch(r852.label){
                    case 0:
                        return [
                            4,
                            this.extractIterations(t1927)
                        ];
                    case 1:
                        return t1927 = r852.sent(), Ze(function() {
                            n1058.accBeta1.assign(No(n1058.beta1, n1058.iterations_ + 1)), n1058.accBeta2.assign(No(n1058.beta2, n1058.iterations_ + 1));
                        }), e1423 = t1927.length / 2, this.accumulatedFirstMoment = t1927.slice(0, e1423).map(function(t1928) {
                            return {
                                originalName: t1928.name,
                                variable: t1928.tensor.variable(!1)
                            };
                        }), this.accumulatedSecondMoment = t1927.slice(e1423, 2 * e1423).map(function(t1929) {
                            return {
                                originalName: t1929.name,
                                variable: t1929.tensor.variable(!1)
                            };
                        }), [
                            2
                        ];
                }
            });
        });
    }, o628.prototype.getConfig = function() {
        return {
            learningRate: this.learningRate,
            beta1: this.beta1,
            beta2: this.beta2,
            epsilon: this.epsilon
        };
    }, o628.fromConfig = function(t1930, e1424) {
        return new t1930(e1424.learningRate, e1424.beta1, e1424.beta2, e1424.epsilon);
    }, o628.className = "Adam", o628;
}(Xd);
Hd(Qd);
var Jd = function(t1931) {
    function o631(e1425, n1059, r853, o632, a513) {
        void 0 === o632 && (o632 = null), void 0 === a513 && (a513 = 0);
        var i386 = t1931.call(this) || this;
        return i386.learningRate = e1425, i386.beta1 = n1059, i386.beta2 = r853, i386.epsilon = o632, i386.decay = a513, i386.accumulatedFirstMoment = [], i386.accumulatedWeightedInfNorm = [], Ze(function() {
            i386.iteration = On(0).variable(), i386.accBeta1 = On(n1059).variable();
        }), null == o632 && (i386.epsilon = Lt.backend.epsilon()), i386;
    }
    return e(o631, t1931), o631.prototype.applyGradients = function(t1932) {
        var e1426 = this, n1060 = Array.isArray(t1932) ? t1932.map(function(t1933) {
            return t1933.name;
        }) : Object.keys(t1932);
        Ze(function() {
            var r854 = Oo(1, e1426.accBeta1), o633 = Bo(-e1426.learningRate, e1426.iteration.mul(e1426.decay).add(1));
            n1060.forEach(function(n1061, a) {
                var i387 = Lt.registeredVariables[n1061];
                null == e1426.accumulatedFirstMoment[a] && (e1426.accumulatedFirstMoment[a] = {
                    originalName: n1061 + "/m",
                    variable: Xn(i387).variable(!1)
                }), null == e1426.accumulatedWeightedInfNorm[a] && (e1426.accumulatedWeightedInfNorm[a] = {
                    originalName: n1061 + "/v",
                    variable: Xn(i387).variable(!1)
                });
                var s340 = Array.isArray(t1932) ? t1932[a].tensor : t1932[n1061];
                if (null != s340) {
                    var u275 = e1426.accumulatedFirstMoment[a].variable, c226 = e1426.accumulatedWeightedInfNorm[a].variable, l186 = u275.mul(e1426.beta1).add(s340.mul(1 - e1426.beta1)), h169 = c226.mul(e1426.beta2), f149 = s340.abs(), d121 = h169.maximum(f149);
                    u275.assign(l186), c226.assign(d121);
                    var p103 = o633.div(r854).mul(l186.div(d121.add(e1426.epsilon))).add(i387);
                    i387.assign(p103);
                }
            }), e1426.iteration.assign(e1426.iteration.add(1)), e1426.accBeta1.assign(e1426.accBeta1.mul(e1426.beta1));
        }), this.incrementIterations();
    }, o631.prototype.dispose = function() {
        this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && tn(this.accumulatedFirstMoment.map(function(t1934) {
            return t1934.variable;
        })), null != this.accumulatedWeightedInfNorm && tn(this.accumulatedWeightedInfNorm.map(function(t1935) {
            return t1935.variable;
        }));
    }, o631.prototype.getWeights = function() {
        return n(this, void 0, void 0, function() {
            return r(this, function(t) {
                throw new Error("getWeights() is not implemented for Adamax yet.");
            });
        });
    }, o631.prototype.setWeights = function(t) {
        return n(this, void 0, void 0, function() {
            return r(this, function(t) {
                throw new Error("setWeights() is not implemented for Adamax yet.");
            });
        });
    }, o631.prototype.getConfig = function() {
        return {
            learningRate: this.learningRate,
            beta1: this.beta1,
            beta2: this.beta2,
            epsilon: this.epsilon,
            decay: this.decay
        };
    }, o631.fromConfig = function(t1936, e1427) {
        return new t1936(e1427.learningRate, e1427.beta1, e1427.beta2, e1427.epsilon, e1427.decay);
    }, o631.className = "Adamax", o631;
}(Xd);
Hd(Jd);
var Zd = function(t1937) {
    function o634(e1428) {
        var n1062 = t1937.call(this) || this;
        return n1062.learningRate = e1428, n1062.setLearningRate(e1428), n1062;
    }
    return e(o634, t1937), o634.prototype.applyGradients = function(t1938) {
        var e1429 = this;
        (Array.isArray(t1938) ? t1938.map(function(t1939) {
            return t1939.name;
        }) : Object.keys(t1938)).forEach(function(n, r) {
            var o635 = Array.isArray(t1938) ? t1938[r].tensor : t1938[n];
            if (null != o635) {
                var a514 = Lt.registeredVariables[n];
                Ze(function() {
                    var t1940 = e1429.c.mul(o635).add(a514);
                    a514.assign(t1940);
                });
            }
        }), this.incrementIterations();
    }, o634.prototype.setLearningRate = function(t1941) {
        this.learningRate = t1941, null != this.c && this.c.dispose(), this.c = en(On(-t1941));
    }, o634.prototype.dispose = function() {
        this.c.dispose();
    }, o634.prototype.getWeights = function() {
        return n(this, void 0, void 0, function() {
            return r(this, function(t1942) {
                switch(t1942.label){
                    case 0:
                        return [
                            4,
                            this.saveIterations()
                        ];
                    case 1:
                        return [
                            2,
                            [
                                t1942.sent()
                            ]
                        ];
                }
            });
        });
    }, o634.prototype.setWeights = function(t1943) {
        return n(this, void 0, void 0, function() {
            return r(this, function(e1430) {
                switch(e1430.label){
                    case 0:
                        return [
                            4,
                            this.extractIterations(t1943)
                        ];
                    case 1:
                        if (0 !== (t1943 = e1430.sent()).length) throw new Error("SGD optimizer does not have settable weights.");
                        return [
                            2
                        ];
                }
            });
        });
    }, o634.prototype.getConfig = function() {
        return {
            learningRate: this.learningRate
        };
    }, o634.fromConfig = function(t1944, e1431) {
        return new t1944(e1431.learningRate);
    }, o634.className = "SGD", o634;
}(Xd);
Hd(Zd);
var tp = function(t1945) {
    function o636(e1432, n1063, r855) {
        void 0 === r855 && (r855 = !1);
        var o637 = t1945.call(this, e1432) || this;
        return o637.learningRate = e1432, o637.momentum = n1063, o637.useNesterov = r855, o637.accumulations = [], o637.m = On(o637.momentum), o637;
    }
    return e(o636, t1945), o636.prototype.applyGradients = function(t1946) {
        var e1433 = this;
        (Array.isArray(t1946) ? t1946.map(function(t1947) {
            return t1947.name;
        }) : Object.keys(t1946)).forEach(function(n1064, r) {
            var o638 = Lt.registeredVariables[n1064];
            if (null == e1433.accumulations[r]) e1433.accumulations[r] = {
                originalName: n1064 + "/momentum",
                variable: Ze(function() {
                    return Xn(o638).variable(!1);
                })
            };
            var a515 = e1433.accumulations[r].variable, i388 = Array.isArray(t1946) ? t1946[r].tensor : t1946[n1064];
            null != i388 && Ze(function() {
                var t1948, n1065 = e1433.m.mul(a515).add(i388);
                t1948 = e1433.useNesterov ? e1433.c.mul(i388.add(n1065.mul(e1433.m))).add(o638) : e1433.c.mul(n1065).add(o638), a515.assign(n1065), o638.assign(t1948);
            });
        }), this.incrementIterations();
    }, o636.prototype.dispose = function() {
        this.m.dispose(), null != this.accumulations && tn(this.accumulations.map(function(t1949) {
            return t1949.variable;
        }));
    }, o636.prototype.setMomentum = function(t1950) {
        this.momentum = t1950;
    }, o636.prototype.getWeights = function() {
        return n(this, void 0, void 0, function() {
            return r(this, function(t1951) {
                switch(t1951.label){
                    case 0:
                        return [
                            4,
                            this.saveIterations()
                        ];
                    case 1:
                        return [
                            2,
                            [
                                t1951.sent()
                            ].concat(this.accumulations.map(function(t1952) {
                                return {
                                    name: t1952.originalName,
                                    tensor: t1952.variable
                                };
                            }))
                        ];
                }
            });
        });
    }, o636.prototype.setWeights = function(t1953) {
        return n(this, void 0, void 0, function() {
            return r(this, function(e1434) {
                switch(e1434.label){
                    case 0:
                        return [
                            4,
                            this.extractIterations(t1953)
                        ];
                    case 1:
                        return t1953 = e1434.sent(), this.accumulations = t1953.map(function(t1954) {
                            return {
                                originalName: t1954.name,
                                variable: t1954.tensor.variable(!1)
                            };
                        }), [
                            2
                        ];
                }
            });
        });
    }, o636.prototype.getConfig = function() {
        return {
            learningRate: this.learningRate,
            momentum: this.momentum,
            useNesterov: this.useNesterov
        };
    }, o636.fromConfig = function(t1955, e1435) {
        return new t1955(e1435.learningRate, e1435.momentum, e1435.useNesterov);
    }, o636.className = "Momentum", o636;
}(Zd);
Hd(tp);
var ep = function(t1956) {
    function o639(e1436, n1066, r856, o640, a516) {
        void 0 === n1066 && (n1066 = 0.9), void 0 === r856 && (r856 = 0), void 0 === o640 && (o640 = null), void 0 === a516 && (a516 = !1);
        var i389 = t1956.call(this) || this;
        if (i389.learningRate = e1436, i389.decay = n1066, i389.momentum = r856, i389.epsilon = o640, i389.accumulatedMeanSquares = [], i389.accumulatedMoments = [], i389.accumulatedMeanGrads = [], i389.centered = a516, null == o640 && (i389.epsilon = Lt.backend.epsilon()), null == e1436) throw new Error("learningRate for RMSPropOptimizer must be defined.");
        return i389;
    }
    return e(o639, t1956), o639.prototype.applyGradients = function(t1957) {
        var e1437 = this;
        (Array.isArray(t1957) ? t1957.map(function(t1958) {
            return t1958.name;
        }) : Object.keys(t1957)).forEach(function(n1067, r) {
            var o641 = Lt.registeredVariables[n1067];
            null == e1437.accumulatedMeanSquares[r] && (e1437.accumulatedMeanSquares[r] = {
                originalName: n1067 + "/rms",
                variable: Ze(function() {
                    return Xn(o641).variable(!1);
                })
            }), null == e1437.accumulatedMoments[r] && (e1437.accumulatedMoments[r] = {
                originalName: n1067 + "/momentum",
                variable: Ze(function() {
                    return Xn(o641).variable(!1);
                })
            }), null == e1437.accumulatedMeanGrads[r] && e1437.centered && (e1437.accumulatedMeanGrads[r] = {
                originalName: n1067 + "/mg",
                variable: Ze(function() {
                    return Xn(o641).variable(!1);
                })
            });
            var a517 = Array.isArray(t1957) ? t1957[r].tensor : t1957[n1067];
            if (null != a517) {
                var i390 = e1437.accumulatedMeanSquares[r].variable, s341 = e1437.accumulatedMoments[r].variable;
                Ze(function() {
                    var t1959 = i390.mul(e1437.decay).add(a517.square().mul(1 - e1437.decay));
                    if (e1437.centered) {
                        var n1068 = e1437.accumulatedMeanGrads[r].variable, u276 = n1068.mul(e1437.decay).add(a517.mul(1 - e1437.decay)), c227 = s341.mul(e1437.momentum).add(a517.mul(e1437.learningRate).div(t1959.sub(u276.square().add(e1437.epsilon)).sqrt()));
                        i390.assign(t1959), n1068.assign(u276), s341.assign(c227);
                        var l187 = o641.sub(c227);
                        o641.assign(l187);
                    } else {
                        var h170 = i390.mul(e1437.decay).add(a517.square().mul(1 - e1437.decay));
                        c227 = s341.mul(e1437.momentum).add(a517.mul(e1437.learningRate).div(h170.add(e1437.epsilon).sqrt()));
                        i390.assign(h170), s341.assign(c227);
                        l187 = o641.sub(c227);
                        o641.assign(l187);
                    }
                });
            }
        }), this.incrementIterations();
    }, o639.prototype.dispose = function() {
        null != this.accumulatedMeanSquares && tn(this.accumulatedMeanSquares.map(function(t1960) {
            return t1960.variable;
        })), null != this.accumulatedMeanGrads && this.centered && tn(this.accumulatedMeanGrads.map(function(t1961) {
            return t1961.variable;
        })), null != this.accumulatedMoments && tn(this.accumulatedMoments.map(function(t1962) {
            return t1962.variable;
        }));
    }, o639.prototype.getWeights = function() {
        return n(this, void 0, void 0, function() {
            var t1963;
            return r(this, function(e1438) {
                switch(e1438.label){
                    case 0:
                        return t1963 = this.accumulatedMeanSquares.concat(this.accumulatedMoments), this.centered && t1963.push.apply(t1963, this.accumulatedMeanGrads), [
                            4,
                            this.saveIterations()
                        ];
                    case 1:
                        return [
                            2,
                            [
                                e1438.sent()
                            ].concat(t1963.map(function(t1964) {
                                return {
                                    name: t1964.originalName,
                                    tensor: t1964.variable
                                };
                            }))
                        ];
                }
            });
        });
    }, o639.prototype.setWeights = function(t1965) {
        return n(this, void 0, void 0, function() {
            var e1439;
            return r(this, function(n1069) {
                switch(n1069.label){
                    case 0:
                        return [
                            4,
                            this.extractIterations(t1965)
                        ];
                    case 1:
                        return t1965 = n1069.sent(), e1439 = this.centered ? t1965.length / 3 : t1965.length / 2, this.accumulatedMeanSquares = t1965.slice(0, e1439).map(function(t1966) {
                            return {
                                originalName: t1966.name,
                                variable: t1966.tensor.variable(!1)
                            };
                        }), this.accumulatedMoments = t1965.slice(e1439, 2 * e1439).map(function(t1967) {
                            return {
                                originalName: t1967.name,
                                variable: t1967.tensor.variable(!1)
                            };
                        }), this.centered && (this.accumulatedMeanGrads = t1965.slice(2 * e1439, 3 * e1439).map(function(t1968) {
                            return {
                                originalName: t1968.name,
                                variable: t1968.tensor.variable(!1)
                            };
                        })), [
                            2
                        ];
                }
            });
        });
    }, o639.prototype.getConfig = function() {
        return {
            learningRate: this.learningRate,
            decay: this.decay,
            momentum: this.momentum,
            epsilon: this.epsilon,
            centered: this.centered
        };
    }, o639.fromConfig = function(t1969, e1440) {
        return new t1969(e1440.learningRate, e1440.decay, e1440.momentum, e1440.epsilon, e1440.centered);
    }, o639.className = "RMSProp", o639;
}(Xd);
Hd(ep);
var np = function() {
    function t1970() {
    }
    return t1970.sgd = function(t1971) {
        return new Zd(t1971);
    }, t1970.momentum = function(t1972, e1441, n1070) {
        return void 0 === n1070 && (n1070 = !1), new tp(t1972, e1441, n1070);
    }, t1970.rmsprop = function(t1973, e1442, n1071, r857, o642) {
        return void 0 === e1442 && (e1442 = 0.9), void 0 === n1071 && (n1071 = 0), void 0 === r857 && (r857 = null), void 0 === o642 && (o642 = !1), new ep(t1973, e1442, n1071, r857, o642);
    }, t1970.adam = function(t1974, e1443, n1072, r858) {
        return void 0 === t1974 && (t1974 = 0.001), void 0 === e1443 && (e1443 = 0.9), void 0 === n1072 && (n1072 = 0.999), void 0 === r858 && (r858 = null), new Qd(t1974, e1443, n1072, r858);
    }, t1970.adadelta = function(t1975, e1444, n1073) {
        return void 0 === t1975 && (t1975 = 0.001), void 0 === e1444 && (e1444 = 0.95), void 0 === n1073 && (n1073 = null), new Yd(t1975, e1444, n1073);
    }, t1970.adamax = function(t1976, e1445, n1074, r859, o643) {
        return void 0 === t1976 && (t1976 = 0.002), void 0 === e1445 && (e1445 = 0.9), void 0 === n1074 && (n1074 = 0.999), void 0 === r859 && (r859 = null), void 0 === o643 && (o643 = 0), new Jd(t1976, e1445, n1074, r859, o643);
    }, t1970.adagrad = function(t1977, e1446) {
        return void 0 === e1446 && (e1446 = 0.1), new $d(t1977, e1446);
    }, t1970;
}(), rp = {
    sgd: np.sgd,
    momentum: np.momentum,
    adadelta: np.adadelta,
    adagrad: np.adagrad,
    rmsprop: np.rmsprop,
    adamax: np.adamax,
    adam: np.adam
}, op = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : function(t1978) {
    return t1978();
};
function ap() {
    return new Promise(function(t1979) {
        return op(function() {
            return t1979();
        });
    });
}
wt.prototype.add = function(t1980) {
    return Or(this, t1980);
}, wt.prototype.broadcastTo = function(t1981) {
    return fc(this, t1981);
}, wt.prototype.div = function(t1982) {
    return Bo(this, t1982);
}, wt.prototype.divNoNan = function(t1983) {
    return bc(this, t1983);
}, wt.prototype.squaredDifference = function(t1984) {
    return Hc(this, t1984);
}, wt.prototype.tile = function(t1985) {
    return wc(this, t1985);
}, wt.prototype.oneHot = function(t1986, e1447, n1075) {
    return void 0 === e1447 && (e1447 = 1), void 0 === n1075 && (n1075 = 0), Rc(this, t1986, e1447, n1075);
}, wt.prototype.transpose = function(t1987) {
    return ua(this, t1987);
}, wt.prototype.pad = function(t1988, e1448) {
    return Ic(this, t1988, e1448);
}, wt.prototype.batchNorm = function(t1989, e1449, n1076, r860, o644) {
    return nc(this, t1989, e1449, n1076, r860, o644);
}, xt = ff;

},{"process":"d5jf4","buffer":"fCgem","crypto":"jhUEF","node-fetch":"jhUEF","util":"jhUEF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d5jf4":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {
};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function() {
    try {
        if (typeof setTimeout === 'function') cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e1) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {
};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {
};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error('process.binding is not supported');
};
process.cwd = function() {
    return '/';
};
process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() {
    return 0;
};

},{}],"fCgem":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ 'use strict';
const base64 = require('base64-js');
const ieee754 = require('ieee754');
const customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 2147483647;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === 'number') throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';
    if (!Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + ' bytes');
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== 'string') throw new TypeError("The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type " + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case 'ascii':
        case 'latin1':
        case 'binary':
            return len;
        case 'utf8':
        case 'utf-8':
            return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return len * 2;
        case 'hex':
            return len >>> 1;
        case 'base64':
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return '';
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return '';
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return '';
    if (!encoding) encoding = 'utf8';
    while(true)switch(encoding){
        case 'hex':
            return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
            return utf8Slice(this, start, end);
        case 'ascii':
            return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
            return latin1Slice(this, start, end);
        case 'base64':
            return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = '';
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError("The \"target\" argument must be one of type Buffer or Uint8Array. Received type " + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 2147483647) byteOffset = 2147483647;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 255 // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i1;
    if (dir) {
        let foundIndex = -1;
        for(i1 = byteOffset; i1 < arrLength; i1++)if (read(arr, i1) === read(val, foundIndex === -1 ? 0 : i1 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i1;
            if (i1 - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i1 -= i1 - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i1 = byteOffset; i1 >= 0; i1--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i1 + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i1;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');
    if (!encoding) encoding = 'utf8';
    let loweredCase = false;
    for(;;)switch(encoding){
        case 'hex':
            return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
            return utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
            return asciiWrite(this, string, offset, length);
        case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = '';
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 127);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = '';
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength1, noAssert) {
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength1, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength1 && (mul *= 256))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    let val = this[offset + --byteLength2];
    let mul = 1;
    while(byteLength2 > 0 && (mul *= 256))val += this[offset + --byteLength2] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 65536 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 65536 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 65536 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength3 && (mul *= 256))val += this[offset + i] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength4, noAssert) {
    offset = offset >>> 0;
    byteLength4 = byteLength4 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength4, this.length);
    let i = byteLength4;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 256))val += this[offset + --i] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength4);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 65536 + (last << 24) // Overflow
    ;
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + this[++offset] * 65536 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 65536 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength5, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength5 = byteLength5 >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength5) - 1;
        checkInt(this, value, offset, byteLength5, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 255;
    while(++i < byteLength5 && (mul *= 256))this[offset + i] = value / mul & 255;
    return offset + byteLength5;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength6, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength6 = byteLength6 >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength6) - 1;
        checkInt(this, value, offset, byteLength6, maxBytes, 0);
    }
    let i = byteLength6 - 1;
    let mul = 1;
    this[offset + i] = value & 255;
    while(--i >= 0 && (mul *= 256))this[offset + i] = value / mul & 255;
    return offset + byteLength6;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength7, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength7 - 1);
        checkInt(this, value, offset, byteLength7, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while(++i < byteLength7 && (mul *= 256)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength7;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength8, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength8 - 1);
        checkInt(this, value, offset, byteLength8, limit - 1, -limit);
    }
    let i = byteLength8 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 255;
    while(--i >= 0 && (mul *= 256)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength8;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError('targetStart out of bounds');
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === 'number') val = val & 255;
    else if (typeof val === 'boolean') val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {
};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, 'message', {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, 'code', {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E('ERR_BUFFER_OUT_OF_BOUNDS', function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INVALID_ARG_TYPE', function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E('ERR_OUT_OF_RANGE', function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === 'bigint') {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += 'n';
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = '';
    let i = val.length;
    const start = val[0] === '-' ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength9) {
    validateNumber(offset, 'offset');
    if (buf[offset] === undefined || buf[offset + byteLength9] === undefined) boundsError(offset, buf.length - (byteLength9 + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength10) {
    if (value > max || value < min) {
        const n = typeof min === 'bigint' ? 'n' : '';
        let range;
        if (byteLength10 > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength10 + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength10 + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength10 + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE('value', range, value);
    }
    checkBounds(buf, offset, byteLength10);
}
function validateNumber(value, name) {
    if (typeof value !== 'number') throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + '=';
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 55295 && codePoint < 57344) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 56319) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 56320) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else throw new Error('Invalid code point');
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 255);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = '0123456789abcdef';
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error('BigInt not supported');
}

},{"base64-js":"eIiSV","ieee754":"cO95r"}],"eIiSV":[function(require,module,exports) {
'use strict';
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len1 = b64.length;
    if (len1 % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len1;
    var placeHoldersLen = validLen === len1 ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i1;
    for(i1 = 0; i1 < len2; i1 += 4){
        tmp = revLookup[b64.charCodeAt(i1)] << 18 | revLookup[b64.charCodeAt(i1 + 1)] << 12 | revLookup[b64.charCodeAt(i1 + 2)] << 6 | revLookup[b64.charCodeAt(i1 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i1)] << 2 | revLookup[b64.charCodeAt(i1 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i1)] << 10 | revLookup[b64.charCodeAt(i1 + 1)] << 4 | revLookup[b64.charCodeAt(i1 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i2 = start; i2 < end; i2 += 3){
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len3 = uint8.length;
    var extraBytes = len3 % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i3 = 0, len2 = len3 - extraBytes; i3 < len2; i3 += maxChunkLength)parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len2 ? len2 : i3 + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len3 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len3 - 2] << 8) + uint8[len3 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + '=');
    }
    return parts.join('');
}

},{}],"cO95r":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"jhUEF":[function(require,module,exports) {
"use strict";

},{}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"lRvbi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "constraints", ()=>exports_constraints
);
parcelHelpers.export(exports, "initializers", ()=>exports_initializers
);
parcelHelpers.export(exports, "layers", ()=>exports_layers
);
parcelHelpers.export(exports, "metrics", ()=>exports_metrics
);
parcelHelpers.export(exports, "models", ()=>exports_models
);
parcelHelpers.export(exports, "regularizers", ()=>exports_regularizers
);
parcelHelpers.export(exports, "CallbackList", ()=>CallbackList
);
parcelHelpers.export(exports, "CustomCallback", ()=>CustomCallback
);
parcelHelpers.export(exports, "History", ()=>History
);
parcelHelpers.export(exports, "Callback", ()=>Callback
);
parcelHelpers.export(exports, "callbacks", ()=>callbacks
);
parcelHelpers.export(exports, "EarlyStopping", ()=>EarlyStopping
);
parcelHelpers.export(exports, "InputSpec", ()=>InputSpec
);
parcelHelpers.export(exports, "SymbolicTensor", ()=>SymbolicTensor
);
parcelHelpers.export(exports, "LayersModel", ()=>LayersModel
);
parcelHelpers.export(exports, "input", ()=>input
);
parcelHelpers.export(exports, "loadLayersModel", ()=>loadLayersModel
);
parcelHelpers.export(exports, "model", ()=>model
);
parcelHelpers.export(exports, "registerCallbackConstructor", ()=>registerCallbackConstructor
);
parcelHelpers.export(exports, "sequential", ()=>sequential
);
parcelHelpers.export(exports, "RNN", ()=>RNN
);
parcelHelpers.export(exports, "Sequential", ()=>Sequential
);
parcelHelpers.export(exports, "LayerVariable", ()=>LayerVariable
);
parcelHelpers.export(exports, "version_layers", ()=>version
);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ var _tfjsCore = require("@tensorflow/tfjs-core");
var extendStatics = function(e1, t1) {
    return (extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(e, t) {
        e.__proto__ = t;
    } || function(e, t) {
        for(var n in t)t.hasOwnProperty(n) && (e[n] = t[n]);
    })(e1, t1);
};
function __extends(e, t) {
    function n() {
        this.constructor = e;
    }
    extendStatics(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n);
}
var _epsilon, __assign = function() {
    return (__assign = Object.assign || function(e) {
        for(var t, n = 1, r = arguments.length; n < r; n++)for(var i in t = arguments[n])Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
        return e;
    }).apply(this, arguments);
};
function __awaiter(e2, t2, n, r) {
    return new (n || (n = Promise))(function(i, a) {
        function o(e) {
            try {
                l(r.next(e));
            } catch (e3) {
                a(e3);
            }
        }
        function s(e) {
            try {
                l(r.throw(e));
            } catch (e4) {
                a(e4);
            }
        }
        function l(e) {
            e.done ? i(e.value) : new n(function(t) {
                t(e.value);
            }).then(o, s);
        }
        l((r = r.apply(e2, t2 || [])).next());
    });
}
function __generator(e5, t) {
    var n, r, i, a1, o = {
        label: 0,
        sent: function() {
            if (1 & i[0]) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    };
    function s1(a2) {
        return function(s) {
            return (function(a) {
                if (n) throw new TypeError("Generator is already executing.");
                for(; o;)try {
                    if (n = 1, r && (i = 2 & a[0] ? r.return : a[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, a[1])).done) return i;
                    switch(r = 0, i && (a = [
                        2 & a[0],
                        i.value
                    ]), a[0]){
                        case 0:
                        case 1:
                            i = a;
                            break;
                        case 4:
                            return o.label++, {
                                value: a[1],
                                done: !1
                            };
                        case 5:
                            o.label++, r = a[1], a = [
                                0
                            ];
                            continue;
                        case 7:
                            a = o.ops.pop(), o.trys.pop();
                            continue;
                        default:
                            if (!(i = (i = o.trys).length > 0 && i[i.length - 1]) && (6 === a[0] || 2 === a[0])) {
                                o = 0;
                                continue;
                            }
                            if (3 === a[0] && (!i || a[1] > i[0] && a[1] < i[3])) {
                                o.label = a[1];
                                break;
                            }
                            if (6 === a[0] && o.label < i[1]) {
                                o.label = i[1], i = a;
                                break;
                            }
                            if (i && o.label < i[2]) {
                                o.label = i[2], o.ops.push(a);
                                break;
                            }
                            i[2] && o.ops.pop(), o.trys.pop();
                            continue;
                    }
                    a = t.call(e5, o);
                } catch (e) {
                    a = [
                        6,
                        e
                    ], r = 0;
                } finally{
                    n = i = 0;
                }
                if (5 & a[0]) throw a[1];
                return {
                    value: a[0] ? a[1] : void 0,
                    done: !0
                };
            })([
                a2,
                s
            ]);
        };
    }
    return a1 = {
        next: s1(0),
        throw: s1(1),
        return: s1(2)
    }, "function" == typeof Symbol && (a1[Symbol.iterator] = function() {
        return this;
    }), a1;
}
function epsilon() {
    return null == _epsilon && (_epsilon = _tfjsCore.backend().epsilon()), _epsilon;
}
function imageDataFormat() {
    return "channelsLast";
}
var AttributeError = function(e) {
    function t(n) {
        var r = e.call(this, n) || this;
        return Object.setPrototypeOf(r, t.prototype), r;
    }
    return __extends(t, e), t;
}(Error), RuntimeError = function(e) {
    function t(n) {
        var r = e.call(this, n) || this;
        return Object.setPrototypeOf(r, t.prototype), r;
    }
    return __extends(t, e), t;
}(Error), ValueError = function(e) {
    function t(n) {
        var r = e.call(this, n) || this;
        return Object.setPrototypeOf(r, t.prototype), r;
    }
    return __extends(t, e), t;
}(Error), NotImplementedError = function(e) {
    function t(n) {
        var r = e.call(this, n) || this;
        return Object.setPrototypeOf(r, t.prototype), r;
    }
    return __extends(t, e), t;
}(Error), AssertionError = function(e) {
    function t(n) {
        var r = e.call(this, n) || this;
        return Object.setPrototypeOf(r, t.prototype), r;
    }
    return __extends(t, e), t;
}(Error), IndexError = function(e) {
    function t(n) {
        var r = e.call(this, n) || this;
        return Object.setPrototypeOf(r, t.prototype), r;
    }
    return __extends(t, e), t;
}(Error);
function pyListRepeat(e, t) {
    if (Array.isArray(e)) {
        for(var n = [], r = 0; r < t; r++)n = n.concat(e);
        return n;
    }
    return (n = new Array(t)).fill(e), n;
}
function assert(e, t) {
    if (!e) throw new AssertionError(t);
}
function count(e, t) {
    for(var n = 0, r = 0, i = e; r < i.length; r++)i[r] === t && n++;
    return n;
}
function singletonOrArray(e) {
    return 1 === e.length ? e[0] : e;
}
function toList(e) {
    return Array.isArray(e) ? e : [
        e
    ];
}
function toSnakeCase(e) {
    var t = e.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
    return "_" !== t[0] ? t : "private" + t;
}
function toCamelCase(e) {
    return e.length <= 1 ? e : -1 === e.indexOf("_") ? e : e.replace(/[_]+(\w|$)/g, function(e, t) {
        return t.toUpperCase();
    });
}
var _GLOBAL_CUSTOM_OBJECTS = {
};
function serializeKerasObject(e) {
    if (null === e || void 0 === e) return null;
    var t = {
    };
    return t.className = e.getClassName(), t.config = e.getConfig(), t;
}
function convertNDArrayScalarsInConfig(e6) {
    if (null != e6 && "object" == typeof e6) {
        if (Array.isArray(e6)) e6.forEach(function(e) {
            return convertNDArrayScalarsInConfig(e);
        });
        else for(var t = 0, n = Object.keys(e6); t < n.length; t++){
            var r = n[t], i = e6[r];
            null != i && "object" == typeof i && (Array.isArray(i) || "ndarray" !== i.type || "number" != typeof i.value ? convertNDArrayScalarsInConfig(i) : e6[r] = i.value);
        }
    }
}
function deserializeKerasObject(e, t, n, r, i) {
    var a, o, s;
    if (void 0 === t && (t = {
    }), void 0 === n && (n = {
    }), void 0 === r && (r = "object"), void 0 === i && (i = !1), "string" == typeof e) {
        var l = e, u = void 0;
        if (l in n) u = n[l];
        else if (l in _GLOBAL_CUSTOM_OBJECTS) u = _GLOBAL_CUSTOM_OBJECTS[l];
        else if (null == (u = t[l])) throw new ValueError("Unknown " + r + ": " + e + ". This may be due to one of the following reasons:\n1. The " + r + " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom " + r + " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");
        return u;
    }
    var c = e;
    if (null == c.className || null == c.config) throw new ValueError(r + ": Improper config format: " + JSON.stringify(c) + ".\n'className' and 'config' must set.");
    var p = c.className, h = void 0, d = void 0;
    if (p in n ? (h = (a = n[p])[0], d = a[1]) : p in _GLOBAL_CUSTOM_OBJECTS ? (h = (o = _GLOBAL_CUSTOM_OBJECTS.className)[0], d = o[1]) : p in t && (h = (s = t[p])[0], d = s[1]), null == h) throw new ValueError("Unknown " + r + ": " + p + ". This may be due to one of the following reasons:\n1. The " + r + " is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom " + r + " is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");
    if (null != d) {
        for(var f = {
        }, g = 0, m = Object.keys(_GLOBAL_CUSTOM_OBJECTS); g < m.length; g++)f[S = m[g]] = _GLOBAL_CUSTOM_OBJECTS[S];
        for(var y = 0, v = Object.keys(n); y < v.length; y++)f[S = v[y]] = n[S];
        c.config.customObjects = f;
        for(var b = __assign({
        }, _GLOBAL_CUSTOM_OBJECTS), w = 0, z = Object.keys(n); w < z.length; w++){
            var S = z[w];
            _GLOBAL_CUSTOM_OBJECTS[S] = n[S];
        }
        convertNDArrayScalarsInConfig(c.config);
        var A = d(h, c.config, n, i);
        return _GLOBAL_CUSTOM_OBJECTS = __assign({
        }, b), A;
    }
    b = __assign({
    }, _GLOBAL_CUSTOM_OBJECTS);
    for(var _ = 0, I = Object.keys(n); _ < I.length; _++){
        S = I[_];
        _GLOBAL_CUSTOM_OBJECTS[S] = n[S];
    }
    A = new h(c.config);
    return _GLOBAL_CUSTOM_OBJECTS = __assign({
    }, b), A;
}
function numberCompare(e, t) {
    return e < t ? -1 : e > t ? 1 : 0;
}
function reverseNumberCompare(e, t) {
    return -1 * numberCompare(e, t);
}
function unique(e) {
    if (null == e) return e;
    for(var t = [], n = 0, r = e; n < r.length; n++){
        var i = r[n];
        -1 === t.indexOf(i) && t.push(i);
    }
    return t;
}
function isObjectEmpty(e) {
    if (null == e) throw new ValueError("Invalid value in obj: " + JSON.stringify(e));
    for(var t in e)if (e.hasOwnProperty(t)) return !1;
    return !0;
}
function checkStringTypeUnionValue(e, t, n) {
    if (null != n && e.indexOf(n) < 0) throw new ValueError(n + " is not a valid " + t + ".  Valid values are " + e + " or null/undefined.");
}
function checkArrayTypeAndLength(e7, t, n, r) {
    return void 0 === n && (n = 0), void 0 === r && (r = 1 / 0), assert(n >= 0), assert(r >= n), Array.isArray(e7) && e7.length >= n && e7.length <= r && e7.every(function(e) {
        return typeof e === t;
    });
}
function assertPositiveInteger(e8, t) {
    Array.isArray(e8) ? (_tfjsCore.util.assert(e8.length > 0, function() {
        return t + " is unexpectedly an empty array.";
    }), e8.forEach(function(e, n) {
        return assertPositiveInteger(e, "element " + (n + 1) + " of " + t);
    })) : _tfjsCore.util.assert(Number.isInteger(e8) && e8 > 0, function() {
        return "Expected " + t + " to be a positive integer, but got " + formatAsFriendlyString(e8) + ".";
    });
}
function formatAsFriendlyString(e9) {
    return null === e9 ? "null" : Array.isArray(e9) ? "[" + e9.map(function(e) {
        return formatAsFriendlyString(e);
    }).join(",") + "]" : "string" == typeof e9 ? '"' + e9 + '"' : "" + e9;
}
function debounce(e, t) {
    var n, r = _tfjsCore.util.now();
    return function() {
        for(var i = [], a = 0; a < arguments.length; a++)i[a] = arguments[a];
        var o = _tfjsCore.util.now();
        return o - r < t ? n : (r = o, n = e.apply(void 0, i));
    };
}
function mapActivationToFusedKernel(e) {
    return "relu" === e ? "relu" : "linear" === e ? "linear" : "elu" === e ? "elu" : null;
}
function calcL2Norms(e, t) {
    return _tfjsCore.tidy(function() {
        return _tfjsCore.sqrt(_tfjsCore.sum(_tfjsCore.mulStrict(e, e), t, !0));
    });
}
var Constraint = function(e) {
    function t() {
        return null !== e && e.apply(this, arguments) || this;
    }
    return __extends(t, e), t.prototype.getConfig = function() {
        return {
        };
    }, t;
}(_tfjsCore.serialization.Serializable), MaxNorm = function(e10) {
    function t3(t) {
        var n = e10.call(this) || this;
        return n.defaultMaxValue = 2, n.defaultAxis = 0, n.maxValue = null != t.maxValue ? t.maxValue : n.defaultMaxValue, n.axis = null != t.axis ? t.axis : n.defaultAxis, n;
    }
    return __extends(t3, e10), t3.prototype.apply = function(e) {
        var t = this;
        return _tfjsCore.tidy(function() {
            var n = calcL2Norms(e, t.axis), r = _tfjsCore.clipByValue(n, 0, t.maxValue);
            return _tfjsCore.mul(e, _tfjsCore.div(r, _tfjsCore.add(epsilon(), n)));
        });
    }, t3.prototype.getConfig = function() {
        return {
            maxValue: this.maxValue,
            axis: this.axis
        };
    }, t3.className = "MaxNorm", t3;
}(Constraint);
_tfjsCore.serialization.registerClass(MaxNorm);
var UnitNorm = function(e11) {
    function t4(t) {
        var n = e11.call(this) || this;
        return n.defaultAxis = 0, n.axis = null != t.axis ? t.axis : n.defaultAxis, n;
    }
    return __extends(t4, e11), t4.prototype.apply = function(e) {
        var t = this;
        return _tfjsCore.tidy(function() {
            return _tfjsCore.div(e, _tfjsCore.add(epsilon(), calcL2Norms(e, t.axis)));
        });
    }, t4.prototype.getConfig = function() {
        return {
            axis: this.axis
        };
    }, t4.className = "UnitNorm", t4;
}(Constraint);
_tfjsCore.serialization.registerClass(UnitNorm);
var NonNeg = function(e12) {
    function t() {
        return null !== e12 && e12.apply(this, arguments) || this;
    }
    return __extends(t, e12), t.prototype.apply = function(e) {
        return _tfjsCore.relu(e);
    }, t.className = "NonNeg", t;
}(Constraint);
_tfjsCore.serialization.registerClass(NonNeg);
var MinMaxNorm = function(e13) {
    function t5(t) {
        var n = e13.call(this) || this;
        return n.defaultMinValue = 0, n.defaultMaxValue = 1, n.defaultRate = 1, n.defaultAxis = 0, n.minValue = null != t.minValue ? t.minValue : n.defaultMinValue, n.maxValue = null != t.maxValue ? t.maxValue : n.defaultMaxValue, n.rate = null != t.rate ? t.rate : n.defaultRate, n.axis = null != t.axis ? t.axis : n.defaultAxis, n;
    }
    return __extends(t5, e13), t5.prototype.apply = function(e) {
        var t = this;
        return _tfjsCore.tidy(function() {
            var n = calcL2Norms(e, t.axis), r = _tfjsCore.add(_tfjsCore.mul(t.rate, _tfjsCore.clipByValue(n, t.minValue, t.maxValue)), _tfjsCore.mul(1 - t.rate, n));
            return _tfjsCore.mul(e, _tfjsCore.div(r, _tfjsCore.add(epsilon(), n)));
        });
    }, t5.prototype.getConfig = function() {
        return {
            minValue: this.minValue,
            maxValue: this.maxValue,
            rate: this.rate,
            axis: this.axis
        };
    }, t5.className = "MinMaxNorm", t5;
}(Constraint);
_tfjsCore.serialization.registerClass(MinMaxNorm);
var CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
    maxNorm: "MaxNorm",
    minMaxNorm: "MinMaxNorm",
    nonNeg: "NonNeg",
    unitNorm: "UnitNorm"
};
function serializeConstraint(e) {
    return serializeKerasObject(e);
}
function deserializeConstraint(e, t) {
    return void 0 === t && (t = {
    }), deserializeKerasObject(e, _tfjsCore.serialization.SerializationMap.getMap().classNameMap, t, "constraint");
}
function getConstraint(e) {
    return null == e ? null : "string" == typeof e ? deserializeConstraint({
        className: e in CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP ? CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[e] : e,
        config: {
        }
    }) : e instanceof Constraint ? e : deserializeConstraint(e);
}
function maxNorm(e) {
    return new MaxNorm(e);
}
function unitNorm(e) {
    return new UnitNorm(e);
}
function nonNeg() {
    return new NonNeg;
}
function minMaxNorm(e) {
    return new MinMaxNorm(e);
}
var exports_constraints = Object.freeze({
    maxNorm: maxNorm,
    unitNorm: unitNorm,
    nonNeg: nonNeg,
    minMaxNorm: minMaxNorm
}), VALID_DATA_FORMAT_VALUES = [
    "channelsFirst",
    "channelsLast"
], VALID_PADDING_MODE_VALUES = [
    "valid",
    "same",
    "causal"
], VALID_POOL_MODE_VALUES = [
    "max",
    "avg"
], VALID_BIDIRECTIONAL_MERGE_MODES = [
    "sum",
    "mul",
    "concat",
    "ave"
], nameMap = new Map;
function checkDataFormat(e) {
    checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, "DataFormat", e);
}
function checkPaddingMode(e) {
    checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, "PaddingMode", e);
}
function checkPoolMode(e) {
    checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, "PoolMode", e);
}
var _nameScopeStack = [], _nameScopeDivider = "/";
function nameScope(e, t) {
    _nameScopeStack.push(e);
    try {
        var n = t();
        return _nameScopeStack.pop(), n;
    } catch (e14) {
        throw _nameScopeStack.pop(), e14;
    }
}
function currentNameScopePrefix() {
    return 0 === _nameScopeStack.length ? "" : _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;
}
function getScopedTensorName(e) {
    if (!isValidTensorName(e)) throw new Error("Not a valid tensor name: '" + e + "'");
    return currentNameScopePrefix() + e;
}
function getUniqueTensorName(e) {
    if (!isValidTensorName(e)) throw new Error("Not a valid tensor name: '" + e + "'");
    nameMap.has(e) || nameMap.set(e, 0);
    var t = nameMap.get(e);
    if (nameMap.set(e, nameMap.get(e) + 1), t > 0) {
        var n = e + "_" + t;
        return nameMap.set(n, 1), n;
    }
    return e;
}
var tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);
function isValidTensorName(e) {
    return !!e.match(tensorNameRegex);
}
function isInteger(e) {
    return e === parseInt(e.toString(), 10);
}
function arrayProd(e, t, n) {
    null == t && (t = 0), null == n && (n = e.length);
    for(var r = 1, i = t; i < n; ++i)r *= e[i];
    return r;
}
function toArray1D(e) {
    return e = Array.isArray(e) ? new Float32Array(e) : e, _tfjsCore.tensor1d(e);
}
function min$1(e) {
    return _tfjsCore.min(toArray1D(e)).dataSync()[0];
}
function max$1(e) {
    return _tfjsCore.max(toArray1D(e)).dataSync()[0];
}
function range(e, t) {
    if (t < e) throw new ValueError("end (" + t + ") < begin (" + e + ") is forbidden.");
    for(var n = [], r = e; r < t; ++r)n.push(r);
    return n;
}
function cast$1(e, t) {
    return e.asType(t);
}
function expandDims$1(e, t) {
    void 0 === t && (t = -1);
    var n = e.shape.slice();
    return t < 0 && (t = n.length + t + 1), n.splice(t, 0, 1), e.reshape(n);
}
function repeat(e, t) {
    return _tfjsCore.tidy(function() {
        if (2 !== e.shape.length) throw new ValueError("repeat() expects a rank-2 tensor, but received a rank-" + e.shape.length + " tensor.");
        return tile$1(expandDims$1(e, 1), [
            1,
            t,
            1
        ]);
    });
}
function flatten(e) {
    var t = [
        arrayProd(e.shape)
    ];
    return e.reshape(t);
}
function batchFlatten(e) {
    if (e.rank <= 1) throw new ValueError("batchFlatten requires a minimum rank of 2. Got rank: " + e.rank + ".");
    var t = [
        e.shape[0],
        arrayProd(e.shape, 1)
    ];
    return e.reshape(t);
}
function sliceAlongFirstAxis(e, t, n) {
    return _tfjsCore.tidy(function() {
        switch(e.rank){
            case 1:
                return _tfjsCore.slice1d(e, t, n);
            case 2:
                return _tfjsCore.slice2d(e, [
                    t,
                    0
                ], [
                    n,
                    e.shape[1]
                ]);
            case 3:
                return _tfjsCore.slice3d(e, [
                    t,
                    0,
                    0
                ], [
                    n,
                    e.shape[1],
                    e.shape[2]
                ]);
            case 4:
                return _tfjsCore.slice4d(e, [
                    t,
                    0,
                    0,
                    0
                ], [
                    n,
                    e.shape[1],
                    e.shape[2],
                    e.shape[3]
                ]);
            case 5:
                return _tfjsCore.slice(e, [
                    t,
                    0,
                    0,
                    0,
                    0
                ], [
                    n,
                    e.shape[1],
                    e.shape[2],
                    e.shape[3],
                    e.shape[4]
                ]);
            case 6:
                return _tfjsCore.slice(e, [
                    t,
                    0,
                    0,
                    0,
                    0,
                    0
                ], [
                    n,
                    e.shape[1],
                    e.shape[2],
                    e.shape[3],
                    e.shape[4],
                    e.shape[5]
                ]);
            default:
                throw new ValueError("sliceAlongFirstAxis() received an unsupported tensor rank: " + e.rank);
        }
    });
}
function sliceAlongLastAxis(e, t, n) {
    return _tfjsCore.tidy(function() {
        switch(e.rank){
            case 1:
                return _tfjsCore.slice1d(e, t, n);
            case 2:
                return _tfjsCore.slice2d(e, [
                    0,
                    t
                ], [
                    e.shape[0],
                    n
                ]);
            case 3:
                return _tfjsCore.slice3d(e, [
                    0,
                    0,
                    t
                ], [
                    e.shape[0],
                    e.shape[1],
                    n
                ]);
            case 4:
                return _tfjsCore.slice4d(e, [
                    0,
                    0,
                    0,
                    t
                ], [
                    e.shape[0],
                    e.shape[1],
                    e.shape[2],
                    n
                ]);
            default:
                throw new ValueError("sliceAlongLastAxis() received an unsupported tensor rank: " + e.rank);
        }
    });
}
function sliceAlongAxis(e, t, n, r) {
    return _tfjsCore.tidy(function() {
        switch(e.rank){
            case 1:
                return _tfjsCore.slice1d(e, t, n);
            case 2:
                switch(r){
                    case 1:
                        return sliceAlongFirstAxis(e, t, n);
                    case 2:
                        return sliceAlongLastAxis(e, t, n);
                    default:
                        throw new ValueError("The axis is not within the rank of the tensor " + r);
                }
            case 3:
                switch(r){
                    case 1:
                        return sliceAlongFirstAxis(e, t, n);
                    case 2:
                        return _tfjsCore.slice3d(e, [
                            0,
                            t,
                            0
                        ], [
                            e.shape[0],
                            n,
                            e.shape[2]
                        ]);
                    case 3:
                        return sliceAlongLastAxis(e, t, n);
                    default:
                        throw new ValueError("The axis is not within the rank of the tensor " + r);
                }
            case 4:
                switch(r){
                    case 1:
                        return sliceAlongFirstAxis(e, t, n);
                    case 2:
                        return _tfjsCore.slice4d(e, [
                            0,
                            t,
                            0,
                            0
                        ], [
                            e.shape[0],
                            n,
                            e.shape[2],
                            e.shape[3]
                        ]);
                    case 3:
                        return _tfjsCore.slice4d(e, [
                            0,
                            0,
                            t,
                            0
                        ], [
                            e.shape[0],
                            e.shape[1],
                            n,
                            e.shape[3]
                        ]);
                    case 4:
                        return sliceAlongLastAxis(e, t, n);
                    default:
                        throw new ValueError("The axis is not within the rank of the tensor " + r);
                }
            default:
                throw new ValueError("sliceAlongLastAxis() received an unsupported tensor rank: " + e.rank);
        }
    });
}
function concatenate(e, t) {
    var n;
    return void 0 === t && (t = -1), t < 0 && (t = 0 !== (n = e[0].rank) ? n : 0), t === e[0].rank && (t = -1), _tfjsCore.concat(e, t);
}
function concatAlongFirstAxis(e, t) {
    switch(e.rank){
        case 1:
            return _tfjsCore.concat1d([
                e,
                t
            ]);
        case 2:
            return _tfjsCore.concat2d([
                e,
                t
            ], 0);
        case 3:
            return _tfjsCore.concat3d([
                e,
                t
            ], 0);
        case 4:
            return _tfjsCore.concat4d([
                e,
                t
            ], 0);
        default:
            throw new ValueError("concatAlongFirstAxis() received an unsupported tensor rank: " + e.rank);
    }
}
function tile$1(e, t) {
    if (Array.isArray(t) || (t = [
        t
    ]), e.rank !== t.length) throw new ValueError("The length of input n (" + t.length + ") does not match the number of dimensions in input x (" + e.rank + ")");
    return _tfjsCore.tile(e, t);
}
function randomNormal$1(e, t, n, r, i) {
    return void 0 === t && (t = 0), void 0 === n && (n = 1), _tfjsCore.randomNormal(e, t, n, r, i);
}
function dot(e, t, n1, r) {
    if (e.rank < 2 || t.rank < 2) throw new NotImplementedError("dot requires both inputs to be rank >= 2 but got x shape = " + e.shape + " and y shape = " + t.shape);
    if (t.rank >= 3 && e.shape.slice(-1)[0] !== (c = t.shape.slice(-2)[0])) throw new NotImplementedError("If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = " + e.shape + " and  y shape = " + t.shape);
    if (2 === e.rank && 2 === t.rank) {
        var i = !1, a = !1;
        return _tfjsCore.fused.matMul({
            a: e,
            b: t,
            transposeA: i,
            transposeB: a,
            bias: r ? reshapeBias(e.rank, r, imageDataFormat()) : null,
            activation: n1
        });
    }
    var o = e.shape.slice(), s = o.pop();
    e = e.reshape([
        -1,
        s
    ]);
    var l = t.shape.slice(), u = l.pop(), c = l.pop(), p = l.concat([
        u
    ]), h = Array.from({
        length: t.rank
    }, function(e, n) {
        return 0 === n ? t.rank - 2 : n <= t.rank - 2 ? n - 1 : n;
    });
    t = t.transpose(h).reshape([
        c,
        -1
    ]);
    var d = o.concat(p);
    i = !1, a = !1;
    return _tfjsCore.fused.matMul({
        a: e,
        b: t,
        transposeA: i,
        transposeB: a,
        bias: r ? reshapeBias(e.rank, r, imageDataFormat()) : null,
        activation: n1
    }).reshape(d);
}
function gather$1(e, t, n) {
    return _tfjsCore.tidy(function() {
        return t = Array.isArray(t) ? _tfjsCore.tensor1d(t, "int32") : t.toInt(), _tfjsCore.gather(e, t, n);
    });
}
function square(e) {
    return _tfjsCore.mulStrict(e, e);
}
function reshapeBias(e, t, n) {
    var r = t.shape;
    if (1 !== t.rank && t.rank !== e) throw new ValueError("Unexpected bias dimensions: " + t.rank + "; expected it to be 1 or " + e);
    if (5 === e) {
        if ("channelsFirst" === n) return 1 === r.length ? t.reshape([
            1,
            r[0],
            1,
            1,
            1
        ]) : t.reshape([
            1,
            r[3],
            r[0],
            r[1],
            r[2]
        ]);
        if ("channelsLast" === n) return 1 === r.length ? t.reshape([
            1,
            1,
            1,
            1,
            r[0]
        ]) : t.reshape([
            1
        ].concat(r));
    } else if (4 === e) {
        if ("channelsFirst" === n) return 1 === r.length ? t.reshape([
            1,
            r[0],
            1,
            1
        ]) : t.reshape([
            1,
            r[2],
            r[0],
            r[1]
        ]);
        if ("channelsLast" === n) return 1 === r.length ? t.reshape([
            1,
            1,
            1,
            r[0]
        ]) : t.reshape([
            1
        ].concat(r));
    } else if (3 === e) {
        if ("channelsFirst" === n) return 1 === r.length ? t.reshape([
            1,
            r[0],
            1
        ]) : t.reshape([
            1,
            r[1],
            r[0]
        ]);
        if ("channelsLast" === n) return 1 === r.length ? t.reshape([
            1,
            1,
            r[0]
        ]) : t.reshape([
            1
        ].concat(r));
    } else if (e < 3) return t;
    throw new ValueError("Unsupported input rank by biasAdd: " + t.rank);
}
function biasAdd(e, t, n) {
    return _tfjsCore.tidy(function() {
        return null == n && (n = imageDataFormat()), checkDataFormat(n), e.add(reshapeBias(e.rank, t, n));
    });
}
function elu$1(e, t) {
    if (void 0 === t && (t = 1), 1 !== t) throw new NotImplementedError("Support for alpha values other than 1 (" + t + ") is not implemented yet.");
    return _tfjsCore.elu(e);
}
function softsign(e) {
    return _tfjsCore.tidy(function() {
        return _tfjsCore.div(e, _tfjsCore.abs(e).add(1));
    });
}
function dropout$1(e, t, n, r) {
    return _tfjsCore.tidy(function() {
        return _tfjsCore.dropout(e, t, n, r);
    });
}
function hardSigmoid(e) {
    return _tfjsCore.tidy(function() {
        var t = _tfjsCore.add(0.5, _tfjsCore.mul(0.2, e));
        return _tfjsCore.clipByValue(t, 0, 1);
    });
}
function inTrainPhase(e, t, n) {
    return void 0 === n && (n = !1), n ? e() : t();
}
var VALID_FAN_MODE_VALUES = [
    "fanIn",
    "fanOut",
    "fanAvg"
], VALID_DISTRIBUTION_VALUES = [
    "normal",
    "uniform",
    "truncatedNormal"
];
function checkFanMode(e) {
    checkStringTypeUnionValue(VALID_FAN_MODE_VALUES, "FanMode", e);
}
function checkDistribution(e) {
    checkStringTypeUnionValue(VALID_DISTRIBUTION_VALUES, "Distribution", e);
}
var Initializer = function(e) {
    function t() {
        return null !== e && e.apply(this, arguments) || this;
    }
    return __extends(t, e), t.prototype.fromConfigUsesCustomObjects = function() {
        return !1;
    }, t.prototype.getConfig = function() {
        return {
        };
    }, t;
}(_tfjsCore.serialization.Serializable), Zeros = function(e15) {
    function t6() {
        return null !== e15 && e15.apply(this, arguments) || this;
    }
    return __extends(t6, e15), t6.prototype.apply = function(e, t) {
        return _tfjsCore.zeros(e, t);
    }, t6.className = "Zeros", t6;
}(Initializer);
_tfjsCore.serialization.registerClass(Zeros);
var Ones = function(e16) {
    function t7() {
        return null !== e16 && e16.apply(this, arguments) || this;
    }
    return __extends(t7, e16), t7.prototype.apply = function(e, t) {
        return _tfjsCore.ones(e, t);
    }, t7.className = "Ones", t7;
}(Initializer);
_tfjsCore.serialization.registerClass(Ones);
var Constant = function(e17) {
    function t8(t) {
        var n = e17.call(this) || this;
        if ("object" != typeof t) throw new ValueError("Expected argument of type ConstantConfig but got " + t);
        if (void 0 === t.value) throw new ValueError("config must have value set but got " + t);
        return n.value = t.value, n;
    }
    return __extends(t8, e17), t8.prototype.apply = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            return _tfjsCore.mul(_tfjsCore.scalar(n.value), _tfjsCore.ones(e, t));
        });
    }, t8.prototype.getConfig = function() {
        return {
            value: this.value
        };
    }, t8.className = "Constant", t8;
}(Initializer);
_tfjsCore.serialization.registerClass(Constant);
var RandomUniform = function(e18) {
    function t9(t) {
        var n = e18.call(this) || this;
        return n.DEFAULT_MINVAL = -0.05, n.DEFAULT_MAXVAL = 0.05, n.minval = t.minval || n.DEFAULT_MINVAL, n.maxval = t.maxval || n.DEFAULT_MAXVAL, n.seed = t.seed, n;
    }
    return __extends(t9, e18), t9.prototype.apply = function(e, t) {
        return _tfjsCore.randomUniform(e, this.minval, this.maxval, t);
    }, t9.prototype.getConfig = function() {
        return {
            minval: this.minval,
            maxval: this.maxval,
            seed: this.seed
        };
    }, t9.className = "RandomUniform", t9;
}(Initializer);
_tfjsCore.serialization.registerClass(RandomUniform);
var RandomNormal = function(e19) {
    function t10(t) {
        var n = e19.call(this) || this;
        return n.DEFAULT_MEAN = 0, n.DEFAULT_STDDEV = 0.05, n.mean = t.mean || n.DEFAULT_MEAN, n.stddev = t.stddev || n.DEFAULT_STDDEV, n.seed = t.seed, n;
    }
    return __extends(t10, e19), t10.prototype.apply = function(e, t) {
        if ("float32" !== (t = t || "float32") && "int32" !== t) throw new NotImplementedError("randomNormal does not support dType " + t + ".");
        return randomNormal$1(e, this.mean, this.stddev, t, this.seed);
    }, t10.prototype.getConfig = function() {
        return {
            mean: this.mean,
            stddev: this.stddev,
            seed: this.seed
        };
    }, t10.className = "RandomNormal", t10;
}(Initializer);
_tfjsCore.serialization.registerClass(RandomNormal);
var TruncatedNormal = function(e20) {
    function t11(t) {
        var n = e20.call(this) || this;
        return n.DEFAULT_MEAN = 0, n.DEFAULT_STDDEV = 0.05, n.mean = t.mean || n.DEFAULT_MEAN, n.stddev = t.stddev || n.DEFAULT_STDDEV, n.seed = t.seed, n;
    }
    return __extends(t11, e20), t11.prototype.apply = function(e, t) {
        if ("float32" !== (t = t || "float32") && "int32" !== t) throw new NotImplementedError("truncatedNormal does not support dType " + t + ".");
        return _tfjsCore.truncatedNormal(e, this.mean, this.stddev, t, this.seed);
    }, t11.prototype.getConfig = function() {
        return {
            mean: this.mean,
            stddev: this.stddev,
            seed: this.seed
        };
    }, t11.className = "TruncatedNormal", t11;
}(Initializer);
_tfjsCore.serialization.registerClass(TruncatedNormal);
var Identity = function(e21) {
    function t12(t) {
        var n = e21.call(this) || this;
        return n.gain = null != t.gain ? t.gain : 1, n;
    }
    return __extends(t12, e21), t12.prototype.apply = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            if (2 !== e.length || e[0] !== e[1]) throw new ValueError("Identity matrix initializer can only be used for 2D square matrices.");
            return _tfjsCore.mul(n.gain, _tfjsCore.eye(e[0]));
        });
    }, t12.prototype.getConfig = function() {
        return {
            gain: this.gain
        };
    }, t12.className = "Identity", t12;
}(Initializer);
function computeFans(e, t) {
    var n, r;
    if (void 0 === t && (t = "channelsLast"), checkDataFormat(t), 2 === e.length) n = e[0], r = e[1];
    else if (-1 !== [
        3,
        4,
        5
    ].indexOf(e.length)) {
        if ("channelsFirst" === t) {
            var i = arrayProd(e, 2);
            n = e[1] * i, r = e[0] * i;
        } else if ("channelsLast" === t) {
            i = arrayProd(e, 0, e.length - 2);
            n = e[e.length - 2] * i, r = e[e.length - 1] * i;
        }
    } else {
        var a = arrayProd(e);
        n = Math.sqrt(a), r = Math.sqrt(a);
    }
    return [
        n,
        r
    ];
}
_tfjsCore.serialization.registerClass(Identity);
var VarianceScaling = function(e22) {
    function t13(t) {
        var n = e22.call(this) || this;
        if (t.scale < 0) throw new ValueError("scale must be a positive float. Got: " + t.scale);
        return n.scale = null == t.scale ? 1 : t.scale, n.mode = null == t.mode ? "fanIn" : t.mode, checkFanMode(n.mode), n.distribution = null == t.distribution ? "normal" : t.distribution, checkDistribution(n.distribution), n.seed = t.seed, n;
    }
    return __extends(t13, e22), t13.prototype.apply = function(e, t) {
        var n = computeFans(e), r = n[0], i = n[1], a = this.scale;
        if ("fanIn" === this.mode ? a /= Math.max(1, r) : "fanOut" === this.mode ? a /= Math.max(1, i) : a /= Math.max(1, (r + i) / 2), "normal" === this.distribution) {
            var o = Math.sqrt(a);
            if ("float32" !== (t = t || "float32") && "int32" !== t) throw new NotImplementedError(this.getClassName() + " does not support dType " + t + ".");
            return _tfjsCore.truncatedNormal(e, 0, o, t, this.seed);
        }
        var s = Math.sqrt(3 * a);
        return _tfjsCore.randomUniform(e, -s, s, t);
    }, t13.prototype.getConfig = function() {
        return {
            scale: this.scale,
            mode: this.mode,
            distribution: this.distribution,
            seed: this.seed
        };
    }, t13.className = "VarianceScaling", t13;
}(Initializer);
_tfjsCore.serialization.registerClass(VarianceScaling);
var GlorotUniform = function(e) {
    function t14(t) {
        return e.call(this, {
            scale: 1,
            mode: "fanAvg",
            distribution: "uniform",
            seed: null == t ? null : t.seed
        }) || this;
    }
    return __extends(t14, e), t14.prototype.getClassName = function() {
        return VarianceScaling.className;
    }, t14.className = "GlorotUniform", t14;
}(VarianceScaling);
_tfjsCore.serialization.registerClass(GlorotUniform);
var GlorotNormal = function(e) {
    function t15(t) {
        return e.call(this, {
            scale: 1,
            mode: "fanAvg",
            distribution: "normal",
            seed: null == t ? null : t.seed
        }) || this;
    }
    return __extends(t15, e), t15.prototype.getClassName = function() {
        return VarianceScaling.className;
    }, t15.className = "GlorotNormal", t15;
}(VarianceScaling);
_tfjsCore.serialization.registerClass(GlorotNormal);
var HeNormal = function(e) {
    function t16(t) {
        return e.call(this, {
            scale: 2,
            mode: "fanIn",
            distribution: "normal",
            seed: null == t ? null : t.seed
        }) || this;
    }
    return __extends(t16, e), t16.prototype.getClassName = function() {
        return VarianceScaling.className;
    }, t16.className = "HeNormal", t16;
}(VarianceScaling);
_tfjsCore.serialization.registerClass(HeNormal);
var HeUniform = function(e) {
    function t17(t) {
        return e.call(this, {
            scale: 2,
            mode: "fanIn",
            distribution: "uniform",
            seed: null == t ? null : t.seed
        }) || this;
    }
    return __extends(t17, e), t17.prototype.getClassName = function() {
        return VarianceScaling.className;
    }, t17.className = "HeUniform", t17;
}(VarianceScaling);
_tfjsCore.serialization.registerClass(HeUniform);
var LeCunNormal = function(e) {
    function t18(t) {
        return e.call(this, {
            scale: 1,
            mode: "fanIn",
            distribution: "normal",
            seed: null == t ? null : t.seed
        }) || this;
    }
    return __extends(t18, e), t18.prototype.getClassName = function() {
        return VarianceScaling.className;
    }, t18.className = "LeCunNormal", t18;
}(VarianceScaling);
_tfjsCore.serialization.registerClass(LeCunNormal);
var LeCunUniform = function(e) {
    function t19(t) {
        return e.call(this, {
            scale: 1,
            mode: "fanIn",
            distribution: "uniform",
            seed: null == t ? null : t.seed
        }) || this;
    }
    return __extends(t19, e), t19.prototype.getClassName = function() {
        return VarianceScaling.className;
    }, t19.className = "LeCunNormal", t19;
}(VarianceScaling);
_tfjsCore.serialization.registerClass(LeCunUniform);
var Orthogonal = function(e23) {
    function t20(t) {
        var n = e23.call(this) || this;
        if (n.DEFAULT_GAIN = 1, n.gain = null == t.gain ? n.DEFAULT_GAIN : t.gain, n.seed = t.seed, null != n.seed) throw new NotImplementedError("Random seed is not implemented for Orthogonal Initializer yet.");
        return n;
    }
    return __extends(t20, e23), t20.prototype.apply = function(e, t21) {
        var n = this;
        return _tfjsCore.tidy(function() {
            if (2 !== e.length) throw new NotImplementedError("The Orthogonal Initializer does not support non-2D shapes yet.");
            e[0] * e[1] > 2000 && console.warn("Orthogonal initializer is being called on a matrix with more than 2000 (" + e[0] * e[1] + ") elements: Slowness may result.");
            var t = randomNormal$1(e[0] > e[1] ? [
                e[1],
                e[0]
            ] : e, 0, 1, "float32"), r = _tfjsCore.linalg.gramSchmidt(t);
            return e[0] > e[1] && (r = r.transpose()), _tfjsCore.mul(n.gain, r);
        });
    }, t20.prototype.getConfig = function() {
        return {
            gain: this.gain,
            seed: this.seed
        };
    }, t20.className = "Orthogonal", t20;
}(Initializer);
_tfjsCore.serialization.registerClass(Orthogonal);
var INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
    constant: "Constant",
    glorotNormal: "GlorotNormal",
    glorotUniform: "GlorotUniform",
    heNormal: "HeNormal",
    heUniform: "HeUniform",
    identity: "Identity",
    leCunNormal: "LeCunNormal",
    leCunUniform: "LeCunUniform",
    ones: "Ones",
    orthogonal: "Orthogonal",
    randomNormal: "RandomNormal",
    randomUniform: "RandomUniform",
    truncatedNormal: "TruncatedNormal",
    varianceScaling: "VarianceScaling",
    zeros: "Zeros"
};
function deserializeInitializer(e, t) {
    return void 0 === t && (t = {
    }), deserializeKerasObject(e, _tfjsCore.serialization.SerializationMap.getMap().classNameMap, t, "initializer");
}
function serializeInitializer(e) {
    return serializeKerasObject(e);
}
function getInitializer(e) {
    if ("string" == typeof e) {
        var t = e in INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[e] : e;
        if ("GlorotNormal" === t) return new GlorotNormal;
        if ("GlorotUniform" === t) return new GlorotUniform;
        if ("HeNormal" === t) return new HeNormal;
        if ("HeUniform" === t) return new HeUniform;
        if ("LeCunNormal" === t) return new LeCunNormal;
        if ("LeCunUniform" === t) return new LeCunUniform;
        var n = {
        };
        return n.className = t, n.config = {
        }, deserializeInitializer(n);
    }
    return e instanceof Initializer ? e : deserializeInitializer(e);
}
function zeros$1() {
    return new Zeros;
}
function ones$1() {
    return new Ones;
}
function constant(e) {
    return new Constant(e);
}
function randomUniform$1(e) {
    return new RandomUniform(e);
}
function randomNormal$2(e) {
    return new RandomNormal(e);
}
function truncatedNormal$1(e) {
    return new TruncatedNormal(e);
}
function identity(e) {
    return new Identity(e);
}
function varianceScaling(e) {
    return new VarianceScaling(e);
}
function glorotUniform(e) {
    return new GlorotUniform(e);
}
function glorotNormal(e) {
    return new GlorotNormal(e);
}
function heNormal(e) {
    return new HeNormal(e);
}
function heUniform(e) {
    return new HeUniform(e);
}
function leCunNormal(e) {
    return new LeCunNormal(e);
}
function leCunUniform(e) {
    return new LeCunUniform(e);
}
function orthogonal(e) {
    return new Orthogonal(e);
}
var exports_initializers = Object.freeze({
    zeros: zeros$1,
    ones: ones$1,
    constant: constant,
    randomUniform: randomUniform$1,
    randomNormal: randomNormal$2,
    truncatedNormal: truncatedNormal$1,
    identity: identity,
    varianceScaling: varianceScaling,
    glorotUniform: glorotUniform,
    glorotNormal: glorotNormal,
    heNormal: heNormal,
    heUniform: heUniform,
    leCunNormal: leCunNormal,
    leCunUniform: leCunUniform,
    orthogonal: orthogonal
}), _nextUniqueTensorId = 0;
function getNextUniqueTensorId() {
    return _nextUniqueTensorId++;
}
var _uidPrefixes = {
};
function getUid(e) {
    return void 0 === e && (e = ""), e in _uidPrefixes || (_uidPrefixes[e] = 0), _uidPrefixes[e] += 1, e + _uidPrefixes[e].toString();
}
function isArrayOfShapes(e) {
    return Array.isArray(e) && Array.isArray(e[0]);
}
function normalizeShapeList(e) {
    return 0 === e.length ? [] : Array.isArray(e[0]) ? e : [
        e
    ];
}
function getExactlyOneTensor(e) {
    var t;
    if (Array.isArray(e)) {
        if (1 !== e.length) throw new ValueError("Expected Tensor length to be 1; got " + e.length);
        t = e[0];
    } else t = e;
    return t;
}
function getExactlyOneShape(e) {
    if (Array.isArray(e) && Array.isArray(e[0])) {
        if (1 === e.length) return e[0];
        throw new ValueError("Expected exactly 1 Shape; got " + e.length);
    }
    return e;
}
function countParamsInWeights(e24) {
    for(var t22 = 0, n = 0, r = e24; n < r.length; n++){
        var i = r[n];
        0 === i.shape.length ? t22 += 1 : t22 += i.shape.reduce(function(e, t) {
            return e * t;
        });
    }
    return t22;
}
var DEFAULT_VARIABLE_NAME_PREFIX = "Variable", LayerVariable = function() {
    function e25(e, t, n, r, i) {
        void 0 === t && (t = "float32"), void 0 === n && (n = DEFAULT_VARIABLE_NAME_PREFIX), void 0 === r && (r = !0), void 0 === i && (i = null), this.dtype = null == t ? "float32" : t, this.shape = e.shape, this.id = getNextUniqueTensorId(), n = null == n ? DEFAULT_VARIABLE_NAME_PREFIX : n, this.originalName = getScopedTensorName(n), this.name = getUniqueTensorName(this.originalName), this.trainable_ = r, this.constraint = i, this.val = _tfjsCore.variable(e, this.trainable_, this.name, this.dtype);
    }
    return e25.prototype.read = function() {
        return this.assertNotDisposed(), this.val;
    }, e25.prototype.write = function(e) {
        return this.assertNotDisposed(), checkShapesMatch(this.val, e), this.val.id !== e.id && (this.val.assign(e), null != this.constraint && this.val.assign(this.constraint.apply(this.val))), this;
    }, e25.prototype.dispose = function() {
        this.assertNotDisposed(), this.val.dispose();
    }, e25.prototype.assertNotDisposed = function() {
        if (this.val.isDisposed) throw new Error("LayersVariable " + this.name + " is already disposed.");
    }, Object.defineProperty(e25.prototype, "trainable", {
        get: function() {
            return this.trainable_;
        },
        set: function(e) {
            this.trainable_ = e, this.val.trainable = e;
        },
        enumerable: !0,
        configurable: !0
    }), e25;
}();
function checkShapesMatch(e, t) {
    if (e.shape.toString() !== t.shape.toString()) throw new Error("Shape mismatch: " + JSON.stringify(e.shape) + " vs. " + JSON.stringify(t.shape));
}
function batchGetValue(e26) {
    return e26.map(function(e) {
        return e.read();
    });
}
function batchSetValue(e27) {
    e27.forEach(function(e) {
        e[0].write(e[1]);
    });
}
var InputSpec = function() {
    return function(e) {
        this.dtype = e.dtype, this.shape = e.shape, null != e.shape ? this.ndim = e.shape.length : this.ndim = e.ndim, this.maxNDim = e.maxNDim, this.minNDim = e.minNDim, this.axes = e.axes || {
        };
    };
}(), SymbolicTensor = function() {
    return function(e, t, n, r, i, a, o) {
        this.dtype = e, this.shape = t, this.sourceLayer = n, this.inputs = r, this.callArgs = i, this.outputTensorIndex = o, this.id = getNextUniqueTensorId(), null != a && (this.originalName = getScopedTensorName(a), this.name = getUniqueTensorName(this.originalName)), this.rank = t.length;
    };
}(), _nextNodeID = 0, Node = function() {
    function e28(e, t) {
        this.callArgs = t, this.id = _nextNodeID++, this.outboundLayer = e.outboundLayer, this.inboundLayers = e.inboundLayers, this.nodeIndices = e.nodeIndices, this.tensorIndices = e.tensorIndices, this.inputTensors = e.inputTensors, this.outputTensors = e.outputTensors, this.inputMasks = e.inputMasks, this.outputMasks = e.outputMasks, this.inputShapes = e.inputShapes, this.outputShapes = e.outputShapes;
        for(var n = 0, r = e.inboundLayers; n < r.length; n++){
            var i = r[n];
            null != i && i.outboundNodes.push(this);
        }
        e.outboundLayer.inboundNodes.push(this);
    }
    return e28.prototype.getConfig = function() {
        for(var e = [], t = 0, n = this.inboundLayers; t < n.length; t++){
            var r = n[t];
            null != r ? e.push(r.name) : e.push(null);
        }
        return {
            outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
            inboundLayers: e,
            nodeIndices: this.nodeIndices,
            tensorIndices: this.tensorIndices
        };
    }, e28;
}(), _nextLayerID = 0, Layer = function(e29) {
    function t23(t) {
        var n = e29.call(this) || this;
        n._callHook = null, n._addedWeightNames = [], n._stateful = !1, n.id = _nextLayerID++, n.activityRegularizer = null, n.inputSpec = null, n.supportsMasking = !1, n._trainableWeights = [], n._nonTrainableWeights = [], n._losses = [], n._updates = [], n._built = !1, n.inboundNodes = [], n.outboundNodes = [];
        var r = t.name;
        if (!r) {
            var i = n.getClassName();
            r = toSnakeCase(i) + "_" + getUid(i);
        }
        if (n.name = r, n.trainable_ = null == t.trainable || t.trainable, null != t.inputShape || null != t.batchInputShape) {
            var a = void 0;
            if (null != t.batchInputShape) a = t.batchInputShape;
            else if (null != t.inputShape) {
                var o = null;
                null != t.batchSize && (o = t.batchSize), a = [
                    o
                ].concat(t.inputShape);
            }
            n.batchInputShape = a;
            var s = t.dtype;
            null == s && (s = t.inputDType), null == s && (s = "float32"), n.dtype = s;
        }
        return null != t.weights ? n.initialWeights = t.weights : n.initialWeights = null, n._refCount = null, n.fastWeightInitDuringBuild = !1, n;
    }
    return __extends(t23, e29), t23.nodeKey = function(e, t) {
        return e.name + "_ib-" + t.toString();
    }, t23.prototype.getNodeAtIndex = function(e, t) {
        if (0 === this.inboundNodes.length) throw new RuntimeError("The layer has never been called and thus has no defined " + t + ".");
        if (this.inboundNodes.length <= e) throw new ValueError("Asked to get " + t + " at node " + e + ", but the layer has only " + this.inboundNodes.length + " inbound nodes.");
        return this.inboundNodes[e];
    }, t23.prototype.getInputAt = function(e) {
        return singletonOrArray(this.getNodeAtIndex(e, "input").inputTensors);
    }, t23.prototype.getOutputAt = function(e) {
        return singletonOrArray(this.getNodeAtIndex(e, "output").outputTensors);
    }, Object.defineProperty(t23.prototype, "input", {
        get: function() {
            if (this.inboundNodes.length > 1) throw new AttributeError("Layer " + this.name + ' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');
            if (0 === this.inboundNodes.length) throw new AttributeError("Layer " + this.name + " is not connected, no input to return.");
            return singletonOrArray(this.getNodeAtIndex(0, "input").inputTensors);
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t23.prototype, "output", {
        get: function() {
            if (0 === this.inboundNodes.length) throw new AttributeError("Layer " + this.name + " has no inbound nodes.");
            if (this.inboundNodes.length > 1) throw new AttributeError("Layer " + this.name + ' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');
            return singletonOrArray(this.getNodeAtIndex(0, "output").outputTensors);
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t23.prototype, "losses", {
        get: function() {
            return this._losses;
        },
        enumerable: !0,
        configurable: !0
    }), t23.prototype.calculateLosses = function() {
        return this.losses.map(function(e) {
            return e();
        });
    }, Object.defineProperty(t23.prototype, "updates", {
        get: function() {
            return this._updates;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t23.prototype, "built", {
        get: function() {
            return this._built;
        },
        set: function(e) {
            this._built = e;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t23.prototype, "trainable", {
        get: function() {
            return this.trainable_;
        },
        set: function(e) {
            this._trainableWeights.forEach(function(t) {
                return t.trainable = e;
            }), this.trainable_ = e;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t23.prototype, "trainableWeights", {
        get: function() {
            return this.trainable_ ? this._trainableWeights.filter(function(e) {
                return e.trainable;
            }) : [];
        },
        set: function(e) {
            this._trainableWeights = e;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t23.prototype, "nonTrainableWeights", {
        get: function() {
            return this.trainable ? this._trainableWeights.filter(function(e) {
                return !e.trainable;
            }).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights);
        },
        set: function(e) {
            this._nonTrainableWeights = e;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t23.prototype, "weights", {
        get: function() {
            return this.trainableWeights.concat(this.nonTrainableWeights);
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t23.prototype, "stateful", {
        get: function() {
            return this._stateful;
        },
        enumerable: !0,
        configurable: !0
    }), t23.prototype.resetStates = function() {
        if (!this.stateful) throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
    }, t23.prototype.assertInputCompatibility = function(e) {
        if (e = toList(e), null != this.inputSpec && 0 !== this.inputSpec.length) {
            var t = toList(this.inputSpec);
            if (e.length !== t.length) throw new ValueError("Layer " + this.name + " expects " + t.length + " inputs, but it received " + e.length + " input tensors. Input received: " + e);
            for(var n = 0; n < e.length; n++){
                var r = e[n], i = t[n];
                if (null != i) {
                    var a = r.rank;
                    if (null != i.ndim && a !== i.ndim) throw new ValueError("Input " + n + " is incompatible with layer " + this.name + ": expected ndim=" + i.ndim + ", found ndim=" + a);
                    if (null != i.maxNDim && a > i.maxNDim) throw new ValueError("Input " + n + " is incompatible with layer " + this.name + ": expected max_ndim=" + i.maxNDim + ", found ndim=" + a);
                    if (null != i.minNDim && a < i.minNDim) throw new ValueError("Input " + n + " is incompatible with layer " + this.name + ": expected min_ndim=" + i.minNDim + ", found ndim=" + a + ".");
                    if (null != i.dtype && r.dtype !== i.dtype) throw new ValueError("Input " + n + " is incompatible with layer " + this.name + " : expected dtype=" + i.dtype + ", found dtype=" + r.dtype + ".");
                    if (i.axes) {
                        var o = r.shape;
                        for(var s in i.axes){
                            var l = Number(s), u = i.axes[s], c = l >= 0 ? o[l] : o[o.length + l];
                            if (null != u && -1 === [
                                u,
                                null
                            ].indexOf(c)) throw new ValueError("Input " + n + " is incompatible with layer " + this.name + ": expected axis " + l + " of input shape to have value " + u + " but got shape " + o + ".");
                        }
                    }
                    if (null != i.shape) for(var p = 0; p < i.shape.length; ++p){
                        var h = i.shape[p], d = r.shape[p];
                        if (null != h && null != d && h !== d) throw new ValueError("Input " + n + " is incompatible with layer " + this.name + ": expected shape=" + i.shape + ", found shape=" + r.shape + ".");
                    }
                }
            }
        }
    }, t23.prototype.call = function(e, t) {
        return e;
    }, t23.prototype.invokeCallHook = function(e, t) {
        null != this._callHook && this._callHook(e, t);
    }, t23.prototype.setCallHook = function(e) {
        this._callHook = e;
    }, t23.prototype.clearCallHook = function() {
        this._callHook = null;
    }, t23.prototype.apply = function(e, t) {
        var n = this;
        t = t || {
        }, this.assertNotDisposed();
        for(var r1 = toList(e), i1 = !0, a3 = 0, o1 = r1; a3 < o1.length; a3++)if (!(o1[a3] instanceof SymbolicTensor)) {
            i1 = !1;
            break;
        }
        for(var s = !0, l3 = 0, u1 = r1; l3 < u1.length; l3++)if (u1[l3] instanceof SymbolicTensor) {
            s = !1;
            break;
        }
        if (i1 === s) throw new ValueError("Arguments to apply() must be all SymbolicTensors or all Tensors");
        return nameScope(this.name, function() {
            if (!n.built) {
                n.assertInputCompatibility(e);
                for(var i = [], a = 0, o = toList(e); a < o.length; a++){
                    var l = o[a];
                    i.push(l.shape);
                }
                n.build(singletonOrArray(i)), n.built = !0, n.initialWeights && n.setWeights(n.initialWeights), null === n._refCount && s && (n._refCount = 1);
            }
            if (n.assertInputCompatibility(e), s) {
                for(var u = [], c = 0, p = toList(g = n.call(e, t)); c < p.length; c++){
                    var h = p[c];
                    -1 !== r1.indexOf(h) && (h = h.clone()), u.push(h);
                }
                if (g = singletonOrArray(u), null != n.activityRegularizer) throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
                return g;
            }
            var d = collectInputShape(e), f = n.computeOutputShape(d), g = void 0, m = guessOutputDType(e);
            if (n.warnOnIncompatibleInputShape(Array.isArray(e) ? d[0] : d), g = null != f && f.length > 0 && Array.isArray(f[0]) ? f.map(function(r, i) {
                return new SymbolicTensor(m, r, n, toList(e), t, n.name, i);
            }) : new SymbolicTensor(m, f, n, toList(e), t, n.name), n.addInboundNode(e, g, null, null, d, f, t), n._refCount++, null != n.activityRegularizer) throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
            return g;
        });
    }, t23.prototype.warnOnIncompatibleInputShape = function(e) {
        if (null != this.batchInputShape) {
            if (e.length !== this.batchInputShape.length) console.warn("The rank of the input tensor provided (shape: " + JSON.stringify(e) + ") does not match that of the batchInputShape (" + JSON.stringify(this.batchInputShape) + ") of the layer " + this.name);
            else {
                var t = !1;
                this.batchInputShape.forEach(function(n, r) {
                    null != n && null != e[r] && e[r] !== n && (t = !0);
                }), t && console.warn("The shape of the input tensor (" + JSON.stringify(e) + ") does not match the expectation of layer " + this.name + ": " + JSON.stringify(this.batchInputShape));
            }
        }
    }, Object.defineProperty(t23.prototype, "outputShape", {
        get: function() {
            if (null == this.inboundNodes || 0 === this.inboundNodes.length) throw new AttributeError("The layer " + this.name + " has never been called and thus has no defined output shape.");
            for(var e = [], t = 0, n = this.inboundNodes; t < n.length; t++){
                var r = n[t], i = JSON.stringify(r.outputShapes);
                -1 === e.indexOf(i) && e.push(i);
            }
            if (1 === e.length) {
                var a = this.inboundNodes[0].outputShapes;
                return Array.isArray(a) && Array.isArray(a[0]) && 1 === a.length ? a[0] : a;
            }
            throw new AttributeError("The layer " + this.name + ' has multiple inbound nodes with different output shapes. Hence the notion of "outut shape" is ill-defined for the layer.');
        },
        enumerable: !0,
        configurable: !0
    }), t23.prototype.countParams = function() {
        if (!this.built) throw new RuntimeError("You tried to call countParams() on " + this.name + ", but the layer is not built yet. Build it first by calling build(batchInputShape).");
        return countParamsInWeights(this.weights);
    }, t23.prototype.build = function(e) {
        this.built = !0;
    }, t23.prototype.getWeights = function(e) {
        return void 0 === e && (e = !1), batchGetValue(e ? this.trainableWeights : this.weights);
    }, t23.prototype.setWeights = function(e) {
        var t = this;
        _tfjsCore.tidy(function() {
            var n = t.weights;
            if (n.length !== e.length) throw new ValueError('You called setWeights(weights) on layer "' + t.name + '" with a weight list of length ' + e.length + ", but the layer was expecting " + n.length + " weights. Provided weights: " + e + "...");
            if (0 !== n.length) {
                for(var r = [], i = batchGetValue(n), a = 0; a < i.length; ++a){
                    var o = i[a], s = n[a], l = e[a];
                    if (!_tfjsCore.util.arraysEqual(o.shape, l.shape)) throw new ValueError("Layer weight shape " + o.shape + " not compatible with provided weight shape " + l.shape);
                    r.push([
                        s,
                        l
                    ]);
                }
                batchSetValue(r);
            }
        });
    }, t23.prototype.addWeight = function(e, t, n, r, i, a, o) {
        if (-1 !== this._addedWeightNames.indexOf(e)) throw new ValueError("Duplicate weight name " + e + " for layer " + this.name);
        this._addedWeightNames.push(e), null == n && (n = "float32"), this.fastWeightInitDuringBuild && (r = getInitializer("zeros"));
        var s = r.apply(t, n), l = new LayerVariable(s, n, e, a, o);
        return s.dispose(), null != i && this.addLoss(function() {
            return i.apply(l.read());
        }), null == a && (a = !0), a ? this._trainableWeights.push(l) : this._nonTrainableWeights.push(l), l;
    }, t23.prototype.setFastWeightInitDuringBuild = function(e) {
        this.fastWeightInitDuringBuild = e;
    }, t23.prototype.addLoss = function(e) {
        var t;
        null == e || Array.isArray(e) && 0 === e.length || (e = toList(e), void 0 !== this._losses && null !== this._losses && (t = this.losses).push.apply(t, e));
    }, t23.prototype.computeOutputShape = function(e) {
        return e;
    }, t23.prototype.computeMask = function(e30, t) {
        var n = this;
        if (!this.supportsMasking) {
            if (null != t) {
                if (!Array.isArray(t)) throw new TypeError("Layer " + this.name + " does not support masking, but was passed an inputMask.");
                t.forEach(function(e) {
                    if (null != e) throw new TypeError("Layer " + n.name + " does not support masking, but was passed an inputMask.");
                });
            }
            return null;
        }
        return t;
    }, t23.prototype.addInboundNode = function(e, t, n, r, i, a, o) {
        void 0 === o && (o = null);
        var s = toList(e);
        t = toList(t), n = toList(n), r = toList(r), i = normalizeShapeList(i), a = normalizeShapeList(a);
        for(var l = [], u = [], c = [], p = 0, h = s; p < h.length; p++){
            var d = h[p];
            l.push(d.sourceLayer), u.push(d.nodeIndex), c.push(d.tensorIndex);
        }
        new Node({
            outboundLayer: this,
            inboundLayers: l,
            nodeIndices: u,
            tensorIndices: c,
            inputTensors: s,
            outputTensors: t,
            inputMasks: n,
            outputMasks: r,
            inputShapes: i,
            outputShapes: a
        }, o);
        for(var f = 0; f < t.length; f++)t[f].sourceLayer = this, t[f].nodeIndex = this.inboundNodes.length - 1, t[f].tensorIndex = f;
    }, t23.prototype.getConfig = function() {
        var e = {
            name: this.name,
            trainable: this.trainable
        };
        return null != this.batchInputShape && (e.batchInputShape = this.batchInputShape), null != this.dtype && (e.dtype = this.dtype), e;
    }, t23.prototype.disposeWeights = function() {
        return this.weights.forEach(function(e) {
            return e.dispose();
        }), this.weights.length;
    }, t23.prototype.assertNotDisposed = function() {
        if (0 === this._refCount) throw new Error("Layer '" + this.name + "' is already disposed.");
    }, t23.prototype.dispose = function() {
        if (!this.built) throw new Error("Cannot dispose Layer " + this.name + " because it has not been built yet.");
        if (null === this._refCount) throw new Error("Cannot dispose Layer " + this.name + " because it has not been used yet.");
        this.assertNotDisposed();
        var e = 0;
        return 0 == --this._refCount && (e = this.disposeWeights()), {
            refCountAfterDispose: this._refCount,
            numDisposedVariables: e
        };
    }, t23;
}(_tfjsCore.serialization.Serializable);
function collectInputShape(e) {
    for(var t = [], n = 0, r = e = toList(e); n < r.length; n++){
        var i = r[n];
        t.push(i.shape);
    }
    return singletonOrArray(t);
}
function guessOutputDType(e) {
    return "float32";
}
function getSourceInputs(e, t, n) {
    if ((null == t || null != n && n > 0) && (t = e.sourceLayer, n = e.nodeIndex), 0 === t.inboundNodes.length) return [
        e
    ];
    var r = t.inboundNodes[n];
    if (0 === r.inboundLayers.length) return r.inputTensors;
    for(var i = [], a = 0; a < r.inboundLayers.length; a++)for(var o = 0, s = getSourceInputs(r.inputTensors[a], r.inboundLayers[a], r.nodeIndices[a]); o < s.length; o++){
        var l = s[o];
        -1 === i.indexOf(l) && i.push(l);
    }
    return i;
}
var ModelLoggingVerbosity, InputLayer = function(e) {
    function t24(t) {
        var n = e.call(this, {
            dtype: t.dtype,
            name: null != t.name ? t.name : getUid("input").toString()
        }) || this;
        if (null == t.batchSize && (t.batchSize = null), null == t.sparse && (t.sparse = !1), n.trainable = !1, n.built = !0, n.sparse = t.sparse, null != t.inputShape && null != t.batchInputShape) throw new ValueError("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
        var r = t.batchInputShape;
        if (null == r) {
            if (null == t.inputShape) throw new ValueError("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
            r = [
                t.batchSize
            ].concat(t.inputShape);
        } else if (null != t.batchSize) throw new ValueError("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
        var i = t.dtype || "float32";
        n.batchInputShape = r, n.dtype = i, n.inputSpec = [
            {
                shape: r
            }
        ];
        var a = new SymbolicTensor(n.dtype, n.batchInputShape, n, [], {
        }, n.name);
        return a.nodeIndex = 0, a.tensorIndex = 0, new Node({
            outboundLayer: n,
            inboundLayers: [],
            nodeIndices: [],
            tensorIndices: [],
            inputTensors: [
                a
            ],
            outputTensors: [
                a
            ],
            inputMasks: [
                null
            ],
            outputMasks: [
                null
            ],
            inputShapes: [
                r
            ],
            outputShapes: [
                r
            ]
        }), n;
    }
    return __extends(t24, e), t24.prototype.apply = function(e, t) {
        throw new ValueError("Cannot pass any input to an InputLayer's apply() method. InputLayer name: " + this.name);
    }, t24.prototype.dispose = function() {
        return {
            refCountAfterDispose: this._refCount,
            numDisposedVariables: 0
        };
    }, t24.prototype.getConfig = function() {
        return {
            batchInputShape: this.batchInputShape,
            dtype: this.dtype,
            sparse: this.sparse,
            name: this.name
        };
    }, t24.className = "InputLayer", t24;
}(Layer);
function Input(e) {
    if (null == e.batchShape && null == e.shape) throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
    if (null != e.batchShape && null != e.shape) throw new ValueError("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
    var t = e.batchShape;
    null != e.shape && null == t && (t = [
        null
    ].concat(e.shape));
    var n = e.dtype;
    return null == n && (n = "float32"), new InputLayer({
        batchInputShape: t,
        name: e.name,
        dtype: n,
        sparse: e.sparse
    }).inboundNodes[0].outputTensors[0];
}
function resolveScalarsInLogs(e) {
    return __awaiter(this, void 0, void 0, function() {
        var t, n, r, i, a, o, s, l;
        return __generator(this, function(u) {
            switch(u.label){
                case 0:
                    if (null == e) return [
                        2
                    ];
                    for(i in t = [], n = [], r = [], e)"number" != typeof (a = e[i]) && (o = a, t.push(o.data()), n.push(i), r.push(o));
                    return t.length > 0 ? [
                        4,
                        Promise.all(t)
                    ] : [
                        3,
                        2
                    ];
                case 1:
                    for(s = u.sent(), l = 0; l < s.length; ++l)e[n[l]] = s[l][0];
                    _tfjsCore.dispose(r), u.label = 2;
                case 2:
                    return [
                        2
                    ];
            }
        });
    });
}
function disposeTensorsInLogs(e) {
    if (null != e) for(var t in e){
        var n = e[t];
        "number" != typeof n && n.dispose();
    }
}
_tfjsCore.serialization.registerClass(InputLayer), (function(e) {
    e[e.SILENT = 0] = "SILENT", e[e.VERBOSE = 1] = "VERBOSE";
})(ModelLoggingVerbosity || (ModelLoggingVerbosity = {
}));
var DEFAULT_YIELD_EVERY_MS = 125, BaseCallback = function() {
    function e31() {
        this.validationData = null;
    }
    return e31.prototype.setParams = function(e) {
        this.params = e;
    }, e31.prototype.onEpochBegin = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(e) {
                return [
                    2
                ];
            });
        });
    }, e31.prototype.onEpochEnd = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(e) {
                return [
                    2
                ];
            });
        });
    }, e31.prototype.onBatchBegin = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(e) {
                return [
                    2
                ];
            });
        });
    }, e31.prototype.onBatchEnd = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(e) {
                return [
                    2
                ];
            });
        });
    }, e31.prototype.onTrainBegin = function(e) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(e) {
                return [
                    2
                ];
            });
        });
    }, e31.prototype.onTrainEnd = function(e) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(e) {
                return [
                    2
                ];
            });
        });
    }, e31.prototype.setModel = function(e) {
    }, e31;
}(), CallbackList = function() {
    function e32(e, t) {
        void 0 === t && (t = 10), null == e && (e = []), this.callbacks = e, this.queueLength = t;
    }
    return e32.prototype.append = function(e) {
        this.callbacks.push(e);
    }, e32.prototype.setParams = function(e) {
        for(var t = 0, n = this.callbacks; t < n.length; t++)n[t].setParams(e);
    }, e32.prototype.setModel = function(e) {
        for(var t = 0, n = this.callbacks; t < n.length; t++)n[t].setModel(e);
    }, e32.prototype.onEpochBegin = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            var n, r;
            return __generator(this, function(i) {
                switch(i.label){
                    case 0:
                        null == t && (t = {
                        }), n = 0, r = this.callbacks, i.label = 1;
                    case 1:
                        return n < r.length ? [
                            4,
                            r[n].onEpochBegin(e, t)
                        ] : [
                            3,
                            4
                        ];
                    case 2:
                        i.sent(), i.label = 3;
                    case 3:
                        return n++, [
                            3,
                            1
                        ];
                    case 4:
                        return [
                            2
                        ];
                }
            });
        });
    }, e32.prototype.onEpochEnd = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            var n, r;
            return __generator(this, function(i) {
                switch(i.label){
                    case 0:
                        null == t && (t = {
                        }), n = 0, r = this.callbacks, i.label = 1;
                    case 1:
                        return n < r.length ? [
                            4,
                            r[n].onEpochEnd(e, t)
                        ] : [
                            3,
                            4
                        ];
                    case 2:
                        i.sent(), i.label = 3;
                    case 3:
                        return n++, [
                            3,
                            1
                        ];
                    case 4:
                        return [
                            2
                        ];
                }
            });
        });
    }, e32.prototype.onBatchBegin = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            var n, r;
            return __generator(this, function(i) {
                switch(i.label){
                    case 0:
                        null == t && (t = {
                        }), n = 0, r = this.callbacks, i.label = 1;
                    case 1:
                        return n < r.length ? [
                            4,
                            r[n].onBatchBegin(e, t)
                        ] : [
                            3,
                            4
                        ];
                    case 2:
                        i.sent(), i.label = 3;
                    case 3:
                        return n++, [
                            3,
                            1
                        ];
                    case 4:
                        return [
                            2
                        ];
                }
            });
        });
    }, e32.prototype.onBatchEnd = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            var n, r;
            return __generator(this, function(i) {
                switch(i.label){
                    case 0:
                        null == t && (t = {
                        }), n = 0, r = this.callbacks, i.label = 1;
                    case 1:
                        return n < r.length ? [
                            4,
                            r[n].onBatchEnd(e, t)
                        ] : [
                            3,
                            4
                        ];
                    case 2:
                        i.sent(), i.label = 3;
                    case 3:
                        return n++, [
                            3,
                            1
                        ];
                    case 4:
                        return [
                            2
                        ];
                }
            });
        });
    }, e32.prototype.onTrainBegin = function(e) {
        return __awaiter(this, void 0, void 0, function() {
            var t, n;
            return __generator(this, function(r) {
                switch(r.label){
                    case 0:
                        null == e && (e = {
                        }), t = 0, n = this.callbacks, r.label = 1;
                    case 1:
                        return t < n.length ? [
                            4,
                            n[t].onTrainBegin(e)
                        ] : [
                            3,
                            4
                        ];
                    case 2:
                        r.sent(), r.label = 3;
                    case 3:
                        return t++, [
                            3,
                            1
                        ];
                    case 4:
                        return [
                            2
                        ];
                }
            });
        });
    }, e32.prototype.onTrainEnd = function(e) {
        return __awaiter(this, void 0, void 0, function() {
            var t, n;
            return __generator(this, function(r) {
                switch(r.label){
                    case 0:
                        null == e && (e = {
                        }), t = 0, n = this.callbacks, r.label = 1;
                    case 1:
                        return t < n.length ? [
                            4,
                            n[t].onTrainEnd(e)
                        ] : [
                            3,
                            4
                        ];
                    case 2:
                        r.sent(), r.label = 3;
                    case 3:
                        return t++, [
                            3,
                            1
                        ];
                    case 4:
                        return [
                            2
                        ];
                }
            });
        });
    }, e32;
}(), BaseLogger = function(e33) {
    function t25() {
        return e33.call(this) || this;
    }
    return __extends(t25, e33), t25.prototype.onEpochBegin = function(e) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(e) {
                return this.seen = 0, this.totals = {
                }, [
                    2
                ];
            });
        });
    }, t25.prototype.onBatchEnd = function(e34, t) {
        return __awaiter(this, void 0, void 0, function() {
            var e, n2, r, i2, a = this;
            return __generator(this, function(o2) {
                for(i2 in null == t && (t = {
                }), e = null == t.size ? 0 : t.size, this.seen += e, n2 = function(n) {
                    var i = t[n];
                    if ("number" == typeof i) r.totals.hasOwnProperty(n) || (r.totals[n] = 0), r.totals[n] = r.totals[n] + i * e;
                    else {
                        var o = void 0;
                        n in r.totals ? o = r.totals[n] : r.totals[n] = 0;
                        var s = _tfjsCore.tidy(function() {
                            return _tfjsCore.add(a.totals[n], _tfjsCore.mul(i, e));
                        });
                        r.totals[n] = s, null != o && o.dispose();
                    }
                }, r = this, t)n2(i2);
                return [
                    2
                ];
            });
        });
    }, t25.prototype.onEpochEnd = function(e35, t) {
        return __awaiter(this, void 0, void 0, function() {
            var e, n3, r, i, a, o = this;
            return __generator(this, function(s) {
                if (null != t) for(e = function(e) {
                    if (null == n3.totals[e]) return "continue";
                    "number" == typeof n3.totals[e] ? t[e] = n3.totals[e] / n3.seen : _tfjsCore.tidy(function() {
                        var n = _tfjsCore.mul(_tfjsCore.div(1, o.seen), o.totals[e]);
                        t[e] = n, o.totals[e].dispose(), _tfjsCore.keep(t[e]);
                    });
                }, n3 = this, r = 0, i = this.params.metrics; r < i.length; r++)a = i[r], e(a);
                return [
                    2
                ];
            });
        });
    }, t25;
}(BaseCallback), History = function(e36) {
    function t26() {
        return null !== e36 && e36.apply(this, arguments) || this;
    }
    return __extends(t26, e36), t26.prototype.onTrainBegin = function(e) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(e) {
                return this.epoch = [], this.history = {
                }, [
                    2
                ];
            });
        });
    }, t26.prototype.onEpochEnd = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            var n;
            return __generator(this, function(r) {
                for(n in null == t && (t = {
                }), this.epoch.push(e), t)null == this.history[n] && (this.history[n] = []), this.history[n].push(t[n]);
                return [
                    2
                ];
            });
        });
    }, t26.prototype.syncData = function() {
        return __awaiter(this, void 0, void 0, function() {
            var e, t, n, r, i, a, o, s, l;
            return __generator(this, function(u) {
                switch(u.label){
                    case 0:
                        for(r in e = [], t = [], n = [], this.history)for(i = this.history[r], a = 0; a < i.length; ++a)"number" != typeof i[a] && (o = i[a], e.push(o.data()), t.push(r), n.push(a));
                        return [
                            4,
                            Promise.all(e)
                        ];
                    case 1:
                        for(s = u.sent(), l = 0; l < s.length; ++l)this.history[t[l]][n[l]].dispose(), this.history[t[l]][n[l]] = s[l][0];
                        return [
                            2
                        ];
                }
            });
        });
    }, t26;
}(BaseCallback), CustomCallback = function(e37) {
    function t27(t, n) {
        var r = e37.call(this) || this;
        if (r.currentEpoch = 0, r.yieldEvery = n || "auto", "auto" === r.yieldEvery && (r.yieldEvery = DEFAULT_YIELD_EVERY_MS), "never" === r.yieldEvery && null != t.onYield) throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
        return _tfjsCore.util.isNumber(r.yieldEvery) && (r.maybeWait = debounce(r.maybeWait.bind(r), r.yieldEvery)), r.trainBegin = t.onTrainBegin, r.trainEnd = t.onTrainEnd, r.epochBegin = t.onEpochBegin, r.epochEnd = t.onEpochEnd, r.batchBegin = t.onBatchBegin, r.batchEnd = t.onBatchEnd, r.yield = t.onYield, r;
    }
    return __extends(t27, e37), t27.prototype.maybeWait = function(e, t, n) {
        return __awaiter(this, void 0, void 0, function() {
            var r;
            return __generator(this, function(i) {
                switch(i.label){
                    case 0:
                        return r = [], null == this.yield ? [
                            3,
                            2
                        ] : [
                            4,
                            resolveScalarsInLogs(n)
                        ];
                    case 1:
                        i.sent(), r.push(this.yield(e, t, n)), i.label = 2;
                    case 2:
                        return r.push(_tfjsCore.nextFrame()), [
                            4,
                            Promise.all(r)
                        ];
                    case 3:
                        return i.sent(), [
                            2
                        ];
                }
            });
        });
    }, t27.prototype.onEpochBegin = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(n) {
                switch(n.label){
                    case 0:
                        return this.currentEpoch = e, null == this.epochBegin ? [
                            3,
                            3
                        ] : [
                            4,
                            resolveScalarsInLogs(t)
                        ];
                    case 1:
                        return n.sent(), [
                            4,
                            this.epochBegin(e, t)
                        ];
                    case 2:
                        n.sent(), n.label = 3;
                    case 3:
                        return [
                            2
                        ];
                }
            });
        });
    }, t27.prototype.onEpochEnd = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            var n;
            return __generator(this, function(r) {
                switch(r.label){
                    case 0:
                        return n = [], null == this.epochEnd ? [
                            3,
                            2
                        ] : [
                            4,
                            resolveScalarsInLogs(t)
                        ];
                    case 1:
                        r.sent(), n.push(this.epochEnd(e, t)), r.label = 2;
                    case 2:
                        return "epoch" === this.yieldEvery && n.push(_tfjsCore.nextFrame()), [
                            4,
                            Promise.all(n)
                        ];
                    case 3:
                        return r.sent(), [
                            2
                        ];
                }
            });
        });
    }, t27.prototype.onBatchBegin = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(n) {
                switch(n.label){
                    case 0:
                        return null == this.batchBegin ? [
                            3,
                            3
                        ] : [
                            4,
                            resolveScalarsInLogs(t)
                        ];
                    case 1:
                        return n.sent(), [
                            4,
                            this.batchBegin(e, t)
                        ];
                    case 2:
                        n.sent(), n.label = 3;
                    case 3:
                        return [
                            2
                        ];
                }
            });
        });
    }, t27.prototype.onBatchEnd = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            var n;
            return __generator(this, function(r) {
                switch(r.label){
                    case 0:
                        return n = [], null == this.batchEnd ? [
                            3,
                            2
                        ] : [
                            4,
                            resolveScalarsInLogs(t)
                        ];
                    case 1:
                        r.sent(), n.push(this.batchEnd(e, t)), r.label = 2;
                    case 2:
                        return "batch" === this.yieldEvery ? n.push(_tfjsCore.nextFrame()) : _tfjsCore.util.isNumber(this.yieldEvery) && n.push(this.maybeWait(this.currentEpoch, e, t)), [
                            4,
                            Promise.all(n)
                        ];
                    case 3:
                        return r.sent(), [
                            2
                        ];
                }
            });
        });
    }, t27.prototype.onTrainBegin = function(e) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(t) {
                switch(t.label){
                    case 0:
                        return null == this.trainBegin ? [
                            3,
                            3
                        ] : [
                            4,
                            resolveScalarsInLogs(e)
                        ];
                    case 1:
                        return t.sent(), [
                            4,
                            this.trainBegin(e)
                        ];
                    case 2:
                        t.sent(), t.label = 3;
                    case 3:
                        return [
                            2
                        ];
                }
            });
        });
    }, t27.prototype.onTrainEnd = function(e) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(t) {
                switch(t.label){
                    case 0:
                        return null == this.trainEnd ? [
                            3,
                            3
                        ] : [
                            4,
                            resolveScalarsInLogs(e)
                        ];
                    case 1:
                        return t.sent(), [
                            4,
                            this.trainEnd(e)
                        ];
                    case 2:
                        t.sent(), t.label = 3;
                    case 3:
                        return [
                            2
                        ];
                }
            });
        });
    }, t27;
}(BaseCallback);
function standardizeCallbacks(e38, t) {
    return null == e38 && (e38 = {
    }), e38 instanceof BaseCallback ? [
        e38
    ] : Array.isArray(e38) && e38[0] instanceof BaseCallback ? e38 : toList(e38).map(function(e) {
        return new CustomCallback(e, t);
    });
}
var CallbackConstructorRegistry = function() {
    function e39() {
    }
    return e39.registerCallbackConstructor = function(t, n) {
        _tfjsCore.util.assert(t >= 0 && Number.isInteger(t), function() {
            return "Verbosity level is expected to be an integer >= 0, but got " + t;
        }), e39.checkForDuplicate(n), null == e39.constructors[t] && (e39.constructors[t] = []), e39.constructors[t].push(n);
    }, e39.checkForDuplicate = function(t) {
        for(var n in e39.constructors)e39.constructors[+n].forEach(function(e) {
            if (e === t) throw new ValueError("Duplicate callback constructor.");
        });
    }, e39.clear = function() {
        e39.constructors = {
        };
    }, e39.createCallbacks = function(t) {
        var n = [];
        for(var r in e39.constructors){
            var i = +r;
            t >= i && n.push.apply(n, e39.constructors[i]);
        }
        return n.map(function(e) {
            return new e;
        });
    }, e39.constructors = {
    }, e39;
}();
function configureCallbacks(e, t, n, r, i, a, o, s, l) {
    var u = new History, c = [
        new BaseLogger
    ].concat(CallbackConstructorRegistry.createCallbacks(t));
    null != e && c.push.apply(c, e), c.push(u);
    var p = new CallbackList(c);
    return p.setParams({
        epochs: n,
        initialEpoch: r,
        samples: i,
        steps: a,
        batchSize: o,
        verbose: t,
        doValidation: s,
        metrics: l
    }), {
        callbackList: p,
        history: u
    };
}
function deserialize(e, t, n) {
    return void 0 === t && (t = {
    }), void 0 === n && (n = !1), deserializeKerasObject(e, _tfjsCore.serialization.SerializationMap.getMap().classNameMap, t, "layer", n);
}
function l2Normalize(e, t) {
    return _tfjsCore.tidy(function() {
        "float32" !== e.dtype && (e = e.asType("float32"));
        var n = _tfjsCore.sum(square(e), t, !0), r = _tfjsCore.fill(n.shape, epsilon()), i = _tfjsCore.sqrt(_tfjsCore.maximum(n, r));
        return _tfjsCore.div(e, i);
    });
}
function meanSquaredError(e, t) {
    return _tfjsCore.tidy(function() {
        return _tfjsCore.mean(square(_tfjsCore.sub(t, e)), -1);
    });
}
function meanAbsoluteError(e, t) {
    return _tfjsCore.tidy(function() {
        return _tfjsCore.mean(_tfjsCore.abs(_tfjsCore.sub(t, e)), -1);
    });
}
function meanAbsolutePercentageError(e, t) {
    return _tfjsCore.tidy(function() {
        var n = _tfjsCore.sub(e, t), r = _tfjsCore.clipByValue(_tfjsCore.abs(e), epsilon(), Number.MAX_VALUE), i = _tfjsCore.abs(_tfjsCore.div(n, r));
        return _tfjsCore.mul(100, _tfjsCore.mean(i, -1));
    });
}
function meanSquaredLogarithmicError(e, t) {
    return _tfjsCore.tidy(function() {
        var n = _tfjsCore.clipByValue(t, epsilon(), Number.MAX_VALUE), r = _tfjsCore.log(_tfjsCore.add(1, n)), i = _tfjsCore.clipByValue(e, epsilon(), Number.MAX_VALUE), a = _tfjsCore.log(_tfjsCore.add(1, i));
        return _tfjsCore.mean(square(_tfjsCore.sub(r, a)), -1);
    });
}
function squaredHinge(e, t) {
    return _tfjsCore.tidy(function() {
        var n = _tfjsCore.maximum(0, _tfjsCore.sub(1, _tfjsCore.mul(e, t)));
        return _tfjsCore.mean(square(n), -1);
    });
}
function hinge(e, t) {
    return _tfjsCore.tidy(function() {
        var n = _tfjsCore.maximum(0, _tfjsCore.sub(1, _tfjsCore.mul(e, t)));
        return _tfjsCore.mean(n, -1);
    });
}
function categoricalHinge(e, t) {
    return _tfjsCore.tidy(function() {
        var n = _tfjsCore.sum(_tfjsCore.mul(e, t), -1), r = _tfjsCore.max(_tfjsCore.mul(_tfjsCore.sub(1, e), t), -1);
        return _tfjsCore.maximum(0, _tfjsCore.add(1, _tfjsCore.sub(r, n)));
    });
}
function logcosh(e, t) {
    return _tfjsCore.tidy(function() {
        var n = Math.log(2), r = _tfjsCore.sub(t, e), i = _tfjsCore.sub(_tfjsCore.add(r, _tfjsCore.softplus(_tfjsCore.mul(-2, r))), n);
        return _tfjsCore.mean(i, -1);
    });
}
function categoricalCrossentropy(e, t, n) {
    return void 0 === n && (n = !1), _tfjsCore.tidy(function() {
        if (n) t = _tfjsCore.softmax(t);
        else {
            var r = _tfjsCore.sum(t, t.shape.length - 1, !0);
            t = _tfjsCore.div(t, r);
        }
        return t = _tfjsCore.clipByValue(t, epsilon(), 1 - epsilon()), _tfjsCore.neg(_tfjsCore.sum(_tfjsCore.mul(e.toFloat(), _tfjsCore.log(t)), t.shape.length - 1));
    });
}
function sparseCategoricalCrossentropy(e, t) {
    return _tfjsCore.tidy(function() {
        var n = _tfjsCore.floor(flatten(e)).toInt(), r = (t = _tfjsCore.clipByValue(t, epsilon(), 1 - epsilon())).shape;
        return categoricalCrossentropy(_tfjsCore.oneHot(n, r[r.length - 1]).reshape(r), t, !1);
    });
}
function sigmoidCrossEntropyWithLogits(e, t) {
    if (!_tfjsCore.util.arraysEqual(e.shape, t.shape)) throw new ValueError("logits and labels must have the same shape, but got shapes " + JSON.stringify(e.shape) + " and " + JSON.stringify(t.shape));
    return _tfjsCore.tidy(function() {
        var n = t.relu(), r = t.abs().neg();
        return n.sub(t.mul(e)).add(r.exp().log1p());
    });
}
function binaryCrossentropy(e, t) {
    return _tfjsCore.tidy(function() {
        var n;
        return n = _tfjsCore.clipByValue(t, epsilon(), 1 - epsilon()), n = _tfjsCore.log(_tfjsCore.div(n, _tfjsCore.sub(1, n))), _tfjsCore.mean(sigmoidCrossEntropyWithLogits(e, n), -1);
    });
}
function kullbackLeiblerDivergence(e, t) {
    return _tfjsCore.tidy(function() {
        var n = _tfjsCore.clipByValue(e, epsilon(), 1), r = _tfjsCore.clipByValue(t, epsilon(), 1);
        return _tfjsCore.sum(_tfjsCore.mul(e, _tfjsCore.log(_tfjsCore.div(n, r))), -1);
    });
}
function poisson(e, t) {
    return _tfjsCore.tidy(function() {
        var n = _tfjsCore.log(_tfjsCore.add(epsilon(), t));
        return _tfjsCore.mean(_tfjsCore.sub(t, _tfjsCore.mul(e, n)), -1);
    });
}
function cosineProximity(e, t) {
    return _tfjsCore.tidy(function() {
        var n = l2Normalize(e, -1), r = l2Normalize(t, -1), i = _tfjsCore.mul(n, r);
        return _tfjsCore.neg(_tfjsCore.sum(i, -1));
    });
}
var lossesMap = {
    meanSquaredError: meanSquaredError,
    meanAbsoluteError: meanAbsoluteError,
    meanAbsolutePercentageError: meanAbsolutePercentageError,
    meanSquaredLogarithmicError: meanSquaredLogarithmicError,
    squaredHinge: squaredHinge,
    hinge: hinge,
    categoricalHinge: categoricalHinge,
    logcosh: logcosh,
    categoricalCrossentropy: categoricalCrossentropy,
    sparseCategoricalCrossentropy: sparseCategoricalCrossentropy,
    binaryCrossentropy: binaryCrossentropy,
    kullbackLeiblerDivergence: kullbackLeiblerDivergence,
    poisson: poisson,
    cosineProximity: cosineProximity
};
function get(e) {
    if ("string" == typeof e) {
        if (e in lossesMap) return lossesMap[e];
        var t = "Unknown loss " + e;
        throw e.toLowerCase().includes("softmaxcrossentropy") && (t = "Unknown loss " + e + '. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'), new ValueError(t);
    }
    return e;
}
function binaryAccuracy(e, t) {
    return _tfjsCore.tidy(function() {
        var n = _tfjsCore.mul(0.5, _tfjsCore.onesLike(t)), r = cast$1(_tfjsCore.greater(t, n), e.dtype);
        return _tfjsCore.mean(_tfjsCore.equal(e, r), -1);
    });
}
function categoricalAccuracy(e, t) {
    return _tfjsCore.tidy(function() {
        return cast$1(_tfjsCore.equal(_tfjsCore.argMax(e, -1), _tfjsCore.argMax(t, -1)), "float32");
    });
}
function truePositives(e, t) {
    return _tfjsCore.tidy(function() {
        return _tfjsCore.logicalAnd(e.equal(1), t.equal(1)).sum().cast("float32");
    });
}
function falseNegatives(e, t) {
    return _tfjsCore.tidy(function() {
        return _tfjsCore.logicalAnd(e.equal(1), t.equal(0)).sum().cast("float32");
    });
}
function falsePositives(e, t) {
    return _tfjsCore.tidy(function() {
        return _tfjsCore.logicalAnd(e.equal(0), t.equal(1)).sum().cast("float32");
    });
}
function precision(e, t) {
    return _tfjsCore.tidy(function() {
        var n = truePositives(e, t), r = falsePositives(e, t), i = n.add(r);
        return _tfjsCore.where(_tfjsCore.greater(i, 0), n.div(i), 0).cast("float32");
    });
}
function recall(e, t) {
    return _tfjsCore.tidy(function() {
        var n = truePositives(e, t), r = falseNegatives(e, t), i = n.add(r);
        return _tfjsCore.where(_tfjsCore.greater(i, 0), n.div(i), 0).cast("float32");
    });
}
function binaryCrossentropy$1(e, t) {
    return binaryCrossentropy(e, t);
}
function sparseCategoricalAccuracy(e, t) {
    return e.rank === t.rank && (e = e.squeeze([
        e.rank - 1
    ])), (t = t.argMax(-1)).dtype !== e.dtype && (t = t.asType(e.dtype)), _tfjsCore.equal(e, t).asType("float32");
}
var mse$1 = meanSquaredError, MSE$1 = meanSquaredError, mae$1 = meanAbsoluteError, MAE$1 = meanAbsoluteError, mape$1 = meanAbsolutePercentageError, MAPE$1 = meanAbsolutePercentageError, categoricalCrossentropy$1 = categoricalCrossentropy, cosine$1 = cosineProximity, sparseCategoricalCrossentropy$1 = sparseCategoricalCrossentropy, metricsMap = {
    binaryAccuracy: binaryAccuracy,
    categoricalAccuracy: categoricalAccuracy,
    precision: precision,
    categoricalCrossentropy: categoricalCrossentropy$1,
    sparseCategoricalCrossentropy: sparseCategoricalCrossentropy$1,
    mse: mse$1,
    MSE: MSE$1,
    mae: mae$1,
    MAE: MAE$1,
    mape: mape$1,
    MAPE: MAPE$1,
    cosine: cosine$1
};
function get$1(e) {
    if ("string" == typeof e && e in metricsMap) return metricsMap[e];
    if ("string" != typeof e && null != e) return e;
    throw new ValueError("Unknown metric " + e);
}
function getLossOrMetricName(e) {
    if (assert(null !== e, "Unknown LossOrMetricFn " + e), "string" == typeof e) return e;
    for(var t = void 0, n = 0, r = Object.keys(lossesMap); n < r.length; n++){
        var i = r[n];
        if (lossesMap[i] === e) {
            t = i;
            break;
        }
    }
    if (void 0 !== t) return t;
    for(var a = 0, o = Object.keys(metricsMap); a < o.length; a++){
        i = o[a];
        if (metricsMap[i] === e) {
            t = i;
            break;
        }
    }
    return void 0 !== t ? t : e.name;
}
function getOptimizer(e) {
    var t = {
        Adagrad: function() {
            return _tfjsCore.train.adagrad(0.01);
        },
        Adadelta: function() {
            return _tfjsCore.train.adadelta(1, 0.95, epsilon());
        },
        Adam: function() {
            return _tfjsCore.train.adam(0.001, 0.9, 0.999, epsilon());
        },
        Adamax: function() {
            return _tfjsCore.train.adamax(0.002, 0.9, 0.999, epsilon(), 0);
        },
        RMSProp: function() {
            return _tfjsCore.train.rmsprop(0.001, 0.9, 0, epsilon());
        },
        SGD: function() {
            return _tfjsCore.train.sgd(0.01);
        }
    };
    if (t.adagrad = t.Adagrad, t.adadelta = t.Adadelta, t.adam = t.Adam, t.adamax = t.Adamax, t.rmsprop = t.RMSProp, t.sgd = t.SGD, e in t) return t[e]();
    throw new ValueError("Unknown Optimizer " + e);
}
var MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH = 1048576;
function checkUserDefinedMetadata(e, t, n) {
    if (void 0 === n && (n = !1), null == e || "object" != typeof e || Object.getPrototypeOf(e) !== Object.prototype || !plainObjectCheck(e)) throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
    if (n) {
        var r = JSON.stringify(e);
        r.length > MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH && console.warn('User-defined metadata of model "' + t + '" is too large in size (length=' + r.length + " when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= " + MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH + ".");
    }
}
function plainObjectCheck(e) {
    if (null === e) return !0;
    if ("object" == typeof e) {
        if (Object.getPrototypeOf(e) === Object.prototype) {
            for(var t = 0, n = Object.keys(e); t < n.length; t++){
                var r = n[t];
                if ("string" != typeof r) return !1;
                if (!plainObjectCheck(e[r])) return !1;
            }
            return !0;
        }
        if (Array.isArray(e)) {
            for(var i = 0, a = e; i < a.length; i++){
                if (!plainObjectCheck(a[i])) return !1;
            }
            return !0;
        }
        return !1;
    }
    var o = typeof e;
    return "string" === o || "number" === o || "boolean" === o;
}
function printSummary(e40, t, n, r) {
    void 0 === r && (r = console.log);
    var i, a = isModelSequentialLike(e40), o = [
        "Layer (type)",
        "Output shape",
        "Param #"
    ];
    if (a ? (t = t || 65, n = n || [
        0.45,
        0.85,
        1
    ]) : (t = t || 98, n = n || [
        0.33,
        0.55,
        0.67,
        1
    ]), n[n.length - 1] <= 1 && (n = n.map(function(e) {
        return Math.floor(t * e);
    })), !a) for(var s in o.push("Receives inputs"), i = [], e40.nodesByDepth)i.push.apply(i, e40.nodesByDepth[s]);
    r("_".repeat(t)), printRow(o, n, r), r("=".repeat(t));
    for(var l = e40.layers, u = 0; u < l.length; ++u)a ? printLayerSummary(l[u], n, r) : printLayerSummaryWithConnections(l[u], n, i, r), r((u === l.length - 1 ? "=" : "_").repeat(t));
    e40.checkTrainableWeightsConsistency();
    var c = countTrainableParams(e40), p = countParamsInWeights(e40.nonTrainableWeights);
    r("Total params: " + (c + p)), r("Trainable params: " + c), r("Non-trainable params: " + p), r("_".repeat(t));
}
function countTrainableParams(e) {
    return null != e.collectedTrainableWeights ? countParamsInWeights(e.collectedTrainableWeights) : countParamsInWeights(e.trainableWeights);
}
function isModelSequentialLike(e) {
    var t = !0, n = [], r = [];
    for(var i in e.nodesByDepth)n.push(e.nodesByDepth[i]);
    for(var a = 0, o = n; a < o.length; a++){
        var s = o[a];
        if (s.length > 1 || 1 === s.length && s[0].inboundLayers.length > 1) {
            t = !1;
            break;
        }
        r.push.apply(r, s);
    }
    if (t) for(var l = 0, u = e.layers; l < u.length; l++){
        for(var c = !1, p = 0, h = u[l].inboundNodes; p < h.length; p++){
            var d = h[p];
            if (-1 !== r.indexOf(d)) {
                if (c) {
                    t = !1;
                    break;
                }
                c = !0;
            }
        }
        if (!t) break;
    }
    return t;
}
function printRow(e, t, n) {
    void 0 === n && (n = console.log);
    for(var r = "", i = 0; i < e.length; ++i)i > 0 && (r = r.slice(0, r.length - 1) + " "), r = (r += e[i]).slice(0, t[i]), r += " ".repeat(t[i] - r.length);
    n(r);
}
function printLayerSummary(e, t, n) {
    var r;
    try {
        r = JSON.stringify(e.outputShape);
    } catch (e41) {
        r = "multiple";
    }
    printRow([
        e.name + " (" + e.getClassName() + ")",
        r,
        e.countParams().toString()
    ], t, n);
}
function printLayerSummaryWithConnections(e, t, n, r) {
    var i;
    try {
        i = JSON.stringify(e.outputShape);
    } catch (e42) {
        i = "multiple";
    }
    for(var a = [], o = 0, s = e.inboundNodes; o < s.length; o++){
        var l = s[o];
        if (!(null != n && n.length > 0 && -1 === n.indexOf(l))) for(var u = 0; u < l.inboundLayers.length; ++u){
            var c = l.inboundLayers[u].name, p = l.nodeIndices[u], h = l.tensorIndices[u];
            a.push(c + "[" + p + "][" + h + "]");
        }
    }
    var d = e.name, f = e.getClassName(), g = 0 === a.length ? "" : a[0];
    printRow([
        d + " (" + f + ")",
        i,
        e.countParams().toString(),
        g
    ], t, r);
    for(u = 1; u < a.length; ++u)printRow([
        "",
        "",
        "",
        a[u]
    ], t, r);
}
function isArrayItemInputOrOutputName(e, t, n) {
    return ("inboundNodes" === e || "outputLayers" === e || "inputLayers" === e) && 0 === t && "string" == typeof n;
}
function convertPythonicToTs(e, t) {
    if (null === e) return null;
    if ("string" == typeof e) return toCamelCase(e);
    if ("number" == typeof e || "boolean" == typeof e) return e;
    if (e instanceof Array) {
        for(var n = [], r = e.length, i = 0; i < r; ++i){
            var a = e[i];
            isArrayItemInputOrOutputName(t, i, a) ? n.push(a) : n.push(convertPythonicToTs(a, t));
        }
        return n;
    }
    for(var o = {
    }, s = 0, l = Object.keys(e); s < l.length; s++){
        var u = l[s], c = e[u];
        if ("name" === u && "string" == typeof c) o[u] = c;
        else {
            var p = toCamelCase(u);
            o[p] = convertPythonicToTs(c, p);
        }
    }
    return o;
}
function convertTsToPythonic(e, t) {
    if (null === e || void 0 === e) return null;
    if ("string" == typeof e) return toSnakeCase(e);
    if ("number" == typeof e || "boolean" == typeof e) return e;
    if (e instanceof Array) {
        for(var n = [], r = e.length, i = 0; i < r; ++i){
            var a = e[i];
            isArrayItemInputOrOutputName(t, i, a) ? n.push(a) : n.push(convertTsToPythonic(a, t));
        }
        return n;
    }
    for(var o = {
    }, s = 0, l = Object.keys(e); s < l.length; s++){
        var u = l[s], c = e[u], p = toSnakeCase(u);
        o[p] = "name" !== u && "className" !== u || "string" != typeof c ? convertTsToPythonic(c, u) : c;
    }
    return o;
}
var version = "1.7.4";
function assertFeedCompatibility(e, t) {
    if (null == e.dtype || e.dtype === t.dtype) return t;
    try {
        return _tfjsCore.cast(t, e.dtype);
    } catch (n) {
        throw new ValueError("The dtype of the feed (" + t.dtype + ") can not be cast to the dtype of the key '" + e.name + "' (" + e.dtype + ").");
    }
}
var FeedDict = function() {
    function e43(t) {
        if (this.id2Value = {
        }, this.id2Mask = {
        }, this.name2Id = {
        }, t instanceof e43) for(var n in t.id2Value)this.id2Value[n] = t.id2Value[n], n in t.id2Mask && (this.id2Mask[n] = t.id2Mask[n]);
        else {
            if (null == t) return;
            for(var r = 0, i = t; r < i.length; r++){
                var a = i[r];
                this.add(a.key, a.value);
            }
        }
    }
    return e43.prototype.add = function(e, t, n) {
        if (null != this.id2Value[e.id]) throw new ValueError("Duplicate key: name=" + e.name + ", id=" + e.id);
        return this.id2Value[e.id] = assertFeedCompatibility(e, t), this.name2Id[e.name] = e.id, null != n && (this.id2Mask[e.id] = n), this;
    }, e43.prototype.addFeed = function(e) {
        this.add(e.key, e.value);
    }, e43.prototype.hasKey = function(e) {
        return null != this.id2Value[e.id];
    }, e43.prototype.names = function() {
        return Object.keys(this.name2Id);
    }, e43.prototype.getValue = function(e) {
        if (e instanceof SymbolicTensor) {
            if (null == this.id2Value[e.id]) throw new ValueError("Nonexistent key: " + e.name);
            return this.id2Value[e.id];
        }
        var t = this.name2Id[e];
        if (null == t) throw new ValueError("Feed dict has no SymbolicTensor name: " + e);
        return this.id2Value[t];
    }, e43.prototype.getMask = function(e) {
        if (e instanceof SymbolicTensor) {
            if (null == this.id2Value[e.id]) throw new ValueError("Nonexistent key: " + e.name);
            return this.id2Mask[e.id];
        }
        var t = this.name2Id[e];
        if (null == t) throw new ValueError("Feed dict has no SymbolicTensor name: " + e);
        return this.id2Mask[t];
    }, e43.prototype.disposeMasks = function() {
        null != this.id2Mask && _tfjsCore.dispose(this.id2Mask);
    }, e43;
}(), cachedSorted = {
}, cachedRecipientCounts = {
};
function execute(e44, t, n, r) {
    for(var i = null != n && n.training, a = Array.isArray(e44), o = a ? e44 : [
        e44
    ], s = o.map(function(e) {
        return e.name;
    }), l = [], u = t.names(), c = 0, p = s; c < p.length; c++){
        var h = p[c];
        -1 !== u.indexOf(h) ? l.push(t.getValue(h)) : l.push(null);
    }
    null != r && (r.maxNumTensors = -1 / 0, r.minNumTensors = 1 / 0);
    var d, f, g = s.join(",") + "|" + t.names().join(",");
    if (null == cachedSorted[g]) {
        var m = getTopologicalSortAndRecipientCounts(o, t);
        d = m.sorted, f = m.recipientCounts, cachedSorted[g] = d, cachedRecipientCounts[g] = f;
    }
    d = cachedSorted[g], f = {
    }, i || Object.assign(f, cachedRecipientCounts[g]);
    for(var y = new FeedDict(t), v = 0; v < d.length; ++v){
        if (null != r) {
            var b = _tfjsCore.memory().numTensors;
            b > r.maxNumTensors && (r.maxNumTensors = b), b < r.minNumTensors && (r.minNumTensors = b);
        }
        var w = d[v], z = w.sourceLayer;
        if (!(z instanceof InputLayer)) {
            for(var S = [], A = [], _ = [], I = !1, C = 0, E = w.inputs; C < E.length; C++){
                var N = E[C], k = y.getValue(N), x = y.getMask(N);
                S.push(k), A.push(x), null != x && (I = !0), i || (f[N.name]--, 0 !== f[N.name] || t.hasKey(N) || -1 !== s.indexOf(N.name) || k.isDisposed || !0 === N.sourceLayer.stateful || _.push(k));
            }
            I && ((n = n || {
            }).mask = A[0]);
            var L = toList(z.apply(S, n)), T = null;
            z.supportsMasking && (T = z.computeMask(S, A));
            for(var D = getNodeOutputs(w), O = Array.isArray(D) ? D : [
                D
            ], R = 0; R < O.length; ++R){
                y.hasKey(O[R]) || y.add(O[R], L[R], Array.isArray(T) ? T[0] : T);
                var M = s.indexOf(O[R].name);
                -1 !== M && (l[M] = L[R]);
            }
            i || _tfjsCore.dispose(_);
        }
    }
    return y.disposeMasks(), a ? l : l[0];
}
function getTopologicalSortAndRecipientCounts(e, t28) {
    _tfjsCore.util.assert(null != e && e.length > 0, function() {
        return "Expected at least one fetch, got none";
    });
    var n = [], r = {
    };
    if (1 === e.length) {
        var i = getTopologicalSortAndRecipientCountsForOneFetch(e[0], t28);
        n = i.sorted, r = i.recipientMap;
    } else for(var a = new Set, o = 0, s = e; o < s.length; o++){
        for(var l = getTopologicalSortAndRecipientCountsForOneFetch(s[o], t28), u = l.sorted, c = l.recipientMap, p = 0, h = u; p < h.length; p++){
            var d = h[p];
            a.has(d.name) || (n.push(d), a.add(d.name));
        }
        var f = function(e) {
            null == r[e] && (r[e] = new Set), c[e].forEach(function(t) {
                return r[e].add(t);
            });
        };
        for(var g in c)f(g);
    }
    return {
        sorted: n,
        recipientCounts: recipientMap2Counts(r)
    };
}
function recipientMap2Counts(e) {
    var t = {
    };
    for(var n in e)t[n] = e[n].size;
    return t;
}
function getTopologicalSortAndRecipientCountsForOneFetch(e, t) {
    for(var n = new Set, r = [], i = {
    }, a = 0, o = t.names(); a < o.length; a++){
        var s = o[a];
        n.add(s);
    }
    var l = [], u = [];
    for(l.push(e); l.length > 0;){
        var c = l[l.length - 1];
        if (n.has(c.name)) l.pop();
        else {
            var p = u[u.length - 1] === l.length - 1;
            if (0 === c.inputs.length || p) l.pop(), r.push(c), n.add(c.name), p && u.pop();
            else {
                u.push(l.length - 1);
                for(var h = 0, d = c.inputs; h < d.length; h++){
                    var f = d[h];
                    null == i[f.name] && (i[f.name] = new Set), i[f.name].add(c.name), n.has(f.name) || l.push(f);
                }
            }
        }
    }
    return {
        sorted: r,
        recipientMap: i
    };
}
function getNodeOutputs(e) {
    var t;
    if (1 === e.sourceLayer.inboundNodes.length) t = e.sourceLayer.output;
    else {
        for(var n = null, r = 0; r < e.sourceLayer.inboundNodes.length; ++r)for(var i = 0, a = e.sourceLayer.inboundNodes[r].outputTensors; i < a.length; i++)if (a[i].id === e.id) {
            n = r;
            break;
        }
        t = e.sourceLayer.getOutputAt(n);
    }
    return t;
}
var Container = function(e45) {
    function t29(n4) {
        var r2 = e45.call(this, {
        }) || this;
        if (r2.containerNodes = new Set, r2.name = n4.name, null == r2.name) {
            var i = r2.getClassName().toLowerCase();
            r2.name = getUid(i);
        }
        if (r2.supportsMasking = !1, r2.trainable_ = !0, Array.isArray(n4.inputs) ? r2.inputs = n4.inputs.slice() : r2.inputs = [
            n4.inputs
        ], Array.isArray(n4.outputs) ? r2.outputs = n4.outputs.slice() : r2.outputs = [
            n4.outputs
        ], unique(r2.inputs).length !== r2.inputs.length) throw new ValueError("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: " + r2.inputs.map(function(e) {
            return e.name;
        }));
        unique(r2.outputs).length !== r2.outputs.length && console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: " + r2.outputs.map(function(e) {
            return e.name;
        })), r2.inputLayers = [], r2.inputLayersNodeIndices = [], r2.inputLayersTensorIndices = [], r2.outputLayers = [], r2.outputLayersNodeIndices = [], r2.outputLayersTensorIndices = [], r2.layers = [], r2.internalContainerRefs = [];
        for(var a4 = 0, o3 = r2.outputs; a4 < o3.length; a4++){
            var s = (C = o3[a4]).sourceLayer, l = C.nodeIndex, u = C.tensorIndex;
            r2.outputLayers.push(s), r2.outputLayersNodeIndices.push(l), r2.outputLayersTensorIndices.push(u);
        }
        for(var c1 = 0, p1 = r2.inputs; c1 < p1.length; c1++){
            s = (C = p1[c1]).sourceLayer, l = C.nodeIndex, u = C.tensorIndex;
            assert(0 === l, "input layer has >1 nodes"), assert(0 === u, "input layer has >1 tensors"), r2.inputLayers.push(s), r2.inputLayersNodeIndices.push(l), r2.inputLayersTensorIndices.push(u);
        }
        r2.inputNames = [], r2.outputNames = [], r2.feedInputShapes = [], r2.feedInputNames = [], r2.feedOutputNames = [];
        for(var h1 = 0; h1 < r2.inputLayers.length; h1++){
            if (!((s = r2.inputLayers[h1]) instanceof InputLayer)) throw new TypeError("Input layers to a LayersModel must be InputLayer objects. Received inputs: " + n4.inputs + ". Input " + h1 + " (0-based) originates from layer type " + s.getClassName() + ".");
            r2.inputNames.push(s.name), r2.feedInputShapes.push(s.batchInputShape), r2.feedInputNames.push(s.name);
        }
        for(var d1 = 0, f1 = r2.outputLayers; d1 < f1.length; d1++){
            s = f1[d1];
            r2.outputNames.push(s.name);
        }
        r2.internalInputShapes = r2.inputs.map(function(e) {
            return e.shape;
        }), r2.internalOutputShapes = r2.outputs.map(function(e) {
            return e.shape;
        });
        for(var g = {
        }, m = {
        }, y = {
        }, v = {
        }, b = {
        }, w = [], z = function(e, n, i, a, o, s) {
            null != a && null != o && null != s || (a = e.sourceLayer, o = e.nodeIndex, s = e.tensorIndex);
            var l = a.inboundNodes[o];
            if (-1 !== i.indexOf(l)) throw new RuntimeError("The tensor " + e.name + ' at layer "' + a.name + '" is part of a cycle.');
            if (-1 === n.indexOf(l)) {
                r2.containerNodes.add(t29.nodeKey(a, o)), (a.id in b) || (b[a.id] = Object.keys(b).length), -1 === i.indexOf(l) && i.push(l);
                for(var u = l.inboundLayers.length, c = 0; c < u; c++){
                    var p = l.inputTensors[c], h = l.inboundLayers[c], d = l.nodeIndices[c], f = l.tensorIndices[c];
                    z(p, n, i, h, d, f);
                }
                for(n.push(l); i.indexOf(l) >= 0;)i.splice(i.indexOf(l), 1);
                w.push(l);
            }
        }, S = [], A = [], _ = 0, I = r2.outputs; _ < I.length; _++){
            var C = I[_];
            z(C, S, A);
        }
        for(var E = 0, N = w.slice().reverse(); E < N.length; E++){
            m[(K = N[E]).id] = K, K.id in g || (g[K.id] = 0);
            var k = g[K.id], x = null == y[K.outboundLayer.id] ? 0 : y[K.outboundLayer.id];
            k = Math.max(k, x), y[K.outboundLayer.id] = k, v[K.outboundLayer.id] = K.outboundLayer, g[K.id] = k;
            for(h1 = 0; h1 < K.inboundLayers.length; h1++){
                var L = K.inboundLayers[h1], T = (l = K.nodeIndices[h1], L.inboundNodes[l]), D = null == g[T.id] ? 0 : g[T.id];
                g[T.id] = Math.max(k + 1, D), m[T.id] = T;
            }
        }
        var O = {
        };
        for(var R in g)(k = g[R]) in O || (O[k] = []), O[k].push(m[R]);
        var M = {
        };
        for(var P in y)(k = y[P]) in M || (M[k] = []), M[k].push(v[P]);
        var F = Object.keys(M).map(function(e) {
            return parseInt(e, 10);
        }).sort(reverseNumberCompare);
        r2.layers = [];
        for(var V = 0, B = F; V < B.length; V++){
            var U = M[k = B[V]];
            U.sort(function(e, t) {
                var n = b[e.id], r = b[t.id];
                return n < r ? -1 : n > r ? 1 : 0;
            });
            for(var j = 0, W = U; j < W.length; j++)(s = W[j]) instanceof t29 && r2.internalContainerRefs.push(s), r2.layers.push(s);
        }
        r2.layersByDepth = M, F = Object.keys(O).map(function(e) {
            return parseInt(e, 10);
        }).sort(reverseNumberCompare);
        for(var $ = r2.inputs.slice(), q = [], G = 0, H = F; G < H.length; G++)for(var J = 0, Z = O[k = H[G]]; J < Z.length; J++){
            var K;
            if (null != (s = (K = Z[J]).outboundLayer)) {
                for(var Y = 0, X = K.inputTensors; Y < X.length; Y++){
                    C = X[Y];
                    if (-1 === $.indexOf(C)) throw new RuntimeError("Graph disconnected: cannot obtain value for tensor " + C + ' at layer "' + s.name + '". The following previous layers were accessed without issue: ' + q);
                }
                for(var Q = 0, ee = K.outputTensors; Q < ee.length; Q++){
                    C = ee[Q];
                    $.push(C);
                }
                q.push(s.name);
            }
        }
        r2.nodesByDepth = O;
        for(var te = r2.layers.map(function(e) {
            return e.name;
        }), ne = function(e) {
            var t30 = te.filter(function(t) {
                return t === e;
            }).length;
            if (1 !== t30) throw new RuntimeError('The name "' + e + '" is used ' + t30 + " times in the model. All layer names should be unique. Layer names: " + JSON.stringify(te));
        }, re = 0, ie = te; re < ie.length; re++)ne(ie[re]);
        return r2.outboundNodes = [], r2.inboundNodes = [], new Node({
            outboundLayer: r2,
            inboundLayers: [],
            nodeIndices: [],
            tensorIndices: [],
            inputTensors: r2.inputs,
            outputTensors: r2.outputs,
            inputMasks: r2.inputs.map(function(e) {
                return null;
            }),
            outputMasks: r2.outputs.map(function(e) {
                return null;
            }),
            inputShapes: r2.inputs.map(function(e) {
                return e.shape;
            }),
            outputShapes: r2.outputs.map(function(e) {
                return e.shape;
            })
        }), r2.built = !0, r2._refCount = 1, r2;
    }
    return __extends(t29, e45), t29.prototype.assertNotDisposed = function() {
        if (0 === this._refCount) throw new Error("Container '" + this.name + "' is already disposed.");
    }, t29.prototype.dispose = function() {
        this.assertNotDisposed();
        var e = {
            refCountAfterDispose: null,
            numDisposedVariables: 0
        };
        if (0 == --this._refCount) {
            for(var t = 0, n = this.layers; t < n.length; t++){
                var r = n[t];
                e.numDisposedVariables += r.dispose().numDisposedVariables;
            }
            for(var i = 0, a = this.internalContainerRefs; i < a.length; i++){
                var o = a[i];
                e.numDisposedVariables += o.dispose().numDisposedVariables;
            }
        }
        return e.refCountAfterDispose = this._refCount, e;
    }, Object.defineProperty(t29.prototype, "trainable", {
        get: function() {
            return this.trainable_;
        },
        set: function(e) {
            this.layers.forEach(function(t31) {
                t31._trainableWeights.forEach(function(t) {
                    return t.trainable = e;
                });
            }), this.trainable_ = e;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t29.prototype, "trainableWeights", {
        get: function() {
            if (this._trainableWeights.length > 0) throw new ValueError("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
            if (!this.trainable) return [];
            for(var e = [], t = 0, n = this.layers; t < n.length; t++){
                var r = n[t];
                e = e.concat(r.trainableWeights);
            }
            return e;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t29.prototype, "nonTrainableWeights", {
        get: function() {
            for(var e = [], t = 0, n = this.layers; t < n.length; t++){
                var r = n[t];
                e.push.apply(e, r.nonTrainableWeights);
            }
            if (!this.trainable) {
                for(var i = [], a = 0, o = this.layers; a < o.length; a++){
                    r = o[a];
                    i.push.apply(i, r.trainableWeights);
                }
                return i.concat(e);
            }
            return e;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t29.prototype, "weights", {
        get: function() {
            return this.trainableWeights.concat(this.nonTrainableWeights);
        },
        enumerable: !0,
        configurable: !0
    }), t29.prototype.loadWeights = function(e, t) {
        void 0 === t && (t = !0);
        for(var n = {
        }, r = 0, i = 0, a = this.layers; i < a.length; i++)for(var o = 0, s = a[i].weights; o < s.length; o++){
            var l = s[o];
            if (null != n[l.originalName]) throw new ValueError("Duplicate weight name: " + l.originalName);
            n[l.originalName] = l, r++;
        }
        var u = [];
        for(var c in e){
            if (null != n[c]) u.push([
                n[c],
                e[c]
            ]);
            else if (t) throw new ValueError("Provided weight data has no target variable: " + c);
            delete n[c];
        }
        if (t) {
            var p = [];
            for(var h in n)p.push(h);
            if (p.length > 0) throw new ValueError(p.length + " of " + r + " weights are not set: " + p);
        }
        batchSetValue(u);
    }, t29.prototype.updatedConfig = function() {
        var e = this.getConfig(), t = {
        };
        return t.className = this.getClassName(), t.config = e, t.kerasVersion = "tfjs-layers " + version, t.backend = "TensorFlow.js", t;
    }, t29.prototype.toJSON = function(e, t) {
        void 0 === t && (t = !0);
        var n = convertTsToPythonic(this.updatedConfig());
        return t ? JSON.stringify(n) : n;
    }, t29.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            e = toList(e);
            for(var r = new FeedDict, i = 0; i < n.inputs.length; ++i)r.add(n.inputs[i], e[i]);
            return execute(n.outputs, r, t);
        });
    }, t29.prototype.computeMask = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            var r;
            return e = toList(e), r = null == t ? pyListRepeat(null, e.length) : toList(t), n.runInternalGraph(e, r)[1];
        });
    }, t29.prototype.computeOutputShape = function(e46) {
        var t = normalizeShapeList(e46);
        if (t.length !== this.inputLayers.length) throw new ValueError("Invalid inputShape argument " + e46 + ": model has " + this.inputLayers.length + " tensor inputs.");
        for(var n = {
        }, r = 0; r < t.length; r++){
            var i = this.inputLayers[r], a = t[r];
            n[A = i.name + "_0_0"] = a;
        }
        var o = Object.keys(this.nodesByDepth).map(function(e) {
            return parseInt(e, 10);
        }).sort(reverseNumberCompare);
        if (o.length > 1) for(var s = 0, l = o; s < l.length; s++)for(var u = l[s], c = 0, p = this.nodesByDepth[u]; c < p.length; c++){
            var h = p[c];
            i = h.outboundLayer;
            if (-1 === this.inputLayers.map(function(e) {
                return e.id;
            }).indexOf(i.id)) {
                for(var d = [], f = 0; f < h.inboundLayers.length; f++){
                    var g = h.inboundLayers[f], m = h.nodeIndices[f], y = h.tensorIndices[f], v = n[A = g.name + "_" + m + "_" + y];
                    d.push(v);
                }
                var b = normalizeShapeList(i.computeOutputShape(singletonOrArray(d))), w = i.inboundNodes.indexOf(h);
                for(f = 0; f < b.length; f++)n[A = i.name + "_" + w + "_" + f] = b[f];
            }
        }
        var z = [], S = [];
        for(r = 0; r < this.outputLayers.length; r++){
            i = this.outputLayers[r], w = this.outputLayersNodeIndices[r], y = this.outputLayersTensorIndices[r];
            var A = i.name + "_" + w + "_" + y;
            S.push(A);
        }
        for(r = 0; r < S.length; r++){
            var _ = S[r];
            assert(_ in n), z.push(n[_]);
        }
        return singletonOrArray(z);
    }, t29.prototype.runInternalGraph = function(e47, t) {
        null == t && (t = pyListRepeat(null, e47.length));
        for(var n = {
        }, r = 0; r < this.inputs.length; ++r){
            var i = this.inputs[r], a = e47[r], o = t[r];
            n[i.id] = [
                a,
                o
            ];
        }
        for(var s = 0, l = Object.keys(this.nodesByDepth).map(function(e) {
            return parseInt(e, 10);
        }).sort(reverseNumberCompare); s < l.length; s++)for(var u = l[s], c = 0, p = this.nodesByDepth[u]; c < p.length; c++){
            for(var h = p[c], d = h.outboundLayer, f = h.inputTensors, g = h.outputTensors, m = new Array, y = 0, v = f; y < v.length; y++)(i = v[y]).id in n && m.push(n[i.id]);
            if (m.length === f.length) {
                var b = {
                }, w = void 0, z = void 0, S = void 0, A = void 0;
                if (null != h.callArgs && (b = h.callArgs), 1 === m.length) {
                    var _ = m[0], I = _[0], C = _[1];
                    null == b.mask && (b.mask = C), S = toList(d.call(I, b)), A = toList(d.computeMask(I, C)), w = [
                        I
                    ], z = [
                        C
                    ];
                } else w = m.map(function(e) {
                    return e[0];
                }), z = m.map(function(e) {
                    return e[1];
                }), null == b.mask && (b.mask = z), S = toList(d.call(w, b)), A = toList(d.computeMask(w, z));
                if (d.activityRegularizer) throw new NotImplementedError("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
                for(r = 0; r < g.length; ++r){
                    i = g[r], a = S[r], o = A[r];
                    n[i.id] = [
                        a,
                        o
                    ];
                }
            }
        }
        for(var E = [], N = [], k = [], x = 0, L = this.outputs; x < L.length; x++){
            assert((i = L[x]).id in n, "Could not compute output " + i.name + " : " + i.id);
            var T = n[i.id], D = T[0];
            o = T[1];
            k.push(D.shape), E.push(D), N.push(o);
        }
        return [
            E,
            N,
            k
        ];
    }, t29.prototype.buildNodeConversionMap = function(e) {
        for(var n, r = {
        }, i = 0, a = this.layers; i < a.length; i++){
            var o = a[i];
            n = o instanceof t29 ? 1 : 0;
            for(var s = 0; s < o.inboundNodes.length; s++){
                var l = t29.nodeKey(o, s);
                this.containerNodes.has(l) && (r[l] = n, n += 1);
            }
        }
        return r;
    }, t29.prototype.getLayer = function(e, t) {
        if (null != t) {
            if (this.layers.length <= t) throw new ValueError("Was asked to retrieve layer at index " + t + ", but model only has " + this.layers.length + " layer(s).");
            return this.layers[t];
        }
        if (null == e) throw new ValueError("Provide either a layer name or layer index");
        for(var n = 0, r = this.layers; n < r.length; n++){
            var i = r[n];
            if (i.name === e) return i;
        }
        throw new ValueError("No such layer: " + e);
    }, t29.prototype.calculateLosses = function() {
        var e = this;
        return _tfjsCore.tidy(function() {
            for(var n = [], r = 0, i = e.layers; r < i.length; r++)for(var a = i[r], o = 0; o < a.inboundNodes.length; ++o){
                var s = t29.nodeKey(a, o);
                e.containerNodes.has(s) && n.push.apply(n, a.calculateLosses());
            }
            return n;
        });
    }, t29.prototype.getConfig = function() {
        for(var e = {
            name: this.name
        }, n = this.buildNodeConversionMap(this.layers), r = [], i = 0, a = this.layers; i < a.length; i++){
            for(var o = (w = a[i]).getClassName(), s = w.getConfig(), l = [], u = 0; u < w.inboundNodes.length; u++){
                var c = w.inboundNodes[u], p = t29.nodeKey(w, u), h = {
                };
                if (this.containerNodes.has(p)) {
                    if (c.callArgs) try {
                        JSON.stringify(c.callArgs), h = c.callArgs;
                    } catch (e) {
                        console.warn("Layer " + w.name + " was passed non-serializable keyword arguments: " + c.callArgs + ". They will not be included in the serialized model (and thus will be missing at deserialization time)."), h = {
                        };
                    }
                    if (c.inboundLayers.length > 0) {
                        for(var d = [], f = 0; f < c.inboundLayers.length; f++){
                            var g = c.inboundLayers[f], m = c.nodeIndices[f], y = c.tensorIndices[f];
                            null == (S = n[t29.nodeKey(g, m)]) && (S = 0), d.push([
                                g.name,
                                S,
                                y,
                                h
                            ]);
                        }
                        l.push(d);
                    }
                }
            }
            var v = {
            };
            v.name = w.name, v.className = o, v.config = s, v.inboundNodes = l, r.push(v);
        }
        e.layers = r;
        var b = [];
        for(f = 0; f < this.inputLayers.length; f++){
            var w = this.inputLayers[f];
            m = this.inputLayersNodeIndices[f], p = t29.nodeKey(w, m);
            if (this.containerNodes.has(p)) {
                null !== (S = n[p]) && void 0 !== S || (S = 0);
                y = this.inputLayersTensorIndices[f];
                b.push([
                    w.name,
                    S,
                    y
                ]);
            }
        }
        e.inputLayers = b;
        var z = [];
        for(f = 0; f < this.outputLayers.length; f++){
            w = this.outputLayers[f], m = this.outputLayersNodeIndices[f], p = t29.nodeKey(w, m);
            if (this.containerNodes.has(p)) {
                var S;
                null !== (S = n[p]) && void 0 !== S || (S = 0);
                y = this.outputLayersTensorIndices[f];
                z.push([
                    w.name,
                    S,
                    y
                ]);
            }
        }
        return e.outputLayers = z, e;
    }, t29.fromConfig = function(e48, t32, n5, r3) {
        void 0 === n5 && (n5 = {
        }), void 0 === r3 && (r3 = !1);
        var i = {
        }, a5 = {
        };
        function o(e, t) {
            e.name in a5 ? a5[e.name].push(t) : a5[e.name] = [
                t
            ];
        }
        function s2(e, t) {
            for(var n, r = [], a = 0, s = t; a < s.length; a++){
                var l = s[a], u = l[0], c = l[1], p = l[2];
                if (n = null == l[3] ? {
                } : l[3], !(u in i)) return void o(e, t);
                var h = i[u];
                if (h.inboundNodes.length <= c) return void o(e, t);
                var d = h.inboundNodes[c];
                r.push(d.outputTensors[p]);
            }
            r.length > 0 && e.apply(singletonOrArray(r), n);
        }
        function l4(e49) {
            var n = e49.name, a = deserialize(e49, null != t32.customObjects ? t32.customObjects : {
            });
            a.setFastWeightInitDuringBuild(r3), i[n] = a, e49.inboundNodes.forEach(function(e) {
                if (!(e instanceof Array)) throw new ValueError("Corrupted configuration, expected array for nodeData: " + e);
                o(a, e);
            });
        }
        for(var u2 = t32.name, c2 = t32.layers, p = 0, h2 = c2; p < h2.length; p++)l4(g = h2[p]);
        for(; !isObjectEmpty(a5);)for(var d2 = 0, f = c2; d2 < f.length; d2++){
            var g = f[d2];
            if ((k = i[g.name]).name in a5) {
                var m = a5[k.name];
                delete a5[k.name];
                for(var y = 0, v = m; y < v.length; y++)s2(k, v[y]);
            }
        }
        for(var b = [], w = [], z = 0, S = t32.inputLayers; z < S.length; z++){
            var A = (g = S[z])[0], _ = g[1], I = g[2];
            assert(A in i);
            var C = (k = i[A]).inboundNodes[_].outputTensors;
            b.push(C[I]);
        }
        for(var E = 0, N = t32.outputLayers; E < N.length; E++){
            A = (g = N[E])[0], _ = g[1], I = g[2];
            assert(A in i);
            var k;
            C = (k = i[A]).inboundNodes[_].outputTensors;
            w.push(C[I]);
        }
        return new e48({
            inputs: b,
            outputs: w,
            name: u2
        });
    }, Object.defineProperty(t29.prototype, "stateful", {
        get: function() {
            if (this._stateful) throw new ValueError("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
            for(var e = 0, t = this.layers; e < t.length; e++){
                if (t[e].stateful) return !0;
            }
            return !1;
        },
        enumerable: !0,
        configurable: !0
    }), t29.prototype.resetStates = function() {
        var e50 = this;
        _tfjsCore.tidy(function() {
            e50.layers.forEach(function(e) {
                e.stateful && e.resetStates();
            });
        });
    }, t29;
}(Layer);
function standardizeSampleOrClassWeights(e, t33, n) {
    var r = t33.length;
    if (null == e || Array.isArray(e) && 0 === e.length) return t33.map(function(e) {
        return null;
    });
    if (1 === r) return Array.isArray(e) && 1 === e.length ? e : "object" == typeof e && t33[0] in e ? [
        e[t33[0]]
    ] : [
        e
    ];
    if (Array.isArray(e)) {
        if (e.length !== r) throw new Error("Provided " + n + " is an array of " + e.length + " element(s), but the model has " + r + " outputs. Make sure a set of weights is provided for each model output.");
        return e;
    }
    if ("object" == typeof e && Object.keys(e).length > 0 && "object" == typeof e[Object.keys(e)[0]]) {
        var i = [];
        return t33.forEach(function(t) {
            t in e ? i.push(e[t]) : i.push(null);
        }), i;
    }
    throw new Error("The model has multiple (" + r + ") outputs, so " + n + " must be either an array with " + r + " elements or an object with " + t33 + " keys. Provided " + n + " not understood: " + JSON.stringify(e));
}
function standardizeClassWeights(e, t) {
    return standardizeSampleOrClassWeights(e, t, "classWeight");
}
function standardizeWeights(e51, t, n, r) {
    return __awaiter(this, void 0, void 0, function() {
        var i, a, o, s, l;
        return __generator(this, function(u) {
            switch(u.label){
                case 0:
                    if (null != t || null != r) throw new Error("Support sampleWeight is not implemented yet");
                    return null == n ? [
                        3,
                        2
                    ] : (i = _tfjsCore.tidy(function() {
                        if (1 === e51.shape.length) return e51.clone();
                        if (2 === e51.shape.length) {
                            if (e51.shape[1] > 1) return e51.argMax(1);
                            if (1 === e51.shape[1]) return e51.reshape([
                                e51.shape[0]
                            ]);
                            throw new Error("Encountered unexpected last-dimension size (" + e51.shape[1] + ") during handling of class weights. The size is expected to be >= 1.");
                        }
                        throw new Error("Unexpected rank of target (y) tensor (" + e51.rank + ") during handling of class weights. The rank is expected to be 1 or 2.");
                    }), s = (o = Array).from, [
                        4,
                        i.data()
                    ]);
                case 1:
                    return a = s.apply(o, [
                        u.sent()
                    ]), _tfjsCore.dispose(i), l = [], a.forEach(function(e) {
                        if (null == n[e]) throw new Error("classWeight must contain all classes in the training data. The class " + e + " exists in the data but not in classWeight");
                        l.push(n[e]);
                    }), [
                        2,
                        _tfjsCore.tensor1d(l, "float32")
                    ];
                case 2:
                    return [
                        2,
                        null
                    ];
            }
        });
    });
}
function computeWeightedLoss(e, t) {
    return _tfjsCore.mul(e, t);
}
var DEFAULT_VALIDATION_BATCH_SIZE = 32;
function standardizeDataIteratorOutput(e, t) {
    var n, r, i = t;
    n = i.xs, r = i.ys, _tfjsCore.util.assert(null != n && null != r, function() {
        return "A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates " + t;
    });
    var a = flattenTensorOrArrayOrMap("input", e.inputNames, n), o = flattenTensorOrArrayOrMap("output", e.outputNames, r), s = a[0].shape[0];
    _tfjsCore.util.assert(a.length === e.inputs.length, function() {
        return "LayersModel has " + e.inputs.length + " inputs, but the dataset provides " + a.length + " inputs.  (Expected input keys: " + JSON.stringify(e.inputNames) + ")";
    }), _tfjsCore.util.assert(o.length === e.outputs.length, function() {
        return "LayersModel has " + e.outputs.length + " outputs, but the dataset provides " + o.length + " outputs.  (Expected output keys: " + JSON.stringify(e.outputNames) + ")";
    });
    for(var l = function(t) {
        _tfjsCore.util.assert(a[t].shape[0] === s, function() {
            return "Batch size mismatch: input " + e.inputNames[t] + " has " + a[t].shape[0] + "; expected  " + s + " based on input " + e.inputNames[0] + ".";
        });
    }, u = 0; u < a.length; u++)l(u);
    for(var c = function(t) {
        _tfjsCore.util.assert(o[t].shape[0] === s, function() {
            return "Batch size mismatch: output " + e.outputNames[t] + " has " + o[t].shape[0] + "; expected  " + s + " based on input " + e.inputNames[0] + ".";
        });
    }, p = 0; p < o.length; p++)c(p);
    return {
        xs: a,
        ys: o
    };
}
function flattenTensorOrArrayOrMap(e, t, n) {
    if (n instanceof _tfjsCore.Tensor) return [
        n
    ];
    if (Array.isArray(n)) return _tfjsCore.util.assert(n.length === t.length, function() {
        return "Received an array of " + n.length + " Tensors, but expected " + t.length + " to match the " + e + " keys " + t + ".";
    }), n;
    for(var r = [], i = 0, a = t; i < a.length; i++){
        var o = a[i];
        if (null == n[o]) throw new ValueError("The feature data generated by the dataset lacks the required " + e + " key '" + o + "'.");
        r.push(n[o]);
    }
    return r;
}
function standardizeTensorValidationData(e) {
    if (3 === e.length) throw new NotImplementedError("Validation with sample weights is not implemented yet.");
    return {
        xs: e[0],
        ys: e[1]
    };
}
function fitDataset(e52, t, n) {
    return __awaiter(this, void 0, void 0, function() {
        var r, i, a, o, s, l, u, c, p, h, d, f, g, m, y, v, b, w, z, S, A, _, I, C, E, N, k, x, L, T, D, O, R, M;
        return __generator(this, function(P) {
            switch(P.label){
                case 0:
                    if (r = null != n.batchesPerEpoch, _tfjsCore.util.assert(null != e52.optimizer, function() {
                        return "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).";
                    }), _tfjsCore.util.assert(null != n, function() {
                        return "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.";
                    }), _tfjsCore.util.assert(null != n.epochs && n.epochs > 0 && Number.isInteger(n.epochs), function() {
                        return "For fitDataset(), config.epochs is expected to be a positive integer, but got " + n.epochs;
                    }), _tfjsCore.util.assert(!r || n.batchesPerEpoch > 0 && Number.isInteger(n.batchesPerEpoch), function() {
                        return "For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got " + n.batchesPerEpoch;
                    }), _tfjsCore.util.assert(null == n.validationSplit, function() {
                        return "`validationSplit` is not supported by `fitDataset()`. Use validationData instead.";
                    }), e52.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
                    e52.isTraining = !0, P.label = 1;
                case 1:
                    return P.trys.push([
                        1,
                        ,
                        26,
                        27
                    ]), i = null != n.validationData, a = void 0, o = void 0, i && (isDatasetObject(n.validationData) ? _tfjsCore.util.assert(null == n.validationBatches || n.validationBatches > 0 && Number.isInteger(n.validationBatches), function() {
                        return "For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got " + n.validationBatches;
                    }) : (s = standardizeTensorValidationData(n.validationData), a = s.xs, o = s.ys)), l = e52.makeTrainFunction(), u = e52.getDedupedMetricsNames(), c = void 0, c = i ? u.slice().concat(u.map(function(e) {
                        return "val_" + e;
                    })) : u.slice(), p = standardizeCallbacks(n.callbacks, n.yieldEvery), h = null == n.verbose ? 1 : n.verbose, d = configureCallbacks(p, h, n.epochs, null, null, getStepsPerEpoch(t, n), null, i, c), f = d.callbackList, g = d.history, f.setModel(e52), e52.history = g, [
                        4,
                        f.onTrainBegin()
                    ];
                case 2:
                    return P.sent(), e52.stopTraining_ = !1, m = null == n.initialEpoch ? 0 : n.initialEpoch, [
                        4,
                        t.iterator()
                    ];
                case 3:
                    y = P.sent(), P.label = 4;
                case 4:
                    return m < n.epochs ? (v = {
                    }, [
                        4,
                        f.onEpochBegin(m)
                    ]) : [
                        3,
                        23
                    ];
                case 5:
                    return P.sent(), b = 0, w = 0, r ? [
                        3,
                        7
                    ] : [
                        4,
                        t.iterator()
                    ];
                case 6:
                    y = P.sent(), P.label = 7;
                case 7:
                    return !r || b < n.batchesPerEpoch ? [
                        4,
                        y.next()
                    ] : [
                        3,
                        21
                    ];
                case 8:
                    return z = P.sent(), r && z.done ? (console.warn("You provided `batchesPerEpoch` as " + n.batchesPerEpoch + ", but your dataset iterator ran out of data after " + b + " batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, " + n.batchesPerEpoch * n.epochs + " batches). You may need to use the repeat() function when building your dataset."), [
                        3,
                        21
                    ]) : null == z.value ? [
                        3,
                        15
                    ] : (S = standardizeDataIteratorOutput(e52, z.value), A = S.xs, _ = S.ys, (I = {
                    }).batch = w, I.size = A[0].shape[0], [
                        4,
                        f.onBatchBegin(w, I)
                    ]);
                case 9:
                    if (P.sent(), C = [], null == n.classWeight) return [
                        3,
                        13
                    ];
                    E = standardizeClassWeights(n.classWeight, e52.outputNames), M = 0, P.label = 10;
                case 10:
                    return M < E.length ? (k = (N = C).push, [
                        4,
                        standardizeWeights(_[M], null, E[M])
                    ]) : [
                        3,
                        13
                    ];
                case 11:
                    k.apply(N, [
                        P.sent()
                    ]), P.label = 12;
                case 12:
                    return ++M, [
                        3,
                        10
                    ];
                case 13:
                    for(x = A.concat(_).concat(C), L = l(x), _tfjsCore.dispose(x), M = 0; M < u.length; ++M)T = u[M], D = L[M], I[T] = D, _tfjsCore.keep(D);
                    return [
                        4,
                        f.onBatchEnd(w, I)
                    ];
                case 14:
                    P.sent(), disposeTensorsInLogs(I), w++, b++, P.label = 15;
                case 15:
                    return (r ? b >= n.batchesPerEpoch : z.done) ? i ? (O = void 0, isDatasetObject(n.validationData) ? (R = toList, [
                        4,
                        e52.evaluateDataset(n.validationData, {
                            batches: n.validationBatches
                        })
                    ]) : [
                        3,
                        17
                    ]) : [
                        3,
                        19
                    ] : [
                        3,
                        20
                    ];
                case 16:
                    return O = R.apply(void 0, [
                        P.sent()
                    ]), [
                        3,
                        18
                    ];
                case 17:
                    O = toList(e52.evaluate(a, o, {
                        batchSize: null == n.validationBatchSize ? DEFAULT_VALIDATION_BATCH_SIZE : n.validationBatchSize,
                        verbose: 0
                    })), P.label = 18;
                case 18:
                    for(M = 0; M < e52.metricsNames.length; ++M)v["val_" + e52.metricsNames[M]] = O[M];
                    P.label = 19;
                case 19:
                    return [
                        3,
                        21
                    ];
                case 20:
                    return e52.stopTraining_ ? [
                        3,
                        21
                    ] : [
                        3,
                        7
                    ];
                case 21:
                    return [
                        4,
                        f.onEpochEnd(m, v)
                    ];
                case 22:
                    return P.sent(), m++, e52.stopTraining_ ? [
                        3,
                        23
                    ] : [
                        3,
                        4
                    ];
                case 23:
                    return [
                        4,
                        f.onTrainEnd()
                    ];
                case 24:
                    return P.sent(), [
                        4,
                        e52.history.syncData()
                    ];
                case 25:
                    return P.sent(), [
                        2,
                        e52.history
                    ];
                case 26:
                    return e52.isTraining = !1, [
                        7
                    ];
                case 27:
                    return [
                        2
                    ];
            }
        });
    });
}
function getStepsPerEpoch(e, t) {
    var n = null;
    return null != t.batchesPerEpoch ? n = t.batchesPerEpoch : Number.isFinite(e.size) && (n = e.size), n;
}
function isDatasetObject(e) {
    return "function" == typeof e.iterator;
}
function isLazyIteratorObject(e) {
    return "function" == typeof e.next;
}
function evaluateDataset(e, t34, n6) {
    return __awaiter(this, void 0, void 0, function() {
        var r4, i, a, o4, s3, l, u, c3, p2, h3;
        return __generator(this, function(d3) {
            switch(d3.label){
                case 0:
                    if (r4 = null != (n6 = n6 || {
                    }).batches, i = e.testFunction, a = [], n6.verbose > 0) throw new NotImplementedError("Verbose mode is not implemented yet.");
                    return _tfjsCore.util.assert(!r4 || n6.batches > 0 && Number.isInteger(n6.batches), function() {
                        return "Test loop expects `batches` to be a positive integer, but received " + JSON.stringify(n6.batches);
                    }), isLazyIteratorObject(t34) ? (s3 = t34, [
                        3,
                        3
                    ]) : [
                        3,
                        1
                    ];
                case 1:
                    return [
                        4,
                        t34.iterator()
                    ];
                case 2:
                    s3 = d3.sent(), d3.label = 3;
                case 3:
                    o4 = s3, l = 0, u = 0, c3 = function() {
                        var t35;
                        return __generator(this, function(s4) {
                            switch(s4.label){
                                case 0:
                                    return [
                                        4,
                                        o4.next()
                                    ];
                                case 1:
                                    return t35 = s4.sent(), a = _tfjsCore.tidy(function() {
                                        if (t35.value) {
                                            var n7 = standardizeDataIteratorOutput(e, t35.value), r = n7.xs, o = n7.ys, s = r.concat(o), c = _tfjsCore.tidy(function() {
                                                return i(s);
                                            });
                                            if (_tfjsCore.dispose(s), 0 === u) for(var p = 0; p < c.length; ++p)a.push(_tfjsCore.scalar(0));
                                            var h = s[0].shape[0], d = function(e) {
                                                var t = c[e], n = a[e];
                                                a[e] = _tfjsCore.tidy(function() {
                                                    return _tfjsCore.add(a[e], _tfjsCore.mul(h, t));
                                                }), u > 0 && _tfjsCore.dispose(n);
                                            };
                                            for(p = 0; p < c.length; ++p)d(p);
                                            _tfjsCore.dispose(c), l += h, ++u;
                                        }
                                        return a;
                                    }), t35.done ? (r4 && console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, " + n6.batches + " batches). You may need to use the repeat() function when building your dataset."), [
                                        2,
                                        "break"
                                    ]) : [
                                        2
                                    ];
                            }
                        });
                    }, d3.label = 4;
                case 4:
                    return !r4 || u < n6.batches ? [
                        5,
                        c3()
                    ] : [
                        3,
                        6
                    ];
                case 5:
                    return "break" === d3.sent() ? [
                        3,
                        6
                    ] : [
                        3,
                        4
                    ];
                case 6:
                    for(p2 = 0; p2 < a.length; ++p2)h3 = a[p2], a[p2] = _tfjsCore.div(a[p2], l), _tfjsCore.dispose(h3);
                    return [
                        2,
                        singletonOrArray(a)
                    ];
            }
        });
    });
}
function checkBatchSize(e) {
    _tfjsCore.util.assert(e > 0 && Number.isInteger(e), function() {
        return "batchSize is required to be a positive integer, but got " + e;
    });
}
function sliceArrays(e53, t, n) {
    return null == e53 ? [
        null
    ] : Array.isArray(e53) ? e53.map(function(e) {
        return sliceAlongFirstAxis(e, t, n - t);
    }) : sliceAlongFirstAxis(e53, t, n - t);
}
function sliceArraysByIndices(e54, t) {
    return _tfjsCore.tidy(function() {
        return null == e54 ? null : Array.isArray(e54) ? e54.map(function(e) {
            return sliceArraysByIndices(e, t);
        }) : gather$1(e54, "int32" === t.dtype ? t : t.toInt());
    });
}
function makeBatches(e, t) {
    for(var n = [], r = 0, i = null; r < e;)(i = r + t) >= e && (i = e), n.push([
        r,
        i
    ]), r = i;
    return n;
}
function fitLoop(e, t, n, r, i, a6, o5, s5, l, u, c4, p3, h4, d4, f2) {
    return __awaiter(this, void 0, void 0, function() {
        var g, m1, y1, v1, b1, w1, z1, S;
        return __generator(this, function(A) {
            switch(A.label){
                case 0:
                    if (null == i && (i = 32), null == a6 && (a6 = 1), null == c4 && (c4 = !0), null == h4 && (h4 = 0), g = !1, null != l && null != u && (g = !0), null != f2 && (g = !0, null == d4)) throw new ValueError("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
                    return null != (m1 = e.checkNumSamples(n, i, d4, "steps_per_epoch")) && (y1 = range(0, m1)), null == o5 && (o5 = 1), v1 = configureCallbacks(s5, o5, a6, h4, m1, d4, i, g, p3), b1 = v1.callbackList, w1 = v1.history, b1.setModel(e), e.history = w1, [
                        4,
                        b1.onTrainBegin()
                    ];
                case 1:
                    A.sent(), e.stopTraining_ = !1, z1 = function(a7) {
                        var o, s, p, h5, f3;
                        return __generator(this, function(v2) {
                            switch(v2.label){
                                case 0:
                                    return [
                                        4,
                                        b1.onEpochBegin(a7)
                                    ];
                                case 1:
                                    if (v2.sent(), o = {
                                    }, null == d4) return [
                                        3,
                                        2
                                    ];
                                    throw new NotImplementedError("stepsPerEpoch mode is not implemented yet.");
                                case 2:
                                    if ("batch" === c4) throw new NotImplementedError("batch shuffling is not implemneted yet");
                                    c4 && _tfjsCore.util.shuffle(y1), s = _tfjsCore.tensor1d(y1), p = makeBatches(m1, i), h5 = function(a) {
                                        var c;
                                        return __generator(this, function(h6) {
                                            switch(h6.label){
                                                case 0:
                                                    return c = {
                                                    }, [
                                                        4,
                                                        b1.onBatchBegin(a, c)
                                                    ];
                                                case 1:
                                                    return h6.sent(), _tfjsCore.tidy(function() {
                                                        var h = p[a][0], d = p[a][1], f = sliceAlongFirstAxis(s, h, d - h);
                                                        c.batch = a, c.size = d - h;
                                                        for(var m = sliceArraysByIndices(n, f), y = t(m), v = 0; v < r.length; ++v){
                                                            var b = r[v], w = y[v];
                                                            c[b] = w, _tfjsCore.keep(w);
                                                        }
                                                        if (a === p.length - 1 && g) {
                                                            var z = e.testLoop(l, u, i);
                                                            for(v = 0; v < r.length; ++v){
                                                                b = r[v], w = z[v];
                                                                _tfjsCore.keep(w), o["val_" + b] = w;
                                                            }
                                                        }
                                                    }), [
                                                        4,
                                                        b1.onBatchEnd(a, c)
                                                    ];
                                                case 2:
                                                    return h6.sent(), disposeTensorsInLogs(c), e.stopTraining_ ? [
                                                        2,
                                                        "break"
                                                    ] : [
                                                        2
                                                    ];
                                            }
                                        });
                                    }, f3 = 0, v2.label = 3;
                                case 3:
                                    return f3 < p.length ? [
                                        5,
                                        h5(f3)
                                    ] : [
                                        3,
                                        6
                                    ];
                                case 4:
                                    if ("break" === v2.sent()) return [
                                        3,
                                        6
                                    ];
                                    v2.label = 5;
                                case 5:
                                    return ++f3, [
                                        3,
                                        3
                                    ];
                                case 6:
                                    s.dispose(), v2.label = 7;
                                case 7:
                                    return [
                                        4,
                                        b1.onEpochEnd(a7, o)
                                    ];
                                case 8:
                                    return v2.sent(), e.stopTraining_ ? [
                                        2,
                                        "break"
                                    ] : [
                                        2
                                    ];
                            }
                        });
                    }, S = h4, A.label = 2;
                case 2:
                    return S < a6 ? [
                        5,
                        z1(S)
                    ] : [
                        3,
                        5
                    ];
                case 3:
                    if ("break" === A.sent()) return [
                        3,
                        5
                    ];
                    A.label = 4;
                case 4:
                    return ++S, [
                        3,
                        2
                    ];
                case 5:
                    return [
                        4,
                        b1.onTrainEnd()
                    ];
                case 6:
                    return A.sent(), [
                        4,
                        e.history.syncData()
                    ];
                case 7:
                    return A.sent(), [
                        2,
                        e.history
                    ];
            }
        });
    });
}
function fitTensors(e55, t, n, r) {
    return void 0 === r && (r = {
    }), __awaiter(this, void 0, void 0, function() {
        var i, a, o, s, l, u, c, p, h, d, f, g, m, y, v, b, w, z, S, A, _, I;
        return __generator(this, function(C) {
            switch(C.label){
                case 0:
                    if (e55.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
                    e55.isTraining = !0, C.label = 1;
                case 1:
                    return C.trys.push([
                        1,
                        ,
                        7,
                        8
                    ]), checkBatchSize(p = null == r.batchSize ? 32 : r.batchSize), h = !1, [
                        4,
                        e55.standardizeUserData(t, n, r.sampleWeight, r.classWeight, h, p)
                    ];
                case 2:
                    if (d = C.sent(), i = d[0], a = d[1], c = d[2], f = !1, g = void 0, !(null != r.validationData && r.validationData.length > 0)) return [
                        3,
                        4
                    ];
                    if (f = !0, 2 !== r.validationData.length) throw 3 === r.validationData.length ? new NotImplementedError("validationData including sample weights is not supported yet.") : new ValueError("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; " + r.validationData + " is invalid.");
                    return o = r.validationData[0], s = r.validationData[1], m = !0, [
                        4,
                        e55.standardizeUserData(o, s, null, null, m, p)
                    ];
                case 3:
                    return y = C.sent(), l = y[0], u = y[1], g = l.concat(u), [
                        3,
                        5
                    ];
                case 4:
                    null != r.validationSplit && r.validationSplit > 0 && r.validationSplit < 1 ? (f = !0, v = Math.floor(i[0].shape[0] * (1 - r.validationSplit)), b = i[0].shape[0], l = sliceArrays(i, v, b), i = sliceArrays(i, 0, v), u = sliceArrays(a, v, b), a = sliceArrays(a, 0, v), g = l.concat(u)) : null != r.validationSteps && (f = !0), C.label = 5;
                case 5:
                    return w = i.concat(a).concat(c), e55.checkTrainableWeightsConsistency(), z = e55.makeTrainFunction(), S = e55.getDedupedMetricsNames(), A = void 0, _ = void 0, f ? (e55.makeTestFunction(), A = e55.testFunction, _ = S.slice().concat(S.map(function(e) {
                        return "val_" + e;
                    }))) : (A = null, g = [], _ = S.slice()), I = standardizeCallbacks(r.callbacks, r.yieldEvery), [
                        4,
                        fitLoop(e55, z, w, S, p, r.epochs, r.verbose, I, A, g, r.shuffle, _, r.initialEpoch, null, null)
                    ];
                case 6:
                    return [
                        2,
                        C.sent()
                    ];
                case 7:
                    return e55.isTraining = !1, disposeNewTensors(i, t), disposeNewTensors(a, n), disposeNewTensors(l, o), disposeNewTensors(u, s), null != c && _tfjsCore.dispose(c), [
                        7
                    ];
                case 8:
                    return [
                        2
                    ];
            }
        });
    });
}
function ensureTensorsRank2OrHigher(e) {
    var t = [];
    e instanceof _tfjsCore.Tensor && (e = [
        e
    ]);
    for(var n = 0; n < e.length; ++n){
        var r = e[n];
        if (1 === r.rank) t.push(expandDims$1(r, 1));
        else {
            if (0 === r.rank) throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
            t.push(r);
        }
    }
    return t;
}
function disposeNewTensors(e56, t) {
    if (null != e56) {
        var n = [];
        if (t instanceof _tfjsCore.Tensor) n.push(t.id);
        else if (Array.isArray(t)) t.forEach(function(e) {
            return n.push(e.id);
        });
        else if (null != t) for(var r in t){
            var i = t[r];
            n.push(i.id);
        }
        var a = [];
        if (e56 instanceof _tfjsCore.Tensor) -1 === n.indexOf(e56.id) && a.push(e56);
        else if (Array.isArray(e56)) e56.forEach(function(e) {
            -1 === n.indexOf(e.id) && a.push(e);
        });
        else if (null != e56) for(var o in e56){
            var s = e56[o];
            -1 === n.indexOf(s.id) && a.push(s);
        }
        a.forEach(function(e) {
            e.isDisposed || e.dispose();
        });
    }
}
function isDataTensor(e) {
    return e instanceof _tfjsCore.Tensor;
}
function isDataArray(e) {
    return Array.isArray(e);
}
function isDataDict(e) {
    return !isDataTensor(e) && !isDataArray(e);
}
function standardizeInputData(e, t, n, r, i) {
    if (void 0 === r && (r = !0), void 0 === i && (i = ""), null == t || 0 === t.length) {
        if (null != e) {
            var a = !1;
            if (isDataArray(e) && e.length > 0) a = !0;
            else if (isDataDict(e)) {
                for(var o in e)if (e.hasOwnProperty(o)) {
                    a = !0;
                    break;
                }
            } else a = !0;
            if (a) throw new ValueError("Error when checking model " + i + " expected no data, but got " + e);
        }
        return [];
    }
    if (null == e) return t.map(function(e) {
        return null;
    });
    var s;
    if (isDataDict(e)) {
        s = [];
        for(var l = 0, u = t; l < u.length; l++){
            var c = u[l];
            if (null == e[c]) throw new ValueError('No data provided for "' + c + '". Need data for each key in: ' + t);
            s.push(e[c]);
        }
    } else if (isDataArray(e)) {
        if (e.length !== t.length) throw new ValueError("Error when checking model " + i + ": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see " + t.length + " Tensor(s), but instead got the following list of Tensor(s): " + e);
        s = e;
    } else {
        if (t.length > 1) throw new ValueError("The model " + i + " expects " + t.length + " Tensor(s), but only received one Tensor. Found: Tensor with shape " + e.shape);
        s = [
            e
        ];
    }
    if (s = ensureTensorsRank2OrHigher(s), null != n) {
        for(var p = 0; p < t.length; ++p)if (null != n[p]) {
            var h = s[p];
            if (h.shape.length !== n[p].length) throw new ValueError("Error when checking " + i + ": expected " + t[p] + " to have " + n[p].length + " dimension(s). but got array with shape " + h.shape);
            for(var d = 0; d < n[p].length; ++d)if (0 !== d || r) {
                var f = h.shape[d], g = n[p][d];
                if (null != g && g >= 0 && f !== g) throw new ValueError("Error when checking " + i + ": expected " + t[p] + " to have shape [" + n[p] + "], but got array with shape [" + h.shape + "].");
            }
        }
    }
    return s;
}
function checkArrayLengths(e57, t, n) {
    var r = unique(e57.map(function(e) {
        return e.shape[0];
    }));
    r.sort();
    var i = unique(t.map(function(e) {
        return e.shape[0];
    }));
    if (i.sort(), r.length > 1) throw new ValueError("All input Tensors (x) should have the same number of samples. Got array shapes: " + JSON.stringify(e57.map(function(e) {
        return e.shape;
    })));
    if (i.length > 1) throw new ValueError("All target Tensors (y) should have the same number of samples. Got array shapes: " + JSON.stringify(t.map(function(e) {
        return e.shape;
    })));
    if (r.length > 0 && i.length > 0 && !_tfjsCore.util.arraysEqual(r, i)) throw new ValueError("Input Tensors should have the same number of samples as target Tensors. Found " + r[0] + " input sample(s) and " + i[0] + " target sample(s).");
}
function checkLossAndTargetCompatibility(e, t, n) {
    for(var r = [
        meanSquaredError,
        binaryCrossentropy,
        categoricalCrossentropy
    ], i = 0; i < e.length; ++i){
        var a = e[i], o = t[i], s = n[i];
        if (null != o) {
            if (o === categoricalCrossentropy && 1 === a.shape[a.shape.length - 1]) throw new ValueError("You are passing a target array of shape " + a.shape + " while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");
            if (-1 !== r.indexOf(o)) for(var l = a.shape.slice(1), u = s.slice(1), c = 0; c < l.length; ++c){
                var p = l[c], h = u[c];
                if (null != h && p !== h) throw new ValueError("A target Tensor with shape " + a.shape + " was passed for an output of shape " + s + ", while using a loss function that expects targets to have the same shape as the output.");
            }
        }
    }
}
function checkInputData(e, t, n, r, i) {
    var a;
    if (void 0 === r && (r = !0), void 0 === i && (i = ""), Array.isArray(e)) {
        if (e.length !== t.length) throw new ValueError("Error when checking model " + i + ": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see " + t.length + " Tensor(s), but instead got " + e.length + " Tensors(s).");
        a = e;
    } else {
        if (t.length > 1) throw new ValueError("The model expects " + t.length + " " + i + " Tensors, but only received one Tensor. Found: array with shape " + JSON.stringify(e.shape) + ".");
        a = [
            e
        ];
    }
    if (null != n) {
        for(var o = 0; o < t.length; ++o)if (null != n[o]) {
            var s = a[o];
            if (s.shape.length !== n[o].length) throw new ValueError("Error when checking " + i + ": expected " + t[o] + " to have " + n[o].length + " dimension(s), but got array with shape " + JSON.stringify(s.shape));
            for(var l = 0; l < n[o].length; ++l)if (0 !== l || r) {
                var u = s.shape[l], c = n[o][l];
                if (null != c && c !== u) throw new ValueError("Error when checking " + i + ": expected " + t[o] + " to have shape " + JSON.stringify(n[o]) + " but got array with shape " + JSON.stringify(s.shape) + ".");
            }
        }
    }
}
function collectMetrics(e, t) {
    if (null == e || Array.isArray(e) && 0 === e.length) return t.map(function(e) {
        return [];
    });
    var n;
    if ("string" == typeof e || "function" == typeof e) n = [
        e
    ];
    else {
        if (!Array.isArray(e) && "object" != typeof e) throw new TypeError("Type of metrics argument not understood. Expected an string,function, Array, or Object, found: " + e);
        n = e;
    }
    if (Array.isArray(n)) return t.map(function(e) {
        return n;
    });
    for(var r = [], i = 0, a = t; i < a.length; i++){
        var o = a[i], s = n.hasOwnProperty(o) ? n[o] : [];
        Array.isArray(s) || (s = [
            s
        ]), r.push(s);
    }
    return r;
}
var LAYERS_MODEL_FORMAT_NAME = "layers-model", LayersModel = function(e58) {
    function t36(t) {
        var n = e58.call(this, t) || this;
        return n.isTraining = !1, n;
    }
    return __extends(t36, e58), t36.prototype.summary = function(e, t, n) {
        if (void 0 === n && (n = console.log), !this.built) throw new ValueError("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
        printSummary(this, e, t, n);
    }, t36.prototype.compile = function(e59) {
        var t = this;
        if (null == e59.loss && (e59.loss = []), this.loss = e59.loss, "string" == typeof e59.optimizer) this.optimizer_ = getOptimizer(e59.optimizer), this.isOptimizerOwned = !0;
        else {
            if (!(e59.optimizer instanceof _tfjsCore.Optimizer)) throw new ValueError("User-defined optimizer must be an instance of tf.Optimizer.");
            this.optimizer_ = e59.optimizer, this.isOptimizerOwned = !1;
        }
        var n9 = [];
        if (Array.isArray(e59.loss) || "string" == typeof e59.loss || "function" == typeof e59.loss) {
            if (Array.isArray(e59.loss)) {
                if (e59.loss.length !== this.outputs.length) throw new ValueError("When passing an Array as loss, it should have one entry per model output. The model has " + this.outputs.length + " output(s), but you passed loss=" + e59.loss + ".");
                var r = e59.loss;
                n9 = r.map(function(e) {
                    return get(e);
                });
            } else {
                var i = get(e59.loss);
                this.outputs.forEach(function(e) {
                    n9.push(i);
                });
            }
        } else {
            for(var a in e59.loss = e59.loss, e59.loss)if (-1 === this.outputNames.indexOf(a)) throw new ValueError('Unknown entry in loss dictionary: "' + a + '". Only expected the following keys: ' + this.outputNames);
            for(var o = 0, s = this.outputNames; o < s.length; o++){
                var l = s[o];
                null == e59.loss[l] && console.warn('Output "' + l + '" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ' + l + " during training"), n9.push(get(e59.loss[l]));
            }
        }
        this.lossFunctions = n9, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];
        for(var u3 = 0; u3 < this.outputs.length; ++u3){
            var c = this.internalOutputShapes[u3], p = this.outputNames[u3];
            this.feedOutputNames.push(p), this.feedOutputShapes.push(c), this.feedLossFns.push(this.lossFunctions[u3]);
        }
        var h = [];
        this.metrics = e59.metrics, this.metricsNames = [
            "loss"
        ], this.metricsTensors = [], nameScope("loss", function() {
            for(var e = 0; e < t.outputs.length; ++e)if (-1 === h.indexOf(e)) {
                var n = t.lossFunctions[e];
                t.outputs.length > 1 && (t.metricsTensors.push([
                    n,
                    e
                ]), t.metricsNames.push(t.outputNames[e] + "_loss"));
            }
        });
        var d = collectMetrics(e59.metrics, this.outputNames);
        nameScope("metric", function() {
            for(var e60 = function(e61) {
                if (-1 !== h.indexOf(e61)) return "continue";
                !function(n11) {
                    for(var r5, i, a, o6 = function(n12) {
                        if ("string" == typeof n12 && -1 !== [
                            "accuracy",
                            "acc",
                            "crossentropy",
                            "ce"
                        ].indexOf(n12)) {
                            var o = t.internalOutputShapes[e61];
                            1 === o[o.length - 1] || t.lossFunctions[e61] === binaryCrossentropy ? -1 !== [
                                "accuracy",
                                "acc"
                            ].indexOf(n12) ? i = binaryAccuracy : -1 !== [
                                "crossentropy",
                                "ce"
                            ].indexOf(n12) && (i = binaryCrossentropy$1) : t.lossFunctions[e61] === sparseCategoricalCrossentropy ? -1 !== [
                                "accuracy",
                                "acc"
                            ].indexOf(n12) ? i = sparseCategoricalAccuracy : -1 !== [
                                "crossentropy",
                                "ce"
                            ].indexOf(n12) && (i = sparseCategoricalCrossentropy$1) : -1 !== [
                                "accuracy",
                                "acc"
                            ].indexOf(n12) ? i = categoricalAccuracy : -1 !== [
                                "crossentropy",
                                "ce"
                            ].indexOf(n12) && (i = categoricalCrossentropy$1);
                            var s = void 0;
                            -1 !== [
                                "accuracy",
                                "acc"
                            ].indexOf(n12) ? s = "acc" : -1 !== [
                                "crossentropy",
                                "ce"
                            ].indexOf(n12) && (s = "ce"), a = i, r5 = "" + s;
                        } else {
                            var l = get$1(n12);
                            a = l, r5 = "" + getLossOrMetricName(n12);
                        }
                        var u;
                        nameScope(r5, function() {
                            u = a;
                        }), (function(e, n, r) {
                            t.outputNames.length > 1 && (n = t.outputNames[e] + "_" + n), t.metricsNames.push(n), t.metricsTensors.push([
                                r,
                                e
                            ]);
                        })(e61, r5, u);
                    }, s6 = 0, l5 = n11; s6 < l5.length; s6++)o6(l5[s6]);
                }(d[e61]);
            }, n10 = 0; n10 < t.outputs.length; ++n10)e60(n10);
        }), this.collectedTrainableWeights = this.trainableWeights;
    }, t36.prototype.checkTrainableWeightsConsistency = function() {
        null != this.collectedTrainableWeights && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?");
    }, t36.prototype.evaluate = function(e, t, n) {
        void 0 === n && (n = {
        });
        var r = null == n.batchSize ? 32 : n.batchSize;
        checkBatchSize(r);
        var i = this.standardizeUserDataXY(e, t, !0, r);
        try {
            var a = i[0].concat(i[1]);
            this.makeTestFunction();
            var o = this.testFunction;
            return singletonOrArray(this.testLoop(o, a, r, n.verbose, n.steps));
        } finally{
            disposeNewTensors(i[0], e), disposeNewTensors(i[1], t);
        }
    }, t36.prototype.evaluateDataset = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(n) {
                return this.makeTestFunction(), [
                    2,
                    evaluateDataset(this, e, t)
                ];
            });
        });
    }, t36.prototype.checkNumSamples = function(e, t, n, r) {
        var i;
        if (void 0 === r && (r = "steps"), null != n) {
            if (i = null, null != t) throw new ValueError("If " + r + " is set, batchSize must be null or undefined.Got batchSize = " + t);
        } else {
            if (null == e) throw new ValueError("Either the input data should have a defined shape, or " + r + " shoud be specified.");
            i = Array.isArray(e) ? e[0].shape[0] : e.shape[0];
        }
        return i;
    }, t36.prototype.execute = function(e, t) {
        if (Array.isArray(t) && 0 === t.length) throw new ValueError("`outputs` is an empty Array, which is not allowed.");
        var n = Array.isArray(t), r = n ? t : [
            t
        ], i = this.retrieveSymbolicTensors(r), a = new FeedDict;
        if (e instanceof _tfjsCore.Tensor && (e = [
            e
        ]), Array.isArray(e)) {
            if (e.length !== this.inputs.length) throw new ValueError("The number of inputs provided (" + e.length + ") does not match the number of inputs of this model (" + this.inputs.length + ").");
            for(var o = 0; o < this.inputs.length; ++o)a.add(this.inputs[o], e[o]);
        } else for(var s = 0, l = this.inputs; s < l.length; s++){
            var u = l[s], c = e[u.name];
            if (null == c) throw new ValueError("No value is provided for the model's input " + u.name);
            a.add(u, c);
        }
        var p = execute(i, a);
        return n ? p : p[0];
    }, t36.prototype.retrieveSymbolicTensors = function(e62) {
        for(var t37 = pyListRepeat(null, e62.length), n = e62.length, r = 0, i = this.layers; r < i.length; r++){
            for(var a = i[r], o = Array.isArray(a.output) ? a.output : [
                a.output
            ], s = o.map(function(e) {
                return e.name;
            }), l = 0; l < e62.length; ++l){
                var u = s.indexOf(e62[l]);
                if (-1 !== u && (t37[l] = o[u], n--), 0 === n) break;
            }
            if (0 === n) break;
        }
        if (n > 0) {
            var c = [];
            throw t37.forEach(function(t, n) {
                null == t && c.push(e62[n]);
            }), new ValueError("Cannot find SymbolicTensors for output name(s): " + JSON.stringify(c));
        }
        return t37;
    }, t36.prototype.predictLoop = function(e63, t, n13) {
        var r = this;
        return void 0 === t && (t = 32), void 0 === n13 && (n13 = !1), _tfjsCore.tidy(function() {
            var i3 = r.checkNumSamples(e63);
            if (n13) throw new NotImplementedError("Verbose predictLoop() is not implemented yet.");
            for(var a = makeBatches(i3, t), o7 = r.outputs.map(function(e) {
                return [];
            }), s7 = function(t) {
                _tfjsCore.tidy(function() {
                    var n = a[t][0], i = a[t][1], o = sliceArrays(e63, n, i), s = [];
                    if (Array.isArray(o)) for(var l = 0; l < o.length; ++l)s.push({
                        key: r.inputs[l],
                        value: o[l]
                    });
                    else s.push({
                        key: r.inputs[0],
                        value: o
                    });
                    var u = new FeedDict(s);
                    return execute(r.outputs, u);
                }).forEach(function(e, t) {
                    return o7[t].push(e);
                });
            }, l6 = 0; l6 < a.length; ++l6)s7(l6);
            return singletonOrArray(o7.map(function(e) {
                return _tfjsCore.concat(e, 0);
            }));
        });
    }, t36.prototype.predict = function(e, t) {
        void 0 === t && (t = {
        });
        var n = ensureTensorsRank2OrHigher(e);
        checkInputData(n, this.inputNames, this.feedInputShapes, !1);
        try {
            var r = null == t.batchSize ? 32 : t.batchSize;
            return checkBatchSize(r), this.predictLoop(n, r);
        } finally{
            disposeNewTensors(n, e);
        }
    }, t36.prototype.predictOnBatch = function(e) {
        checkInputData(e, this.inputNames, this.feedInputShapes, !0);
        var t = (Array.isArray(e) ? e[0] : e).shape[0];
        return this.predictLoop(e, t);
    }, t36.prototype.standardizeUserDataXY = function(e, t, n, r) {
        if (void 0 === n && (n = !0), null == this.optimizer_) throw new RuntimeError("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
        for(var i = [], a = 0; a < this.feedOutputShapes.length; ++a){
            var o = this.feedOutputShapes[a];
            this.feedLossFns[a] === sparseCategoricalCrossentropy ? i.push(o.slice(0, o.length - 1).concat([
                1
            ])) : i.push(o);
        }
        if (checkArrayLengths(e = standardizeInputData(e, this.feedInputNames, this.feedInputShapes, !1, "input"), t = standardizeInputData(t, this.feedOutputNames, i, !1, "target"), null), checkLossAndTargetCompatibility(t, this.feedLossFns, this.feedOutputShapes), this.stateful && null != r && r > 0 && e[0].shape[0] % r != 0) throw new ValueError("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size " + r + ". Found: " + e[0].shape[0] + " sample(s).");
        return [
            e,
            t
        ];
    }, t36.prototype.standardizeUserData = function(e, t, n, r, i, a) {
        return void 0 === i && (i = !0), __awaiter(this, void 0, void 0, function() {
            var o, s, l, u, c, p, h, d;
            return __generator(this, function(f) {
                switch(f.label){
                    case 0:
                        if (o = this.standardizeUserDataXY(e, t, i, a), s = o[0], l = o[1], null != n) throw new Error("sample weight is not supported yet.");
                        if (u = null, null == r) return [
                            3,
                            4
                        ];
                        c = standardizeClassWeights(r, this.outputNames), u = [], p = 0, f.label = 1;
                    case 1:
                        return p < c.length ? (d = (h = u).push, [
                            4,
                            standardizeWeights(l[p], null, c[p])
                        ]) : [
                            3,
                            4
                        ];
                    case 2:
                        d.apply(h, [
                            f.sent()
                        ]), f.label = 3;
                    case 3:
                        return ++p, [
                            3,
                            1
                        ];
                    case 4:
                        return [
                            2,
                            [
                                s,
                                l,
                                u
                            ]
                        ];
                }
            });
        });
    }, t36.prototype.testLoop = function(e, t, n, r, i) {
        var a = this;
        return void 0 === r && (r = 0), _tfjsCore.tidy(function() {
            var o = a.checkNumSamples(t, n, i, "steps"), s = [];
            if (r > 0) throw new NotImplementedError("Verbose mode is not implemented yet.");
            if (null != i) throw new NotImplementedError("steps mode in testLoop() is not implemented yet");
            for(var l = makeBatches(o, n), u = _tfjsCore.tensor1d(range(0, o)), c = 0; c < l.length; ++c){
                var p = l[c][0], h = l[c][1], d = sliceAlongFirstAxis(u, p, h - p), f = sliceArraysByIndices(t, d), g = e(f);
                if (0 === c) for(var m = 0; m < g.length; ++m)s.push(_tfjsCore.scalar(0));
                for(m = 0; m < g.length; ++m){
                    var y = g[m];
                    s[m] = _tfjsCore.add(s[m], _tfjsCore.mul(h - p, y));
                }
            }
            for(m = 0; m < s.length; ++m)s[m] = _tfjsCore.div(s[m], o);
            return s;
        });
    }, t36.prototype.getDedupedMetricsNames = function() {
        for(var e = this.metricsNames, t = [], n = 0; n < e.length; ++n){
            var r = e[n], i = r;
            if (count(e, r) > 1) i += "_" + count(e.slice(0, n), r);
            t.push(i);
        }
        return t;
    }, t36.prototype.makeTrainFunction = function() {
        var e64 = this;
        return function(t38) {
            var n = [], r = t38.slice(0, e64.inputs.length), i = t38.slice(e64.inputs.length, e64.inputs.length + e64.outputs.length), a = t38.slice(e64.inputs.length + e64.outputs.length, e64.inputs.length + 2 * e64.outputs.length), o = [], s8 = e64.collectedTrainableWeights.map(function(e) {
                return e.read();
            });
            return [
                e64.optimizer_.minimize(function() {
                    for(var t = [], s = 0; s < e64.inputs.length; ++s)t.push({
                        key: e64.inputs[s],
                        value: r[s]
                    });
                    var l, u = new FeedDict(t), c = execute(e64.outputs, u, {
                        training: !0
                    });
                    for(s = 0; s < e64.lossFunctions.length; ++s){
                        var p = (0, e64.lossFunctions[s])(i[s], c[s]);
                        null != a[s] && (p = computeWeightedLoss(p, a[s]));
                        var h = _tfjsCore.mean(p);
                        n.push(h), l = 0 === s ? p : _tfjsCore.add(l, p);
                    }
                    for(s = 0; s < e64.metricsTensors.length; ++s){
                        var d = void 0;
                        if (e64.outputs.length > 1 && s < e64.outputs.length) d = n[s];
                        else {
                            var f = e64.metricsTensors[s][0], g = e64.metricsTensors[s][1];
                            d = _tfjsCore.mean(f(i[g], c[g]));
                        }
                        _tfjsCore.keep(d), o.push(d);
                    }
                    return l = _tfjsCore.mean(l), e64.calculateLosses().forEach(function(e) {
                        l = _tfjsCore.add(l, e);
                    }), l;
                }, !0, s8)
            ].concat(o);
        };
    }, t36.prototype.makeTestFunction = function() {
        var e = this;
        this.testFunction = function(t) {
            return _tfjsCore.tidy(function() {
                for(var n, r = [], i = t.slice(0, e.inputs.length), a = t.slice(e.inputs.length, e.inputs.length + e.outputs.length), o = [], s = 0; s < e.inputs.length; ++s)o.push({
                    key: e.inputs[s],
                    value: i[s]
                });
                var l = new FeedDict(o), u = execute(e.outputs, l);
                for(s = 0; s < e.lossFunctions.length; ++s){
                    var c = e.lossFunctions[s], p = _tfjsCore.mean(c(a[s], u[s]));
                    n = 0 === s ? p : _tfjsCore.add(n, p), r.push(n);
                }
                for(s = 0; s < e.metricsTensors.length; ++s){
                    var h = e.metricsTensors[s][0], d = e.metricsTensors[s][1], f = _tfjsCore.mean(h(a[d], u[d]));
                    r.push(f);
                }
                return r;
            });
        };
    }, t36.prototype.fit = function(e, t, n) {
        return void 0 === n && (n = {
        }), __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(r) {
                return [
                    2,
                    fitTensors(this, e, t, n)
                ];
            });
        });
    }, t36.prototype.fitDataset = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(n) {
                return [
                    2,
                    fitDataset(this, e, t)
                ];
            });
        });
    }, t36.prototype.trainOnBatch = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            var n, r, i, a, o, s, l, u, c;
            return __generator(this, function(p) {
                switch(p.label){
                    case 0:
                        return [
                            4,
                            this.standardizeUserData(e, t)
                        ];
                    case 1:
                        n = p.sent(), r = n[0], i = n[1], a = this.makeTrainFunction(), o = a(r.concat(i)), s = [], l = 0, u = o, p.label = 2;
                    case 2:
                        return l < u.length ? [
                            4,
                            u[l].data()
                        ] : [
                            3,
                            5
                        ];
                    case 3:
                        c = p.sent(), s.push(c[0]), p.label = 4;
                    case 4:
                        return l++, [
                            3,
                            2
                        ];
                    case 5:
                        return _tfjsCore.dispose(o), [
                            2,
                            singletonOrArray(s)
                        ];
                }
            });
        });
    }, t36.prototype.getNamedWeights = function(e) {
        for(var t = [], n = null != e && e.trainableOnly, r = n ? this.trainableWeights : this.weights, i = this.getWeights(n), a = 0; a < r.length; ++a)n && !r[a].trainable || t.push({
            name: r[a].originalName,
            tensor: i[a]
        });
        return t;
    }, Object.defineProperty(t36.prototype, "stopTraining", {
        get: function() {
            return this.stopTraining_;
        },
        set: function(e) {
            this.stopTraining_ = e;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t36.prototype, "optimizer", {
        get: function() {
            return this.optimizer_;
        },
        set: function(e) {
            this.optimizer_ !== e && (this.optimizer_ = e, this.isOptimizerOwned = !1);
        },
        enumerable: !0,
        configurable: !0
    }), t36.prototype.dispose = function() {
        var t = e58.prototype.dispose.call(this);
        if (0 === t.refCountAfterDispose && null != this.optimizer && this.isOptimizerOwned) {
            var n = _tfjsCore.memory().numTensors;
            this.optimizer_.dispose(), t.numDisposedVariables += n - _tfjsCore.memory().numTensors;
        }
        return t;
    }, t36.prototype.getLossIdentifiers = function() {
        var e65;
        if ("string" == typeof this.loss) e65 = toSnakeCase(this.loss);
        else if (Array.isArray(this.loss)) {
            for(var t = 0, n = this.loss; t < n.length; t++){
                if ("string" != typeof n[t]) throw new Error("Serialization of non-string loss is not supported.");
            }
            e65 = this.loss.map(function(e) {
                return toSnakeCase(e);
            });
        } else {
            var r = Object.keys(this.loss);
            e65 = {
            };
            for(var i = this.loss, a = 0, o = r; a < o.length; a++){
                var s = o[a];
                if ("string" != typeof i[s]) throw new Error("Serialization of non-string loss is not supported.");
                e65[s] = toSnakeCase(i[s]);
            }
        }
        return e65;
    }, t36.prototype.getMetricIdentifiers = function() {
        if ("string" == typeof this.metrics || "function" == typeof this.metrics) return [
            toSnakeCase(getLossOrMetricName(this.metrics))
        ];
        if (Array.isArray(this.metrics)) return this.metrics.map(function(e) {
            return toSnakeCase(getLossOrMetricName(e));
        });
        var e66 = {
        };
        for(var t in this.metrics)e66[t] = toSnakeCase(getLossOrMetricName(this.metrics[t]));
        return e66;
    }, t36.prototype.getTrainingConfig = function() {
        return {
            loss: this.getLossIdentifiers(),
            metrics: this.getMetricIdentifiers(),
            optimizer_config: {
                class_name: this.optimizer.getClassName(),
                config: this.optimizer.getConfig()
            }
        };
    }, t36.prototype.loadTrainingConfig = function(e67) {
        if (null != e67.weighted_metrics) throw new Error("Loading weight_metrics is not supported yet.");
        if (null != e67.loss_weights) throw new Error("Loading loss_weights is not supported yet.");
        if (null != e67.sample_weight_mode) throw new Error("Loading sample_weight_mode is not supported yet.");
        var t, n, r = deserialize(convertPythonicToTs(e67.optimizer_config));
        if ("string" == typeof e67.loss) t = toCamelCase(e67.loss);
        else if (Array.isArray(e67.loss)) t = e67.loss.map(function(e) {
            return toCamelCase(e);
        });
        else if (null != e67.loss) for(var i in t = {
        }, e67.loss)t[i] = toCamelCase(e67.loss[i]);
        if (Array.isArray(e67.metrics)) n = e67.metrics.map(function(e) {
            return toCamelCase(e);
        });
        else if (null != e67.metrics) for(var i in n = {
        }, e67.metrics)n[i] = toCamelCase(e67.metrics[i]);
        this.compile({
            loss: t,
            metrics: n,
            optimizer: r
        });
    }, t36.prototype.save = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            var n, r, i, a, o, s, l, u, c, p, h, d, f, g;
            return __generator(this, function(m) {
                switch(m.label){
                    case 0:
                        if ("string" == typeof e) {
                            if (0 === (n = _tfjsCore.io.getSaveHandlers(e)).length) throw new ValueError("Cannot find any save handlers for URL '" + e + "'");
                            if (n.length > 1) throw new ValueError("Found more than one (" + n.length + ") save handlers for URL '" + e + "'");
                            e = n[0];
                        }
                        if (null == e.save) throw new ValueError("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
                        return [
                            4,
                            _tfjsCore.io.encodeWeights(this.getNamedWeights(t))
                        ];
                    case 1:
                        return r = m.sent(), i = !1, a = null, o = this.toJSON(a, i), s = {
                            modelTopology: o,
                            format: LAYERS_MODEL_FORMAT_NAME,
                            generatedBy: "TensorFlow.js tfjs-layers v" + version,
                            convertedBy: null
                        }, null != t && t.includeOptimizer && null != this.optimizer ? (s.trainingConfig = this.getTrainingConfig(), l = "optimizer", d = (h = _tfjsCore.io).encodeWeights, [
                            4,
                            this.optimizer.getWeights()
                        ]) : [
                            3,
                            4
                        ];
                    case 2:
                        return [
                            4,
                            d.apply(h, [
                                m.sent(),
                                l
                            ])
                        ];
                    case 3:
                        u = m.sent(), c = u.data, p = u.specs, (g = r.specs).push.apply(g, p), r.data = _tfjsCore.io.concatenateArrayBuffers([
                            r.data,
                            c
                        ]), m.label = 4;
                    case 4:
                        return null != this.userDefinedMetadata && (f = !0, checkUserDefinedMetadata(this.userDefinedMetadata, this.name, f), s.userDefinedMetadata = this.userDefinedMetadata), s.weightData = r.data, s.weightSpecs = r.specs, [
                            2,
                            e.save(s)
                        ];
                }
            });
        });
    }, t36.prototype.setUserDefinedMetadata = function(e) {
        checkUserDefinedMetadata(e, this.name), this.userDefinedMetadata = e;
    }, t36.prototype.getUserDefinedMetadata = function() {
        return this.userDefinedMetadata;
    }, t36.className = "Model", t36;
}(Container);
function modelFromJSON(e68, t) {
    return __awaiter(this, void 0, void 0, function() {
        var n, r, i, a, o, s, l, u;
        return __generator(this, function(c) {
            switch(c.label){
                case 0:
                    return "modelTopology" in e68 || (e68 = {
                        modelTopology: e68
                    }), null != (n = e68.modelTopology).model_config && (n = n.model_config), r = convertPythonicToTs(n), i = deserialize(r, t), null == e68.weightsManifest ? [
                        3,
                        2
                    ] : [
                        4,
                        _tfjsCore.io.loadWeights(e68.weightsManifest, e68.pathPrefix, i.weights.map(function(e) {
                            return e.originalName;
                        }))
                    ];
                case 1:
                    for(a = c.sent(), o = {
                    }, s = 0, l = i.weights; s < l.length; s++)u = l[s], o[u.originalName] = a[u.originalName];
                    i.loadWeights(o), _tfjsCore.dispose(a), c.label = 2;
                case 2:
                    return [
                        2,
                        i
                    ];
            }
        });
    });
}
function loadLayersModelInternal(e, t) {
    return __awaiter(this, void 0, void 0, function() {
        var n;
        return __generator(this, function(r) {
            if (null == t && (t = {
            }), "string" == typeof e) {
                if (0 === (n = _tfjsCore.io.getLoadHandlers(e, t.onProgress)).length) n.push(_tfjsCore.io.browserHTTPRequest(e, t));
                else if (n.length > 1) throw new ValueError("Found more than one (" + n.length + ") load handlers for URL '" + e + "'");
                e = n[0];
            }
            return [
                2,
                loadLayersModelFromIOHandler(e, void 0, t)
            ];
        });
    });
}
function loadLayersModelFromIOHandler(e69, t, n) {
    return __awaiter(this, void 0, void 0, function() {
        var r, i, a, o, s, l, u, c, p;
        return __generator(this, function(h) {
            switch(h.label){
                case 0:
                    if (null == n && (n = {
                    }), null == e69.load) throw new ValueError("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
                    return [
                        4,
                        e69.load()
                    ];
                case 1:
                    if (r = h.sent(), null != (i = r.modelTopology).model_config && (i = i.model_config), a = null == n.strict || n.strict, o = null != r.weightData && null != r.weightSpecs && a, s = deserialize(convertPythonicToTs(i), t, o), null != (l = r.trainingConfig) && s.loadTrainingConfig(l), null != r.userDefinedMetadata && s.setUserDefinedMetadata(r.userDefinedMetadata), null == r.weightData) return [
                        3,
                        4
                    ];
                    if (null == r.weightSpecs) throw new ValueError("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");
                    return u = decodeModelAndOptimizerWeights(r.weightData, r.weightSpecs), c = u.modelWeights, p = u.optimizerWeights, s.loadWeights(c, a), null != s.optimizer && p.length > 0 ? [
                        4,
                        s.optimizer.setWeights(p)
                    ] : [
                        3,
                        3
                    ];
                case 2:
                    h.sent(), h.label = 3;
                case 3:
                    _tfjsCore.dispose(c), _tfjsCore.dispose(p.map(function(e) {
                        return e.tensor;
                    })), h.label = 4;
                case 4:
                    return [
                        2,
                        s
                    ];
            }
        });
    });
}
function decodeModelAndOptimizerWeights(e70, t) {
    var n = _tfjsCore.io.decodeWeights(e70, t), r = {
    }, i = [];
    return t.forEach(function(e) {
        "optimizer" === e.group ? i.push({
            name: e.name,
            tensor: n[e.name]
        }) : r[e.name] = n[e.name];
    }), {
        modelWeights: r,
        optimizerWeights: i
    };
}
_tfjsCore.serialization.registerClass(LayersModel);
var Sequential = function(e71) {
    function t39(t) {
        var n = e71.call(this, {
            inputs: [],
            outputs: []
        }) || this;
        if (t = t || {
        }, n.trainable = !0, n.built = !1, n.name = null != t.name ? t.name : getUid("sequential_"), null != t.layers) for(var r = 0, i = t.layers; r < i.length; r++){
            var a = i[r];
            n.add(a);
        }
        return n;
    }
    return __extends(t39, e71), t39.prototype.checkShape = function(e72) {
        if (e72.inboundNodes[0].outputTensors[0].shape.some(function(e) {
            return e < 0;
        })) throw new ValueError("Negative dimension size caused by adding layer " + e72.name + " with input shape [" + e72.inboundNodes[0].inputTensors[0].shape + "]");
    }, t39.prototype.add = function(e73) {
        var n, r = e73 instanceof t39 || e73 instanceof LayersModel;
        if (r) {
            if (1 !== (n = e73).outputs.length) throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
            if (1 !== n.inputs.length) throw new ValueError("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
        }
        if (0 === this.outputs.length) {
            if (0 === e73.inboundNodes.length) {
                if (null == e73.batchInputShape) throw new ValueError("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
                var i = Input({
                    batchShape: e73.batchInputShape,
                    dtype: e73.dtype,
                    name: e73.name + "_input"
                });
                e73.apply(i);
            }
            if (r) this.outputs = n.outputs, this.inputs = n.inputs;
            else {
                if (1 !== e73.inboundNodes.length) throw new ValueError("A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer " + e73.name + " which has " + e73.inboundNodes.length + " pre-existing inbound connections.");
                if (1 !== e73.inboundNodes[0].outputTensors.length) throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
                this.checkShape(e73), this.outputs = [
                    e73.inboundNodes[0].outputTensors[0]
                ], this.inputs = getSourceInputs(this.outputs[0]);
            }
            this.inboundNodes = [], new Node({
                outboundLayer: this,
                inboundLayers: [],
                nodeIndices: [],
                tensorIndices: [],
                inputTensors: this.inputs,
                outputTensors: this.outputs,
                inputMasks: pyListRepeat(null, this.inputs.length),
                outputMasks: [
                    null
                ],
                inputShapes: this.inputs.map(function(e) {
                    return e.shape;
                }),
                outputShapes: this.outputs[0].shape
            });
        } else {
            var a = e73.apply(this.outputs[0]);
            if (Array.isArray(a)) throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
            this.checkShape(e73), this.outputs = [
                a
            ], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [
                this.outputs[0].shape
            ];
        }
        this.layers.push(e73), this.built = !1;
    }, t39.prototype.pop = function() {
        if (0 === this.layers.length) throw new TypeError("There are no layers in the model.");
        if (this.layers.pop(), 0 === this.layers.length) this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];
        else {
            var e = this.layers.length - 1;
            this.layers[e].outboundNodes = [], this.outputs = [
                this.layers[e].output
            ], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [
                this.outputs[0].shape
            ];
        }
    }, t39.prototype.call = function(e, t) {
        return null == this.model && this.build(), this.model.call(e, t);
    }, t39.prototype.build = function(e) {
        if (getExactlyOneShape(e), 0 === this.inputs.length || 0 === this.outputs.length) throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
        this.model = new LayersModel({
            inputs: this.inputs,
            outputs: this.outputs[0],
            name: this.name + "_model"
        }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = !0;
    }, t39.prototype.countParams = function() {
        return this.built || this.build(), e71.prototype.countParams.call(this);
    }, t39.prototype.summary = function(t, n, r) {
        void 0 === r && (r = console.log), this.built || this.build(), e71.prototype.summary.call(this, t, n, r);
    }, t39.prototype.setWeights = function(e) {
        null == this.model && this.build(), this.model.setWeights(e);
    }, t39.prototype.evaluate = function(e, t, n) {
        if (void 0 === n && (n = {
        }), !this.built) throw new RuntimeError("The model needs to be compiled before being used.");
        return this.model.evaluate(e, t, n);
    }, t39.prototype.evaluateDataset = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(n) {
                if (!this.built) throw new RuntimeError("The model needs to be compiled before being used.");
                return [
                    2,
                    this.model.evaluateDataset(e, t)
                ];
            });
        });
    }, t39.prototype.predict = function(e, t) {
        return void 0 === t && (t = {
        }), null == this.model && this.build(), this.model.predict(e, t);
    }, t39.prototype.predictOnBatch = function(e) {
        return null == this.model && this.build(), this.model.predictOnBatch(e);
    }, t39.prototype.compile = function(e) {
        this.build(), this.model.compile(e), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames;
    }, Object.defineProperty(t39.prototype, "optimizer", {
        get: function() {
            return null == this.model ? void 0 : this.model.optimizer;
        },
        set: function(e) {
            this.model.optimizer = e;
        },
        enumerable: !0,
        configurable: !0
    }), t39.prototype.fit = function(e, t, n) {
        return void 0 === n && (n = {
        }), __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(r) {
                if (!this.built) throw new RuntimeError("The model needs to be compiled before being used.");
                return [
                    2,
                    this.model.fit(e, t, n)
                ];
            });
        });
    }, t39.prototype.fitDataset = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(n) {
                if (!this.built) throw new RuntimeError("The model needs to be compiled before being used.");
                return [
                    2,
                    this.model.fitDataset(e, t)
                ];
            });
        });
    }, t39.prototype.trainOnBatch = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(n) {
                return [
                    2,
                    this.model.trainOnBatch(e, t)
                ];
            });
        });
    }, t39.fromConfig = function(e, n, r, i) {
        var a;
        void 0 === r && (r = {
        }), void 0 === i && (i = !1);
        var o = {
        };
        if (n instanceof Array) {
            if (null == n[0].className || "Merge" === n[0].className) throw new ValueError("Legacy serialization format not supported yet.");
            a = n;
        } else _tfjsCore.util.assert(null != n.layers, function() {
            return "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.";
        }), a = n.layers, delete n.layers, o = n;
        var s = new e(o);
        if (!(s instanceof t39)) throw new NotImplementedError("Sequential.fromConfig called on non-Sequential input: " + s);
        for(var l = 0, u = a; l < u.length; l++){
            var c = deserialize(u[l], void 0, i);
            i && c.setFastWeightInitDuringBuild(!0), s.add(c);
        }
        return s;
    }, Object.defineProperty(t39.prototype, "stopTraining", {
        get: function() {
            if (null == this.model) throw new ValueError("Cannot get the stopTraining property of a sequential model before it is compiled.");
            return this.model.stopTraining;
        },
        set: function(e) {
            if (null == this.model) throw new ValueError("Cannot set the stopTraining property of a sequential model before it is compiled.");
            this.model.stopTraining = e;
        },
        enumerable: !0,
        configurable: !0
    }), t39.prototype.getConfig = function() {
        for(var e = [], t = 0, n = this.layers; t < n.length; t++){
            var r = n[t], i = {
            };
            i.className = r.getClassName(), i.config = r.getConfig(), e.push(i);
        }
        return {
            name: this.name,
            layers: e
        };
    }, t39.className = "Sequential", t39;
}(LayersModel);
function model(e) {
    return new LayersModel(e);
}
function sequential(e) {
    return new Sequential(e);
}
function loadLayersModel(e, t) {
    return null == t && (t = {
    }), loadLayersModelInternal(e, t);
}
function input(e) {
    return Input(e);
}
function registerCallbackConstructor(e, t) {
    CallbackConstructorRegistry.registerCallbackConstructor(e, t);
}
_tfjsCore.serialization.registerClass(Sequential);
var Activation = function(e) {
    function t() {
        return null !== e && e.apply(this, arguments) || this;
    }
    return __extends(t, e), t.prototype.getConfig = function() {
        return {
        };
    }, t;
}(_tfjsCore.serialization.Serializable), Elu = function(e74) {
    function t40() {
        return null !== e74 && e74.apply(this, arguments) || this;
    }
    return __extends(t40, e74), t40.prototype.apply = function(e, t) {
        return void 0 === t && (t = 1), elu$1(e, t);
    }, t40.className = "elu", t40;
}(Activation);
_tfjsCore.serialization.registerClass(Elu);
var Selu = function(e75) {
    function t() {
        return null !== e75 && e75.apply(this, arguments) || this;
    }
    return __extends(t, e75), t.prototype.apply = function(e) {
        return _tfjsCore.selu(e);
    }, t.className = "selu", t;
}(Activation);
_tfjsCore.serialization.registerClass(Selu);
var Relu = function(e76) {
    function t() {
        return null !== e76 && e76.apply(this, arguments) || this;
    }
    return __extends(t, e76), t.prototype.apply = function(e) {
        return _tfjsCore.relu(e);
    }, t.className = "relu", t;
}(Activation);
_tfjsCore.serialization.registerClass(Relu);
var Relu6 = function(e77) {
    function t() {
        return null !== e77 && e77.apply(this, arguments) || this;
    }
    return __extends(t, e77), t.prototype.apply = function(e) {
        return _tfjsCore.tidy(function() {
            return _tfjsCore.minimum(6, _tfjsCore.relu(e));
        });
    }, t.className = "relu6", t;
}(Activation);
_tfjsCore.serialization.registerClass(Relu6);
var Linear = function(e78) {
    function t() {
        return null !== e78 && e78.apply(this, arguments) || this;
    }
    return __extends(t, e78), t.prototype.apply = function(e) {
        return e;
    }, t.className = "linear", t;
}(Activation);
_tfjsCore.serialization.registerClass(Linear);
var Sigmoid = function(e79) {
    function t() {
        return null !== e79 && e79.apply(this, arguments) || this;
    }
    return __extends(t, e79), t.prototype.apply = function(e) {
        return _tfjsCore.sigmoid(e);
    }, t.className = "sigmoid", t;
}(Activation);
_tfjsCore.serialization.registerClass(Sigmoid);
var HardSigmoid = function(e80) {
    function t() {
        return null !== e80 && e80.apply(this, arguments) || this;
    }
    return __extends(t, e80), t.prototype.apply = function(e) {
        return hardSigmoid(e);
    }, t.className = "hardSigmoid", t;
}(Activation);
_tfjsCore.serialization.registerClass(HardSigmoid);
var Softplus = function(e81) {
    function t() {
        return null !== e81 && e81.apply(this, arguments) || this;
    }
    return __extends(t, e81), t.prototype.apply = function(e) {
        return _tfjsCore.softplus(e);
    }, t.className = "softplus", t;
}(Activation);
_tfjsCore.serialization.registerClass(Softplus);
var Softsign = function(e82) {
    function t() {
        return null !== e82 && e82.apply(this, arguments) || this;
    }
    return __extends(t, e82), t.prototype.apply = function(e) {
        return softsign(e);
    }, t.className = "softsign", t;
}(Activation);
_tfjsCore.serialization.registerClass(Softsign);
var Tanh = function(e83) {
    function t() {
        return null !== e83 && e83.apply(this, arguments) || this;
    }
    return __extends(t, e83), t.prototype.apply = function(e) {
        return _tfjsCore.tanh(e);
    }, t.className = "tanh", t;
}(Activation);
_tfjsCore.serialization.registerClass(Tanh);
var Softmax = function(e84) {
    function t41() {
        return null !== e84 && e84.apply(this, arguments) || this;
    }
    return __extends(t41, e84), t41.prototype.apply = function(e, t) {
        return void 0 === t && (t = -1), _tfjsCore.softmax(e, t);
    }, t41.className = "softmax", t41;
}(Activation);
_tfjsCore.serialization.registerClass(Softmax);
var LogSoftmax = function(e85) {
    function t42() {
        return null !== e85 && e85.apply(this, arguments) || this;
    }
    return __extends(t42, e85), t42.prototype.apply = function(e, t) {
        return void 0 === t && (t = -1), _tfjsCore.logSoftmax(e, t);
    }, t42.className = "logSoftmax", t42;
}(Activation);
function serializeActivation(e) {
    return e.getClassName();
}
function deserializeActivation(e, t) {
    return void 0 === t && (t = {
    }), deserializeKerasObject(e, _tfjsCore.serialization.SerializationMap.getMap().classNameMap, t, "activation");
}
function getActivation(e) {
    var t;
    return null == e ? deserializeActivation(t = {
        className: "linear",
        config: {
        }
    }) : "string" == typeof e ? ((t = {
    }).className = e, t.config = {
    }, deserializeActivation(t)) : e instanceof Activation ? e : deserializeActivation(e);
}
function assertObjectArgs(e) {
    if (null != e && "object" != typeof e) throw new Error("Argument to L1L2 regularizer's constructor is expected to be an object, but received: " + e);
}
_tfjsCore.serialization.registerClass(LogSoftmax);
var Regularizer = function(e) {
    function t() {
        return null !== e && e.apply(this, arguments) || this;
    }
    return __extends(t, e), t;
}(_tfjsCore.serialization.Serializable), L1L2 = function(e86) {
    function t43(t) {
        var n = e86.call(this) || this;
        return assertObjectArgs(t), n.l1 = null == t || null == t.l1 ? 0.01 : t.l1, n.l2 = null == t || null == t.l2 ? 0.01 : t.l2, n.hasL1 = 0 !== n.l1, n.hasL2 = 0 !== n.l2, n;
    }
    return __extends(t43, e86), t43.prototype.apply = function(e) {
        var t = this;
        return _tfjsCore.tidy(function() {
            var n = _tfjsCore.zeros([
                1
            ]);
            return t.hasL1 && (n = _tfjsCore.add(n, _tfjsCore.sum(_tfjsCore.mul(t.l1, _tfjsCore.abs(e))))), t.hasL2 && (n = _tfjsCore.add(n, _tfjsCore.sum(_tfjsCore.mul(t.l2, square(e))))), n.asScalar();
        });
    }, t43.prototype.getConfig = function() {
        return {
            l1: this.l1,
            l2: this.l2
        };
    }, t43.fromConfig = function(e, t) {
        return new e({
            l1: t.l1,
            l2: t.l2
        });
    }, t43.className = "L1L2", t43;
}(Regularizer);
function l1(e) {
    return assertObjectArgs(e), new L1L2({
        l1: null != e ? e.l1 : null,
        l2: 0
    });
}
function l2(e) {
    return assertObjectArgs(e), new L1L2({
        l2: null != e ? e.l2 : null,
        l1: 0
    });
}
_tfjsCore.serialization.registerClass(L1L2);
var REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
    l1l2: "L1L2"
};
function serializeRegularizer(e) {
    return serializeKerasObject(e);
}
function deserializeRegularizer(e, t) {
    return void 0 === t && (t = {
    }), deserializeKerasObject(e, _tfjsCore.serialization.SerializationMap.getMap().classNameMap, t, "regularizer");
}
function getRegularizer(e) {
    return null == e ? null : "string" == typeof e ? deserializeRegularizer({
        className: e in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[e] : e,
        config: {
        }
    }) : e instanceof Regularizer ? e : deserializeRegularizer(e);
}
var ReLU = function(e87) {
    function t44(t) {
        var n = e87.call(this, null == t ? {
        } : t) || this;
        return n.supportsMasking = !0, null != t && (n.maxValue = t.maxValue), n;
    }
    return __extends(t44, e87), t44.prototype.call = function(e, t) {
        e = getExactlyOneTensor(e);
        var n = _tfjsCore.relu(e);
        return null != this.maxValue && (n = _tfjsCore.clipByValue(n, 0, this.maxValue)), n;
    }, t44.prototype.computeOutputShape = function(e) {
        return e;
    }, t44.prototype.getConfig = function() {
        var t = {
            maxValue: this.maxValue
        }, n = e87.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t44.className = "ReLU", t44;
}(Layer);
_tfjsCore.serialization.registerClass(ReLU);
var LeakyReLU = function(e88) {
    function t45(t) {
        var n = e88.call(this, null == t ? {
        } : t) || this;
        return n.DEFAULT_ALPHA = 0.3, null == t && (t = {
        }), n.alpha = null == t.alpha ? n.DEFAULT_ALPHA : t.alpha, n;
    }
    return __extends(t45, e88), t45.prototype.call = function(e, t) {
        var n = getExactlyOneTensor(e);
        return _tfjsCore.leakyRelu(n, this.alpha);
    }, t45.prototype.computeOutputShape = function(e) {
        return e;
    }, t45.prototype.getConfig = function() {
        var t = {
            alpha: this.alpha
        }, n = e88.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t45.className = "LeakyReLU", t45;
}(Layer);
_tfjsCore.serialization.registerClass(LeakyReLU);
var PReLU = function(e89) {
    function t46(t) {
        var n = e89.call(this, null == t ? {
        } : t) || this;
        if (n.DEFAULT_ALPHA_INITIALIZER = "zeros", null == t && (t = {
        }), n.supportsMasking = !0, n.alphaInitializer = getInitializer(t.alphaInitializer || n.DEFAULT_ALPHA_INITIALIZER), n.alphaRegularizer = getRegularizer(t.alphaRegularizer), n.alphaConstraint = getConstraint(t.alphaConstraint), null == t.sharedAxes) n.sharedAxes = null;
        else if (Array.isArray(t.sharedAxes)) n.sharedAxes = t.sharedAxes;
        else {
            if ("number" != typeof t.sharedAxes) throw new ValueError("Expected sharedAxes to be a number or an array of numbers, but got " + t.sharedAxes);
            n.sharedAxes = [
                t.sharedAxes
            ];
        }
        return n;
    }
    return __extends(t46, e89), t46.prototype.build = function(e) {
        var t = (e = getExactlyOneShape(e)).slice(1);
        if (null != this.sharedAxes) for(var n = 0, r = this.sharedAxes; n < r.length; n++)t[(a = r[n]) - 1] = 1;
        this.alpha = this.addWeight("alpha", t, "float32", this.alphaInitializer, this.alphaRegularizer, !0, this.alphaConstraint);
        var i = {
        };
        if (null != this.sharedAxes) for(var a = 1; a < e.length; ++a)i[a] = e[a];
        this.inputSpec = [
            new InputSpec({
                ndim: e.length,
                axes: i
            })
        ], this.built = !0;
    }, t46.prototype.call = function(e, t) {
        return e = getExactlyOneTensor(e), _tfjsCore.prelu(e, this.alpha.read());
    }, t46.prototype.getConfig = function() {
        var t = {
            alphaInitializer: serializeInitializer(this.alphaInitializer),
            alphaRegularizer: serializeRegularizer(this.alphaRegularizer),
            alphaConstraint: serializeConstraint(this.alphaConstraint),
            sharedAxes: this.sharedAxes
        }, n = e89.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t46.className = "PReLU", t46;
}(Layer);
_tfjsCore.serialization.registerClass(PReLU);
var ELU = function(e90) {
    function t47(t) {
        var n = e90.call(this, null == t ? {
        } : t) || this;
        if (n.DEFAULT_ALPHA = 1, null == t && (t = {
        }), null != t.alpha && t.alpha !== n.DEFAULT_ALPHA) throw new NotImplementedError("Non-default alpha value (" + t.alpha + ") is not supported by the ELU layer yet.");
        return n.alpha = null == t.alpha ? n.DEFAULT_ALPHA : t.alpha, n;
    }
    return __extends(t47, e90), t47.prototype.call = function(e, t) {
        var n = getExactlyOneTensor(e);
        return _tfjsCore.elu(n);
    }, t47.prototype.computeOutputShape = function(e) {
        return e;
    }, t47.prototype.getConfig = function() {
        var t = {
            alpha: this.alpha
        }, n = e90.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t47.className = "ELU", t47;
}(Layer);
_tfjsCore.serialization.registerClass(ELU);
var ThresholdedReLU = function(e91) {
    function t48(t) {
        var n = e91.call(this, null == t ? {
        } : t) || this;
        return n.DEFAULT_THETA = 1, null == t && (t = {
        }), n.theta = null == t.theta ? n.DEFAULT_THETA : t.theta, n;
    }
    return __extends(t48, e91), t48.prototype.call = function(e, t) {
        var n = getExactlyOneTensor(e);
        return n.mul(cast$1(n.greater(this.theta), "float32"));
    }, t48.prototype.computeOutputShape = function(e) {
        return e;
    }, t48.prototype.getConfig = function() {
        var t = {
            theta: this.theta
        }, n = e91.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t48.className = "ThresholdedReLU", t48;
}(Layer);
_tfjsCore.serialization.registerClass(ThresholdedReLU);
var Softmax$1 = function(e92) {
    function t49(t) {
        var n = e92.call(this, null == t ? {
        } : t) || this;
        return n.DEFAULT_AXIS = 1, null == t && (t = {
        }), n.softmax = (new Softmax).apply, n.axis = null == t.axis ? n.DEFAULT_AXIS : t.axis, n;
    }
    return __extends(t49, e92), t49.prototype.call = function(e, t) {
        var n = getExactlyOneTensor(e);
        return this.softmax(n, this.axis);
    }, t49.prototype.computeOutputShape = function(e) {
        return e;
    }, t49.prototype.getConfig = function() {
        var t = {
            axis: this.axis
        }, n = e92.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t49.className = "Softmax", t49;
}(Layer);
function normalizeArray(e, t, n) {
    if ("number" == typeof e) return pyListRepeat(e, t);
    if (e.length !== t) throw new ValueError("The " + n + " argument must be an integer or tuple of " + t + " integers. Received: " + e.length + " elements.");
    for(var r = 0; r < t; ++r){
        var i = e[r];
        if (!isInteger(i)) throw new ValueError("The " + n + " argument must be an integer or tuple of " + t + " integers. Received: " + JSON.stringify(e) + " including a non-integer number " + i);
    }
    return e;
}
function convOutputLength(e, t, n, r, i) {
    var a;
    return void 0 === i && (i = 1), null == e ? e : (a = "same" === n ? e : e - (t + (t - 1) * (i - 1)) + 1, Math.floor((a + r - 1) / r));
}
function deconvLength(e, t, n, r) {
    if (null == e) return null;
    if ("valid" === r) e = e * t + max$1([
        n - t,
        0
    ]);
    else {
        if ("same" !== r) throw new ValueError("Unsupport padding mode: " + r + ".");
        e *= t;
    }
    return e;
}
function preprocessConv2DInput(e, t) {
    return _tfjsCore.tidy(function() {
        return checkDataFormat(t), "channelsFirst" === t ? _tfjsCore.transpose(e, [
            0,
            2,
            3,
            1
        ]) : e;
    });
}
function preprocessConv3DInput(e, t) {
    return _tfjsCore.tidy(function() {
        return checkDataFormat(t), "channelsFirst" === t ? _tfjsCore.transpose(e, [
            0,
            2,
            3,
            4,
            1
        ]) : e;
    });
}
function conv1dWithBias(e, t, n, r, i, a, o) {
    return void 0 === r && (r = 1), void 0 === i && (i = "valid"), void 0 === o && (o = 1), _tfjsCore.tidy(function() {
        if (null == a && (a = imageDataFormat()), checkDataFormat(a), 3 !== e.shape.length) throw new ValueError("The input of a conv1dWithBias operation should be 3, but is " + e.shape.length + " instead.");
        if (3 !== t.shape.length) throw new ValueError("The kernel for a conv1dWithBias operation should be 3, but is " + t.shape.length + " instead");
        if (null != n && 1 !== n.shape.length) throw new ValueError("The bias for a conv1dWithBias operation should be 1, but is " + t.shape.length + " instead");
        if ("channelsFirst" === a && (e = _tfjsCore.transpose(e, [
            0,
            2,
            1
        ])), "causal" === i) throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
        var s = _tfjsCore.conv1d(e, t, r, "same" === i ? "same" : "valid", "NWC", o);
        return null != n && (s = biasAdd(s, n)), s;
    });
}
function conv2dWithBiasActivation(e, t, n, r, i, a, o, s) {
    return void 0 === r && (r = [
        1,
        1
    ]), void 0 === i && (i = "valid"), void 0 === s && (s = null), _tfjsCore.tidy(function() {
        if (null == a && (a = imageDataFormat()), checkDataFormat(a), 3 !== e.rank && 4 !== e.rank) throw new ValueError("conv2dWithBiasActivation expects input to be of rank 3 or 4, but received " + e.rank + ".");
        if (3 !== t.rank && 4 !== t.rank) throw new ValueError("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received " + e.rank + ".");
        var l = preprocessConv2DInput(e, a);
        if ("causal" === i) throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
        return l = _tfjsCore.fused.conv2d({
            x: l,
            filter: t,
            strides: r,
            pad: "same" === i ? "same" : "valid",
            dilations: o,
            dataFormat: "NHWC",
            bias: n,
            activation: s
        }), "channelsFirst" === a && (l = _tfjsCore.transpose(l, [
            0,
            3,
            1,
            2
        ])), l;
    });
}
function conv3dWithBias(e, t, n, r, i, a, o) {
    return void 0 === r && (r = [
        1,
        1,
        1
    ]), void 0 === i && (i = "valid"), _tfjsCore.tidy(function() {
        if (null == a && (a = imageDataFormat()), checkDataFormat(a), 4 !== e.rank && 5 !== e.rank) throw new ValueError("conv3dWithBias expects input to be of rank 4 or 5, but received " + e.rank + ".");
        if (4 !== t.rank && 5 !== t.rank) throw new ValueError("conv3dWithBias expects kernel to be of rank 4 or 5, but received " + e.rank + ".");
        var s = preprocessConv3DInput(e, a);
        if ("causal" === i) throw new NotImplementedError("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
        return s = _tfjsCore.conv3d(s, t, r, "same" === i ? "same" : "valid", "NDHWC", o), null != n && (s = biasAdd(s, n)), "channelsFirst" === a && (s = _tfjsCore.transpose(s, [
            0,
            4,
            1,
            2,
            3
        ])), s;
    });
}
_tfjsCore.serialization.registerClass(Softmax$1);
var BaseConv = function(e93) {
    function t50(n, r) {
        var i = e93.call(this, r) || this;
        if (i.bias = null, i.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", i.DEFAULT_BIAS_INITIALIZER = "zeros", t50.verifyArgs(r), i.rank = n, assertPositiveInteger(i.rank, "rank"), 1 !== i.rank && 2 !== i.rank && 3 !== i.rank) throw new NotImplementedError("Convolution layer for rank other than 1, 2, or 3 (" + i.rank + ") is not implemented yet.");
        if (i.kernelSize = normalizeArray(r.kernelSize, n, "kernelSize"), i.strides = normalizeArray(null == r.strides ? 1 : r.strides, n, "strides"), i.padding = null == r.padding ? "valid" : r.padding, checkPaddingMode(i.padding), i.dataFormat = null == r.dataFormat ? "channelsLast" : r.dataFormat, checkDataFormat(i.dataFormat), i.activation = getActivation(r.activation), i.useBias = null == r.useBias || r.useBias, i.biasInitializer = getInitializer(r.biasInitializer || i.DEFAULT_BIAS_INITIALIZER), i.biasConstraint = getConstraint(r.biasConstraint), i.biasRegularizer = getRegularizer(r.biasRegularizer), i.activityRegularizer = getRegularizer(r.activityRegularizer), i.dilationRate = normalizeArray(null == r.dilationRate ? 1 : r.dilationRate, n, "dilationRate"), 1 === i.rank && Array.isArray(i.dilationRate) && 1 !== i.dilationRate.length) throw new ValueError("dilationRate must be a number or an array of a single number for 1D convolution, but received " + JSON.stringify(i.dilationRate));
        if (2 === i.rank) {
            if ("number" == typeof i.dilationRate) i.dilationRate = [
                i.dilationRate,
                i.dilationRate
            ];
            else if (2 !== i.dilationRate.length) throw new ValueError("dilationRate must be a number or array of two numbers for 2D convolution, but received " + JSON.stringify(i.dilationRate));
        } else if (3 === i.rank) {
            if ("number" == typeof i.dilationRate) i.dilationRate = [
                i.dilationRate,
                i.dilationRate,
                i.dilationRate
            ];
            else if (3 !== i.dilationRate.length) throw new ValueError("dilationRate must be a number or array of three numbers for 3D convolution, but received " + JSON.stringify(i.dilationRate));
        }
        return i;
    }
    return __extends(t50, e93), t50.verifyArgs = function(e) {
        if (assert("kernelSize" in e, "required key 'kernelSize' not in config"), "number" != typeof e.kernelSize && !checkArrayTypeAndLength(e.kernelSize, "number", 1, 3)) throw new ValueError("BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received " + JSON.stringify(e.kernelSize) + ".");
    }, t50.prototype.getConfig = function() {
        var t = {
            kernelSize: this.kernelSize,
            strides: this.strides,
            padding: this.padding,
            dataFormat: this.dataFormat,
            dilationRate: this.dilationRate,
            activation: serializeActivation(this.activation),
            useBias: this.useBias,
            biasInitializer: serializeInitializer(this.biasInitializer),
            biasRegularizer: serializeRegularizer(this.biasRegularizer),
            activityRegularizer: serializeRegularizer(this.activityRegularizer),
            biasConstraint: serializeConstraint(this.biasConstraint)
        }, n = e93.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t50;
}(Layer), Conv = function(e94) {
    function t51(n, r) {
        var i = e94.call(this, n, r) || this;
        return i.kernel = null, t51.verifyArgs(r), i.filters = r.filters, assertPositiveInteger(i.filters, "filters"), i.kernelInitializer = getInitializer(r.kernelInitializer || i.DEFAULT_KERNEL_INITIALIZER), i.kernelConstraint = getConstraint(r.kernelConstraint), i.kernelRegularizer = getRegularizer(r.kernelRegularizer), i;
    }
    return __extends(t51, e94), t51.prototype.build = function(e) {
        var t;
        e = getExactlyOneShape(e);
        var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
        if (null == e[n]) throw new ValueError("The channel dimension of the input should be defined. Found " + e[n]);
        var r = e[n], i = this.kernelSize.concat([
            r,
            this.filters
        ]);
        this.kernel = this.addWeight("kernel", i, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [
            this.filters
        ], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [
            {
                ndim: this.rank + 2,
                axes: (t = {
                }, t[n] = r, t)
            }
        ], this.built = !0;
    }, t51.prototype.call = function(e, t52) {
        var n = this;
        return _tfjsCore.tidy(function() {
            var t;
            e = getExactlyOneTensor(e);
            var r = null == n.bias ? null : n.bias.read(), i = mapActivationToFusedKernel(n.activation.getClassName());
            if (null != i && 2 === n.rank) t = conv2dWithBiasActivation(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate, i);
            else {
                if (1 === n.rank) t = conv1dWithBias(e, n.kernel.read(), r, n.strides[0], n.padding, n.dataFormat, n.dilationRate[0]);
                else if (2 === n.rank) t = conv2dWithBiasActivation(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate);
                else {
                    if (3 !== n.rank) throw new NotImplementedError("convolutions greater than 3D are not implemented yet.");
                    t = conv3dWithBias(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate);
                }
                null != n.activation && (t = n.activation.apply(t));
            }
            return t;
        });
    }, t51.prototype.computeOutputShape = function(e) {
        e = getExactlyOneShape(e);
        for(var t = [], n = "channelsLast" === this.dataFormat ? e.slice(1, e.length - 1) : e.slice(2), r = 0; r < n.length; ++r){
            var i = convOutputLength(n[r], this.kernelSize[r], this.padding, this.strides[r], "number" == typeof this.dilationRate ? this.dilationRate : this.dilationRate[r]);
            t.push(i);
        }
        var a = [
            e[0]
        ];
        return "channelsLast" === this.dataFormat ? (a = a.concat(t)).push(this.filters) : (a.push(this.filters), a = a.concat(t)), a;
    }, t51.prototype.getConfig = function() {
        var t = {
            filters: this.filters,
            kernelInitializer: serializeInitializer(this.kernelInitializer),
            kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
            kernelConstraint: serializeConstraint(this.kernelConstraint)
        }, n = e94.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t51.verifyArgs = function(e) {
        if (!("filters" in e) || "number" != typeof e.filters || e.filters < 1) throw new ValueError("Convolution layer expected config.filters to be a 'number' > 0 but got " + JSON.stringify(e.filters));
    }, t51;
}(BaseConv), Conv2D = function(e95) {
    function t53(n) {
        var r = e95.call(this, 2, n) || this;
        return t53.verifyArgs(n), r;
    }
    return __extends(t53, e95), t53.prototype.getConfig = function() {
        var t = e95.prototype.getConfig.call(this);
        return delete t.rank, t;
    }, t53.verifyArgs = function(e) {
        if ("number" != typeof e.kernelSize && !checkArrayTypeAndLength(e.kernelSize, "number", 1, 2)) throw new ValueError("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received " + JSON.stringify(e.kernelSize) + ".");
    }, t53.className = "Conv2D", t53;
}(Conv);
_tfjsCore.serialization.registerClass(Conv2D);
var Conv3D = function(e96) {
    function t54(n) {
        var r = e96.call(this, 3, n) || this;
        return t54.verifyArgs(n), r;
    }
    return __extends(t54, e96), t54.prototype.getConfig = function() {
        var t = e96.prototype.getConfig.call(this);
        return delete t.rank, t;
    }, t54.verifyArgs = function(e) {
        if ("number" != typeof e.kernelSize && (!Array.isArray(e.kernelSize) || 1 !== e.kernelSize.length && 3 !== e.kernelSize.length)) throw new ValueError("Conv3D expects config.kernelSize to be number or [number, number, number], but received " + JSON.stringify(e.kernelSize) + ".");
    }, t54.className = "Conv3D", t54;
}(Conv);
_tfjsCore.serialization.registerClass(Conv3D);
var Conv2DTranspose = function(e97) {
    function t55(t) {
        var n = e97.call(this, t) || this;
        if (n.inputSpec = [
            new InputSpec({
                ndim: 4
            })
        ], "same" !== n.padding && "valid" !== n.padding) throw new ValueError("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode " + n.padding);
        return n;
    }
    return __extends(t55, e97), t55.prototype.build = function(e) {
        var t;
        if (4 !== (e = getExactlyOneShape(e)).length) throw new ValueError("Input should have rank 4; Received input shape: " + JSON.stringify(e));
        var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
        if (null == e[n]) throw new ValueError("The channel dimension of the inputs should be defined. Found `None`.");
        var r = e[n], i = this.kernelSize.concat([
            this.filters,
            r
        ]);
        this.kernel = this.addWeight("kernel", i, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [
            this.filters
        ], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [
            new InputSpec({
                ndim: 4,
                axes: (t = {
                }, t[n] = r, t)
            })
        ], this.built = !0;
    }, t55.prototype.call = function(e, t56) {
        var n = this;
        return _tfjsCore.tidy(function() {
            var t = getExactlyOneTensor(e);
            if (4 !== t.shape.length) throw new ValueError("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-" + t.shape.length);
            var r, i, a = t.shape, o = a[0];
            "channelsFirst" === n.dataFormat ? (r = 2, i = 3) : (r = 1, i = 2);
            var s = a[r], l = a[i], u = n.kernelSize[0], c = n.kernelSize[1], p = n.strides[0], h = n.strides[1], d = [
                o,
                deconvLength(s, p, u, n.padding),
                deconvLength(l, h, c, n.padding),
                n.filters
            ];
            "channelsLast" !== n.dataFormat && (t = _tfjsCore.transpose(t, [
                0,
                2,
                3,
                1
            ]));
            var f = _tfjsCore.conv2dTranspose(t, n.kernel.read(), d, n.strides, n.padding);
            return "channelsLast" !== n.dataFormat && (f = _tfjsCore.transpose(f, [
                0,
                3,
                1,
                2
            ])), null != n.bias && (f = biasAdd(f, n.bias.read(), n.dataFormat)), null != n.activation && (f = n.activation.apply(f)), f;
        });
    }, t55.prototype.computeOutputShape = function(e) {
        var t, n, r, i = (e = getExactlyOneShape(e)).slice();
        "channelsFirst" === this.dataFormat ? (t = 1, n = 2, r = 3) : (t = 3, n = 1, r = 2);
        var a = this.kernelSize[0], o = this.kernelSize[1], s = this.strides[0], l = this.strides[1];
        return i[t] = this.filters, i[n] = deconvLength(i[n], s, a, this.padding), i[r] = deconvLength(i[r], l, o, this.padding), i;
    }, t55.prototype.getConfig = function() {
        var t = e97.prototype.getConfig.call(this);
        return delete t.dilationRate, t;
    }, t55.className = "Conv2DTranspose", t55;
}(Conv2D);
_tfjsCore.serialization.registerClass(Conv2DTranspose);
var SeparableConv = function(e98) {
    function t57(t, n) {
        var r = e98.call(this, t, n) || this;
        if (r.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", r.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", r.depthwiseKernel = null, r.pointwiseKernel = null, null == n.filters) throw new ValueError("The `filters` configuration field is required by SeparableConv, but is unspecified.");
        if (null != n.kernelInitializer || null != n.kernelRegularizer || null != n.kernelConstraint) throw new ValueError("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
        if (null != n.padding && "same" !== n.padding && "valid" !== n.padding) throw new ValueError("SeparableConv" + r.rank + "D supports only padding modes: 'same' and 'valid', but received " + JSON.stringify(n.padding));
        return r.depthMultiplier = null == n.depthMultiplier ? 1 : n.depthMultiplier, r.depthwiseInitializer = getInitializer(n.depthwiseInitializer || r.DEFAULT_DEPTHWISE_INITIALIZER), r.depthwiseRegularizer = getRegularizer(n.depthwiseRegularizer), r.depthwiseConstraint = getConstraint(n.depthwiseConstraint), r.pointwiseInitializer = getInitializer(n.depthwiseInitializer || r.DEFAULT_POINTWISE_INITIALIZER), r.pointwiseRegularizer = getRegularizer(n.pointwiseRegularizer), r.pointwiseConstraint = getConstraint(n.pointwiseConstraint), r;
    }
    return __extends(t57, e98), t57.prototype.build = function(e) {
        var t;
        if ((e = getExactlyOneShape(e)).length < this.rank + 2) throw new ValueError("Inputs to SeparableConv" + this.rank + "D should have rank " + (this.rank + 2) + ", but received input shape: " + JSON.stringify(e));
        var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
        if (null == e[n] || e[n] < 0) throw new ValueError("The channel dimension of the inputs should be defined, but found " + JSON.stringify(e[n]));
        for(var r = e[n], i = this.kernelSize.concat([
            r,
            this.depthMultiplier
        ]), a = [], o = 0; o < this.rank; ++o)a.push(1);
        a.push(r * this.depthMultiplier, this.filters);
        this.depthwiseKernel = this.addWeight("depthwise_kernel", i, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", a, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, !0, this.pointwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [
            this.filters
        ], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.inputSpec = [
            new InputSpec({
                ndim: this.rank + 2,
                axes: (t = {
                }, t[n] = r, t)
            })
        ], this.built = !0;
    }, t57.prototype.call = function(e, t58) {
        var n = this;
        return _tfjsCore.tidy(function() {
            var t;
            if (e = getExactlyOneTensor(e), 1 === n.rank) throw new NotImplementedError("1D separable convolution is not implemented yet.");
            return 2 === n.rank && ("channelsFirst" === n.dataFormat && (e = _tfjsCore.transpose(e, [
                0,
                2,
                3,
                1
            ])), t = _tfjsCore.separableConv2d(e, n.depthwiseKernel.read(), n.pointwiseKernel.read(), n.strides, n.padding, n.dilationRate, "NHWC")), n.useBias && (t = biasAdd(t, n.bias.read(), n.dataFormat)), null != n.activation && (t = n.activation.apply(t)), "channelsFirst" === n.dataFormat && (t = _tfjsCore.transpose(t, [
                0,
                3,
                1,
                2
            ])), t;
        });
    }, t57.prototype.getConfig = function() {
        var t = e98.prototype.getConfig.call(this);
        return delete t.rank, delete t.kernelInitializer, delete t.kernelRegularizer, delete t.kernelConstraint, t.depthwiseInitializer = serializeInitializer(this.depthwiseInitializer), t.pointwiseInitializer = serializeInitializer(this.pointwiseInitializer), t.depthwiseRegularizer = serializeRegularizer(this.depthwiseRegularizer), t.pointwiseRegularizer = serializeRegularizer(this.pointwiseRegularizer), t.depthwiseConstraint = serializeConstraint(this.depthwiseConstraint), t.pointwiseConstraint = serializeConstraint(this.pointwiseConstraint), t;
    }, t57.className = "SeparableConv", t57;
}(Conv), SeparableConv2D = function(e) {
    function t59(t) {
        return e.call(this, 2, t) || this;
    }
    return __extends(t59, e), t59.className = "SeparableConv2D", t59;
}(SeparableConv);
_tfjsCore.serialization.registerClass(SeparableConv2D);
var Conv1D = function(e99) {
    function t60(n) {
        var r = e99.call(this, 1, n) || this;
        return t60.verifyArgs(n), r.inputSpec = [
            {
                ndim: 3
            }
        ], r;
    }
    return __extends(t60, e99), t60.prototype.getConfig = function() {
        var t = e99.prototype.getConfig.call(this);
        return delete t.rank, delete t.dataFormat, t;
    }, t60.verifyArgs = function(e) {
        if ("number" != typeof e.kernelSize && !checkArrayTypeAndLength(e.kernelSize, "number", 1, 1)) throw new ValueError("Conv1D expects config.kernelSize to be number or number[] with length 1, but received " + JSON.stringify(e.kernelSize) + ".");
    }, t60.className = "Conv1D", t60;
}(Conv);
_tfjsCore.serialization.registerClass(Conv1D);
var Cropping2D = function(e100) {
    function t61(t) {
        var n = e100.call(this, t) || this;
        return "number" == typeof t.cropping ? n.cropping = [
            [
                t.cropping,
                t.cropping
            ],
            [
                t.cropping,
                t.cropping
            ]
        ] : "number" == typeof t.cropping[0] ? n.cropping = [
            [
                t.cropping[0],
                t.cropping[0]
            ],
            [
                t.cropping[1],
                t.cropping[1]
            ]
        ] : n.cropping = t.cropping, n.dataFormat = void 0 === t.dataFormat ? "channelsLast" : t.dataFormat, n.inputSpec = [
            {
                ndim: 4
            }
        ], n;
    }
    return __extends(t61, e100), t61.prototype.computeOutputShape = function(e) {
        return "channelsFirst" === this.dataFormat ? [
            e[0],
            e[1],
            e[2] - this.cropping[0][0] - this.cropping[0][1],
            e[3] - this.cropping[1][0] - this.cropping[1][1]
        ] : [
            e[0],
            e[1] - this.cropping[0][0] - this.cropping[0][1],
            e[2] - this.cropping[1][0] - this.cropping[1][1],
            e[3]
        ];
    }, t61.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            return e = getExactlyOneTensor(e), "channelsLast" === n.dataFormat ? sliceAlongAxis(sliceAlongAxis(e, n.cropping[0][0], e.shape[1] - n.cropping[0][0] - n.cropping[0][1], 2), n.cropping[1][0], e.shape[2] - n.cropping[1][1] - n.cropping[1][0], 3) : sliceAlongAxis(sliceAlongAxis(e, n.cropping[0][0], e.shape[2] - n.cropping[0][0] - n.cropping[0][1], 3), n.cropping[1][0], e.shape[3] - n.cropping[1][1] - n.cropping[1][0], 4);
        });
    }, t61.prototype.getConfig = function() {
        var t = {
            cropping: this.cropping,
            dataFormat: this.dataFormat
        }, n = e100.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t61.className = "Cropping2D", t61;
}(Layer);
_tfjsCore.serialization.registerClass(Cropping2D);
var UpSampling2D = function(e101) {
    function t62(t) {
        var n = e101.call(this, t) || this;
        return n.DEFAULT_SIZE = [
            2,
            2
        ], n.inputSpec = [
            {
                ndim: 4
            }
        ], n.size = null == t.size ? n.DEFAULT_SIZE : t.size, n.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, n;
    }
    return __extends(t62, e101), t62.prototype.computeOutputShape = function(e) {
        if ("channelsFirst" === this.dataFormat) {
            var t = null == e[2] ? null : this.size[0] * e[2], n = null == e[3] ? null : this.size[1] * e[3];
            return [
                e[0],
                e[1],
                t,
                n
            ];
        }
        t = null == e[1] ? null : this.size[0] * e[1], n = null == e[2] ? null : this.size[1] * e[2];
        return [
            e[0],
            t,
            n,
            e[3]
        ];
    }, t62.prototype.call = function(e, t63) {
        var n = this;
        return _tfjsCore.tidy(function() {
            var t = getExactlyOneTensor(e), r = t.shape;
            if ("channelsFirst" === n.dataFormat) {
                t = _tfjsCore.transpose(t, [
                    0,
                    2,
                    3,
                    1
                ]);
                var i = n.size[0] * r[2], a = n.size[1] * r[3], o = t.resizeNearestNeighbor([
                    i,
                    a
                ]);
                return _tfjsCore.transpose(o, [
                    0,
                    3,
                    1,
                    2
                ]);
            }
            i = n.size[0] * r[1], a = n.size[1] * r[2];
            return t.resizeNearestNeighbor([
                i,
                a
            ]);
        });
    }, t62.prototype.getConfig = function() {
        var t = {
            size: this.size,
            dataFormat: this.dataFormat
        }, n = e101.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t62.className = "UpSampling2D", t62;
}(Layer);
function depthwiseConv2d$1(e, t, n, r, i, a) {
    return void 0 === n && (n = [
        1,
        1
    ]), void 0 === r && (r = "valid"), _tfjsCore.tidy(function() {
        null == i && (i = imageDataFormat()), checkDataFormat(i);
        var o = preprocessConv2DInput(e, i);
        if (4 !== e.rank) throw new ValueError("Input for depthwiseConv2d is required to be 4-D, but is instead " + e.rank + "-D");
        if (4 !== t.rank) throw new ValueError("depthwiseKernel is required to be 4-D, but is instead " + t.rank + "-D");
        return o = _tfjsCore.depthwiseConv2d(o, t, n, "same" === r ? "same" : "valid", "NHWC", a), "channelsFirst" === i && (o = _tfjsCore.transpose(o, [
            0,
            3,
            1,
            2
        ])), o;
    });
}
_tfjsCore.serialization.registerClass(UpSampling2D);
var DepthwiseConv2D = function(e102) {
    function t64(t) {
        var n = e102.call(this, 2, t) || this;
        return n.depthwiseKernel = null, n.depthMultiplier = null == t.depthMultiplier ? 1 : t.depthMultiplier, n.depthwiseInitializer = getInitializer(t.depthwiseInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.depthwiseConstraint = getConstraint(t.depthwiseConstraint), n.depthwiseRegularizer = getRegularizer(t.depthwiseRegularizer), n;
    }
    return __extends(t64, e102), t64.prototype.build = function(e) {
        if ((e = getExactlyOneShape(e)).length < 4) throw new ValueError("Inputs to DepthwiseConv2D should have rank 4. Received input shape: " + JSON.stringify(e) + ".");
        var t = "channelsFirst" === this.dataFormat ? 1 : 3;
        if (null == e[t] || e[t] < 0) throw new ValueError("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (" + e[t] + ").");
        var n = e[t], r = [
            this.kernelSize[0],
            this.kernelSize[1],
            n,
            this.depthMultiplier
        ];
        this.depthwiseKernel = this.addWeight("depthwise_kernel", r, null, this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [
            n * this.depthMultiplier
        ], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0;
    }, t64.prototype.call = function(e, t65) {
        var n = this;
        return _tfjsCore.tidy(function() {
            var t = depthwiseConv2d$1(e = getExactlyOneTensor(e), n.depthwiseKernel.read(), n.strides, n.padding, n.dataFormat, null);
            return n.useBias && (t = biasAdd(t, n.bias.read(), n.dataFormat)), null != n.activation && (t = n.activation.apply(t)), t;
        });
    }, t64.prototype.computeOutputShape = function(e) {
        e = getExactlyOneShape(e);
        var t = "channelsFirst" === this.dataFormat ? e[2] : e[1], n = "channelsFirst" === this.dataFormat ? e[3] : e[2], r = "channelsFirst" === this.dataFormat ? e[1] * this.depthMultiplier : e[3] * this.depthMultiplier, i = convOutputLength(t, this.kernelSize[0], this.padding, this.strides[0]), a = convOutputLength(n, this.kernelSize[1], this.padding, this.strides[1]);
        return "channelsFirst" === this.dataFormat ? [
            e[0],
            r,
            i,
            a
        ] : [
            e[0],
            i,
            a,
            r
        ];
    }, t64.prototype.getConfig = function() {
        var t = e102.prototype.getConfig.call(this);
        return t.depthMultiplier = this.depthMultiplier, t.depthwiseInitializer = serializeInitializer(this.depthwiseInitializer), t.depthwiseRegularizer = serializeRegularizer(this.depthwiseRegularizer), t.depthwiseConstraint = serializeConstraint(this.depthwiseRegularizer), t;
    }, t64.className = "DepthwiseConv2D", t64;
}(BaseConv);
_tfjsCore.serialization.registerClass(DepthwiseConv2D);
var Dropout = function(e103) {
    function t66(t) {
        var n = e103.call(this, t) || this;
        return n.rate = Math.max(Math.min(t.rate, 1), 0), n.noiseShape = t.noiseShape, n.seed = t.seed, n.supportsMasking = !0, n;
    }
    return __extends(t66, e103), t66.prototype.getNoiseShape = function(e) {
        if (null == this.noiseShape) return this.noiseShape;
        for(var t = e.shape, n = [], r = 0; r < this.noiseShape.length; ++r)n.push(null == this.noiseShape[r] ? t[r] : this.noiseShape[r]);
        return n;
    }, t66.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            n.invokeCallHook(e, t);
            var r = getExactlyOneTensor(e);
            if (0 < n.rate && n.rate < 1) {
                var i = null != t.training && t.training, a = n.getNoiseShape(r);
                return inTrainPhase(function() {
                    return dropout$1(r, n.rate, a, n.seed);
                }, function() {
                    return r;
                }, i);
            }
            return e;
        });
    }, t66.prototype.getConfig = function() {
        var t = {
            rate: this.rate,
            noiseShape: this.noiseShape,
            seed: this.seed
        }, n = e103.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t66.prototype.dispose = function() {
        return e103.prototype.dispose.call(this);
    }, t66.className = "Dropout", t66;
}(Layer);
_tfjsCore.serialization.registerClass(Dropout);
var SpatialDropout1D = function(e104) {
    function t67(t) {
        var n = e104.call(this, t) || this;
        return n.inputSpec = [
            {
                ndim: 3
            }
        ], n;
    }
    return __extends(t67, e104), t67.prototype.getNoiseShape = function(e) {
        var t = e.shape;
        return [
            t[0],
            1,
            t[2]
        ];
    }, t67.className = "SpatialDropout1D", t67;
}(Dropout);
_tfjsCore.serialization.registerClass(SpatialDropout1D);
var Dense = function(e105) {
    function t68(t) {
        var n = e105.call(this, t) || this;
        if (n.activation = null, n.useBias = !0, n.kernel = null, n.bias = null, n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_BIAS_INITIALIZER = "zeros", null == t.batchInputShape && null == t.inputShape && null != t.inputDim) {
            var r = null;
            null != t.batchSize && (r = t.batchSize), n.batchInputShape = [
                r,
                t.inputDim
            ];
        }
        return n.units = t.units, assertPositiveInteger(n.units, "units"), n.activation = getActivation(t.activation), null != t.useBias && (n.useBias = t.useBias), n.kernelInitializer = getInitializer(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.biasInitializer = getInitializer(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.kernelConstraint = getConstraint(t.kernelConstraint), n.biasConstraint = getConstraint(t.biasConstraint), n.kernelRegularizer = getRegularizer(t.kernelRegularizer), n.biasRegularizer = getRegularizer(t.biasRegularizer), n.activityRegularizer = getRegularizer(t.activityRegularizer), n.supportsMasking = !0, n.inputSpec = [
            {
                minNDim: 2
            }
        ], n;
    }
    return __extends(t68, e105), t68.prototype.build = function(e) {
        var t, n = (e = getExactlyOneShape(e))[e.length - 1];
        null == this.kernel && (this.kernel = this.addWeight("kernel", [
            n,
            this.units
        ], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [
            this.units
        ], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint))), this.inputSpec = [
            {
                minNDim: 2,
                axes: (t = {
                }, t[-1] = n, t)
            }
        ], this.built = !0;
    }, t68.prototype.computeOutputShape = function(e) {
        var t = (e = getExactlyOneShape(e)).slice();
        return t[t.length - 1] = this.units, t;
    }, t68.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            n.invokeCallHook(e, t);
            var r, i = getExactlyOneTensor(e), a = mapActivationToFusedKernel(n.activation.getClassName());
            return null != a ? r = dot(i, n.kernel.read(), a, n.bias ? n.bias.read() : null) : (r = dot(i, n.kernel.read()), null != n.bias && (r = biasAdd(r, n.bias.read())), null != n.activation && (r = n.activation.apply(r))), r;
        });
    }, t68.prototype.getConfig = function() {
        var t = {
            units: this.units,
            activation: serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: serializeInitializer(this.kernelInitializer),
            biasInitializer: serializeInitializer(this.biasInitializer),
            kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
            biasRegularizer: serializeRegularizer(this.biasRegularizer),
            activityRegularizer: serializeRegularizer(this.activityRegularizer),
            kernelConstraint: serializeConstraint(this.kernelConstraint),
            biasConstraint: serializeConstraint(this.biasConstraint)
        }, n = e105.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t68.className = "Dense", t68;
}(Layer);
_tfjsCore.serialization.registerClass(Dense);
var Flatten = function(e106) {
    function t69(t) {
        var n = this;
        return t = t || {
        }, (n = e106.call(this, t) || this).inputSpec = [
            {
                minNDim: 3
            }
        ], n.dataFormat = t.dataFormat, n;
    }
    return __extends(t69, e106), t69.prototype.computeOutputShape = function(e) {
        for(var t = 0, n = (e = getExactlyOneShape(e)).slice(1); t < n.length; t++){
            if (null == n[t]) throw new ValueError('The shape of the input to "Flatten" is not fully defined (got ' + e.slice(1) + '). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.');
        }
        return [
            e[0],
            arrayProd(e, 1)
        ];
    }, t69.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            n.invokeCallHook(e, t);
            var r = getExactlyOneTensor(e);
            if ("channelsFirst" === n.dataFormat && r.rank > 1) {
                for(var i = [
                    0
                ], a = 2; a < r.rank; ++a)i.push(a);
                i.push(1), r = r.transpose(i);
            }
            return batchFlatten(r);
        });
    }, t69.prototype.getConfig = function() {
        var t = {
        };
        null != this.dataFormat && (t.dataFormat = this.dataFormat);
        var n = e106.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t69.className = "Flatten", t69;
}(Layer);
_tfjsCore.serialization.registerClass(Flatten);
var Activation$1 = function(e107) {
    function t70(t) {
        var n = e107.call(this, t) || this;
        return n.supportsMasking = !0, n.activation = getActivation(t.activation), n;
    }
    return __extends(t70, e107), t70.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            n.invokeCallHook(e, t);
            var r = getExactlyOneTensor(e);
            return n.activation.apply(r);
        });
    }, t70.prototype.getConfig = function() {
        var t = {
            activation: serializeActivation(this.activation)
        }, n = e107.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t70.className = "Activation", t70;
}(Layer);
_tfjsCore.serialization.registerClass(Activation$1);
var RepeatVector = function(e108) {
    function t71(t) {
        var n = e108.call(this, t) || this;
        return n.n = t.n, n.inputSpec = [
            {
                ndim: 2
            }
        ], n;
    }
    return __extends(t71, e108), t71.prototype.computeOutputShape = function(e) {
        return [
            e[0],
            this.n,
            e[1]
        ];
    }, t71.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            return repeat(e = getExactlyOneTensor(e), n.n);
        });
    }, t71.prototype.getConfig = function() {
        var t = {
            n: this.n
        }, n = e108.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t71.className = "RepeatVector", t71;
}(Layer);
_tfjsCore.serialization.registerClass(RepeatVector);
var Reshape = function(e109) {
    function t72(t) {
        var n = e109.call(this, t) || this;
        n.targetShape = t.targetShape;
        for(var r = 0; r < n.targetShape.length; ++r)n.isUnknown(n.targetShape[r]) && (n.targetShape[r] = null);
        return n;
    }
    return __extends(t72, e109), t72.prototype.isUnknown = function(e) {
        return e < 0 || null == e;
    }, t72.prototype.fixUnknownDimension = function(e, t) {
        for(var n = "Total size of new array must be unchanged.", r = t.slice(), i = 1, a = null, o = 0; o < r.length; ++o){
            var s = r[o];
            if (this.isUnknown(s)) {
                if (null !== a) throw new ValueError("Can only specifiy one unknown dimension.");
                a = o;
            } else i *= s;
        }
        var l = arrayProd(e);
        if (null !== a) {
            if (0 === i || l % i != 0) throw new ValueError(n);
            r[a] = l / i;
        } else if (l !== i) throw new ValueError(n);
        return r;
    }, t72.prototype.computeOutputShape = function(e) {
        for(var t = !1, n = 0; n < e.length; ++n)if (this.isUnknown(e[n])) {
            t = !0;
            break;
        }
        return t ? e.slice(0, 1).concat(this.targetShape) : e.slice(0, 1).concat(this.fixUnknownDimension(e.slice(1), this.targetShape));
    }, t72.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            n.invokeCallHook(e, t);
            var r = getExactlyOneTensor(e), i = r.shape, a = i.slice(0, 1).concat(n.fixUnknownDimension(i.slice(1), n.targetShape));
            return r.reshape(a);
        });
    }, t72.prototype.getConfig = function() {
        var t = {
            targetShape: this.targetShape
        }, n = e109.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t72.className = "Reshape", t72;
}(Layer);
_tfjsCore.serialization.registerClass(Reshape);
var Permute = function(e110) {
    function t73(t) {
        var n = e110.call(this, t) || this;
        if (null == t.dims) throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
        if (!Array.isArray(t.dims)) throw new Error("Permute constructor requires `dims` to be an Array, but received " + t.dims + " instead.");
        var r = range(1, t.dims.length + 1);
        if (!_tfjsCore.util.arraysEqual(t.dims.slice().sort(), r)) throw new Error("Invalid permutation `dims`: " + JSON.stringify(t.dims) + " `dims` must contain consecutive integers starting from 1.");
        return n.dims = t.dims, n.dimsIncludingBatch = [
            0
        ].concat(n.dims), n.inputSpec = [
            new InputSpec({
                ndim: n.dims.length + 1
            })
        ], n;
    }
    return __extends(t73, e110), t73.prototype.computeOutputShape = function(e) {
        var t = (e = getExactlyOneShape(e)).slice();
        return this.dims.forEach(function(n, r) {
            t[r + 1] = e[n];
        }), t;
    }, t73.prototype.call = function(e, t) {
        return _tfjsCore.transpose(getExactlyOneTensor(e), this.dimsIncludingBatch);
    }, t73.prototype.getConfig = function() {
        var t = {
            dims: this.dims
        }, n = e110.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t73.className = "Permute", t73;
}(Layer);
_tfjsCore.serialization.registerClass(Permute);
var Masking = function(e111) {
    function t74(t) {
        var n = e111.call(this, null == t ? {
        } : t) || this;
        return n.supportsMasking = !0, n.maskValue = null != t ? null == t.maskValue ? 0 : t.maskValue : 0, n;
    }
    return __extends(t74, e111), t74.prototype.computeOutputShape = function(e) {
        return e;
    }, t74.prototype.getConfig = function() {
        var t = e111.prototype.getConfig.call(this), n = {
            maskValue: this.maskValue
        };
        return Object.assign(n, t), n;
    }, t74.prototype.computeMask = function(e, t) {
        var n = getExactlyOneTensor(e);
        return _tfjsCore.any(_tfjsCore.notEqual(n, this.maskValue), -1);
    }, t74.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            n.invokeCallHook(e, t);
            var r = getExactlyOneTensor(e), i = _tfjsCore.any(_tfjsCore.notEqual(r, n.maskValue), -1, !0);
            return r.mul(i.asType(r.dtype));
        });
    }, t74.className = "Masking", t74;
}(Layer);
_tfjsCore.serialization.registerClass(Masking);
var Embedding = function(e112) {
    function t75(t) {
        var n = e112.call(this, t) || this;
        if (n.embeddings = null, n.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", null == t.batchInputShape && null == t.inputShape) {
            var r = null;
            null != t.batchSize && (r = t.batchSize), null == t.inputLength ? n.batchInputShape = [
                r,
                null
            ] : n.batchInputShape = [
                r
            ].concat(toList(t.inputLength));
        }
        return n.inputDim = t.inputDim, assertPositiveInteger(n.inputDim, "inputDim"), n.outputDim = t.outputDim, assertPositiveInteger(n.outputDim, "outputDim"), n.embeddingsInitializer = getInitializer(t.embeddingsInitializer || n.DEFAULT_EMBEDDINGS_INITIALIZER), n.embeddingsRegularizer = getRegularizer(t.embeddingsRegularizer), n.activityRegularizer = getRegularizer(t.activityRegularizer), n.embeddingsConstraint = getConstraint(t.embeddingsConstraint), n.maskZero = t.maskZero, n.supportsMasking = t.maskZero, n.inputLength = t.inputLength, n;
    }
    return __extends(t75, e112), t75.prototype.build = function(e) {
        this.embeddings = this.addWeight("embeddings", [
            this.inputDim,
            this.outputDim
        ], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, !0, this.embeddingsConstraint), this.built = !0;
    }, t75.prototype.warnOnIncompatibleInputShape = function(e) {
    }, t75.prototype.computeMask = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            return n.maskZero ? (e = getExactlyOneTensor(e), _tfjsCore.notEqual(e, _tfjsCore.zerosLike(e))) : null;
        });
    }, t75.prototype.computeOutputShape = function(e) {
        if (e = getExactlyOneShape(e), null == this.inputLength) return e.concat([
            this.outputDim
        ]);
        var t = toList(this.inputLength);
        if (t.length !== e.length - 1) throw new ValueError('"inputLength" is ' + this.inputLength + ", but received input shape has shape " + e);
        for(var n = 0, r = 0; r < t.length; ++r){
            var i = t[r], a = e[r + 1];
            if (null != i && null != a && i !== a) throw new ValueError('"inputLength" is ' + this.inputLength + ", but received input shape has shape " + e);
            null == i && (t[n] = a), n++;
        }
        return [
            e[0]
        ].concat(t, [
            this.outputDim
        ]);
    }, t75.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            n.invokeCallHook(e, t);
            var r = getExactlyOneTensor(e);
            return "int32" !== r.dtype && (r = cast$1(r, "int32")), gather$1(n.embeddings.read(), r.as1D()).reshape(getExactlyOneShape(n.computeOutputShape(r.shape)));
        });
    }, t75.prototype.getConfig = function() {
        var t = {
            inputDim: this.inputDim,
            outputDim: this.outputDim,
            embeddingsInitializer: serializeInitializer(this.embeddingsInitializer),
            embeddingsRegularizer: serializeRegularizer(this.embeddingsRegularizer),
            activityRegularizer: serializeRegularizer(this.activityRegularizer),
            embeddingsConstraint: serializeConstraint(this.embeddingsConstraint),
            maskZero: this.maskZero,
            inputLength: this.inputLength
        }, n = e112.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t75.className = "Embedding", t75;
}(Layer);
_tfjsCore.serialization.registerClass(Embedding);
var Merge = function(e113) {
    function t76(t) {
        var n = e113.call(this, t || {
        }) || this;
        return n.supportsMasking = !0, n;
    }
    return __extends(t76, e113), t76.prototype.mergeFunction = function(e) {
        throw new NotImplementedError;
    }, t76.prototype.computeElementwiseOpOutputShape = function(e, t) {
        if (null == e || null == t) return null;
        if (e.length < t.length) return this.computeElementwiseOpOutputShape(t, e);
        if (0 === t.length) return e;
        for(var n = e.slice(0, e.length - t.length), r = 0; r < t.length; ++r){
            var i = e[e.length - t.length + r], a = t[r];
            if (null == i || null == a || i < 0 || a < 0) n.push(null);
            else if (1 === i) n.push(a);
            else if (1 === a) n.push(i);
            else {
                if (i !== a) throw new ValueError("Operands could not be broadcast together with shapes " + JSON.stringify(e) + " " + JSON.stringify(t));
                n.push(i);
            }
        }
        return n;
    }, t76.prototype.build = function(e114) {
        if (Array.isArray(e114) && !Array.isArray(e114[0]) && (e114 = [
            getExactlyOneShape(e114)
        ]), e114.length < 2) throw new ValueError("A merge layer should be called on an Array of at least 2 inputs. Got " + e114.length + " input(s).");
        for(var t = [], n = 0, r = e114; n < r.length; n++)null != (o = r[n]) && null !== o[0] && t.push(o[0]);
        if ((t = unique(t)).length > 1) throw new ValueError("Can not merge tensors with different batch sizes. Got tensors with shapes: " + JSON.stringify(e114) + ".");
        for(var i = null == e114[0] ? null : e114[0].slice(1), a = 1; a < e114.length; ++a){
            var o = null == e114[a] ? null : e114[a].slice(1);
            i = this.computeElementwiseOpOutputShape(i, o);
        }
        var s = e114.map(function(e) {
            return e.length;
        });
        -1 === e114.indexOf(null) && 1 === unique(s).length ? this.reshapeRequired = !1 : this.reshapeRequired = !0;
    }, t76.prototype.call = function(e115, t77) {
        var n = this;
        return _tfjsCore.tidy(function() {
            if (e115, n.reshapeRequired) {
                var t = [], r = e115.map(function(e) {
                    return e.rank;
                });
                if (-1 === r.indexOf(null)) {
                    for(var i = max$1(r), a = 0, o = e115; a < o.length; a++){
                        for(var s = (h = o[a]).rank, l = 0; l < i - s; ++l)h = expandDims$1(h, 1);
                        t.push(h);
                    }
                    return n.mergeFunction(t);
                }
                for(var u = !1, c = 0, p = e115; c < p.length; c++){
                    var h;
                    if (null == (s = (h = p[c]).rank)) {
                        var d = h.shape, f = d[0], g = d.slice(1).concat([
                            f
                        ]), m = h.reshape([
                            f
                        ].concat(arrayProd(d.slice(1))));
                        m = (m = _tfjsCore.transpose(m, [
                            1,
                            0
                        ])).reshape(g), t.push(m), u = !0;
                    } else if (s > 1) {
                        var y = range(1, s).concat([
                            0
                        ]);
                        t.push(_tfjsCore.transpose(h, y)), u = !0;
                    } else t.push(h);
                }
                var v = n.mergeFunction(t), b = v.rank;
                if (u) {
                    if (null == b) {
                        var w = v.shape;
                        g = [
                            f = w[w.length - 1]
                        ].concat(w.slice(0, w.length - 1));
                        v = _tfjsCore.transpose(v.reshape([
                            -1,
                            f
                        ]), [
                            1,
                            0
                        ]).reshape(g);
                    } else if (b > 1) {
                        y = [
                            b - 1
                        ].concat(range(0, b - 1));
                        v = _tfjsCore.transpose(v, y);
                    }
                }
                return v;
            }
            return n.mergeFunction(e115);
        });
    }, t76.prototype.computeOutputShape = function(e) {
        var t;
        t = null == e[0] ? null : e[0].slice(1);
        for(var n = 1; n < e.length; ++n){
            var r = null == e[n] ? null : e[n].slice(1);
            t = this.computeElementwiseOpOutputShape(t, r);
        }
        for(var i = [], a = 0, o = e; a < o.length; a++)null != (r = o[a]) && null !== r[0] && i.push(r[0]);
        return t = 1 === (i = unique(i)).length ? i.concat(t) : [
            null
        ].concat(t);
    }, t76.prototype.computeMask = function(e116, t) {
        return _tfjsCore.tidy(function() {
            if (null == t) return null;
            if (!Array.isArray(t)) throw new ValueError("`mask` should be an Array");
            if (!Array.isArray(e116)) throw new ValueError("`inputs` should be an Array");
            if (t.length !== e116.length) throw new ValueError("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (" + e116.length + " vs " + t.length + ")");
            if (t.every(function(e) {
                return null == e;
            })) return null;
            for(var n = (t = t.map(function(e) {
                return null == e ? e : _tfjsCore.expandDims(e, 0);
            }))[0], r = 1; r < t.length - 1; ++r)n = _tfjsCore.logicalAnd(n, t[r]);
            return n;
        });
    }, t76;
}(Layer), Add = function(e117) {
    function t78(t) {
        return e117.call(this, t) || this;
    }
    return __extends(t78, e117), t78.prototype.mergeFunction = function(e) {
        return _tfjsCore.tidy(function() {
            for(var t = e[0].clone(), n = 1; n < e.length; ++n)t = _tfjsCore.add(t, e[n]);
            return t;
        });
    }, t78.className = "Add", t78;
}(Merge);
_tfjsCore.serialization.registerClass(Add);
var Multiply = function(e118) {
    function t79(t) {
        return e118.call(this, t) || this;
    }
    return __extends(t79, e118), t79.prototype.mergeFunction = function(e) {
        return _tfjsCore.tidy(function() {
            for(var t = e[0].clone(), n = 1; n < e.length; ++n)t = _tfjsCore.mul(t, e[n]);
            return t;
        });
    }, t79.className = "Multiply", t79;
}(Merge);
_tfjsCore.serialization.registerClass(Multiply);
var Average = function(e119) {
    function t80(t) {
        return e119.call(this, t) || this;
    }
    return __extends(t80, e119), t80.prototype.mergeFunction = function(e) {
        return _tfjsCore.tidy(function() {
            for(var t = e[0].clone(), n = 1; n < e.length; ++n)t = _tfjsCore.add(t, e[n]);
            return _tfjsCore.mul(1 / e.length, t);
        });
    }, t80.className = "Average", t80;
}(Merge);
_tfjsCore.serialization.registerClass(Average);
var Maximum = function(e120) {
    function t81(t) {
        return e120.call(this, t) || this;
    }
    return __extends(t81, e120), t81.prototype.mergeFunction = function(e) {
        return _tfjsCore.tidy(function() {
            for(var t = e[0], n = 1; n < e.length; ++n)t = _tfjsCore.maximum(t, e[n]);
            return t;
        });
    }, t81.className = "Maximum", t81;
}(Merge);
_tfjsCore.serialization.registerClass(Maximum);
var Minimum = function(e121) {
    function t82(t) {
        return e121.call(this, t) || this;
    }
    return __extends(t82, e121), t82.prototype.mergeFunction = function(e) {
        return _tfjsCore.tidy(function() {
            for(var t = e[0], n = 1; n < e.length; ++n)t = _tfjsCore.minimum(t, e[n]);
            return t;
        });
    }, t82.className = "Minimum", t82;
}(Merge);
_tfjsCore.serialization.registerClass(Minimum);
var Concatenate = function(e122) {
    function t83(t) {
        var n = e122.call(this, t) || this;
        return n.DEFAULT_AXIS = -1, null == t && (t = {
        }), n.axis = null == t.axis ? n.DEFAULT_AXIS : t.axis, n.supportsMasking = !0, n.reshapeRequired = !1, n;
    }
    return __extends(t83, e122), t83.prototype.build = function(e) {
        if (!Array.isArray(e) || !Array.isArray(e[0]) || 1 === e.length) throw new ValueError("A `Concatenate` layer should be called on a list of at least 2 inputs");
        for(var t = !0, n = 0, r = e; n < r.length; n++)if (null != (c = r[n])) {
            t = !1;
            break;
        }
        if (!t) {
            for(var i = [], a = 0; a < e.length; ++a){
                var o = e[a].slice();
                o.splice(this.axis, 1);
                for(var s = !1, l = 0, u = i; l < u.length; l++){
                    var c = u[l];
                    if (_tfjsCore.util.arraysEqual(c, o)) {
                        s = !0;
                        break;
                    }
                }
                s || i.push(o);
            }
            if (i.length > 1) throw new ValueError("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(e));
        }
    }, t83.prototype.mergeFunction = function(e) {
        var t = this;
        return _tfjsCore.tidy(function() {
            return concatenate(e, t.axis);
        });
    }, t83.prototype.computeOutputShape = function(e) {
        if (!Array.isArray(e) || !Array.isArray(e[0])) throw new ValueError("A `Concatenate` layer should be called on a list of inputs.");
        for(var t = e, n = t[0].slice(), r = this.axis < 0 ? n.length + this.axis : this.axis, i = 0, a = t.slice(1); i < a.length; i++){
            var o = a[i];
            if (null == n[r] || null == o[r]) {
                n[r] = null;
                break;
            }
            n[r] += o[r];
        }
        return n;
    }, t83.prototype.computeMask = function(e123, t) {
        var n = this;
        if (null == t) return null;
        if (!Array.isArray(t)) throw new ValueError("`mask` should be an array for Concatenate");
        if (!Array.isArray(e123)) throw new ValueError("`inputs` should be an array for Concatenate");
        if (t.length !== e123.length) throw new ValueError("Mismatch in the length of mask (" + t.length + ") and the legnth of inputs (" + e123.length + ")");
        return _tfjsCore.tidy(function() {
            var r = !0;
            if (t.forEach(function(e) {
                null == e || (r = !1);
            }), r) return null;
            for(var i = [], a = 0; a < e123.length; ++a)null == t[a] ? i.push(_tfjsCore.onesLike(e123[a]).asType("bool")) : t[a].rank < e123[a].rank ? i.push(_tfjsCore.expandDims(t[a], -1)) : i.push(t[a]);
            var o = _tfjsCore.concat(i, n.axis);
            return _tfjsCore.all(o, -1, !1);
        });
    }, t83.prototype.getConfig = function() {
        var t = {
            axis: this.axis
        }, n = e122.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t83.className = "Concatenate", t83;
}(Merge);
function interpretAxis(e, t) {
    for(; e < 0;)e += t;
    return e;
}
function batchDot(e, t, n14) {
    if (e.shape.length > 3 || t.shape.length > 3) throw new NotImplementedError("batchDot is not implemented for tensors of 4D or higher rank yet");
    if (_tfjsCore.util.assert(e.shape.length >= 2, function() {
        return "batchDot requires the rank of x to be >= 2, but got " + e.shape.length;
    }), _tfjsCore.util.assert(e.shape.length >= 2, function() {
        return "batchDot requires the rank of y to be >= 2, but got " + t.shape.length;
    }), "number" == typeof n14 && (n14 = [
        n14,
        n14
    ]), "complex64" === e.dtype || "complex64" === t.dtype) throw new NotImplementedError("batchDot is not implemented for complex64-type Tensors yet.");
    var r = e.shape.length, i = t.shape.length;
    null == n14 && (n14 = [
        r - 1,
        i - 2
    ]);
    var a = n14;
    return _tfjsCore.tidy(function() {
        var n, o;
        if (r > i) {
            n = r - i;
            for(var s = [], l = 0; l < n; ++l)s.push(1);
            t = t.reshape(t.shape.concat(s));
        } else if (i > r) {
            n = i - r;
            for(s = [], l = 0; l < n; ++l)s.push(1);
            e = e.reshape(e.shape.concat(s));
        } else n = 0;
        if (2 === e.shape.length && 2 === t.shape.length) o = a[0] === a[1] ? e.mulStrict(t).sum(a[0]) : e.transpose([
            1,
            0
        ]).mulStrict(t).sum(a[1]);
        else {
            var u = a[0] !== e.shape.length - 1, c = a[1] === t.shape.length - 1;
            o = e.matMul(t, u, c);
        }
        if (n > 0) {
            var p = void 0, h = [];
            for(l = p = r > i ? r + i - 3 : r - 1; l < p + n; ++l)h.push(l);
            o = o.squeeze(h);
        }
        return 1 === o.shape.length && (o = o.expandDims(1)), o;
    });
}
_tfjsCore.serialization.registerClass(Concatenate);
var Dot = function(e124) {
    function t84(t) {
        var n = e124.call(this, t) || this;
        return n.axes = t.axes, n.normalize = null != t.normalize && t.normalize, n.supportsMasking = !0, n.reshapeRequired = !1, n;
    }
    return __extends(t84, e124), t84.prototype.build = function(e) {
        _tfjsCore.util.assert(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), function() {
            return "A `Dot` layer should be called on a list of exactly 2 inputs.";
        });
        var t = e[0], n = e[1];
        if (t.length > 3 || n.length > 3) throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");
        var r = this.interpretAxes(t, n);
        if (t[r[0]] !== n[r[1]]) throw new ValueError("Dimension incompatibility: " + t[r[0]] + " !== " + n[r[1]]);
    }, t84.prototype.mergeFunction = function(e) {
        if (2 !== e.length) throw new ValueError("A `Dot` layer must be called on exactly 2 inputs, but received " + e.length + " input(s).");
        var t85, n = e[0], r = e[1];
        return t85 = Array.isArray(this.axes) ? this.axes.map(function(t, n) {
            return interpretAxis(t, e[n].shape.length);
        }) : [
            interpretAxis(this.axes, n.shape.length),
            interpretAxis(this.axes, r.shape.length)
        ], this.normalize && (n = l2Normalize(n, t85[0]), r = l2Normalize(r, t85[1])), batchDot(n, r, t85);
    }, t84.prototype.interpretAxes = function(e, t) {
        return Array.isArray(this.axes) ? this.axes : [
            interpretAxis(this.axes, e.length),
            interpretAxis(this.axes, t.length)
        ];
    }, t84.prototype.computeOutputShape = function(e) {
        _tfjsCore.util.assert(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), function() {
            return "A `Dot` layer should be called on a list of exactly 2 inputs.";
        });
        var t = e[0].slice(), n = e[1].slice();
        if (t.length > 3 || n.length > 3) throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");
        var r = this.interpretAxes(t, n);
        t.splice(r[0], 1), n.splice(r[1], 1), n.splice(0, 1);
        var i = t.concat(n);
        return 1 === i.length && i.push(1), i;
    }, t84.prototype.computeMask = function(e, t) {
        return null;
    }, t84.prototype.getConfig = function() {
        var t = {
            axes: this.axes,
            normalize: this.normalize
        }, n = e124.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t84.className = "Dot", t84;
}(Merge);
_tfjsCore.serialization.registerClass(Dot);
var GaussianNoise = function(e125) {
    function t86(t) {
        var n = e125.call(this, t) || this;
        return n.supportsMasking = !0, n.stddev = t.stddev, n;
    }
    return __extends(t86, e125), t86.prototype.computeOutputShape = function(e) {
        return e;
    }, t86.prototype.getConfig = function() {
        var t = e125.prototype.getConfig.call(this), n = {
            stddev: this.stddev
        };
        return Object.assign(n, t), n;
    }, t86.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            n.invokeCallHook(e, t);
            var r = getExactlyOneTensor(e);
            return inTrainPhase(function() {
                return randomNormal$1(r.shape, 0, n.stddev).add(r);
            }, function() {
                return r;
            }, t.training || !1);
        });
    }, t86.className = "GaussianNoise", t86;
}(Layer);
_tfjsCore.serialization.registerClass(GaussianNoise);
var GaussianDropout = function(e126) {
    function t87(t) {
        var n = e126.call(this, t) || this;
        return n.supportsMasking = !0, n.rate = t.rate, n;
    }
    return __extends(t87, e126), t87.prototype.computeOutputShape = function(e) {
        return e;
    }, t87.prototype.getConfig = function() {
        var t = e126.prototype.getConfig.call(this), n = {
            rate: this.rate
        };
        return Object.assign(n, t), n;
    }, t87.prototype.call = function(e127, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            n.invokeCallHook(e127, t);
            var r = getExactlyOneTensor(e127);
            if (n.rate > 0 && n.rate < 1) return inTrainPhase(function() {
                var e = Math.sqrt(n.rate / (1 - n.rate));
                return r.mul(randomNormal$1(r.shape, 1, e));
            }, function() {
                return r;
            }, t.training || !1);
            return r;
        });
    }, t87.className = "GaussianDropout", t87;
}(Layer);
_tfjsCore.serialization.registerClass(GaussianDropout);
var AlphaDropout = function(e128) {
    function t88(t) {
        var n = e128.call(this, t) || this;
        return n.supportsMasking = !0, n.rate = t.rate, n.noiseShape = t.noiseShape, n;
    }
    return __extends(t88, e128), t88.prototype._getNoiseShape = function(e) {
        return this.noiseShape || getExactlyOneTensor(e).shape;
    }, t88.prototype.computeOutputShape = function(e) {
        return e;
    }, t88.prototype.getConfig = function() {
        var t = e128.prototype.getConfig.call(this), n = {
            rate: this.rate
        };
        return Object.assign(n, t), n;
    }, t88.prototype.call = function(e, t89) {
        var n = this;
        return _tfjsCore.tidy(function() {
            if (n.rate < 1 && n.rate > 0) {
                var r = n._getNoiseShape(e);
                return inTrainPhase(function() {
                    var t = getExactlyOneTensor(e), i = -1.7580993408473766, a = _tfjsCore.greaterEqual(_tfjsCore.randomUniform(r), n.rate);
                    a = cast$1(a, "float32");
                    var o = Math.pow((1 - n.rate) * (1 + n.rate * Math.pow(i, 2)), -0.5), s = -o * i * n.rate;
                    return t.mul(a).add(a.add(-1).mul(i)).mul(o).add(s);
                }, function() {
                    return getExactlyOneTensor(e);
                }, t89.training || !1);
            }
            return e;
        });
    }, t88.className = "AlphaDropout", t88;
}(Layer);
function batchNormalization(e, t, n, r, i, a) {
    var o;
    if (void 0 === a && (a = 0.001), 2 === e.rank) o = _tfjsCore.batchNorm2d(e, t, n, r, i, a);
    else if (3 === e.rank) o = _tfjsCore.batchNorm3d(e, t, n, r, i, a);
    else {
        if (4 !== e.rank) throw new NotImplementedError("batchNormalization is not implemented for array of rank " + e.rank + " yet");
        o = _tfjsCore.batchNorm4d(e, t, n, r, i, a);
    }
    return o;
}
function regularNormalizeBatchInTraining(e, t, n, r, i) {
    return void 0 === i && (i = 0.001), _tfjsCore.tidy(function() {
        var a = _tfjsCore.moments(e, r), o = a.mean, s = a.variance;
        return [
            batchNormalization(e, o, s, n, t, i),
            o,
            s
        ];
    });
}
function broadcastNormalizeBatchInTraining(e, t, n, r, i) {
    return void 0 === i && (i = 0.001), _tfjsCore.tidy(function() {
        for(var a = _tfjsCore.moments(e, r), o = a.mean, s = a.variance, l = [], u = 0, c = range(0, e.rank); u < c.length; u++){
            var p = c[u];
            -1 !== r.indexOf(p) ? l.push(1) : l.push(e.shape[p]);
        }
        var h = o.reshape(l), d = s.reshape(l), f = null == t ? null : t.reshape(l), g = null == n ? null : n.reshape(l);
        return [
            batchNormalization(e, h, d, g, f, i),
            o,
            s
        ];
    });
}
function normalizeBatchInTraining(e, t, n, r, i) {
    return void 0 === i && (i = 0.001), _tfjsCore.util.arraysEqual(r.slice().sort(), range(0, e.rank - 1)) ? regularNormalizeBatchInTraining(e, t, n, r, i) : broadcastNormalizeBatchInTraining(e, t, n, r, i);
}
_tfjsCore.serialization.registerClass(AlphaDropout);
var BatchNormalization = function(e129) {
    function t90(t) {
        var n = this;
        return null == t && (t = {
        }), (n = e129.call(this, t) || this).supportsMasking = !0, n.axis = null == t.axis ? -1 : t.axis, n.momentum = null == t.momentum ? 0.99 : t.momentum, n.epsilon = null == t.epsilon ? 0.001 : t.epsilon, n.center = null == t.center || t.center, n.scale = null == t.scale || t.scale, n.betaInitializer = getInitializer(t.betaInitializer || "zeros"), n.gammaInitializer = getInitializer(t.gammaInitializer || "ones"), n.movingMeanInitializer = getInitializer(t.movingMeanInitializer || "zeros"), n.movingVarianceInitializer = getInitializer(t.movingVarianceInitializer || "ones"), n.betaConstraint = getConstraint(t.betaConstraint), n.gammaConstraint = getConstraint(t.gammaConstraint), n.betaRegularizer = getRegularizer(t.betaRegularizer), n.gammaRegularizer = getRegularizer(t.gammaRegularizer), n;
    }
    return __extends(t90, e129), t90.prototype.build = function(e) {
        var t;
        e = getExactlyOneShape(e);
        var n = this.axis >= 0 ? this.axis : this.axis + e.length, r = e[n];
        if (null == r) throw new ValueError("Axis " + n + " of input tensor should have a defined dimension but the layer received an input with shape " + JSON.stringify(e) + ".");
        this.inputSpec = [
            new InputSpec({
                ndim: e.length,
                axes: (t = {
                }, t[n] = r, t)
            })
        ];
        var i = [
            r
        ];
        this.scale && (this.gamma = this.addWeight("gamma", i, null, this.gammaInitializer, this.gammaRegularizer, !0, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", i, null, this.betaInitializer, this.betaRegularizer, !0, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", i, null, this.movingMeanInitializer, null, !1), this.movingVariance = this.addWeight("moving_variance", i, null, this.movingVarianceInitializer, null, !1), this.built = !0;
    }, t90.prototype.call = function(e130, t91) {
        var n15 = this;
        return _tfjsCore.tidy(function() {
            var r6 = null != t91.training && t91.training, i4 = getExactlyOneTensor(e130), a8 = i4.shape, o = a8.length, s = range(0, o), l = n15.axis >= 0 ? n15.axis : n15.axis + o;
            s.splice(l, 1);
            var u = pyListRepeat(1, o);
            u[l] = a8[l];
            var c = s.slice();
            c.sort();
            var p = !_tfjsCore.util.arraysEqual(c, range(0, o).slice(0, o - 1));
            if (!r6) return (function() {
                if (p) {
                    var e = n15.movingMean.read().reshape(u), t = n15.movingVariance.read().reshape(u), r = n15.center ? n15.beta.read().reshape(u) : null, a = n15.scale ? n15.gamma.read().reshape(u) : null;
                    return batchNormalization(i4, e, t, r, a, n15.epsilon);
                }
                return batchNormalization(i4, n15.movingMean.read(), n15.movingVariance.read(), null == n15.beta ? null : n15.beta.read(), null == n15.gamma ? null : n15.gamma.read(), n15.epsilon);
            })();
            var h = normalizeBatchInTraining(i4, n15.gamma.read(), n15.beta.read(), s, n15.epsilon), d = h[0], f = h[1], g = h[2], m = function(e, t, n) {
                _tfjsCore.tidy(function() {
                    var r = 1 - n, i = e.read(), a = i.sub(t).mul(r);
                    e.write(i.sub(a));
                });
            };
            return m(n15.movingMean, f, n15.momentum), m(n15.movingVariance, g, n15.momentum), d;
        });
    }, t90.prototype.getConfig = function() {
        var t = {
            axis: this.axis,
            momentum: this.momentum,
            epsilon: this.epsilon,
            center: this.center,
            scale: this.scale,
            betaInitializer: serializeInitializer(this.betaInitializer),
            gammaInitializer: serializeInitializer(this.gammaInitializer),
            movingMeanInitializer: serializeInitializer(this.movingMeanInitializer),
            movingVarianceInitializer: serializeInitializer(this.movingVarianceInitializer),
            betaRegularizer: serializeRegularizer(this.betaRegularizer),
            gammaRegularizer: serializeRegularizer(this.gammaRegularizer),
            betaConstraint: serializeConstraint(this.betaConstraint),
            gammaConstraint: serializeConstraint(this.gammaConstraint)
        }, n = e129.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t90.className = "BatchNormalization", t90;
}(Layer);
_tfjsCore.serialization.registerClass(BatchNormalization);
var LayerNormalization = function(e131) {
    function t92(t) {
        var n = this;
        if (null == t && (t = {
        }), (n = e131.call(this, t) || this).axis = null == t.axis ? -1 : t.axis, "number" == typeof n.axis) {
            if (!Number.isInteger(n.axis)) throw new Error("Expected axis to be an integer, but received " + n.axis);
        } else {
            if (!Array.isArray(n.axis)) throw new Error("Expected axis to be an integer or an array of integers, but received " + JSON.stringify(n.axis));
            for(var r = 0, i = n.axis; r < i.length; r++){
                var a = i[r];
                if (!Number.isInteger(a)) throw new Error("Expected axis to be an array of integers, but received " + JSON.stringify(n.axis));
            }
        }
        return n.epsilon = null == t.epsilon ? 0.001 : t.epsilon, n.center = null == t.center || t.center, n.scale = null == t.scale || t.scale, n.betaInitializer = getInitializer(t.betaInitializer || "zeros"), n.gammaInitializer = getInitializer(t.gammaInitializer || "ones"), n.betaRegularizer = getRegularizer(t.betaRegularizer), n.gammaRegularizer = getRegularizer(t.gammaRegularizer), n.supportsMasking = !0, n;
    }
    return __extends(t92, e131), t92.prototype.build = function(e) {
        var t = (e = getExactlyOneShape(e)).length;
        "number" == typeof this.axis && (this.axis = [
            this.axis
        ]);
        for(var n = 0; n < this.axis.length; ++n)this.axis[n] < 0 && (this.axis[n] += t);
        for(var r = 0, i = this.axis; r < i.length; r++){
            var a = i[r];
            if (a < 0 || a >= t) throw new Error("Invalid axis: " + a);
        }
        if (this.axis.length !== unique(this.axis).length) throw new Error("Found duplicate axes in: " + this.axis);
        var o = this.axis.map(function(t) {
            return e[t];
        });
        this.scale ? this.gamma = this.addWeight("gamma", o, "float32", this.gammaInitializer, this.gammaRegularizer, !0) : this.gamma = null, this.center ? this.beta = this.addWeight("beta", o, "float32", this.betaInitializer, this.betaRegularizer, !0) : this.beta = null, this.built = !0;
    }, t92.prototype.call = function(e132, t93) {
        var n = this, r = getExactlyOneTensor(e132), i = r.shape, a = i.length;
        return _tfjsCore.tidy(function() {
            for(var e133 = _tfjsCore.moments(r, n.axis, !0), t = e133.mean, o = e133.variance, s = pyListRepeat(1, a), l = 0, u = n.axis; l < u.length; l++){
                var c = u[l];
                s[c] = i[c];
            }
            for(var p = function(e) {
                return null != e && e.shape.length !== a && n.axis !== [
                    a - 1
                ] ? e.reshape(s) : e;
            }, h = p(n.gamma.read()), d = p(n.beta.read()), f = [], g = [], m = 0; m < a; ++m)-1 !== n.axis.indexOf(m) ? (f.push(i[m]), g.push(1)) : (f.push(1), g.push(i[m]));
            return t = t.tile(f), o = o.tile(f), h = h.tile(g), d = d.tile(g), batchNormalization(r, t, o, d, h, n.epsilon);
        });
    }, t92.prototype.getConfig = function() {
        var t = {
            axis: this.axis,
            epsilon: this.epsilon,
            center: this.center,
            scale: this.scale,
            betaInitializer: serializeInitializer(this.betaInitializer),
            gammaInitializer: serializeInitializer(this.gammaInitializer),
            betaRegularizer: serializeRegularizer(this.betaRegularizer),
            gammaRegularizer: serializeRegularizer(this.gammaRegularizer)
        }, n = e131.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t92.className = "LayerNormalization", t92;
}(Layer);
function spatial2dPadding(e, t, n) {
    return _tfjsCore.tidy(function() {
        if (4 !== e.rank) throw new ValueError("temporalPadding expects input tensor to be 4-D, but received a " + e.rank + "-D tensor.");
        if (null == t && (t = [
            [
                1,
                1
            ],
            [
                1,
                1
            ]
        ]), 2 !== t.length || 2 !== t[0].length || 2 !== t[1].length) throw new ValueError("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
        if (null == n && (n = imageDataFormat()), "channelsLast" !== n && "channelsFirst" !== n) throw new ValueError("Unknown data format: " + n + ". Supported data formats are 'channelsLast' and 'channelsFirst.");
        var r;
        return r = "channelsFirst" === n ? [
            [
                0,
                0
            ],
            [
                0,
                0
            ],
            t[0],
            t[1]
        ] : [
            [
                0,
                0
            ],
            t[0],
            t[1],
            [
                0,
                0
            ]
        ], _tfjsCore.pad(e, r);
    });
}
_tfjsCore.serialization.registerClass(LayerNormalization);
var ZeroPadding2D = function(e134) {
    function t94(t) {
        var n = this;
        if (null == t && (t = {
        }), (n = e134.call(this, t) || this).dataFormat = null == t.dataFormat ? imageDataFormat() : t.dataFormat, null == t.padding) n.padding = [
            [
                1,
                1
            ],
            [
                1,
                1
            ]
        ];
        else if ("number" == typeof t.padding) n.padding = [
            [
                t.padding,
                t.padding
            ],
            [
                t.padding,
                t.padding
            ]
        ];
        else {
            if (t.padding = t.padding, 2 !== t.padding.length) throw new ValueError("ZeroPadding2D expects padding to be a length-2 array, but received a length-" + t.padding.length + " array.");
            var r = void 0, i = void 0;
            if ("number" == typeof t.padding[0]) r = [
                t.padding[0],
                t.padding[0]
            ], i = [
                t.padding[1],
                t.padding[1]
            ];
            else {
                if (t.padding = t.padding, 2 !== t.padding[0].length) throw new ValueError("ZeroPadding2D expects height padding to be a length-2 array, but received a length-" + t.padding[0].length + " array.");
                if (r = t.padding[0], 2 !== t.padding[1].length) throw new ValueError("ZeroPadding2D expects width padding to be a length-2 array, but received a length-" + t.padding[1].length + " array.");
                i = t.padding[1];
            }
            n.padding = [
                r,
                i
            ];
        }
        return n.inputSpec = [
            new InputSpec({
                ndim: 4
            })
        ], n;
    }
    return __extends(t94, e134), t94.prototype.computeOutputShape = function(e) {
        var t, n;
        return e = getExactlyOneShape(e), "channelsFirst" === this.dataFormat ? (t = null != e[2] && e[2] >= 0 ? e[2] + this.padding[0][0] + this.padding[0][1] : null, n = null != e[3] && e[3] >= 0 ? e[3] + this.padding[1][0] + this.padding[1][1] : null, [
            e[0],
            e[1],
            t,
            n
        ]) : (t = null != e[1] && e[1] >= 0 ? e[1] + this.padding[0][0] + this.padding[0][1] : null, n = null != e[2] && e[2] >= 0 ? e[2] + this.padding[1][0] + this.padding[1][1] : null, [
            e[0],
            t,
            n,
            e[3]
        ]);
    }, t94.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            return spatial2dPadding(getExactlyOneTensor(e), n.padding, n.dataFormat);
        });
    }, t94.prototype.getConfig = function() {
        var t = {
            padding: this.padding,
            dataFormat: this.dataFormat
        }, n = e134.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t94.className = "ZeroPadding2D", t94;
}(Layer);
function pool2d(e, t, n, r, i, a) {
    return _tfjsCore.tidy(function() {
        var o;
        checkDataFormat(i), checkPoolMode(a), checkPaddingMode(r), null == n && (n = [
            1,
            1
        ]), null == r && (r = "valid"), null == i && (i = imageDataFormat()), null == a && (a = "max"), e = preprocessConv2DInput(e, i);
        var s = "same" === r ? "same" : "valid";
        return o = "max" === a ? _tfjsCore.maxPool(e, t, n, s) : _tfjsCore.avgPool(e, t, n, s), "channelsFirst" === i && (o = _tfjsCore.transpose(o, [
            0,
            3,
            1,
            2
        ])), o;
    });
}
function pool3d(e, t, n, r, i, a) {
    return _tfjsCore.tidy(function() {
        var o;
        checkDataFormat(i), checkPoolMode(a), checkPaddingMode(r), null == n && (n = [
            1,
            1,
            1
        ]), null == r && (r = "valid"), null == i && (i = imageDataFormat()), null == a && (a = "max"), e = preprocessConv3DInput(e, i);
        var s = "same" === r ? "same" : "valid";
        return o = "max" === a ? _tfjsCore.maxPool3d(e, t, n, s) : _tfjsCore.avgPool3d(e, t, n, s), "channelsFirst" === i && (o = _tfjsCore.transpose(o, [
            0,
            4,
            1,
            2,
            3
        ])), o;
    });
}
_tfjsCore.serialization.registerClass(ZeroPadding2D);
var Pooling1D = function(e135) {
    function t95(t) {
        var n = this;
        if (null == t.poolSize && (t.poolSize = 2), n = e135.call(this, t) || this, "number" == typeof t.poolSize) n.poolSize = [
            t.poolSize
        ];
        else {
            if (!Array.isArray(t.poolSize) || 1 !== t.poolSize.length || "number" != typeof t.poolSize[0]) throw new ValueError("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received " + JSON.stringify(t.poolSize));
            n.poolSize = t.poolSize;
        }
        if (assertPositiveInteger(n.poolSize, "poolSize"), null == t.strides) n.strides = n.poolSize;
        else if ("number" == typeof t.strides) n.strides = [
            t.strides
        ];
        else {
            if (!Array.isArray(t.strides) || 1 !== t.strides.length || "number" != typeof t.strides[0]) throw new ValueError("strides for 1D convolutional layer must be a number or an Array of a single number, but received " + JSON.stringify(t.strides));
            n.strides = t.strides;
        }
        return assertPositiveInteger(n.strides, "strides"), n.padding = null == t.padding ? "valid" : t.padding, checkPaddingMode(n.padding), n.inputSpec = [
            new InputSpec({
                ndim: 3
            })
        ], n;
    }
    return __extends(t95, e135), t95.prototype.computeOutputShape = function(e) {
        var t = convOutputLength((e = getExactlyOneShape(e))[1], this.poolSize[0], this.padding, this.strides[0]);
        return [
            e[0],
            t,
            e[2]
        ];
    }, t95.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            n.invokeCallHook(e, t), e = expandDims$1(getExactlyOneTensor(e), 2);
            var r = n.poolingFunction(getExactlyOneTensor(e), [
                n.poolSize[0],
                1
            ], [
                n.strides[0],
                1
            ], n.padding, "channelsLast");
            return _tfjsCore.squeeze(r, [
                2
            ]);
        });
    }, t95.prototype.getConfig = function() {
        var t = {
            poolSize: this.poolSize,
            padding: this.padding,
            strides: this.strides
        }, n = e135.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t95;
}(Layer), MaxPooling1D = function(e136) {
    function t96(t) {
        return e136.call(this, t) || this;
    }
    return __extends(t96, e136), t96.prototype.poolingFunction = function(e, t, n, r, i) {
        return checkDataFormat(i), checkPaddingMode(r), pool2d(e, t, n, r, i, "max");
    }, t96.className = "MaxPooling1D", t96;
}(Pooling1D);
_tfjsCore.serialization.registerClass(MaxPooling1D);
var AveragePooling1D = function(e137) {
    function t97(t) {
        return e137.call(this, t) || this;
    }
    return __extends(t97, e137), t97.prototype.poolingFunction = function(e, t, n, r, i) {
        return checkDataFormat(i), checkPaddingMode(r), pool2d(e, t, n, r, i, "avg");
    }, t97.className = "AveragePooling1D", t97;
}(Pooling1D);
_tfjsCore.serialization.registerClass(AveragePooling1D);
var Pooling2D = function(e138) {
    function t98(t) {
        var n = this;
        if (null == t.poolSize && (t.poolSize = [
            2,
            2
        ]), (n = e138.call(this, t) || this).poolSize = Array.isArray(t.poolSize) ? t.poolSize : [
            t.poolSize,
            t.poolSize
        ], null == t.strides) n.strides = n.poolSize;
        else if (Array.isArray(t.strides)) {
            if (2 !== t.strides.length) throw new ValueError("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length " + t.strides.length + ".");
            n.strides = t.strides;
        } else n.strides = [
            t.strides,
            t.strides
        ];
        return assertPositiveInteger(n.poolSize, "poolSize"), assertPositiveInteger(n.strides, "strides"), n.padding = null == t.padding ? "valid" : t.padding, n.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, checkDataFormat(n.dataFormat), checkPaddingMode(n.padding), n.inputSpec = [
            new InputSpec({
                ndim: 4
            })
        ], n;
    }
    return __extends(t98, e138), t98.prototype.computeOutputShape = function(e) {
        e = getExactlyOneShape(e);
        var t = "channelsFirst" === this.dataFormat ? e[2] : e[1], n = "channelsFirst" === this.dataFormat ? e[3] : e[2];
        return t = convOutputLength(t, this.poolSize[0], this.padding, this.strides[0]), n = convOutputLength(n, this.poolSize[1], this.padding, this.strides[1]), "channelsFirst" === this.dataFormat ? [
            e[0],
            e[1],
            t,
            n
        ] : [
            e[0],
            t,
            n,
            e[3]
        ];
    }, t98.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            return n.invokeCallHook(e, t), n.poolingFunction(getExactlyOneTensor(e), n.poolSize, n.strides, n.padding, n.dataFormat);
        });
    }, t98.prototype.getConfig = function() {
        var t = {
            poolSize: this.poolSize,
            padding: this.padding,
            strides: this.strides,
            dataFormat: this.dataFormat
        }, n = e138.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t98;
}(Layer), MaxPooling2D = function(e139) {
    function t99(t) {
        return e139.call(this, t) || this;
    }
    return __extends(t99, e139), t99.prototype.poolingFunction = function(e, t, n, r, i) {
        return checkDataFormat(i), checkPaddingMode(r), pool2d(e, t, n, r, i, "max");
    }, t99.className = "MaxPooling2D", t99;
}(Pooling2D);
_tfjsCore.serialization.registerClass(MaxPooling2D);
var AveragePooling2D = function(e140) {
    function t100(t) {
        return e140.call(this, t) || this;
    }
    return __extends(t100, e140), t100.prototype.poolingFunction = function(e, t, n, r, i) {
        return checkDataFormat(i), checkPaddingMode(r), pool2d(e, t, n, r, i, "avg");
    }, t100.className = "AveragePooling2D", t100;
}(Pooling2D);
_tfjsCore.serialization.registerClass(AveragePooling2D);
var Pooling3D = function(e141) {
    function t101(t) {
        var n = this;
        if (null == t.poolSize && (t.poolSize = [
            2,
            2,
            2
        ]), (n = e141.call(this, t) || this).poolSize = Array.isArray(t.poolSize) ? t.poolSize : [
            t.poolSize,
            t.poolSize,
            t.poolSize
        ], null == t.strides) n.strides = n.poolSize;
        else if (Array.isArray(t.strides)) {
            if (3 !== t.strides.length) throw new ValueError("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length " + t.strides.length + ".");
            n.strides = t.strides;
        } else n.strides = [
            t.strides,
            t.strides,
            t.strides
        ];
        return assertPositiveInteger(n.poolSize, "poolSize"), assertPositiveInteger(n.strides, "strides"), n.padding = null == t.padding ? "valid" : t.padding, n.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, checkDataFormat(n.dataFormat), checkPaddingMode(n.padding), n.inputSpec = [
            new InputSpec({
                ndim: 5
            })
        ], n;
    }
    return __extends(t101, e141), t101.prototype.computeOutputShape = function(e) {
        e = getExactlyOneShape(e);
        var t = "channelsFirst" === this.dataFormat ? e[2] : e[1], n = "channelsFirst" === this.dataFormat ? e[3] : e[2], r = "channelsFirst" === this.dataFormat ? e[4] : e[3];
        return t = convOutputLength(t, this.poolSize[0], this.padding, this.strides[0]), n = convOutputLength(n, this.poolSize[1], this.padding, this.strides[1]), r = convOutputLength(r, this.poolSize[2], this.padding, this.strides[2]), "channelsFirst" === this.dataFormat ? [
            e[0],
            e[1],
            t,
            n,
            r
        ] : [
            e[0],
            t,
            n,
            r,
            e[4]
        ];
    }, t101.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            return n.invokeCallHook(e, t), n.poolingFunction(getExactlyOneTensor(e), n.poolSize, n.strides, n.padding, n.dataFormat);
        });
    }, t101.prototype.getConfig = function() {
        var t = {
            poolSize: this.poolSize,
            padding: this.padding,
            strides: this.strides,
            dataFormat: this.dataFormat
        }, n = e141.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t101;
}(Layer), MaxPooling3D = function(e142) {
    function t102(t) {
        return e142.call(this, t) || this;
    }
    return __extends(t102, e142), t102.prototype.poolingFunction = function(e, t, n, r, i) {
        return checkDataFormat(i), checkPaddingMode(r), pool3d(e, t, n, r, i, "max");
    }, t102.className = "MaxPooling3D", t102;
}(Pooling3D);
_tfjsCore.serialization.registerClass(MaxPooling3D);
var AveragePooling3D = function(e143) {
    function t103(t) {
        return e143.call(this, t) || this;
    }
    return __extends(t103, e143), t103.prototype.poolingFunction = function(e, t, n, r, i) {
        return checkDataFormat(i), checkPaddingMode(r), pool3d(e, t, n, r, i, "avg");
    }, t103.className = "AveragePooling3D", t103;
}(Pooling3D);
_tfjsCore.serialization.registerClass(AveragePooling3D);
var GlobalPooling1D = function(e144) {
    function t104(t) {
        var n = e144.call(this, t) || this;
        return n.inputSpec = [
            new InputSpec({
                ndim: 3
            })
        ], n;
    }
    return __extends(t104, e144), t104.prototype.computeOutputShape = function(e) {
        return [
            e[0],
            e[2]
        ];
    }, t104.prototype.call = function(e, t) {
        throw new NotImplementedError;
    }, t104;
}(Layer), GlobalAveragePooling1D = function(e145) {
    function t105(t) {
        return e145.call(this, t || {
        }) || this;
    }
    return __extends(t105, e145), t105.prototype.call = function(e, t106) {
        return _tfjsCore.tidy(function() {
            var t = getExactlyOneTensor(e);
            return _tfjsCore.mean(t, 1);
        });
    }, t105.className = "GlobalAveragePooling1D", t105;
}(GlobalPooling1D);
_tfjsCore.serialization.registerClass(GlobalAveragePooling1D);
var GlobalMaxPooling1D = function(e146) {
    function t107(t) {
        return e146.call(this, t || {
        }) || this;
    }
    return __extends(t107, e146), t107.prototype.call = function(e, t108) {
        return _tfjsCore.tidy(function() {
            var t = getExactlyOneTensor(e);
            return _tfjsCore.max(t, 1);
        });
    }, t107.className = "GlobalMaxPooling1D", t107;
}(GlobalPooling1D);
_tfjsCore.serialization.registerClass(GlobalMaxPooling1D);
var GlobalPooling2D = function(e147) {
    function t109(t) {
        var n = e147.call(this, t) || this;
        return n.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, checkDataFormat(n.dataFormat), n.inputSpec = [
            new InputSpec({
                ndim: 4
            })
        ], n;
    }
    return __extends(t109, e147), t109.prototype.computeOutputShape = function(e) {
        return "channelsLast" === this.dataFormat ? [
            e[0],
            e[3]
        ] : [
            e[0],
            e[1]
        ];
    }, t109.prototype.call = function(e, t) {
        throw new NotImplementedError;
    }, t109.prototype.getConfig = function() {
        var t = {
            dataFormat: this.dataFormat
        }, n = e147.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t109;
}(Layer), GlobalAveragePooling2D = function(e148) {
    function t110() {
        return null !== e148 && e148.apply(this, arguments) || this;
    }
    return __extends(t110, e148), t110.prototype.call = function(e, t111) {
        var n = this;
        return _tfjsCore.tidy(function() {
            var t = getExactlyOneTensor(e);
            return "channelsLast" === n.dataFormat ? _tfjsCore.mean(t, [
                1,
                2
            ]) : _tfjsCore.mean(t, [
                2,
                3
            ]);
        });
    }, t110.className = "GlobalAveragePooling2D", t110;
}(GlobalPooling2D);
_tfjsCore.serialization.registerClass(GlobalAveragePooling2D);
var GlobalMaxPooling2D = function(e149) {
    function t112() {
        return null !== e149 && e149.apply(this, arguments) || this;
    }
    return __extends(t112, e149), t112.prototype.call = function(e, t113) {
        var n = this;
        return _tfjsCore.tidy(function() {
            var t = getExactlyOneTensor(e);
            return "channelsLast" === n.dataFormat ? _tfjsCore.max(t, [
                1,
                2
            ]) : _tfjsCore.max(t, [
                2,
                3
            ]);
        });
    }, t112.className = "GlobalMaxPooling2D", t112;
}(GlobalPooling2D);
function standardizeArgs(e150, t, n, r) {
    if (Array.isArray(e150)) {
        if (null != t || null != n) throw new ValueError("When inputs is an array, neither initialState or constants should be provided");
        null != r && (n = e150.slice(e150.length - r, e150.length), e150 = e150.slice(0, e150.length - r)), e150.length > 1 && (t = e150.slice(1, e150.length)), e150 = e150[0];
    }
    function i(e) {
        return null == e || Array.isArray(e) ? e : [
            e
        ];
    }
    return {
        inputs: e150,
        initialState: t = i(t),
        constants: n = i(n)
    };
}
function rnn(e151, t114, n16, r7, i, a9, o, s) {
    return void 0 === r7 && (r7 = !1), void 0 === o && (o = !1), void 0 === s && (s = !1), _tfjsCore.tidy(function() {
        var l = t114.shape.length;
        if (l < 3) throw new ValueError("Input should be at least 3D, but is " + l + "D.");
        var u = [
            1,
            0
        ].concat(range(2, l));
        if (t114 = _tfjsCore.transpose(t114, u), null != a9) throw new NotImplementedError("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
        o && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), null != i && ((i = i.asType("bool").asType("float32")).rank === l - 1 && (i = _tfjsCore.expandDims(i, -1)), i = _tfjsCore.transpose(i, u)), r7 && (t114 = _tfjsCore.reverse(t114, 0), null != i && (i = _tfjsCore.reverse(i, 0)));
        var c, p, h = [], d = n16, f = t114.shape[0], g = _tfjsCore.unstack(t114);
        null != i && (p = _tfjsCore.unstack(i));
        for(var m, y = function(t115) {
            var n17 = g[t115], r = _tfjsCore.tidy(function() {
                return e151(n17, d);
            });
            if (null == i) c = r[0], d = r[1];
            else {
                var a = _tfjsCore.tidy(function() {
                    var e = p[t115], n = _tfjsCore.onesLike(e).sub(e);
                    return {
                        output: r[0].mul(e).addStrict(d[0].mul(n)),
                        newStates: d.map(function(t, i) {
                            return r[1][i].mul(e).addStrict(t.mul(n));
                        })
                    };
                });
                c = a.output, d = a.newStates;
            }
            s && h.push(c);
        }, v = 0; v < f; ++v)y(v);
        if (s) m = _tfjsCore.stack(h, 1);
        return [
            c,
            m,
            d
        ];
    });
}
_tfjsCore.serialization.registerClass(GlobalMaxPooling2D);
var RNN = function(e152) {
    function t116(t) {
        var n, r = e152.call(this, t) || this;
        if (null == t.cell) throw new ValueError("cell property is missing for the constructor of RNN.");
        if (null == (n = Array.isArray(t.cell) ? new StackedRNNCells({
            cells: t.cell
        }) : t.cell).stateSize) throw new ValueError("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
        return r.cell = n, r.returnSequences = null != t.returnSequences && t.returnSequences, r.returnState = null != t.returnState && t.returnState, r.goBackwards = null != t.goBackwards && t.goBackwards, r._stateful = null != t.stateful && t.stateful, r.unroll = null != t.unroll && t.unroll, r.supportsMasking = !0, r.inputSpec = [
            new InputSpec({
                ndim: 3
            })
        ], r.stateSpec = null, r.states_ = null, r.numConstants = null, r.keptStates = [], r;
    }
    return __extends(t116, e152), t116.prototype.getStates = function() {
        return null == this.states_ ? range(0, Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1).map(function(e) {
            return null;
        }) : this.states_;
    }, t116.prototype.setStates = function(e) {
        this.states_ = e;
    }, t116.prototype.computeOutputShape = function(e) {
        isArrayOfShapes(e) && (e = e[0]);
        var t = this.cell.stateSize;
        Array.isArray(t) || (t = [
            t
        ]);
        var n, r = t[0];
        if (n = this.returnSequences ? [
            e[0],
            e[1],
            r
        ] : [
            e[0],
            r
        ], this.returnState) {
            for(var i = [], a = 0, o = t; a < o.length; a++){
                var s = o[a];
                i.push([
                    e[0],
                    s
                ]);
            }
            return [
                n
            ].concat(i);
        }
        return n;
    }, t116.prototype.computeMask = function(e153, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            Array.isArray(t) && (t = t[0]);
            var e = n.returnSequences ? t : null;
            if (n.returnState) {
                var r = n.states.map(function(e) {
                    return null;
                });
                return [
                    e
                ].concat(r);
            }
            return e;
        });
    }, Object.defineProperty(t116.prototype, "states", {
        get: function() {
            if (null == this.states_) {
                for(var e = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1, t = [], n = 0; n < e; ++n)t.push(null);
                return t;
            }
            return this.states_;
        },
        set: function(e) {
            this.states_ = e;
        },
        enumerable: !0,
        configurable: !0
    }), t116.prototype.build = function(e154) {
        if (null != this.numConstants) throw new NotImplementedError("Constants support is not implemented in RNN yet.");
        isArrayOfShapes(e154) && (e154 = e154[0]);
        var t = this.stateful ? e154[0] : null, n = e154[e154.length - 1];
        this.inputSpec[0] = new InputSpec({
            shape: [
                t,
                null,
                n
            ]
        });
        var r, i = [
            e154[0]
        ].concat(e154.slice(2));
        if (this.cell.build(i), r = Array.isArray(this.cell.stateSize) ? this.cell.stateSize : [
            this.cell.stateSize
        ], null != this.stateSpec) {
            if (!_tfjsCore.util.arraysEqual(this.stateSpec.map(function(e) {
                return e.shape[e.shape.length - 1];
            }), r)) throw new ValueError("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=" + this.stateSpec + "; However cell.stateSize is " + this.cell.stateSize);
        } else this.stateSpec = r.map(function(e) {
            return new InputSpec({
                shape: [
                    null,
                    e
                ]
            });
        });
        this.stateful && this.resetStates();
    }, t116.prototype.resetStates = function(e155, t) {
        var n = this;
        void 0 === t && (t = !1), _tfjsCore.tidy(function() {
            if (!n.stateful) throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");
            var r = n.inputSpec[0].shape[0];
            if (null == r) throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
            if (null == n.states_) Array.isArray(n.cell.stateSize) ? n.states_ = n.cell.stateSize.map(function(e) {
                return _tfjsCore.zeros([
                    r,
                    e
                ]);
            }) : n.states_ = [
                _tfjsCore.zeros([
                    r,
                    n.cell.stateSize
                ])
            ];
            else if (null == e155) _tfjsCore.dispose(n.states_), null != n.keptStates && (_tfjsCore.dispose(n.keptStates), n.keptStates = []), Array.isArray(n.cell.stateSize) ? n.states_ = n.cell.stateSize.map(function(e) {
                return _tfjsCore.zeros([
                    r,
                    e
                ]);
            }) : n.states_[0] = _tfjsCore.zeros([
                r,
                n.cell.stateSize
            ]);
            else {
                if (Array.isArray(e155) || (e155 = [
                    e155
                ]), e155.length !== n.states_.length) throw new ValueError("Layer " + n.name + " expects " + n.states_.length + " state(s), but it received " + e155.length + " state value(s). Input received: " + e155);
                !0 === t ? n.keptStates.push(n.states_.slice()) : _tfjsCore.dispose(n.states_);
                for(var i = 0; i < n.states_.length; ++i){
                    var a = e155[i], o = Array.isArray(n.cell.stateSize) ? n.cell.stateSize[i] : n.cell.stateSize, s = [
                        r,
                        o
                    ];
                    if (!_tfjsCore.util.arraysEqual(a.shape, s)) throw new ValueError("State " + i + " is incompatible with layer " + n.name + ": expected shape=" + s + ", received shape=" + a.shape);
                    n.states_[i] = a;
                }
            }
            n.states_ = n.states_.map(function(e) {
                return _tfjsCore.keep(e.clone());
            });
        });
    }, t116.prototype.apply = function(t, n) {
        var r = null == n ? null : n.initialState, i = null == n ? null : n.constants;
        null == n && (n = {
        });
        var a = standardizeArgs(t, r, i, this.numConstants);
        t = a.inputs, r = a.initialState, i = a.constants;
        var o = [], s = [];
        if (null != r) {
            n.initialState = r, o = o.concat(r), this.stateSpec = [];
            for(var l = 0, u = r; l < u.length; l++){
                var c = u[l];
                this.stateSpec.push(new InputSpec({
                    shape: c.shape
                }));
            }
            s = s.concat(this.stateSpec);
        }
        if (null != i && (n.constants = i, o = o.concat(i), this.numConstants = i.length), o[0] instanceof SymbolicTensor) {
            var p = [
                t
            ].concat(o), h = this.inputSpec.concat(s), d = this.inputSpec;
            this.inputSpec = h;
            var f = e152.prototype.apply.call(this, p, n);
            return this.inputSpec = d, f;
        }
        return e152.prototype.apply.call(this, t, n);
    }, t116.prototype.call = function(e156, t117) {
        var n = this;
        return _tfjsCore.tidy(function() {
            var r8 = null == t117 ? null : t117.mask, i = null == t117 ? null : t117.training, a = null == t117 ? null : t117.initialState;
            e156 = getExactlyOneTensor(e156), null == a && (a = n.stateful ? n.states_ : n.getInitialState(e156));
            var o = Array.isArray(n.cell.stateSize) ? n.cell.stateSize.length : 1;
            if (a.length !== o) throw new ValueError("RNN Layer has " + o + " state(s) but was passed " + a.length + " initial state(s).");
            n.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
            var s = {
                training: i
            }, l = rnn(function(e, t) {
                var r = n.cell.call([
                    e
                ].concat(t), s);
                return [
                    r[0],
                    r.slice(1)
                ];
            }, e156, a, n.goBackwards, r8, null, n.unroll, n.returnSequences), u = l[0], c = l[1], p = l[2];
            n.stateful && n.resetStates(p, i);
            var h = n.returnSequences ? c : u;
            return n.returnState ? [
                h
            ].concat(p) : h;
        });
    }, t116.prototype.getInitialState = function(e157) {
        var t = this;
        return _tfjsCore.tidy(function() {
            var n = _tfjsCore.zeros(e157.shape);
            return n = expandDims$1(n = _tfjsCore.sum(n, [
                1,
                2
            ])), Array.isArray(t.cell.stateSize) ? t.cell.stateSize.map(function(e) {
                return e > 1 ? tile$1(n, [
                    1,
                    e
                ]) : n;
            }) : t.cell.stateSize > 1 ? [
                tile$1(n, [
                    1,
                    t.cell.stateSize
                ])
            ] : [
                n
            ];
        });
    }, Object.defineProperty(t116.prototype, "trainableWeights", {
        get: function() {
            return this.trainable ? this.cell.trainableWeights : [];
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t116.prototype, "nonTrainableWeights", {
        get: function() {
            return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights;
        },
        enumerable: !0,
        configurable: !0
    }), t116.prototype.setFastWeightInitDuringBuild = function(t) {
        e152.prototype.setFastWeightInitDuringBuild.call(this, t), null != this.cell && this.cell.setFastWeightInitDuringBuild(t);
    }, t116.prototype.getConfig = function() {
        var t = {
            returnSequences: this.returnSequences,
            returnState: this.returnState,
            goBackwards: this.goBackwards,
            stateful: this.stateful,
            unroll: this.unroll
        };
        null != this.numConstants && (t.numConstants = this.numConstants);
        var n = this.cell.getConfig();
        t.cell = {
            className: this.cell.getClassName(),
            config: n
        };
        var r = e152.prototype.getConfig.call(this);
        return Object.assign(t, r), t;
    }, t116.fromConfig = function(e, t, n) {
        void 0 === n && (n = {
        });
        var r = deserialize(t.cell, n);
        return new e(Object.assign(t, {
            cell: r
        }));
    }, t116.className = "RNN", t116;
}(Layer);
_tfjsCore.serialization.registerClass(RNN);
var RNNCell = function(e) {
    function t() {
        return null !== e && e.apply(this, arguments) || this;
    }
    return __extends(t, e), t;
}(Layer), SimpleRNNCell = function(e158) {
    function t118(t) {
        var n = e158.call(this, t) || this;
        return n.DEFAULT_ACTIVATION = "tanh", n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n.DEFAULT_BIAS_INITIALIZER = "zeros", n.units = t.units, assertPositiveInteger(n.units, "units"), n.activation = getActivation(null == t.activation ? n.DEFAULT_ACTIVATION : t.activation), n.useBias = null == t.useBias || t.useBias, n.kernelInitializer = getInitializer(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.recurrentInitializer = getInitializer(t.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER), n.biasInitializer = getInitializer(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.kernelRegularizer = getRegularizer(t.kernelRegularizer), n.recurrentRegularizer = getRegularizer(t.recurrentRegularizer), n.biasRegularizer = getRegularizer(t.biasRegularizer), n.kernelConstraint = getConstraint(t.kernelConstraint), n.recurrentConstraint = getConstraint(t.recurrentConstraint), n.biasConstraint = getConstraint(t.biasConstraint), n.dropout = min$1([
            1,
            max$1([
                0,
                null == t.dropout ? 0 : t.dropout
            ])
        ]), n.recurrentDropout = min$1([
            1,
            max$1([
                0,
                null == t.recurrentDropout ? 0 : t.recurrentDropout
            ])
        ]), n.stateSize = n.units, n.dropoutMask = null, n.recurrentDropoutMask = null, n;
    }
    return __extends(t118, e158), t118.prototype.build = function(e) {
        e = getExactlyOneShape(e), this.kernel = this.addWeight("kernel", [
            e[e.length - 1],
            this.units
        ], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [
            this.units,
            this.units
        ], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [
            this.units
        ], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0;
    }, t118.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            if (2 !== e.length) throw new ValueError("SimpleRNNCell expects 2 input Tensors, got " + e.length + ".");
            var r = e[1];
            e = e[0];
            var i, a = null != t.training && t.training;
            0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = generateDropoutMask(function() {
                return _tfjsCore.onesLike(e);
            }, n.dropout, a)), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = generateDropoutMask(function() {
                return _tfjsCore.onesLike(r);
            }, n.recurrentDropout, a));
            var o = n.dropoutMask, s = n.recurrentDropoutMask;
            i = dot(null != o ? _tfjsCore.mul(e, o) : e, n.kernel.read()), null != n.bias && (i = biasAdd(i, n.bias.read())), null != s && (r = _tfjsCore.mul(r, s));
            var l = _tfjsCore.add(i, dot(r, n.recurrentKernel.read()));
            return null != n.activation && (l = n.activation.apply(l)), [
                l,
                l
            ];
        });
    }, t118.prototype.getConfig = function() {
        var t = {
            units: this.units,
            activation: serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: serializeInitializer(this.kernelInitializer),
            recurrentInitializer: serializeInitializer(this.recurrentInitializer),
            biasInitializer: serializeInitializer(this.biasInitializer),
            kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: serializeRegularizer(this.biasRegularizer),
            activityRegularizer: serializeRegularizer(this.activityRegularizer),
            kernelConstraint: serializeConstraint(this.kernelConstraint),
            recurrentConstraint: serializeConstraint(this.recurrentConstraint),
            biasConstraint: serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout
        }, n = e158.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t118.className = "SimpleRNNCell", t118;
}(RNNCell);
_tfjsCore.serialization.registerClass(SimpleRNNCell);
var SimpleRNN = function(e159) {
    function t119(t) {
        return t.cell = new SimpleRNNCell(t), e159.call(this, t) || this;
    }
    return __extends(t119, e159), t119.prototype.call = function(t, n) {
        var r = this;
        return _tfjsCore.tidy(function() {
            null != r.cell.dropoutMask && (_tfjsCore.dispose(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && (_tfjsCore.dispose(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
            var i = null == n ? null : n.mask, a = null == n ? null : n.training, o = null == n ? null : n.initialState;
            return e159.prototype.call.call(r, t, {
                mask: i,
                training: a,
                initialState: o
            });
        });
    }, Object.defineProperty(t119.prototype, "units", {
        get: function() {
            return this.cell.units;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t119.prototype, "activation", {
        get: function() {
            return this.cell.activation;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t119.prototype, "useBias", {
        get: function() {
            return this.cell.useBias;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t119.prototype, "kernelInitializer", {
        get: function() {
            return this.cell.kernelInitializer;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t119.prototype, "recurrentInitializer", {
        get: function() {
            return this.cell.recurrentInitializer;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t119.prototype, "biasInitializer", {
        get: function() {
            return this.cell.biasInitializer;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t119.prototype, "kernelRegularizer", {
        get: function() {
            return this.cell.kernelRegularizer;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t119.prototype, "recurrentRegularizer", {
        get: function() {
            return this.cell.recurrentRegularizer;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t119.prototype, "biasRegularizer", {
        get: function() {
            return this.cell.biasRegularizer;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t119.prototype, "kernelConstraint", {
        get: function() {
            return this.cell.kernelConstraint;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t119.prototype, "recurrentConstraint", {
        get: function() {
            return this.cell.recurrentConstraint;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t119.prototype, "biasConstraint", {
        get: function() {
            return this.cell.biasConstraint;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t119.prototype, "dropout", {
        get: function() {
            return this.cell.dropout;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t119.prototype, "recurrentDropout", {
        get: function() {
            return this.cell.recurrentDropout;
        },
        enumerable: !0,
        configurable: !0
    }), t119.prototype.getConfig = function() {
        var t = {
            units: this.units,
            activation: serializeActivation(this.activation),
            useBias: this.useBias,
            kernelInitializer: serializeInitializer(this.kernelInitializer),
            recurrentInitializer: serializeInitializer(this.recurrentInitializer),
            biasInitializer: serializeInitializer(this.biasInitializer),
            kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: serializeRegularizer(this.biasRegularizer),
            activityRegularizer: serializeRegularizer(this.activityRegularizer),
            kernelConstraint: serializeConstraint(this.kernelConstraint),
            recurrentConstraint: serializeConstraint(this.recurrentConstraint),
            biasConstraint: serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout
        }, n = e159.prototype.getConfig.call(this);
        return delete n.cell, Object.assign(t, n), t;
    }, t119.fromConfig = function(e, t) {
        return new e(t);
    }, t119.className = "SimpleRNN", t119;
}(RNN);
_tfjsCore.serialization.registerClass(SimpleRNN);
var GRUCell = function(e160) {
    function t120(t) {
        var n = e160.call(this, t) || this;
        return n.DEFAULT_ACTIVATION = "tanh", n.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n.DEFAULT_BIAS_INITIALIZER = "zeros", n.units = t.units, assertPositiveInteger(n.units, "units"), n.activation = getActivation(void 0 === t.activation ? n.DEFAULT_ACTIVATION : t.activation), n.recurrentActivation = getActivation(void 0 === t.recurrentActivation ? n.DEFAULT_RECURRENT_ACTIVATION : t.recurrentActivation), n.useBias = null == t.useBias || t.useBias, n.kernelInitializer = getInitializer(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.recurrentInitializer = getInitializer(t.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER), n.biasInitializer = getInitializer(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.kernelRegularizer = getRegularizer(t.kernelRegularizer), n.recurrentRegularizer = getRegularizer(t.recurrentRegularizer), n.biasRegularizer = getRegularizer(t.biasRegularizer), n.kernelConstraint = getConstraint(t.kernelConstraint), n.recurrentConstraint = getConstraint(t.recurrentConstraint), n.biasConstraint = getConstraint(t.biasConstraint), n.dropout = min$1([
            1,
            max$1([
                0,
                null == t.dropout ? 0 : t.dropout
            ])
        ]), n.recurrentDropout = min$1([
            1,
            max$1([
                0,
                null == t.recurrentDropout ? 0 : t.recurrentDropout
            ])
        ]), n.implementation = t.implementation, n.stateSize = n.units, n.dropoutMask = null, n.recurrentDropoutMask = null, n;
    }
    return __extends(t120, e160), t120.prototype.build = function(e) {
        var t = (e = getExactlyOneShape(e))[e.length - 1];
        this.kernel = this.addWeight("kernel", [
            t,
            3 * this.units
        ], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [
            this.units,
            3 * this.units
        ], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [
            3 * this.units
        ], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0;
    }, t120.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            if (2 !== e.length) throw new ValueError("GRUCell expects 2 input Tensors (inputs, h, c), got " + e.length + ".");
            var r = null != t.training && t.training, i = e[1];
            e = e[0], 0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = generateDropoutMask(function() {
                return _tfjsCore.onesLike(e);
            }, n.dropout, r, 3)), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = generateDropoutMask(function() {
                return _tfjsCore.onesLike(i);
            }, n.recurrentDropout, r, 3));
            var a, o, s, l = n.dropoutMask, u = n.recurrentDropoutMask;
            0 < n.dropout && n.dropout < 1 && (e = _tfjsCore.mul(e, l[0]));
            var c = dot(e, n.kernel.read());
            n.useBias && (c = biasAdd(c, n.bias.read())), 0 < n.recurrentDropout && n.recurrentDropout < 1 && (i = _tfjsCore.mul(i, u[0]));
            var p = n.recurrentKernel.read(), h = _tfjsCore.split(p, [
                2 * n.units,
                n.units
            ], p.rank - 1), d = h[0], f = h[1], g = dot(i, d), m = _tfjsCore.split(c, 3, c.rank - 1), y = m[0], v = m[1], b = m[2], w = _tfjsCore.split(g, 2, g.rank - 1), z = w[0], S = w[1];
            a = n.recurrentActivation.apply(_tfjsCore.add(y, z)), o = n.recurrentActivation.apply(_tfjsCore.add(v, S));
            var A = dot(_tfjsCore.mul(o, i), f);
            s = n.activation.apply(_tfjsCore.add(b, A));
            var _ = _tfjsCore.add(_tfjsCore.mul(a, i), _tfjsCore.mul(_tfjsCore.add(1, _tfjsCore.neg(a)), s));
            return [
                _,
                _
            ];
        });
    }, t120.prototype.getConfig = function() {
        var t = {
            units: this.units,
            activation: serializeActivation(this.activation),
            recurrentActivation: serializeActivation(this.recurrentActivation),
            useBias: this.useBias,
            kernelInitializer: serializeInitializer(this.kernelInitializer),
            recurrentInitializer: serializeInitializer(this.recurrentInitializer),
            biasInitializer: serializeInitializer(this.biasInitializer),
            kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: serializeRegularizer(this.biasRegularizer),
            activityRegularizer: serializeRegularizer(this.activityRegularizer),
            kernelConstraint: serializeConstraint(this.kernelConstraint),
            recurrentConstraint: serializeConstraint(this.recurrentConstraint),
            biasConstraint: serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
            implementation: this.implementation
        }, n = e160.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t120.className = "GRUCell", t120;
}(RNNCell);
_tfjsCore.serialization.registerClass(GRUCell);
var GRU = function(e161) {
    function t121(t) {
        return 0 === t.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), t.cell = new GRUCell(t), e161.call(this, t) || this;
    }
    return __extends(t121, e161), t121.prototype.call = function(t, n) {
        var r = this;
        return _tfjsCore.tidy(function() {
            null != r.cell.dropoutMask && (_tfjsCore.dispose(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && (_tfjsCore.dispose(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
            var i = null == n ? null : n.mask, a = null == n ? null : n.training, o = null == n ? null : n.initialState;
            return e161.prototype.call.call(r, t, {
                mask: i,
                training: a,
                initialState: o
            });
        });
    }, Object.defineProperty(t121.prototype, "units", {
        get: function() {
            return this.cell.units;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t121.prototype, "activation", {
        get: function() {
            return this.cell.activation;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t121.prototype, "recurrentActivation", {
        get: function() {
            return this.cell.recurrentActivation;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t121.prototype, "useBias", {
        get: function() {
            return this.cell.useBias;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t121.prototype, "kernelInitializer", {
        get: function() {
            return this.cell.kernelInitializer;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t121.prototype, "recurrentInitializer", {
        get: function() {
            return this.cell.recurrentInitializer;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t121.prototype, "biasInitializer", {
        get: function() {
            return this.cell.biasInitializer;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t121.prototype, "kernelRegularizer", {
        get: function() {
            return this.cell.kernelRegularizer;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t121.prototype, "recurrentRegularizer", {
        get: function() {
            return this.cell.recurrentRegularizer;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t121.prototype, "biasRegularizer", {
        get: function() {
            return this.cell.biasRegularizer;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t121.prototype, "kernelConstraint", {
        get: function() {
            return this.cell.kernelConstraint;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t121.prototype, "recurrentConstraint", {
        get: function() {
            return this.cell.recurrentConstraint;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t121.prototype, "biasConstraint", {
        get: function() {
            return this.cell.biasConstraint;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t121.prototype, "dropout", {
        get: function() {
            return this.cell.dropout;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t121.prototype, "recurrentDropout", {
        get: function() {
            return this.cell.recurrentDropout;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t121.prototype, "implementation", {
        get: function() {
            return this.cell.implementation;
        },
        enumerable: !0,
        configurable: !0
    }), t121.prototype.getConfig = function() {
        var t = {
            units: this.units,
            activation: serializeActivation(this.activation),
            recurrentActivation: serializeActivation(this.recurrentActivation),
            useBias: this.useBias,
            kernelInitializer: serializeInitializer(this.kernelInitializer),
            recurrentInitializer: serializeInitializer(this.recurrentInitializer),
            biasInitializer: serializeInitializer(this.biasInitializer),
            kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: serializeRegularizer(this.biasRegularizer),
            activityRegularizer: serializeRegularizer(this.activityRegularizer),
            kernelConstraint: serializeConstraint(this.kernelConstraint),
            recurrentConstraint: serializeConstraint(this.recurrentConstraint),
            biasConstraint: serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
            implementation: this.implementation
        }, n = e161.prototype.getConfig.call(this);
        return delete n.cell, Object.assign(t, n), t;
    }, t121.fromConfig = function(e, t) {
        return 0 === t.implmentation && (t.implementation = 1), new e(t);
    }, t121.className = "GRU", t121;
}(RNN);
_tfjsCore.serialization.registerClass(GRU);
var LSTMCell = function(e162) {
    function t122(t) {
        var n = e162.call(this, t) || this;
        return n.DEFAULT_ACTIVATION = "tanh", n.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", n.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", n.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", n.DEFAULT_BIAS_INITIALIZER = "zeros", n.units = t.units, assertPositiveInteger(n.units, "units"), n.activation = getActivation(void 0 === t.activation ? n.DEFAULT_ACTIVATION : t.activation), n.recurrentActivation = getActivation(void 0 === t.recurrentActivation ? n.DEFAULT_RECURRENT_ACTIVATION : t.recurrentActivation), n.useBias = null == t.useBias || t.useBias, n.kernelInitializer = getInitializer(t.kernelInitializer || n.DEFAULT_KERNEL_INITIALIZER), n.recurrentInitializer = getInitializer(t.recurrentInitializer || n.DEFAULT_RECURRENT_INITIALIZER), n.biasInitializer = getInitializer(t.biasInitializer || n.DEFAULT_BIAS_INITIALIZER), n.unitForgetBias = t.unitForgetBias, n.kernelRegularizer = getRegularizer(t.kernelRegularizer), n.recurrentRegularizer = getRegularizer(t.recurrentRegularizer), n.biasRegularizer = getRegularizer(t.biasRegularizer), n.kernelConstraint = getConstraint(t.kernelConstraint), n.recurrentConstraint = getConstraint(t.recurrentConstraint), n.biasConstraint = getConstraint(t.biasConstraint), n.dropout = min$1([
            1,
            max$1([
                0,
                null == t.dropout ? 0 : t.dropout
            ])
        ]), n.recurrentDropout = min$1([
            1,
            max$1([
                0,
                null == t.recurrentDropout ? 0 : t.recurrentDropout
            ])
        ]), n.implementation = t.implementation, n.stateSize = [
            n.units,
            n.units
        ], n.dropoutMask = null, n.recurrentDropoutMask = null, n;
    }
    return __extends(t122, e162), t122.prototype.build = function(e163) {
        var t123, n18, r9 = (e163 = getExactlyOneShape(e163))[e163.length - 1];
        if (this.kernel = this.addWeight("kernel", [
            r9,
            4 * this.units
        ], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [
            this.units,
            4 * this.units
        ], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias) {
            if (this.unitForgetBias) {
                var i = this.biasInitializer, a = this.units;
                n18 = new ((t123 = (function(e) {
                    function t() {
                        return null !== e && e.apply(this, arguments) || this;
                    }
                    return __extends(t, e), t.prototype.apply = function(e, t) {
                        var n = i.apply([
                            a
                        ]), r = (new Ones).apply([
                            a
                        ]), o = i.apply([
                            2 * a
                        ]);
                        return concatAlongFirstAxis(concatAlongFirstAxis(n, r), o);
                    }, t;
                }(Initializer))).className = "CustomInit", t123);
            } else n18 = this.biasInitializer;
            this.bias = this.addWeight("bias", [
                4 * this.units
            ], null, n18, this.biasRegularizer, !0, this.biasConstraint);
        } else this.bias = null;
        this.built = !0;
    }, t122.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            var r = null != t.training && t.training;
            if (3 !== e.length) throw new ValueError("LSTMCell expects 3 input Tensors (inputs, h, c), got " + e.length + ".");
            var i = e[1], a = e[2];
            e = e[0], 0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = generateDropoutMask(function() {
                return _tfjsCore.onesLike(e);
            }, n.dropout, r, 4)), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = generateDropoutMask(function() {
                return _tfjsCore.onesLike(i);
            }, n.recurrentDropout, r, 4));
            var o, s, l, u, c = n.dropoutMask, p = n.recurrentDropoutMask;
            0 < n.dropout && n.dropout < 1 && (e = _tfjsCore.mul(e, c[0]));
            var h = dot(e, n.kernel.read());
            0 < n.recurrentDropout && n.recurrentDropout < 1 && (i = _tfjsCore.mul(i, p[0])), h = _tfjsCore.add(h, dot(i, n.recurrentKernel.read())), n.useBias && (h = biasAdd(h, n.bias.read()));
            var d = _tfjsCore.split(h, 4, h.rank - 1), f = d[0], g = d[1], m = d[2], y = d[3];
            o = n.recurrentActivation.apply(f), s = n.recurrentActivation.apply(g), l = _tfjsCore.add(_tfjsCore.mul(s, a), _tfjsCore.mul(o, n.activation.apply(m))), u = n.recurrentActivation.apply(y);
            var v = _tfjsCore.mul(u, n.activation.apply(l));
            return [
                v,
                v,
                l
            ];
        });
    }, t122.prototype.getConfig = function() {
        var t = {
            units: this.units,
            activation: serializeActivation(this.activation),
            recurrentActivation: serializeActivation(this.recurrentActivation),
            useBias: this.useBias,
            kernelInitializer: serializeInitializer(this.kernelInitializer),
            recurrentInitializer: serializeInitializer(this.recurrentInitializer),
            biasInitializer: serializeInitializer(this.biasInitializer),
            unitForgetBias: this.unitForgetBias,
            kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: serializeRegularizer(this.biasRegularizer),
            activityRegularizer: serializeRegularizer(this.activityRegularizer),
            kernelConstraint: serializeConstraint(this.kernelConstraint),
            recurrentConstraint: serializeConstraint(this.recurrentConstraint),
            biasConstraint: serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
            implementation: this.implementation
        }, n = e162.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t122.className = "LSTMCell", t122;
}(RNNCell);
_tfjsCore.serialization.registerClass(LSTMCell);
var LSTM = function(e164) {
    function t124(t) {
        return 0 === t.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), t.cell = new LSTMCell(t), e164.call(this, t) || this;
    }
    return __extends(t124, e164), t124.prototype.call = function(t, n) {
        var r = this;
        return _tfjsCore.tidy(function() {
            null != r.cell.dropoutMask && (_tfjsCore.dispose(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && (_tfjsCore.dispose(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
            var i = null == n ? null : n.mask, a = null == n ? null : n.training, o = null == n ? null : n.initialState;
            return e164.prototype.call.call(r, t, {
                mask: i,
                training: a,
                initialState: o
            });
        });
    }, Object.defineProperty(t124.prototype, "units", {
        get: function() {
            return this.cell.units;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t124.prototype, "activation", {
        get: function() {
            return this.cell.activation;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t124.prototype, "recurrentActivation", {
        get: function() {
            return this.cell.recurrentActivation;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t124.prototype, "useBias", {
        get: function() {
            return this.cell.useBias;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t124.prototype, "kernelInitializer", {
        get: function() {
            return this.cell.kernelInitializer;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t124.prototype, "recurrentInitializer", {
        get: function() {
            return this.cell.recurrentInitializer;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t124.prototype, "biasInitializer", {
        get: function() {
            return this.cell.biasInitializer;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t124.prototype, "unitForgetBias", {
        get: function() {
            return this.cell.unitForgetBias;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t124.prototype, "kernelRegularizer", {
        get: function() {
            return this.cell.kernelRegularizer;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t124.prototype, "recurrentRegularizer", {
        get: function() {
            return this.cell.recurrentRegularizer;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t124.prototype, "biasRegularizer", {
        get: function() {
            return this.cell.biasRegularizer;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t124.prototype, "kernelConstraint", {
        get: function() {
            return this.cell.kernelConstraint;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t124.prototype, "recurrentConstraint", {
        get: function() {
            return this.cell.recurrentConstraint;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t124.prototype, "biasConstraint", {
        get: function() {
            return this.cell.biasConstraint;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t124.prototype, "dropout", {
        get: function() {
            return this.cell.dropout;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t124.prototype, "recurrentDropout", {
        get: function() {
            return this.cell.recurrentDropout;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t124.prototype, "implementation", {
        get: function() {
            return this.cell.implementation;
        },
        enumerable: !0,
        configurable: !0
    }), t124.prototype.getConfig = function() {
        var t = {
            units: this.units,
            activation: serializeActivation(this.activation),
            recurrentActivation: serializeActivation(this.recurrentActivation),
            useBias: this.useBias,
            kernelInitializer: serializeInitializer(this.kernelInitializer),
            recurrentInitializer: serializeInitializer(this.recurrentInitializer),
            biasInitializer: serializeInitializer(this.biasInitializer),
            unitForgetBias: this.unitForgetBias,
            kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
            recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
            biasRegularizer: serializeRegularizer(this.biasRegularizer),
            activityRegularizer: serializeRegularizer(this.activityRegularizer),
            kernelConstraint: serializeConstraint(this.kernelConstraint),
            recurrentConstraint: serializeConstraint(this.recurrentConstraint),
            biasConstraint: serializeConstraint(this.biasConstraint),
            dropout: this.dropout,
            recurrentDropout: this.recurrentDropout,
            implementation: this.implementation
        }, n = e164.prototype.getConfig.call(this);
        return delete n.cell, Object.assign(t, n), t;
    }, t124.fromConfig = function(e, t) {
        return 0 === t.implmentation && (t.implementation = 1), new e(t);
    }, t124.className = "LSTM", t124;
}(RNN);
_tfjsCore.serialization.registerClass(LSTM);
var StackedRNNCells = function(e165) {
    function t125(t) {
        var n = e165.call(this, t) || this;
        return n.cells = t.cells, n;
    }
    return __extends(t125, e165), Object.defineProperty(t125.prototype, "stateSize", {
        get: function() {
            for(var e = [], t = 0, n = this.cells.slice().reverse(); t < n.length; t++){
                var r = n[t];
                Array.isArray(r.stateSize) ? e.push.apply(e, r.stateSize) : e.push(r.stateSize);
            }
            return e;
        },
        enumerable: !0,
        configurable: !0
    }), t125.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            for(var r = e.slice(1), i = [], a = 0, o = n.cells.slice().reverse(); a < o.length; a++){
                var s = o[a];
                Array.isArray(s.stateSize) ? i.push(r.splice(0, s.stateSize.length)) : i.push(r.splice(0, 1));
            }
            i.reverse();
            for(var l, u = [], c = 0; c < n.cells.length; ++c){
                s = n.cells[c];
                r = i[c], l = 0 === c ? [
                    e[0]
                ].concat(r) : [
                    l[0]
                ].concat(r), l = s.call(l, t), u.push(l.slice(1));
            }
            r = [];
            for(var p = 0, h = u.slice().reverse(); p < h.length; p++){
                var d = h[p];
                r.push.apply(r, d);
            }
            return [
                l[0]
            ].concat(r);
        });
    }, t125.prototype.build = function(e) {
        var t;
        isArrayOfShapes(e) && (e = e[0]), this.cells.forEach(function(n, r) {
            nameScope("RNNCell_" + r, function() {
                n.build(e), t = Array.isArray(n.stateSize) ? n.stateSize[0] : n.stateSize, e = [
                    e[0],
                    t
                ];
            });
        }), this.built = !0;
    }, t125.prototype.getConfig = function() {
        for(var t = [], n = 0, r = this.cells; n < r.length; n++){
            var i = r[n];
            t.push({
                className: i.getClassName(),
                config: i.getConfig()
            });
        }
        var a = {
            cells: t
        }, o = e165.prototype.getConfig.call(this);
        return Object.assign(a, o), a;
    }, t125.fromConfig = function(e, t, n) {
        void 0 === n && (n = {
        });
        for(var r = [], i = 0, a = t.cells; i < a.length; i++){
            var o = a[i];
            r.push(deserialize(o, n));
        }
        return new e({
            cells: r
        });
    }, Object.defineProperty(t125.prototype, "trainableWeights", {
        get: function() {
            if (!this.trainable) return [];
            for(var e = [], t = 0, n = this.cells; t < n.length; t++){
                var r = n[t];
                e.push.apply(e, r.trainableWeights);
            }
            return e;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t125.prototype, "nonTrainableWeights", {
        get: function() {
            for(var e = [], t = 0, n = this.cells; t < n.length; t++){
                var r = n[t];
                e.push.apply(e, r.nonTrainableWeights);
            }
            if (!this.trainable) {
                for(var i = [], a = 0, o = this.cells; a < o.length; a++){
                    r = o[a];
                    i.push.apply(i, r.trainableWeights);
                }
                return i.concat(e);
            }
            return e;
        },
        enumerable: !0,
        configurable: !0
    }), t125.prototype.getWeights = function() {
        for(var e = [], t = 0, n = this.cells; t < n.length; t++){
            var r = n[t];
            e.push.apply(e, r.weights);
        }
        return batchGetValue(e);
    }, t125.prototype.setWeights = function(e) {
        for(var t = [], n = 0, r = this.cells; n < r.length; n++)for(var i = r[n], a = i.weights.length, o = e.splice(a), s = 0; s < i.weights.length; ++s)t.push([
            i.weights[s],
            o[s]
        ]);
        batchSetValue(t);
    }, t125.className = "StackedRNNCells", t125;
}(RNNCell);
function generateDropoutMask(e166, t, n, r) {
    function i() {
        return dropout$1(e166(), t);
    }
    if (void 0 === n && (n = null), void 0 === r && (r = 1), r > 1) {
        for(var a = [], o = 0; o < r; o++)a.push(inTrainPhase(i, e166, n));
        return a.map(function(e) {
            return _tfjsCore.keep(e.clone());
        });
    }
    return _tfjsCore.keep(inTrainPhase(i, e166, n).clone());
}
_tfjsCore.serialization.registerClass(StackedRNNCells);
var Wrapper = function(e167) {
    function t126(t) {
        var n = e167.call(this, t) || this;
        return n.layer = t.layer, n;
    }
    return __extends(t126, e167), t126.prototype.build = function(e) {
        this.built = !0;
    }, Object.defineProperty(t126.prototype, "trainable", {
        get: function() {
            return null != this.layer && this.layer.trainable;
        },
        set: function(e) {
            null != this.layer && (this.layer.trainable = e);
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t126.prototype, "trainableWeights", {
        get: function() {
            return this.layer.trainableWeights;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t126.prototype, "nonTrainableWeights", {
        get: function() {
            return this.layer.nonTrainableWeights;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t126.prototype, "updates", {
        get: function() {
            return this.layer._updates;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t126.prototype, "losses", {
        get: function() {
            return this.layer.losses;
        },
        enumerable: !0,
        configurable: !0
    }), t126.prototype.getWeights = function() {
        return this.layer.getWeights();
    }, t126.prototype.setWeights = function(e) {
        this.layer.setWeights(e);
    }, t126.prototype.getConfig = function() {
        var t = {
            layer: {
                className: this.layer.getClassName(),
                config: this.layer.getConfig()
            }
        }, n = e167.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t126.prototype.setFastWeightInitDuringBuild = function(t) {
        e167.prototype.setFastWeightInitDuringBuild.call(this, t), null != this.layer && this.layer.setFastWeightInitDuringBuild(t);
    }, t126.fromConfig = function(e, t, n) {
        void 0 === n && (n = {
        });
        var r = deserialize(t.layer, n);
        delete t.layer;
        var i = {
            layer: r
        };
        return Object.assign(i, t), new e(i);
    }, t126;
}(Layer), TimeDistributed = function(e168) {
    function t127(t) {
        var n = e168.call(this, t) || this;
        return n.supportsMasking = !0, n;
    }
    return __extends(t127, e168), t127.prototype.build = function(t) {
        if ((t = getExactlyOneShape(t)).length < 3) throw new ValueError("TimeDistributed layer expects an input shape >= 3D, but received input shape " + JSON.stringify(t));
        this.inputSpec = [
            {
                shape: t
            }
        ];
        var n = [
            t[0]
        ].concat(t.slice(2));
        this.layer.built || (this.layer.build(n), this.layer.built = !0), e168.prototype.build.call(this, t);
    }, t127.prototype.computeOutputShape = function(e) {
        var t = [
            (e = getExactlyOneShape(e))[0]
        ].concat(e.slice(2)), n = this.layer.computeOutputShape(t), r = e[1];
        return [
            n[0],
            r
        ].concat(n.slice(1));
    }, t127.prototype.call = function(e169, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            return rnn(function(e, r) {
                return [
                    getExactlyOneTensor(n.layer.call(e, t)),
                    []
                ];
            }, e169 = getExactlyOneTensor(e169), [], !1, null, null, !1, !0)[1];
        });
    }, t127.className = "TimeDistributed", t127;
}(Wrapper);
function checkBidirectionalMergeMode(e) {
    checkStringTypeUnionValue(VALID_BIDIRECTIONAL_MERGE_MODES, "BidirectionalMergeMode", e);
}
_tfjsCore.serialization.registerClass(TimeDistributed);
var DEFAULT_BIDIRECTIONAL_MERGE_MODE = "concat", Bidirectional = function(e170) {
    function t128(t) {
        var n = e170.call(this, t) || this, r = t.layer.getConfig(), i = {
        };
        i.className = t.layer.getClassName(), i.config = r, n.forwardLayer = deserialize(i), r.goBackwards = !0 !== r.goBackwards;
        var a = {
        };
        if (a.className = t.layer.getClassName(), a.config = r, n.backwardLayer = deserialize(a), n.forwardLayer.name = "forward_" + n.forwardLayer.name, n.backwardLayer.name = "backward_" + n.backwardLayer.name, n.mergeMode = void 0 === t.mergeMode ? DEFAULT_BIDIRECTIONAL_MERGE_MODE : t.mergeMode, checkBidirectionalMergeMode(n.mergeMode), t.weights) throw new NotImplementedError("weights support is not implemented for Bidirectional layer yet.");
        return n._stateful = t.layer.stateful, n.returnSequences = t.layer.returnSequences, n.returnState = t.layer.returnState, n.supportsMasking = !0, n._trainable = !0, n.inputSpec = t.layer.inputSpec, n.numConstants = null, n;
    }
    return __extends(t128, e170), Object.defineProperty(t128.prototype, "trainable", {
        get: function() {
            return this._trainable;
        },
        set: function(e) {
            this._trainable = e, null != this.forwardLayer && (this.forwardLayer.trainable = e), null != this.backwardLayer && (this.backwardLayer.trainable = e);
        },
        enumerable: !0,
        configurable: !0
    }), t128.prototype.getWeights = function() {
        return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
    }, t128.prototype.setWeights = function(e) {
        var t = e.length, n = Math.floor(t / 2);
        this.forwardLayer.setWeights(e.slice(0, n)), this.backwardLayer.setWeights(e.slice(n));
    }, t128.prototype.computeOutputShape = function(e) {
        var t, n, r, i = this.forwardLayer.computeOutputShape(e);
        return Array.isArray(i) && Array.isArray(i[0]) || (i = [
            i
        ]), this.returnState ? (r = i.slice(1), t = i[0]) : t = i[0], "concat" === this.mergeMode ? (t[t.length - 1] *= 2, n = [
            t
        ]) : n = null == this.mergeMode ? [
            t,
            t.slice()
        ] : [
            t
        ], this.returnState ? null == this.mergeMode ? n.concat(r).concat(r.slice()) : [
            t
        ].concat(r).concat(r.slice()) : singletonOrArray(n);
    }, t128.prototype.apply = function(t, n) {
        var r = null == n ? null : n.initialState, i = null == n ? null : n.constants;
        null == n && (n = {
        });
        var a = standardizeArgs(t, r, i, this.numConstants);
        if (t = a.inputs, r = a.initialState, i = a.constants, Array.isArray(t) && (r = t.slice(1), t = t[0]), (null == r || 0 === r.length) && null == i) return e170.prototype.apply.call(this, t, n);
        var o = [], s = [];
        if (null != r) {
            var l = r.length;
            if (l % 2 > 0) throw new ValueError("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
            n.initialState = r, o.push.apply(o, r);
            var u = r.map(function(e) {
                return new InputSpec({
                    shape: e.shape
                });
            });
            this.forwardLayer.stateSpec = u.slice(0, l / 2), this.backwardLayer.stateSpec = u.slice(l / 2), s.push.apply(s, u);
        }
        if (null != i) throw new NotImplementedError("Support for constants in Bidirectional layers is not implemented yet.");
        for(var c = o[0] instanceof SymbolicTensor, p = 0, h = o; p < h.length; p++){
            if (h[p] instanceof SymbolicTensor !== c) throw new ValueError("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
        }
        if (c) {
            var d = [
                t
            ].concat(o), f = this.inputSpec.concat(s), g = this.inputSpec;
            this.inputSpec = f;
            var m = e170.prototype.apply.call(this, d, n);
            return this.inputSpec = g, m;
        }
        return e170.prototype.apply.call(this, t, n);
    }, t128.prototype.call = function(e, t) {
        var n = this;
        return _tfjsCore.tidy(function() {
            var r, i, a, o, s = t.initialState;
            if (null == s) r = n.forwardLayer.call(e, t), i = n.backwardLayer.call(e, t);
            else {
                var l = s.slice(0, s.length / 2), u = s.slice(s.length / 2);
                r = n.forwardLayer.call(e, Object.assign(t, {
                    initialState: l
                })), i = n.backwardLayer.call(e, Object.assign(t, {
                    initialState: u
                }));
            }
            return n.returnState && (Array.isArray(r) && (a = r.slice(1).concat(i.slice(1))), r = r[0], i = i[0]), n.returnSequences && (i = _tfjsCore.reverse(i, 1)), "concat" === n.mergeMode ? o = concatenate([
                r,
                i
            ]) : "sum" === n.mergeMode ? o = _tfjsCore.add(r, i) : "ave" === n.mergeMode ? o = _tfjsCore.mul(0.5, _tfjsCore.add(r, i)) : "mul" === n.mergeMode ? o = _tfjsCore.mul(r, i) : null == n.mergeMode && (o = [
                r,
                i
            ]), n.returnState ? null == n.mergeMode ? o.concat(a) : [
                o
            ].concat(a) : o;
        });
    }, t128.prototype.resetStates = function(e) {
        this.forwardLayer.resetStates(), this.backwardLayer.resetStates();
    }, t128.prototype.build = function(e) {
        var t = this;
        nameScope(this.forwardLayer.name, function() {
            t.forwardLayer.build(e);
        }), nameScope(this.backwardLayer.name, function() {
            t.backwardLayer.build(e);
        }), this.built = !0;
    }, t128.prototype.computeMask = function(e, t) {
        var n;
        if (Array.isArray(t) && (t = t[0]), n = this.returnSequences ? null == this.mergeMode ? [
            t,
            t
        ] : t : null == this.mergeMode ? [
            null,
            null
        ] : null, this.returnState) {
            var r = this.forwardLayer.states.map(function(e) {
                return null;
            });
            return Array.isArray(n) ? n.concat(r).concat(r) : [
                n
            ].concat(r).concat(r);
        }
        return n;
    }, Object.defineProperty(t128.prototype, "trainableWeights", {
        get: function() {
            return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(t128.prototype, "nonTrainableWeights", {
        get: function() {
            return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
        },
        enumerable: !0,
        configurable: !0
    }), t128.prototype.setFastWeightInitDuringBuild = function(t) {
        e170.prototype.setFastWeightInitDuringBuild.call(this, t), null != this.forwardLayer && this.forwardLayer.setFastWeightInitDuringBuild(t), null != this.backwardLayer && this.backwardLayer.setFastWeightInitDuringBuild(t);
    }, t128.prototype.getConfig = function() {
        var t = {
            mergeMode: this.mergeMode
        }, n = e170.prototype.getConfig.call(this);
        return Object.assign(t, n), t;
    }, t128.fromConfig = function(e, t) {
        var n = deserialize(t.layer);
        if (delete t.layer, null != t.numConstants) throw new NotImplementedError("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
        var r = t;
        return r.layer = n, new e(r);
    }, t128.className = "Bidirectional", t128;
}(Wrapper);
function inputLayer(e) {
    return new InputLayer(e);
}
function elu$2(e) {
    return new ELU(e);
}
function reLU(e) {
    return new ReLU(e);
}
function leakyReLU(e) {
    return new LeakyReLU(e);
}
function prelu$1(e) {
    return new PReLU(e);
}
function softmax$1(e) {
    return new Softmax$1(e);
}
function thresholdedReLU(e) {
    return new ThresholdedReLU(e);
}
function conv1d$2(e) {
    return new Conv1D(e);
}
function conv2d$1(e) {
    return new Conv2D(e);
}
function conv2dTranspose$1(e) {
    return new Conv2DTranspose(e);
}
function conv3d$2(e) {
    return new Conv3D(e);
}
function separableConv2d$1(e) {
    return new SeparableConv2D(e);
}
function cropping2D(e) {
    return new Cropping2D(e);
}
function upSampling2d(e) {
    return new UpSampling2D(e);
}
function depthwiseConv2d$2(e) {
    return new DepthwiseConv2D(e);
}
function activation(e) {
    return new Activation$1(e);
}
function dense(e) {
    return new Dense(e);
}
function dropout$2(e) {
    return new Dropout(e);
}
function spatialDropout1d(e) {
    return new SpatialDropout1D(e);
}
function flatten$1(e) {
    return new Flatten(e);
}
function repeatVector(e) {
    return new RepeatVector(e);
}
function reshape(e) {
    return new Reshape(e);
}
function permute(e) {
    return new Permute(e);
}
function embedding(e) {
    return new Embedding(e);
}
function add$2(e) {
    return new Add(e);
}
function average$1(e) {
    return new Average(e);
}
function concatenate$2(e) {
    return new Concatenate(e);
}
function maximum$2(e) {
    return new Maximum(e);
}
function minimum$2(e) {
    return new Minimum(e);
}
function multiply$1(e) {
    return new Multiply(e);
}
function dot$1(e) {
    return new Dot(e);
}
function batchNormalization$1(e) {
    return new BatchNormalization(e);
}
function layerNormalization(e) {
    return new LayerNormalization(e);
}
function zeroPadding2d(e) {
    return new ZeroPadding2D(e);
}
function averagePooling1d(e) {
    return new AveragePooling1D(e);
}
function avgPool1d(e) {
    return averagePooling1d(e);
}
function avgPooling1d(e) {
    return averagePooling1d(e);
}
function averagePooling2d(e) {
    return new AveragePooling2D(e);
}
function avgPool2d(e) {
    return averagePooling2d(e);
}
function avgPooling2d(e) {
    return averagePooling2d(e);
}
function averagePooling3d(e) {
    return new AveragePooling3D(e);
}
function avgPool3d$1(e) {
    return averagePooling3d(e);
}
function avgPooling3d(e) {
    return averagePooling3d(e);
}
function globalAveragePooling1d(e) {
    return new GlobalAveragePooling1D(e);
}
function globalAveragePooling2d(e) {
    return new GlobalAveragePooling2D(e);
}
function globalMaxPooling1d(e) {
    return new GlobalMaxPooling1D(e);
}
function globalMaxPooling2d(e) {
    return new GlobalMaxPooling2D(e);
}
function maxPooling1d(e) {
    return new MaxPooling1D(e);
}
function maxPooling2d(e) {
    return new MaxPooling2D(e);
}
function maxPooling3d(e) {
    return new MaxPooling3D(e);
}
function gru(e) {
    return new GRU(e);
}
function gruCell(e) {
    return new GRUCell(e);
}
function lstm(e) {
    return new LSTM(e);
}
function lstmCell(e) {
    return new LSTMCell(e);
}
function simpleRNN(e) {
    return new SimpleRNN(e);
}
function simpleRNNCell(e) {
    return new SimpleRNNCell(e);
}
function rnn$1(e) {
    return new RNN(e);
}
function stackedRNNCells(e) {
    return new StackedRNNCells(e);
}
function bidirectional(e) {
    return new Bidirectional(e);
}
function timeDistributed(e) {
    return new TimeDistributed(e);
}
_tfjsCore.serialization.registerClass(Bidirectional);
var globalMaxPool1d = globalMaxPooling1d, globalMaxPool2d = globalMaxPooling2d, maxPool1d = maxPooling1d, maxPool2d = maxPooling2d;
function gaussianNoise(e) {
    return new GaussianNoise(e);
}
function gaussianDropout(e) {
    return new GaussianDropout(e);
}
function alphaDropout(e) {
    return new AlphaDropout(e);
}
function masking(e) {
    return new Masking(e);
}
var exports_layers = Object.freeze({
    inputLayer: inputLayer,
    elu: elu$2,
    reLU: reLU,
    leakyReLU: leakyReLU,
    prelu: prelu$1,
    softmax: softmax$1,
    thresholdedReLU: thresholdedReLU,
    conv1d: conv1d$2,
    conv2d: conv2d$1,
    conv2dTranspose: conv2dTranspose$1,
    conv3d: conv3d$2,
    separableConv2d: separableConv2d$1,
    cropping2D: cropping2D,
    upSampling2d: upSampling2d,
    depthwiseConv2d: depthwiseConv2d$2,
    activation: activation,
    dense: dense,
    dropout: dropout$2,
    spatialDropout1d: spatialDropout1d,
    flatten: flatten$1,
    repeatVector: repeatVector,
    reshape: reshape,
    permute: permute,
    embedding: embedding,
    add: add$2,
    average: average$1,
    concatenate: concatenate$2,
    maximum: maximum$2,
    minimum: minimum$2,
    multiply: multiply$1,
    dot: dot$1,
    batchNormalization: batchNormalization$1,
    layerNormalization: layerNormalization,
    zeroPadding2d: zeroPadding2d,
    averagePooling1d: averagePooling1d,
    avgPool1d: avgPool1d,
    avgPooling1d: avgPooling1d,
    averagePooling2d: averagePooling2d,
    avgPool2d: avgPool2d,
    avgPooling2d: avgPooling2d,
    averagePooling3d: averagePooling3d,
    avgPool3d: avgPool3d$1,
    avgPooling3d: avgPooling3d,
    globalAveragePooling1d: globalAveragePooling1d,
    globalAveragePooling2d: globalAveragePooling2d,
    globalMaxPooling1d: globalMaxPooling1d,
    globalMaxPooling2d: globalMaxPooling2d,
    maxPooling1d: maxPooling1d,
    maxPooling2d: maxPooling2d,
    maxPooling3d: maxPooling3d,
    gru: gru,
    gruCell: gruCell,
    lstm: lstm,
    lstmCell: lstmCell,
    simpleRNN: simpleRNN,
    simpleRNNCell: simpleRNNCell,
    rnn: rnn$1,
    stackedRNNCells: stackedRNNCells,
    bidirectional: bidirectional,
    timeDistributed: timeDistributed,
    globalMaxPool1d: globalMaxPool1d,
    globalMaxPool2d: globalMaxPool2d,
    maxPool1d: maxPool1d,
    maxPool2d: maxPool2d,
    Layer: Layer,
    RNN: RNN,
    RNNCell: RNNCell,
    input: input,
    gaussianNoise: gaussianNoise,
    gaussianDropout: gaussianDropout,
    alphaDropout: alphaDropout,
    masking: masking
});
function binaryAccuracy$1(e, t) {
    return binaryAccuracy(e, t);
}
function binaryCrossentropy$2(e, t) {
    return binaryCrossentropy$1(e, t);
}
function sparseCategoricalAccuracy$1(e, t) {
    return sparseCategoricalAccuracy(e, t);
}
function categoricalAccuracy$1(e, t) {
    return categoricalAccuracy(e, t);
}
function categoricalCrossentropy$2(e, t) {
    return categoricalCrossentropy$1(e, t);
}
function precision$1(e, t) {
    return precision(e, t);
}
function recall$1(e, t) {
    return recall(e, t);
}
function cosineProximity$1(e, t) {
    return cosineProximity(e, t);
}
function meanAbsoluteError$1(e, t) {
    return meanAbsoluteError(e, t);
}
function meanAbsolutePercentageError$1(e, t) {
    return meanAbsolutePercentageError(e, t);
}
function MAPE$2(e, t) {
    return meanAbsolutePercentageError(e, t);
}
function mape$2(e, t) {
    return meanAbsolutePercentageError(e, t);
}
function meanSquaredError$1(e, t) {
    return meanSquaredError(e, t);
}
function MSE$2(e, t) {
    return meanSquaredError(e, t);
}
function mse$2(e, t) {
    return meanSquaredError(e, t);
}
var exports_metrics = Object.freeze({
    binaryAccuracy: binaryAccuracy$1,
    binaryCrossentropy: binaryCrossentropy$2,
    sparseCategoricalAccuracy: sparseCategoricalAccuracy$1,
    categoricalAccuracy: categoricalAccuracy$1,
    categoricalCrossentropy: categoricalCrossentropy$2,
    precision: precision$1,
    recall: recall$1,
    cosineProximity: cosineProximity$1,
    meanAbsoluteError: meanAbsoluteError$1,
    meanAbsolutePercentageError: meanAbsolutePercentageError$1,
    MAPE: MAPE$2,
    mape: mape$2,
    meanSquaredError: meanSquaredError$1,
    MSE: MSE$2,
    mse: mse$2
}), exports_models = Object.freeze({
    modelFromJSON: modelFromJSON
});
function l1l2(e) {
    return new L1L2(e);
}
function l1$1(e) {
    return l1(e);
}
function l2$1(e) {
    return l2(e);
}
var exports_regularizers = Object.freeze({
    l1l2: l1l2,
    l1: l1$1,
    l2: l2$1
}), Callback = function(e171) {
    function t129() {
        var t = null !== e171 && e171.apply(this, arguments) || this;
        return t.model = null, t;
    }
    return __extends(t129, e171), t129.prototype.setModel = function(e) {
        if (!(e instanceof LayersModel)) throw new Error("model must be a LayersModel, not some other Container");
        this.model = e;
    }, t129;
}(BaseCallback);
function less(e, t) {
    return e < t;
}
function greater$1(e, t) {
    return e > t;
}
var EarlyStopping = function(e172) {
    function t130(t) {
        var n = e172.call(this) || this;
        if (null == t && (t = {
        }), t.restoreBestWeights) throw new NotImplementedError("restoreBestWeights = True is not implemented in EarlyStopping yet.");
        return n.monitor = t.monitor || "val_loss", n.minDelta = Math.abs(t.minDelta || 0), n.patience = t.patience || 0, n.verbose = t.verbose || 0, n.mode = t.mode || "auto", n.baseline = t.baseline, -1 === [
            "auto",
            "min",
            "max"
        ].indexOf(n.mode) && (console.warn("EarlyStopping mode '" + n.mode + "' is invalid. Falling back to mode 'auto'."), n.mode = "auto"), "min" === n.mode ? n.monitorFunc = less : "max" === n.mode ? n.monitorFunc = greater$1 : -1 !== n.monitor.indexOf("acc") ? n.monitorFunc = greater$1 : n.monitorFunc = less, n.monitorFunc === less && (n.minDelta *= -1), n;
    }
    return __extends(t130, e172), t130.prototype.onTrainBegin = function(e) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(e) {
                return this.wait = 0, this.stoppedEpoch = 0, null != this.baseline ? this.best = this.baseline : this.best = this.monitorFunc === less ? 1 / 0 : -1 / 0, [
                    2
                ];
            });
        });
    }, t130.prototype.onEpochEnd = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            var n;
            return __generator(this, function(r) {
                switch(r.label){
                    case 0:
                        return [
                            4,
                            resolveScalarsInLogs(t)
                        ];
                    case 1:
                        return r.sent(), null == (n = this.getMonitorValue(t)) ? [
                            2
                        ] : (this.monitorFunc(n - this.minDelta, this.best) ? (this.best = n, this.wait = 0) : (this.wait++, this.wait >= this.patience && (this.stoppedEpoch = e, this.model.stopTraining = !0)), [
                            2
                        ]);
                }
            });
        });
    }, t130.prototype.onTrainEnd = function(e) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(e) {
                return this.stoppedEpoch > 0 && this.verbose && console.log("Epoch " + this.stoppedEpoch + ": early stopping."), [
                    2
                ];
            });
        });
    }, t130.prototype.getMonitorValue = function(e) {
        null == e && (e = {
        });
        var t = e[this.monitor];
        return null == t && console.warn("Metric for EarlyStopping " + this.monitor + " is not available. Available metrics are: " + Object.keys(e)), t;
    }, t130;
}(Callback);
function earlyStopping(e) {
    return new EarlyStopping(e);
}
var callbacks = {
    earlyStopping: earlyStopping
};

},{"@tensorflow/tfjs-core":"djGzH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h4Rqn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GraphModel", ()=>GraphModel
);
parcelHelpers.export(exports, "loadGraphModel", ()=>loadGraphModel
);
parcelHelpers.export(exports, "deregisterOp", ()=>deregisterOp
);
parcelHelpers.export(exports, "registerOp", ()=>registerOp
);
parcelHelpers.export(exports, "version_converter", ()=>version
);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ var _tfjsCore = require("@tensorflow/tfjs-core");
var Buffer = require("buffer").Buffer;
var DataType, SaverDef, __assign = function() {
    return (__assign = Object.assign || function(e) {
        for(var t, a = 1, r = arguments.length; a < r; a++)for(var n in t = arguments[a])Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
        return e;
    }).apply(this, arguments);
};
function __awaiter(e1, t1, a, r) {
    return new (a || (a = Promise))(function(n, s) {
        function o(e) {
            try {
                u(r.next(e));
            } catch (e2) {
                s(e2);
            }
        }
        function p(e) {
            try {
                u(r.throw(e));
            } catch (e3) {
                s(e3);
            }
        }
        function u(e) {
            e.done ? n(e.value) : new a(function(t) {
                t(e.value);
            }).then(o, p);
        }
        u((r = r.apply(e1, t1 || [])).next());
    });
}
function __generator(e4, t) {
    var a, r, n, s1, o = {
        label: 0,
        sent: function() {
            if (1 & n[0]) throw n[1];
            return n[1];
        },
        trys: [],
        ops: []
    };
    function p1(s2) {
        return function(p) {
            return (function(s) {
                if (a) throw new TypeError("Generator is already executing.");
                for(; o;)try {
                    if (a = 1, r && (n = 2 & s[0] ? r.return : s[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, s[1])).done) return n;
                    switch(r = 0, n && (s = [
                        2 & s[0],
                        n.value
                    ]), s[0]){
                        case 0:
                        case 1:
                            n = s;
                            break;
                        case 4:
                            return o.label++, {
                                value: s[1],
                                done: !1
                            };
                        case 5:
                            o.label++, r = s[1], s = [
                                0
                            ];
                            continue;
                        case 7:
                            s = o.ops.pop(), o.trys.pop();
                            continue;
                        default:
                            if (!(n = (n = o.trys).length > 0 && n[n.length - 1]) && (6 === s[0] || 2 === s[0])) {
                                o = 0;
                                continue;
                            }
                            if (3 === s[0] && (!n || s[1] > n[0] && s[1] < n[3])) {
                                o.label = s[1];
                                break;
                            }
                            if (6 === s[0] && o.label < n[1]) {
                                o.label = n[1], n = s;
                                break;
                            }
                            if (n && o.label < n[2]) {
                                o.label = n[2], o.ops.push(s);
                                break;
                            }
                            n[2] && o.ops.pop(), o.trys.pop();
                            continue;
                    }
                    s = t.call(e4, o);
                } catch (e) {
                    s = [
                        6,
                        e
                    ], r = 0;
                } finally{
                    a = n = 0;
                }
                if (5 & s[0]) throw s[1];
                return {
                    value: s[0] ? s[1] : void 0,
                    done: !0
                };
            })([
                s2,
                p
            ]);
        };
    }
    return s1 = {
        next: p1(0),
        throw: p1(1),
        return: p1(2)
    }, "function" == typeof Symbol && (s1[Symbol.iterator] = function() {
        return this;
    }), s1;
}
!function(e) {
    e[e.DT_INVALID = 0] = "DT_INVALID", e[e.DT_FLOAT = 1] = "DT_FLOAT", e[e.DT_DOUBLE = 2] = "DT_DOUBLE", e[e.DT_INT32 = 3] = "DT_INT32", e[e.DT_UINT8 = 4] = "DT_UINT8", e[e.DT_INT16 = 5] = "DT_INT16", e[e.DT_INT8 = 6] = "DT_INT8", e[e.DT_STRING = 7] = "DT_STRING", e[e.DT_COMPLEX64 = 8] = "DT_COMPLEX64", e[e.DT_INT64 = 9] = "DT_INT64", e[e.DT_BOOL = 10] = "DT_BOOL", e[e.DT_QINT8 = 11] = "DT_QINT8", e[e.DT_QUINT8 = 12] = "DT_QUINT8", e[e.DT_QINT32 = 13] = "DT_QINT32", e[e.DT_BFLOAT16 = 14] = "DT_BFLOAT16", e[e.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", e[e.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", e[e.DT_INT32_REF = 103] = "DT_INT32_REF", e[e.DT_UINT8_REF = 104] = "DT_UINT8_REF", e[e.DT_INT16_REF = 105] = "DT_INT16_REF", e[e.DT_INT8_REF = 106] = "DT_INT8_REF", e[e.DT_STRING_REF = 107] = "DT_STRING_REF", e[e.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", e[e.DT_INT64_REF = 109] = "DT_INT64_REF", e[e.DT_BOOL_REF = 110] = "DT_BOOL_REF", e[e.DT_QINT8_REF = 111] = "DT_QINT8_REF", e[e.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", e[e.DT_QINT32_REF = 113] = "DT_QINT32_REF", e[e.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF";
}(DataType || (DataType = {
})), (function(e5) {
    !function(e) {
        e[e.LEGACY = 0] = "LEGACY", e[e.V1 = 1] = "V1", e[e.V2 = 2] = "V2";
    }(e5.CheckpointFormatVersion || (e5.CheckpointFormatVersion = {
    }));
})(SaverDef || (SaverDef = {
}));
var CUSTOM_OPS = {
};
function registerOp(e, t) {
    var a = {
        tfOpName: e,
        category: "custom",
        inputs: [],
        attrs: [],
        customExecutor: t
    };
    CUSTOM_OPS[e] = a;
}
function getRegisteredOp(e) {
    return CUSTOM_OPS[e];
}
function deregisterOp(e) {
    delete CUSTOM_OPS[e];
}
function getParamValue(e6, t, a, r) {
    var n = t.inputParams[e6];
    if (n && void 0 !== n.inputIndexStart) {
        var s = n.inputIndexStart, o = 0 === n.inputIndexEnd ? void 0 : void 0 === n.inputIndexEnd ? s + 1 : n.inputIndexEnd;
        if ("tensor" === n.type) return getTensor(t.inputNames[n.inputIndexStart], a, r);
        if ("tensors" === n.type) return t.inputNames.slice(s, o).map(function(e) {
            return getTensor(e, a, r);
        });
        var p = Array.prototype.slice.call(getTensor(t.inputNames.slice(s)[0], a, r).dataSync());
        return "number" === n.type ? p[0] : p;
    }
    var u = t.attrParams[e6];
    return u && u.value;
}
function getTensor(e, t, a) {
    var r = parseNodeName(e), n = r[0], s = r[1], o = a.currentContextIds.find(function(e) {
        return !!t[getNodeNameWithContextId(n, e)];
    });
    return void 0 !== o ? t[getNodeNameWithContextId(n, o)][s] : void 0;
}
function getTensorsForCurrentContenxt(e, t, a) {
    return t[getNodeNameWithContextId(e, a.currentContextId)];
}
function getNodeNameAndIndex(e, t) {
    var a = parseNodeName(e), r = a[0], n = a[1];
    return [
        getNodeNameWithContextId(r, t && t.currentContextId),
        n
    ];
}
function getNodeNameWithContextId(e, t) {
    return t ? e + "-" + t : e;
}
function parseNodeName(e) {
    var t = e.lastIndexOf(":");
    return -1 === t ? [
        e,
        0
    ] : [
        e.substring(0, t),
        Number(e.substring(t + 1))
    ];
}
function split$1(e, t) {
    for(var a = [], r = 0; r < e.length; r += t)a.push(e.slice(r, r + t));
    return a;
}
var json = [
    {
        tfOpName: "Add",
        category: "arithmetic",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "AddV2",
        category: "arithmetic",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "AddN",
        category: "arithmetic",
        inputs: [
            {
                start: 0,
                end: 0,
                name: "tensors",
                type: "tensors"
            }
        ]
    },
    {
        tfOpName: "BiasAdd",
        category: "arithmetic",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Sub",
        category: "arithmetic",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "RealDiv",
        category: "arithmetic",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Div",
        category: "arithmetic",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "DivNoNan",
        category: "arithmetic",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "FloorDiv",
        category: "arithmetic",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Mul",
        category: "arithmetic",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Maximum",
        category: "arithmetic",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ]
    },
    {
        tfOpName: "Minimum",
        category: "arithmetic",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ]
    },
    {
        tfOpName: "Pow",
        category: "arithmetic",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "SquaredDifference",
        category: "arithmetic",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Mod",
        category: "arithmetic",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "FloorMod",
        category: "arithmetic",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    }
], arithmetic = Object.freeze({
    json: json
}), json$1 = [
    {
        tfOpName: "Abs",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Acos",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Asin",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Atan",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Atan2",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "y",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Ceil",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "ClipByValue",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "clip_value_min",
                name: "clipValueMin",
                type: "number"
            },
            {
                tfName: "clip_value_max",
                name: "clipValueMax",
                type: "number"
            }
        ]
    },
    {
        tfOpName: "Complex",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "real",
                type: "tensor"
            },
            {
                start: 1,
                name: "imag",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "ComplexAbs",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Cos",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Cosh",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Elu",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Exp",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Floor",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Log",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Imag",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            },
            {
                tfName: "Tout",
                name: "outputType",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Neg",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Real",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            },
            {
                tfName: "Tout",
                name: "outputType",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Prelu",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "alpha",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Relu",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Relu6",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            },
            {
                tfName: "clipValueMin",
                name: "clipValueMin",
                type: "number",
                defaultValue: 0
            },
            {
                tfName: "clipValueMax",
                name: "clipValueMax",
                type: "number",
                defaultValue: 6
            }
        ]
    },
    {
        tfOpName: "Selu",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Sigmoid",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Sin",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Sinh",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Sqrt",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Rsqrt",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Square",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Tan",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Tanh",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Sign",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Round",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Expm1",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Log1p",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Reciprocal",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Softplus",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Asinh",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Acosh",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Atanh",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Erf",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Prod",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "axes",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "keep_dims",
                name: "keepDims",
                type: "bool",
                notSupported: !0
            },
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "LeakyRelu",
        category: "basic_math",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "alpha",
                name: "alpha",
                type: "number",
                defaultValue: 0.2
            },
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    }
], basicMath = Object.freeze({
    json: json$1
}), json$2 = [
    {
        tfOpName: "LoopCond",
        category: "control",
        inputs: [
            {
                start: 0,
                name: "pred",
                type: "tensor"
            }
        ]
    },
    {
        tfOpName: "Switch",
        category: "control",
        inputs: [
            {
                start: 0,
                name: "data",
                type: "tensor"
            },
            {
                start: 1,
                name: "pred",
                type: "tensor"
            }
        ]
    },
    {
        tfOpName: "Merge",
        category: "control",
        inputs: [
            {
                start: 0,
                end: 0,
                name: "tensors",
                type: "tensors"
            }
        ]
    },
    {
        tfOpName: "Enter",
        category: "control",
        inputs: [
            {
                start: 0,
                name: "tensor",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            },
            {
                tfName: "frame_name",
                name: "frameName",
                type: "string"
            },
            {
                tfName: "is_constant",
                name: "isConstant",
                type: "bool"
            }
        ]
    },
    {
        tfOpName: "Exit",
        category: "control",
        inputs: [
            {
                start: 0,
                name: "tensor",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "NextIteration",
        category: "control",
        inputs: [
            {
                start: 0,
                name: "tensor",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "TensorArrayV3",
        category: "control",
        inputs: [
            {
                start: 0,
                name: "size",
                type: "number"
            }
        ],
        attrs: [
            {
                tfName: "dtype",
                name: "dtype",
                type: "dtype"
            },
            {
                tfName: "element_shape",
                name: "elementShape",
                type: "shape"
            },
            {
                tfName: "dynamic_size",
                name: "dynamicSize",
                type: "bool"
            },
            {
                tfName: "clear_after_read",
                name: "clearAfterRead",
                type: "bool"
            },
            {
                tfName: "identical_element_shapes",
                name: "identicalElementShapes",
                type: "bool"
            },
            {
                tfName: "tensor_array_name",
                name: "name",
                type: "string"
            }
        ]
    },
    {
        tfOpName: "TensorArrayWriteV3",
        category: "control",
        inputs: [
            {
                start: 0,
                name: "tensorArrayId",
                type: "number"
            },
            {
                start: 1,
                name: "index",
                type: "number"
            },
            {
                start: 2,
                name: "tensor",
                type: "tensor"
            },
            {
                start: 3,
                name: "flowIn",
                type: "number"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "TensorArrayReadV3",
        category: "control",
        inputs: [
            {
                start: 0,
                name: "tensorArrayId",
                type: "number"
            },
            {
                start: 1,
                name: "index",
                type: "number"
            },
            {
                start: 2,
                name: "flowIn",
                type: "number"
            }
        ],
        attrs: [
            {
                tfName: "dtype",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "TensorArrayGatherV3",
        category: "control",
        inputs: [
            {
                start: 0,
                name: "tensorArrayId",
                type: "number"
            },
            {
                start: 1,
                name: "indices",
                type: "number[]"
            },
            {
                start: 2,
                name: "flowIn",
                type: "number"
            }
        ],
        attrs: [
            {
                tfName: "dtype",
                name: "dtype",
                type: "dtype"
            },
            {
                tfName: "element_shape",
                name: "elementShape",
                type: "shape"
            }
        ]
    },
    {
        tfOpName: "TensorArrayScatterV3",
        category: "control",
        inputs: [
            {
                start: 0,
                name: "tensorArrayId",
                type: "number"
            },
            {
                start: 1,
                name: "indices",
                type: "number[]"
            },
            {
                start: 2,
                name: "tensor",
                type: "tensor"
            },
            {
                start: 3,
                name: "flowIn",
                type: "number"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype"
            }
        ]
    },
    {
        tfOpName: "TensorArrayConcatV3",
        category: "control",
        inputs: [
            {
                start: 0,
                name: "tensorArrayId",
                type: "number"
            },
            {
                start: 1,
                name: "flowIn",
                type: "number"
            }
        ],
        attrs: [
            {
                tfName: "dtype",
                name: "dtype",
                type: "dtype"
            },
            {
                tfName: "element_shape_except0",
                name: "elementShapeExcept0",
                type: "shape",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "TensorArraySplitV3",
        category: "control",
        inputs: [
            {
                start: 0,
                name: "tensorArrayId",
                type: "number"
            },
            {
                start: 1,
                name: "tensor",
                type: "tensor"
            },
            {
                start: 2,
                name: "lengths",
                type: "number[]"
            },
            {
                start: 3,
                name: "flowIn",
                type: "number"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype"
            }
        ]
    },
    {
        tfOpName: "TensorArraySizeV3",
        category: "control",
        inputs: [
            {
                start: 0,
                name: "tensorArrayId",
                type: "number"
            },
            {
                start: 1,
                name: "flowIn",
                type: "number"
            }
        ]
    },
    {
        tfOpName: "TensorArrayCloseV3",
        category: "control",
        inputs: [
            {
                start: 0,
                name: "tensorArrayId",
                type: "number"
            }
        ]
    }
], control = Object.freeze({
    json: json$2
}), json$3 = [
    {
        tfOpName: "AvgPool",
        category: "convolution",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "strides",
                name: "strides",
                type: "number[]"
            },
            {
                tfName: "padding",
                name: "pad",
                type: "string"
            },
            {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                notSupported: !0
            },
            {
                tfName: "ksize",
                name: "kernelSize",
                type: "number[]"
            },
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "MaxPool",
        category: "convolution",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "strides",
                name: "strides",
                type: "number[]"
            },
            {
                tfName: "padding",
                name: "pad",
                type: "string"
            },
            {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                notSupported: !0
            },
            {
                tfName: "ksize",
                name: "kernelSize",
                type: "number[]"
            },
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "MaxPoolWithArgmax",
        category: "convolution",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "strides",
                name: "strides",
                type: "number[]"
            },
            {
                tfName: "padding",
                name: "pad",
                type: "string"
            },
            {
                tfName: "ksize",
                name: "kernelSize",
                type: "number[]"
            },
            {
                tfName: "include_batch_in_index",
                name: "includeBatchInIndex",
                type: "bool"
            },
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "AvgPool3D",
        category: "convolution",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "strides",
                name: "strides",
                type: "number[]"
            },
            {
                tfName: "padding",
                name: "pad",
                type: "string"
            },
            {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                notSupported: !0
            },
            {
                tfName: "ksize",
                name: "kernelSize",
                type: "number[]"
            },
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "MaxPool3D",
        category: "convolution",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "strides",
                name: "strides",
                type: "number[]"
            },
            {
                tfName: "padding",
                name: "pad",
                type: "string"
            },
            {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                notSupported: !0
            },
            {
                tfName: "ksize",
                name: "kernelSize",
                type: "number[]"
            },
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Conv1D",
        category: "convolution",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "filter",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "stride",
                name: "stride",
                type: "number"
            },
            {
                tfName: "padding",
                name: "pad",
                type: "string"
            },
            {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                defaultValue: "NWC"
            },
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            },
            {
                tfName: "dilation",
                name: "dilation",
                type: "number",
                defaultValue: 1
            }
        ]
    },
    {
        tfOpName: "Conv2D",
        category: "convolution",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "filter",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            },
            {
                tfName: "strides",
                name: "strides",
                type: "number[]"
            },
            {
                tfName: "padding",
                name: "pad",
                type: "string"
            },
            {
                tfName: "useCudnnOnGpu",
                name: "useCudnnOnGpu",
                type: "bool"
            },
            {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                defaultValue: "NHWC"
            },
            {
                tfName: "dilations",
                name: "dilations",
                type: "number[]"
            }
        ]
    },
    {
        tfOpName: "_FusedConv2D",
        category: "convolution",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "filter",
                type: "tensor"
            },
            {
                start: 2,
                end: 0,
                name: "args",
                type: "tensors"
            }
        ],
        attrs: [
            {
                tfName: "num_args",
                name: "numArgs",
                type: "number"
            },
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            },
            {
                tfName: "strides",
                name: "strides",
                type: "number[]"
            },
            {
                tfName: "padding",
                name: "pad",
                type: "string"
            },
            {
                tfName: "explicit_paddings",
                name: "explicitPaddings",
                type: "number[]",
                defaultValue: []
            },
            {
                tfName: "use_cudnn_on_gpu",
                name: "useCudnnOnGpu",
                type: "bool",
                defaultValue: !0
            },
            {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                defaultValue: "NHWC"
            },
            {
                tfName: "dilations",
                name: "dilations",
                type: "number[]",
                defaultValue: [
                    1,
                    1,
                    1,
                    1
                ]
            },
            {
                tfName: "fused_ops",
                name: "fusedOps",
                type: "string[]",
                defaultValue: []
            },
            {
                tfName: "epsilon",
                name: "epsilon",
                type: "number",
                defaultValue: 0.0001
            }
        ]
    },
    {
        tfOpName: "Conv2DBackpropInput",
        category: "convolution",
        inputs: [
            {
                start: 2,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "filter",
                type: "tensor"
            },
            {
                start: 0,
                name: "outputShape",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "strides",
                name: "strides",
                type: "number[]"
            },
            {
                tfName: "padding",
                name: "pad",
                type: "string"
            },
            {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "DepthwiseConv2d",
        category: "convolution",
        inputs: [
            {
                start: 0,
                name: "input",
                type: "tensor"
            },
            {
                start: 1,
                name: "filter",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "strides",
                name: "strides",
                type: "number[]"
            },
            {
                tfName: "padding",
                name: "pad",
                type: "string"
            },
            {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                defaultValue: "NHWC"
            },
            {
                tfName: "dilations",
                name: "dilations",
                type: "number[]"
            }
        ]
    },
    {
        tfOpName: "DepthwiseConv2dNative",
        category: "convolution",
        inputs: [
            {
                start: 0,
                name: "input",
                type: "tensor"
            },
            {
                start: 1,
                name: "filter",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "strides",
                name: "strides",
                type: "number[]"
            },
            {
                tfName: "padding",
                name: "pad",
                type: "string"
            },
            {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                defaultValue: "NHWC"
            },
            {
                tfName: "dilations",
                name: "dilations",
                type: "number[]"
            }
        ]
    },
    {
        tfOpName: "FusedDepthwiseConv2dNative",
        category: "convolution",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "filter",
                type: "tensor"
            },
            {
                start: 2,
                end: 0,
                name: "args",
                type: "tensors"
            }
        ],
        attrs: [
            {
                tfName: "num_args",
                name: "numArgs",
                type: "number"
            },
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            },
            {
                tfName: "strides",
                name: "strides",
                type: "number[]"
            },
            {
                tfName: "padding",
                name: "pad",
                type: "string"
            },
            {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                defaultValue: "NHWC"
            },
            {
                tfName: "dilations",
                name: "dilations",
                type: "number[]",
                defaultValue: [
                    1,
                    1,
                    1,
                    1
                ]
            },
            {
                tfName: "fused_ops",
                name: "fusedOps",
                type: "string[]",
                defaultValue: []
            }
        ]
    },
    {
        tfOpName: "Conv3D",
        category: "convolution",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "filter",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "strides",
                name: "strides",
                type: "number[]"
            },
            {
                tfName: "padding",
                name: "pad",
                type: "string"
            },
            {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                defaultValue: "NHWC"
            },
            {
                tfName: "dilations",
                name: "dilations",
                type: "number[]"
            }
        ]
    }
], convolution = Object.freeze({
    json: json$3
}), json$4 = [
    {
        tfOpName: "Fill",
        category: "creation",
        inputs: [
            {
                start: 0,
                name: "shape",
                type: "number[]"
            },
            {
                start: 1,
                name: "value",
                type: "number"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype"
            }
        ]
    },
    {
        tfOpName: "LinSpace",
        category: "creation",
        inputs: [
            {
                start: 0,
                name: "start",
                type: "number"
            },
            {
                start: 1,
                name: "stop",
                type: "number"
            },
            {
                start: 2,
                name: "num",
                type: "number"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "OneHot",
        category: "creation",
        inputs: [
            {
                start: 0,
                name: "indices",
                type: "tensor"
            },
            {
                start: 1,
                name: "depth",
                type: "number"
            },
            {
                start: 2,
                name: "onValue",
                type: "number",
                defaultValue: 1
            },
            {
                start: 3,
                name: "offValue",
                type: "number",
                defaultValue: 0
            }
        ],
        attrs: [
            {
                tfName: "axis",
                name: "axis",
                type: "number",
                notSupported: !0
            },
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Ones",
        category: "creation",
        inputs: [
            {
                start: 0,
                name: "shape",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype"
            }
        ]
    },
    {
        tfOpName: "OnesLike",
        category: "creation",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "dtype",
                name: "dtype",
                type: "dtype"
            }
        ]
    },
    {
        tfOpName: "RandomUniform",
        category: "creation",
        inputs: [
            {
                start: 0,
                name: "shape",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "minval",
                name: "minval",
                type: "number",
                defaultValue: 0
            },
            {
                tfName: "maxval",
                name: "maxval",
                type: "number",
                defaultValue: 1
            },
            {
                tfName: "dtype",
                name: "dtype",
                type: "dtype"
            },
            {
                tfName: "seed",
                name: "seed",
                type: "number",
                defaultValue: 0
            },
            {
                tfName: "seed2",
                name: "seed2",
                type: "number",
                defaultValue: 0,
                notSupported: !0
            },
            {
                tfName: "T",
                name: "T",
                type: "number",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Range",
        category: "creation",
        inputs: [
            {
                start: 0,
                name: "start",
                type: "number"
            },
            {
                start: 1,
                name: "stop",
                type: "number"
            },
            {
                start: 2,
                name: "step",
                type: "number",
                defaultValue: 0
            }
        ],
        attrs: [
            {
                tfName: "Tidx",
                name: "dtype",
                type: "dtype"
            }
        ]
    },
    {
        tfOpName: "TruncatedNormal",
        category: "creation",
        inputs: [
            {
                start: 0,
                name: "shape",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "means",
                name: "mean",
                type: "number",
                defaultValue: 0
            },
            {
                tfName: "stddev",
                name: "stdDev",
                type: "number",
                defaultValue: 1
            },
            {
                tfName: "seed",
                name: "seed",
                type: "number"
            },
            {
                tfName: "seed2",
                name: "seed2",
                type: "number",
                defaultValue: 0,
                notSupported: !0
            },
            {
                tfName: "dtype",
                name: "dtype",
                type: "dtype"
            },
            {
                tfName: "T",
                name: "T",
                type: "number",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Zeros",
        category: "creation",
        inputs: [
            {
                start: 0,
                name: "shape",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype"
            }
        ]
    },
    {
        tfOpName: "ZerosLike",
        category: "creation",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype"
            }
        ]
    },
    {
        tfOpName: "Multinomial",
        category: "creation",
        inputs: [
            {
                start: 0,
                name: "logits",
                type: "tensor"
            },
            {
                start: 1,
                name: "numSamples",
                type: "number"
            }
        ],
        attrs: [
            {
                tfName: "seed",
                name: "seed",
                type: "number"
            },
            {
                tfName: "seed2",
                name: "seed2",
                type: "number"
            },
            {
                tfName: "T",
                name: "dtype",
                type: "dtype"
            },
            {
                tfName: "output_dtype",
                name: "output_dtype",
                type: "dtype"
            }
        ]
    }
], creation = Object.freeze({
    json: json$4
}), json$5 = [
    {
        tfOpName: "NonMaxSuppressionV2",
        category: "dynamic",
        inputs: [
            {
                start: 0,
                name: "boxes",
                type: "tensor"
            },
            {
                start: 1,
                name: "scores",
                type: "tensor"
            },
            {
                start: 2,
                name: "maxOutputSize",
                type: "number"
            },
            {
                start: 3,
                name: "iouThreshold",
                type: "number"
            }
        ]
    },
    {
        tfOpName: "NonMaxSuppressionV3",
        category: "dynamic",
        inputs: [
            {
                start: 0,
                name: "boxes",
                type: "tensor"
            },
            {
                start: 1,
                name: "scores",
                type: "tensor"
            },
            {
                start: 2,
                name: "maxOutputSize",
                type: "number"
            },
            {
                start: 3,
                name: "iouThreshold",
                type: "number"
            },
            {
                start: 4,
                name: "scoreThreshold",
                type: "number"
            }
        ]
    },
    {
        tfOpName: "NonMaxSuppressionV5",
        category: "dynamic",
        inputs: [
            {
                start: 0,
                name: "boxes",
                type: "tensor"
            },
            {
                start: 1,
                name: "scores",
                type: "tensor"
            },
            {
                start: 2,
                name: "maxOutputSize",
                type: "number"
            },
            {
                start: 3,
                name: "iouThreshold",
                type: "number"
            },
            {
                start: 4,
                name: "scoreThreshold",
                type: "number"
            },
            {
                start: 5,
                name: "softNmsSigma",
                type: "number"
            }
        ]
    },
    {
        tfOpName: "Where",
        category: "dynamic",
        inputs: [
            {
                start: 0,
                name: "condition",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "ListDiff",
        category: "dynamic",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "y",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    }
], dynamic = Object.freeze({
    json: json$5
}), json$6 = [
    {
        tfOpName: "TopKV2",
        category: "evaluation",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "k",
                type: "number"
            }
        ],
        attrs: [
            {
                tfName: "sorted",
                name: "sorted",
                type: "bool"
            }
        ]
    }
], evaluation = Object.freeze({
    json: json$6
}), json$7 = [
    {
        tfOpName: "PlaceholderWithDefault",
        category: "graph",
        inputs: [
            {
                start: 0,
                name: "default",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "shape",
                name: "shape",
                type: "shape"
            },
            {
                tfName: "dtype",
                name: "dtype",
                type: "dtype"
            }
        ]
    },
    {
        tfOpName: "Placeholder",
        category: "graph",
        attrs: [
            {
                tfName: "shape",
                name: "shape",
                type: "shape"
            },
            {
                tfName: "dtype",
                name: "dtype",
                type: "dtype"
            }
        ]
    },
    {
        tfOpName: "Const",
        category: "graph"
    },
    {
        tfOpName: "Identity",
        category: "graph",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ]
    },
    {
        tfOpName: "IdentityN",
        category: "graph",
        inputs: [
            {
                start: 0,
                end: 0,
                name: "x",
                type: "tensors"
            }
        ]
    },
    {
        tfOpName: "Snapshot",
        category: "graph",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ]
    },
    {
        tfOpName: "Rank",
        category: "graph",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ]
    },
    {
        tfOpName: "Size",
        category: "graph",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ]
    },
    {
        tfOpName: "Shape",
        category: "graph",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ]
    },
    {
        tfOpName: "ShapeN",
        category: "graph",
        inputs: [
            {
                start: 0,
                end: 0,
                name: "x",
                type: "tensors"
            }
        ]
    },
    {
        tfOpName: "Print",
        category: "graph",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "data",
                type: "tensors"
            }
        ],
        attrs: [
            {
                tfName: "message",
                name: "message",
                type: "string"
            },
            {
                tfName: "first_n",
                name: "firstN",
                type: "number",
                notSupported: !0
            },
            {
                tfName: "summarize",
                name: "summarize",
                type: "number",
                defaultValue: 3
            }
        ]
    },
    {
        tfOpName: "NoOp",
        category: "graph",
        inputs: []
    },
    {
        tfOpName: "StopGradient",
        category: "graph",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ]
    },
    {
        tfOpName: "FakeQuantWithMinMaxVars",
        category: "graph",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "min",
                name: "min",
                type: "number"
            },
            {
                tfName: "max",
                name: "max",
                type: "number"
            }
        ]
    }
], graph = Object.freeze({
    json: json$7
}), json$8 = [
    {
        tfOpName: "ResizeBilinear",
        category: "image",
        inputs: [
            {
                start: 0,
                name: "images",
                type: "tensor"
            },
            {
                start: 1,
                name: "size",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "align_corners",
                name: "alignCorners",
                type: "bool"
            },
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "ResizeNearestNeighbor",
        category: "image",
        inputs: [
            {
                start: 0,
                name: "images",
                type: "tensor"
            },
            {
                start: 1,
                name: "size",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "align_corners",
                name: "alignCorners",
                type: "bool"
            },
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "CropAndResize",
        category: "image",
        inputs: [
            {
                start: 0,
                name: "image",
                type: "tensor"
            },
            {
                start: 1,
                name: "boxes",
                type: "tensor"
            },
            {
                start: 2,
                name: "boxInd",
                type: "tensor"
            },
            {
                start: 3,
                name: "cropSize",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "method",
                name: "method",
                type: "string"
            },
            {
                tfName: "extrapolation_value",
                name: "extrapolationValue",
                type: "number"
            }
        ]
    }
], image$1 = Object.freeze({
    json: json$8
}), json$9 = [
    {
        tfOpName: "Equal",
        category: "logical",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "NotEqual",
        category: "logical",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Greater",
        category: "logical",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "GreaterEqual",
        category: "logical",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Less",
        category: "logical",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "LessEqual",
        category: "logical",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "LogicalAnd",
        category: "logical",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "LogicalNot",
        category: "logical",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "LogicalOr",
        category: "logical",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Select",
        category: "logical",
        inputs: [
            {
                start: 0,
                name: "condition",
                type: "tensor"
            },
            {
                start: 1,
                name: "a",
                type: "tensor"
            },
            {
                start: 2,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "SelectV2",
        category: "logical",
        inputs: [
            {
                start: 0,
                name: "condition",
                type: "tensor"
            },
            {
                start: 1,
                name: "a",
                type: "tensor"
            },
            {
                start: 2,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    }
], logical = Object.freeze({
    json: json$9
}), json$10 = [
    {
        tfOpName: "_FusedMatMul",
        category: "matrices",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            },
            {
                start: 2,
                end: 0,
                name: "args",
                type: "tensors"
            }
        ],
        attrs: [
            {
                tfName: "num_args",
                name: "numArgs",
                type: "number"
            },
            {
                tfName: "fused_ops",
                name: "fusedOps",
                type: "string[]",
                defaultValue: []
            },
            {
                tfName: "epsilon",
                name: "epsilon",
                type: "number",
                defaultValue: 0.0001
            },
            {
                tfName: "transpose_a",
                name: "transposeA",
                type: "bool",
                defaultValue: !1
            },
            {
                tfName: "transpose_b",
                name: "transposeB",
                type: "bool",
                defaultValue: !1
            },
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "MatMul",
        category: "matrices",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "transpose_a",
                name: "transposeA",
                type: "bool",
                defaultValue: !1
            },
            {
                tfName: "transpose_b",
                name: "transposeB",
                type: "bool",
                defaultValue: !1
            },
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "BatchMatMul",
        category: "matrices",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "adj_x",
                name: "transposeA",
                type: "bool",
                defaultValue: !1
            },
            {
                tfName: "adj_y",
                name: "transposeB",
                type: "bool",
                defaultValue: !1
            },
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "BatchMatMulV2",
        category: "matrices",
        inputs: [
            {
                start: 0,
                name: "a",
                type: "tensor"
            },
            {
                start: 1,
                name: "b",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "adj_x",
                name: "transposeA",
                type: "bool",
                defaultValue: !1
            },
            {
                tfName: "adj_y",
                name: "transposeB",
                type: "bool",
                defaultValue: !1
            },
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Transpose",
        category: "matrices",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "perm",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "T",
                name: "dtype",
                type: "dtype",
                notSupported: !0
            }
        ]
    }
], matrices = Object.freeze({
    json: json$10
}), json$11 = [
    {
        tfOpName: "FusedBatchNorm",
        category: "normalization",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "scale",
                type: "tensor"
            },
            {
                start: 2,
                name: "offset",
                type: "tensor"
            },
            {
                start: 3,
                name: "mean",
                type: "tensor"
            },
            {
                start: 4,
                name: "variance",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "epsilon",
                name: "epsilon",
                type: "number",
                defaultValue: 0.001
            },
            {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "FusedBatchNormV2",
        category: "normalization",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "scale",
                type: "tensor"
            },
            {
                start: 2,
                name: "offset",
                type: "tensor"
            },
            {
                start: 3,
                name: "mean",
                type: "tensor"
            },
            {
                start: 4,
                name: "variance",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "epsilon",
                name: "epsilon",
                type: "number",
                defaultValue: 0.001
            },
            {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "FusedBatchNormV3",
        category: "normalization",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "scale",
                type: "tensor"
            },
            {
                start: 2,
                name: "offset",
                type: "tensor"
            },
            {
                start: 3,
                name: "mean",
                type: "tensor"
            },
            {
                start: 4,
                name: "variance",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "epsilon",
                name: "epsilon",
                type: "number",
                defaultValue: 0.001
            },
            {
                tfName: "data_format",
                name: "dataFormat",
                type: "string",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "LRN",
        category: "normalization",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "depth_radius",
                name: "radius",
                type: "number",
                defaultValue: 5
            },
            {
                tfName: "bias",
                name: "bias",
                type: "number",
                defaultValue: 1
            },
            {
                tfName: "alpha",
                name: "alpha",
                type: "number",
                defaultValue: 1
            },
            {
                tfName: "beta",
                name: "beta",
                type: "number",
                defaultValue: 0.5
            }
        ]
    },
    {
        tfOpName: "Softmax",
        category: "normalization",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ]
    },
    {
        tfOpName: "LogSoftmax",
        category: "normalization",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ]
    },
    {
        tfOpName: "SparseToDense",
        category: "normalization",
        inputs: [
            {
                start: 0,
                name: "sparseIndices",
                type: "tensor"
            },
            {
                start: 1,
                name: "outputShape",
                type: "number[]"
            },
            {
                start: 2,
                name: "sparseValues",
                type: "tensor"
            },
            {
                start: 3,
                name: "defaultValue",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "validate_indices",
                name: "validateIndices",
                type: "bool",
                defaultValue: !0,
                notSupported: !0
            }
        ]
    }
], normalization = Object.freeze({
    json: json$11
}), json$12 = [
    {
        tfOpName: "Max",
        category: "reduction",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "axis",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "keep_dims",
                name: "keepDims",
                type: "bool"
            }
        ]
    },
    {
        tfOpName: "Mean",
        category: "reduction",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "axis",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "keep_dims",
                name: "keepDims",
                type: "bool"
            }
        ]
    },
    {
        tfOpName: "Min",
        category: "reduction",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "axis",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "keep_dims",
                name: "keepDims",
                type: "bool"
            }
        ]
    },
    {
        tfOpName: "Sum",
        category: "reduction",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "axis",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "keep_dims",
                name: "keepDims",
                type: "bool"
            }
        ]
    },
    {
        tfOpName: "All",
        category: "reduction",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "axis",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "keep_dims",
                name: "keepDims",
                type: "bool"
            }
        ]
    },
    {
        tfOpName: "Any",
        category: "reduction",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "axis",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "keep_dims",
                name: "keepDims",
                type: "bool"
            }
        ]
    },
    {
        tfOpName: "ArgMax",
        category: "reduction",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "axis",
                type: "number"
            }
        ]
    },
    {
        tfOpName: "ArgMin",
        category: "reduction",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "axis",
                type: "number"
            }
        ]
    },
    {
        tfOpName: "Prod",
        category: "reduction",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "axis",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "keep_dims",
                name: "keepDims",
                type: "bool"
            }
        ]
    }
], reduction = Object.freeze({
    json: json$12
}), json$13 = [
    {
        tfOpName: "ConcatV2",
        category: "slice_join",
        inputs: [
            {
                start: 0,
                end: -1,
                name: "tensors",
                type: "tensors"
            },
            {
                start: -1,
                name: "axis",
                type: "number"
            }
        ],
        attrs: [
            {
                tfName: "N",
                name: "n",
                type: "number",
                defaultValue: 2
            }
        ]
    },
    {
        tfOpName: "Concat",
        category: "slice_join",
        inputs: [
            {
                start: 1,
                end: 0,
                name: "tensors",
                type: "tensors"
            },
            {
                start: 0,
                name: "axis",
                type: "number"
            }
        ],
        attrs: [
            {
                tfName: "N",
                name: "n",
                type: "number",
                defaultValue: 2
            }
        ]
    },
    {
        tfOpName: "GatherV2",
        category: "slice_join",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "indices",
                type: "tensor"
            },
            {
                start: 2,
                name: "axis",
                type: "number",
                defaultValue: 0
            }
        ]
    },
    {
        tfOpName: "Gather",
        category: "slice_join",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "indices",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "axis",
                name: "axis",
                type: "number",
                defaultValue: 0
            },
            {
                tfName: "validate_indices",
                name: "validateIndices",
                type: "bool",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Reverse",
        category: "slice_join",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "dims",
                type: "bool",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "ReverseV2",
        category: "slice_join",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "axis",
                type: "number[]"
            }
        ]
    },
    {
        tfOpName: "Slice",
        category: "slice_join",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "begin",
                type: "number[]"
            },
            {
                start: 2,
                name: "size",
                type: "number[]"
            }
        ]
    },
    {
        tfOpName: "StridedSlice",
        category: "slice_join",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "begin",
                type: "number[]"
            },
            {
                start: 2,
                name: "end",
                type: "number[]"
            },
            {
                start: 3,
                name: "strides",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "begin_mask",
                name: "beginMask",
                type: "number",
                defaultValue: 0
            },
            {
                tfName: "end_mask",
                name: "endMask",
                type: "number",
                defaultValue: 0
            },
            {
                tfName: "new_axis_mask",
                name: "newAxisMask",
                type: "number",
                defaultValue: 0
            },
            {
                tfName: "ellipsis_mask",
                name: "ellipsisMask",
                type: "number",
                defaultValue: 0
            },
            {
                tfName: "shrink_axis_mask",
                name: "shrinkAxisMask",
                type: "number",
                defaultValue: 0
            }
        ]
    },
    {
        tfOpName: "Pack",
        category: "slice_join",
        inputs: [
            {
                start: 0,
                end: 0,
                name: "tensors",
                type: "tensors"
            }
        ],
        attrs: [
            {
                tfName: "axis",
                name: "axis",
                type: "number",
                defaultValue: 0
            }
        ]
    },
    {
        tfOpName: "Unpack",
        category: "slice_join",
        inputs: [
            {
                start: 0,
                name: "tensor",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "axis",
                name: "axis",
                type: "number",
                defaultValue: 0
            },
            {
                tfName: "num",
                name: "num",
                type: "number",
                defaultValue: 0,
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "Tile",
        category: "slice_join",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "reps",
                type: "number[]"
            }
        ]
    },
    {
        tfOpName: "Split",
        category: "slice_join",
        inputs: [
            {
                start: 0,
                name: "axis",
                type: "number",
                defaultValue: 0
            },
            {
                start: 1,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "num_split",
                name: "numOrSizeSplits",
                type: "number",
                defaultValue: 1
            }
        ]
    },
    {
        tfOpName: "SplitV",
        category: "slice_join",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "numOrSizeSplits",
                type: "number[]"
            },
            {
                start: 2,
                name: "axis",
                type: "number",
                defaultValue: 0
            }
        ]
    },
    {
        tfOpName: "ScatterNd",
        category: "slice_join",
        inputs: [
            {
                start: 0,
                name: "indices",
                type: "tensor"
            },
            {
                start: 1,
                name: "values",
                type: "tensor"
            },
            {
                start: 2,
                name: "shape",
                type: "number[]"
            }
        ]
    },
    {
        tfOpName: "GatherNd",
        category: "slice_join",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "indices",
                type: "tensor"
            }
        ]
    },
    {
        tfOpName: "SparseToDense",
        category: "slice_join",
        inputs: [
            {
                start: 0,
                name: "sparseIndices",
                type: "tensor"
            },
            {
                start: 1,
                name: "outputShape",
                type: "number[]"
            },
            {
                start: 2,
                name: "sparseValues",
                type: "tensor"
            },
            {
                start: 3,
                name: "defaultValue",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "validate_indices",
                name: "validateIndices",
                type: "bool",
                defaultValue: !1,
                notSupported: !0
            }
        ]
    }
], sliceJoin = Object.freeze({
    json: json$13
}), json$14 = [
    {
        tfOpName: "FFT",
        category: "spectral",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ]
    },
    {
        tfOpName: "IFFT",
        category: "spectral",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ]
    },
    {
        tfOpName: "RFFT",
        category: "spectral",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "fft_length",
                type: "number",
                notSupported: !0
            }
        ]
    },
    {
        tfOpName: "IRFFT",
        category: "spectral",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "fft_length",
                type: "number",
                notSupported: !0
            }
        ]
    }
], spectral = Object.freeze({
    json: json$14
}), json$15 = [
    {
        tfOpName: "Cast",
        category: "transformation",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "SrcT",
                name: "sdtype",
                type: "dtype",
                notSupported: !0
            },
            {
                tfName: "DstT",
                name: "dtype",
                type: "dtype"
            }
        ]
    },
    {
        tfOpName: "ExpandDims",
        category: "transformation",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "axis",
                type: "number"
            }
        ]
    },
    {
        tfOpName: "Pad",
        category: "transformation",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "padding",
                type: "number[]"
            }
        ],
        attrs: [
            {
                tfName: "constant_value",
                name: "constantValue",
                type: "number",
                defaultValue: 0
            }
        ]
    },
    {
        tfOpName: "PadV2",
        category: "transformation",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "padding",
                type: "number[]"
            },
            {
                start: 2,
                name: "constantValue",
                type: "number",
                defaultValue: 0
            }
        ]
    },
    {
        tfOpName: "Reshape",
        category: "transformation",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "shape",
                type: "number[]"
            }
        ]
    },
    {
        tfOpName: "Squeeze",
        category: "transformation",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "axis",
                tfDeprecatedName: "squeeze_dims",
                name: "axis",
                type: "number[]"
            }
        ]
    },
    {
        tfOpName: "SpaceToBatchND",
        category: "transformation",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "blockShape",
                type: "number[]"
            },
            {
                start: 2,
                name: "paddings",
                type: "number[]"
            }
        ]
    },
    {
        tfOpName: "BatchToSpaceND",
        category: "transformation",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            },
            {
                start: 1,
                name: "blockShape",
                type: "number[]"
            },
            {
                start: 2,
                name: "crops",
                type: "number[]"
            }
        ]
    },
    {
        tfOpName: "DepthToSpace",
        category: "transformation",
        inputs: [
            {
                start: 0,
                name: "x",
                type: "tensor"
            }
        ],
        attrs: [
            {
                tfName: "block_size",
                name: "blockSize",
                type: "number"
            },
            {
                tfName: "data_format",
                name: "dataFormat",
                type: "string"
            }
        ]
    }
], transformation = Object.freeze({
    json: json$15
}), OperationMapper = function() {
    function e7() {
        var e8 = [
            arithmetic,
            basicMath,
            control,
            convolution,
            creation,
            dynamic,
            evaluation,
            logical,
            image$1,
            graph,
            matrices,
            normalization,
            reduction,
            sliceJoin,
            spectral,
            transformation
        ], t2 = [].concat.apply([], e8.map(function(e) {
            return e.json;
        }));
        this.opMappers = t2.reduce(function(e, t) {
            return e[t.tfOpName] = t, e;
        }, {
        });
    }
    return Object.defineProperty(e7, "Instance", {
        get: function() {
            return this._instance || (this._instance = new this);
        },
        enumerable: !0,
        configurable: !0
    }), e7.prototype.transformGraph = function(e9, t3) {
        var a1 = this;
        void 0 === t3 && (t3 = {
        });
        var r = [], n = [], s = e9.node.reduce(function(e, t) {
            return e[t.name] = a1.mapNode(t), t.op.startsWith("Placeholder") && r.push(e[t.name]), "Const" === t.op && n.push(e[t.name]), e;
        }, {
        }), o = [], p = [], u = {
        }, i = {
        };
        null != t3 && (u = this.mapSignatureEntries(t3.inputs), i = this.mapSignatureEntries(t3.outputs));
        var m = Object.keys(s);
        return m.forEach(function(e10) {
            var t = s[e10];
            t.inputNames.forEach(function(e) {
                var a = getNodeNameAndIndex(e)[0];
                t.inputs.push(s[a]), s[a].children.push(t);
            });
        }), 0 === Object.keys(i).length ? m.forEach(function(e) {
            var t = s[e];
            0 === t.children.length && p.push(t);
        }) : Object.keys(i).forEach(function(e) {
            var t = getNodeNameAndIndex(e)[0], a = s[t];
            null != a && (a.signatureKey = i[e], p.push(a));
        }), Object.keys(u).length > 0 ? Object.keys(u).forEach(function(e) {
            var t = getNodeNameAndIndex(e)[0], a = s[t];
            a && (a.signatureKey = u[e], o.push(a));
        }) : o = r, {
            nodes: s,
            inputs: o,
            outputs: p,
            weights: n,
            placeholders: r,
            signature: t3
        };
    }, e7.prototype.mapSignatureEntries = function(e) {
        return Object.keys(e || {
        }).reduce(function(t, a) {
            return t[e[a].name] = a, t;
        }, {
        });
    }, e7.prototype.mapNode = function(e11) {
        var t4 = getRegisteredOp(e11.op) || this.opMappers[e11.op] || {
        };
        null == e11.attr && (e11.attr = {
        });
        var a2 = {
            name: e11.name,
            op: e11.op,
            category: t4.category,
            inputNames: (e11.input || []).map(function(e) {
                return e.startsWith("^") ? e.substr(1) : e;
            }),
            inputs: [],
            children: [],
            inputParams: {
            },
            attrParams: {
            },
            rawAttrs: e11.attr
        };
        return null != t4.inputs && (a2.inputParams = t4.inputs.reduce(function(e, t) {
            return e[t.name] = {
                type: t.type,
                inputIndexStart: t.start,
                inputIndexEnd: t.end
            }, e;
        }, {
        })), null != t4.attrs && (a2.attrParams = t4.attrs.reduce(function(t, a) {
            var r = a.type, n = void 0;
            switch(a.type){
                case "string":
                    void 0 === (n = getStringParam(e11.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getStringParam(e11.attr, a.tfDeprecatedName, a.defaultValue));
                    break;
                case "string[]":
                    void 0 === (n = getStringArrayParam(e11.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getStringArrayParam(e11.attr, a.tfDeprecatedName, a.defaultValue));
                    break;
                case "number":
                    void 0 === (n = getNumberParam(e11.attr, a.tfName, a.defaultValue || 0)) && a.tfDeprecatedName && (n = getNumberParam(e11.attr, a.tfDeprecatedName, a.defaultValue));
                    break;
                case "number[]":
                    void 0 === (n = getNumericArrayParam(e11.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getNumericArrayParam(e11.attr, a.tfDeprecatedName, a.defaultValue));
                    break;
                case "bool":
                    void 0 === (n = getBoolParam(e11.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getBoolParam(e11.attr, a.tfDeprecatedName, a.defaultValue));
                    break;
                case "bool[]":
                    void 0 === (n = getBoolArrayParam(e11.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getBoolArrayParam(e11.attr, a.tfDeprecatedName, a.defaultValue));
                    break;
                case "shape":
                    void 0 === (n = getTensorShapeParam(e11.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getTensorShapeParam(e11.attr, a.tfDeprecatedName, a.defaultValue));
                    break;
                case "shape[]":
                    void 0 === (n = getTensorShapeArrayParam(e11.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getTensorShapeArrayParam(e11.attr, a.tfDeprecatedName, a.defaultValue));
                    break;
                case "dtype":
                    void 0 === (n = getDtypeParam(e11.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getDtypeParam(e11.attr, a.tfDeprecatedName, a.defaultValue));
                    break;
                case "dtype[]":
                    void 0 === (n = getDtypeArrayParam(e11.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getDtypeArrayParam(e11.attr, a.tfDeprecatedName, a.defaultValue));
                    break;
                case "tensor":
                case "tensors":
                    break;
                default:
                    throw new Error("Unsupported param type: " + a.type + " for op: " + e11.op);
            }
            return t[a.name] = {
                value: n,
                type: r
            }, t;
        }, {
        })), a2;
    }, e7;
}();
function decodeBase64(e) {
    var t = _tfjsCore.env().global;
    if (void 0 !== t.atob) return t.atob(e);
    if ("undefined" != typeof Buffer) return new Buffer(e, "base64").toString();
    throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
}
function parseStringParam(e, t) {
    var a = Array.isArray(e) ? String.fromCharCode.apply(null, e) : decodeBase64(e);
    return t ? a : a.toLowerCase();
}
function getStringParam(e, t, a, r) {
    void 0 === r && (r = !1);
    var n = e[t];
    return null != n ? parseStringParam(n.s, r) : a;
}
function getBoolParam(e, t, a) {
    var r = e[t];
    return r ? r.b : a;
}
function getNumberParam(e, t, a) {
    var r = e[t] || {
    }, n = null != r.i ? r.i : null != r.f ? r.f : a;
    return "number" == typeof n ? n : parseInt(n, 10);
}
function parseDtypeParam(e) {
    switch("string" == typeof e && (e = DataType[e]), e){
        case DataType.DT_FLOAT:
            return "float32";
        case DataType.DT_INT32:
        case DataType.DT_INT64:
        case DataType.DT_INT8:
        case DataType.DT_UINT8:
            return "int32";
        case DataType.DT_BOOL:
            return "bool";
        case DataType.DT_DOUBLE:
            return "float32";
        case DataType.DT_STRING:
            return "string";
        default:
            return null;
    }
}
function getDtypeParam(e, t, a) {
    var r = e[t];
    return r && r.type ? parseDtypeParam(r.type) : a;
}
function getDtypeArrayParam(e12, t, a) {
    var r = e12[t];
    return r && r.list && r.list.type ? r.list.type.map(function(e) {
        return parseDtypeParam(e);
    }) : a;
}
function parseTensorShapeParam(e13) {
    if (!e13.unknownRank) return null != e13.dim ? e13.dim.map(function(e) {
        return "number" == typeof e.size ? e.size : parseInt(e.size, 10);
    }) : [];
}
function getTensorShapeParam(e, t, a) {
    var r = e[t];
    return r && r.shape ? parseTensorShapeParam(r.shape) : a;
}
function getNumericArrayParam(e14, t, a) {
    var r = e14[t];
    return r ? ((r.list.f && r.list.f.length ? r.list.f : r.list.i) || []).map(function(e) {
        return "number" == typeof e ? e : parseInt(e, 10);
    }) : a;
}
function getStringArrayParam(e15, t, a, r) {
    void 0 === r && (r = !1);
    var n = e15[t];
    return n && n.list && n.list.s ? n.list.s.map(function(e) {
        return parseStringParam(e, r);
    }) : a;
}
function getTensorShapeArrayParam(e16, t, a) {
    var r = e16[t];
    return r && r.list && r.list.shape ? r.list.shape.map(function(e) {
        return parseTensorShapeParam(e);
    }) : a;
}
function getBoolArrayParam(e, t, a) {
    var r = e[t];
    return r && r.list && r.list.b ? r.list.b : a;
}
var NodeValueImpl = function() {
    function e17(e18, t5, a) {
        var r = this;
        this.node = e18, this.tensorMap = t5, this.context = a, this.inputs = [], this.attrs = {
        }, this.inputs = e18.inputNames.map(function(e) {
            return r.getInput(e);
        }), null != e18.rawAttrs && (this.attrs = Object.keys(e18.rawAttrs).reduce(function(e, t) {
            return e[t] = r.getAttr(t), e;
        }, {
        }));
    }
    return e17.prototype.getInput = function(e) {
        return getTensor(e, this.tensorMap, this.context);
    }, e17.prototype.getAttr = function(e, t) {
        var a = this.node.rawAttrs[e];
        if (null != a.tensor) return getTensor(e, this.tensorMap, this.context);
        if (null != a.i || null != a.f) return getNumberParam(this.node.rawAttrs, e, t);
        if (null != a.s) return getStringParam(this.node.rawAttrs, e, t);
        if (null != a.b) return getBoolParam(this.node.rawAttrs, e, t);
        if (null != a.shape) return getTensorShapeParam(this.node.rawAttrs, e, t);
        if (null != a.type) return getDtypeParam(this.node.rawAttrs, e, t);
        if (null != a.list) {
            if (null != a.list.i || null != a.list.f) return getNumericArrayParam(this.node.rawAttrs, e, t);
            if (null != a.list.s) return getStringArrayParam(this.node.rawAttrs, e, t);
            if (null != a.list.shape) return getTensorShapeArrayParam(this.node.rawAttrs, e, t);
            if (null != a.list.b) return getBoolArrayParam(this.node.rawAttrs, e, t);
            if (null != a.list.type) return getDtypeArrayParam(this.node.rawAttrs, e, t);
        }
        return t;
    }, e17;
}(), executeOp = function(e, t, a) {
    switch(e.op){
        case "BiasAdd":
        case "AddV2":
        case "Add":
            return [
                _tfjsCore.add(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        case "AddN":
            return [
                _tfjsCore.addN(getParamValue("tensors", e, t, a))
            ];
        case "FloorMod":
        case "Mod":
            return [
                _tfjsCore.mod(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        case "Mul":
            return [
                _tfjsCore.mul(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        case "RealDiv":
        case "Div":
            return [
                _tfjsCore.div(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        case "DivNoNan":
            return [
                _tfjsCore.divNoNan(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        case "FloorDiv":
            return [
                _tfjsCore.floorDiv(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        case "Sub":
            return [
                _tfjsCore.sub(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        case "Minimum":
            return [
                _tfjsCore.minimum(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        case "Maximum":
            return [
                _tfjsCore.maximum(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        case "Pow":
            return [
                _tfjsCore.pow(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        case "SquaredDifference":
            return [
                _tfjsCore.squaredDifference(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        default:
            throw TypeError("Node type " + e.op + " is not implemented");
    }
}, executeOp$1 = function(e, t, a) {
    switch(e.op){
        case "Abs":
        case "ComplexAbs":
            return [
                _tfjsCore.abs(getParamValue("x", e, t, a))
            ];
        case "Acos":
            return [
                _tfjsCore.acos(getParamValue("x", e, t, a))
            ];
        case "Acosh":
            return [
                _tfjsCore.acosh(getParamValue("x", e, t, a))
            ];
        case "Asin":
            return [
                _tfjsCore.asin(getParamValue("x", e, t, a))
            ];
        case "Asinh":
            return [
                _tfjsCore.asinh(getParamValue("x", e, t, a))
            ];
        case "Atan":
            return [
                _tfjsCore.atan(getParamValue("x", e, t, a))
            ];
        case "Atan2":
            return [
                _tfjsCore.atan2(getParamValue("x", e, t, a), getParamValue("y", e, t, a))
            ];
        case "Atanh":
            return [
                _tfjsCore.atanh(getParamValue("x", e, t, a))
            ];
        case "Ceil":
            return [
                _tfjsCore.ceil(getParamValue("x", e, t, a))
            ];
        case "Complex":
            return [
                _tfjsCore.complex(getParamValue("real", e, t, a), getParamValue("imag", e, t, a))
            ];
        case "Cos":
            return [
                _tfjsCore.cos(getParamValue("x", e, t, a))
            ];
        case "Cosh":
            return [
                _tfjsCore.cosh(getParamValue("x", e, t, a))
            ];
        case "Elu":
            return [
                _tfjsCore.elu(getParamValue("x", e, t, a))
            ];
        case "Erf":
            return [
                _tfjsCore.erf(getParamValue("x", e, t, a))
            ];
        case "Exp":
            return [
                _tfjsCore.exp(getParamValue("x", e, t, a))
            ];
        case "Expm1":
            return [
                _tfjsCore.expm1(getParamValue("x", e, t, a))
            ];
        case "Floor":
            return [
                _tfjsCore.floor(getParamValue("x", e, t, a))
            ];
        case "Log":
            return [
                _tfjsCore.log(getParamValue("x", e, t, a))
            ];
        case "Log1p":
            return [
                _tfjsCore.log1p(getParamValue("x", e, t, a))
            ];
        case "Imag":
            return [
                _tfjsCore.imag(getParamValue("x", e, t, a))
            ];
        case "Neg":
            return [
                _tfjsCore.neg(getParamValue("x", e, t, a))
            ];
        case "Reciprocal":
            return [
                _tfjsCore.reciprocal(getParamValue("x", e, t, a))
            ];
        case "Real":
            return [
                _tfjsCore.real(getParamValue("x", e, t, a))
            ];
        case "Relu":
            return [
                _tfjsCore.relu(getParamValue("x", e, t, a))
            ];
        case "Round":
            return [
                _tfjsCore.round(getParamValue("x", e, t, a))
            ];
        case "Selu":
            return [
                _tfjsCore.selu(getParamValue("x", e, t, a))
            ];
        case "Sigmoid":
            return [
                _tfjsCore.sigmoid(getParamValue("x", e, t, a))
            ];
        case "Sin":
            return [
                _tfjsCore.sin(getParamValue("x", e, t, a))
            ];
        case "Sign":
            return [
                _tfjsCore.sign(getParamValue("x", e, t, a))
            ];
        case "Sinh":
            return [
                _tfjsCore.sinh(getParamValue("x", e, t, a))
            ];
        case "Softplus":
            return [
                _tfjsCore.softplus(getParamValue("x", e, t, a))
            ];
        case "Sqrt":
            return [
                _tfjsCore.sqrt(getParamValue("x", e, t, a))
            ];
        case "Square":
            return [
                _tfjsCore.square(getParamValue("x", e, t, a))
            ];
        case "Tanh":
            return [
                _tfjsCore.tanh(getParamValue("x", e, t, a))
            ];
        case "Tan":
            return [
                _tfjsCore.tan(getParamValue("x", e, t, a))
            ];
        case "Relu6":
        case "ClipByValue":
            return [
                _tfjsCore.clipByValue(getParamValue("x", e, t, a), getParamValue("clipValueMin", e, t, a), getParamValue("clipValueMax", e, t, a))
            ];
        case "Rsqrt":
            return [
                _tfjsCore.rsqrt(getTensor(e.inputNames[0], t, a))
            ];
        case "Prod":
            return [
                _tfjsCore.prod(getParamValue("x", e, t, a), getParamValue("axes", e, t, a))
            ];
        case "LeakyRelu":
            return [
                _tfjsCore.leakyRelu(getParamValue("x", e, t, a), getParamValue("alpha", e, t, a))
            ];
        case "Prelu":
            return [
                _tfjsCore.prelu(getParamValue("x", e, t, a), getParamValue("alpha", e, t, a))
            ];
        default:
            throw TypeError("Node type " + e.op + " is not implemented");
    }
}, TensorArray = function() {
    function e19(t, a, r, n, s, o, p) {
        this.name = t, this.dtype = a, this.maxSize = r, this.elementShape = n, this.identicalElementShapes = s, this.dynamicSize = o, this.clearAfterRead = p, this.tensors = [], this.closed_ = !1, this.id = e19.nextId++;
    }
    return Object.defineProperty(e19.prototype, "closed", {
        get: function() {
            return this.closed_;
        },
        enumerable: !0,
        configurable: !0
    }), e19.prototype.clearAndClose = function() {
        this.tensors.forEach(function(e) {
            return e.tensor.dispose();
        }), this.tensors = [], this.closed_ = !0;
    }, e19.prototype.size = function() {
        return this.tensors.length;
    }, e19.prototype.read = function(e) {
        if (this.closed_) throw new Error("TensorArray " + this.name + " has already been closed.");
        if (e < 0 || e >= this.tensors.length) throw new Error("Tried to read from index " + e + ", but array size is: " + this.tensors.length);
        var t = this.tensors[e];
        if (t.cleared) throw new Error("TensorArray " + this.name + ": Could not read index " + e + " twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");
        return this.clearAfterRead && (t.cleared = !0), t.read = !0, t.tensor;
    }, e19.prototype.readMany = function(e20) {
        var t = this;
        return e20.map(function(e) {
            return t.read(e);
        });
    }, e19.prototype.write = function(e, t) {
        if (this.closed_) throw new Error("TensorArray " + this.name + " has already been closed.");
        if (e < 0 || !this.dynamicSize && e >= this.maxSize) throw new Error("Tried to write to index " + e + ", but array is not resizeable and size is: " + this.maxSize);
        var a = this.tensors[e] || {
        };
        if (t.dtype !== this.dtype) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e + ",\n          because the value dtype is " + t.dtype + ", but TensorArray dtype is " + this.dtype + ".");
        if (0 !== this.size() || null != this.elementShape && 0 !== this.elementShape.length || (this.elementShape = t.shape), this.assertShapesMatchAllowUndefinedSize(this.elementShape, t.shape, "TensorArray " + this.name + ": Could not write to TensorArray index " + e + "."), a && a.read) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e + ", because it has already been read.");
        if (a && a.written) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e + ", because it has already been written.");
        a.tensor = t, a.written = !0, this.tensors[e] = a;
    }, e19.prototype.writeMany = function(e21, t) {
        var a = this;
        if (e21.length !== t.length) throw new Error("TensorArray " + this.name + ": could not write multiple tensors,because the index size: " + e21.length + " is not the same as tensors size: " + t.length + ".");
        e21.forEach(function(e, r) {
            return a.write(e, t[r]);
        });
    }, e19.prototype.gather = function(e, t) {
        if (t && t !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but gather requested dtype " + t);
        if (!e) {
            e = [];
            for(var a = 0; a < this.size(); a++)e.push(a);
        }
        if (0 === e.length) return _tfjsCore.tensor([], [
            0
        ].concat(this.elementShape));
        var r = this.readMany(e);
        return this.assertShapesMatchAllowUndefinedSize(this.elementShape, r[0].shape, "TensorArray shape mismatch: "), _tfjsCore.stack(r, 0);
    }, e19.prototype.concat = function(e) {
        if (e && e !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but concat requested dtype " + e);
        if (0 === this.size()) return _tfjsCore.tensor([], [
            0
        ].concat(this.elementShape));
        for(var t = [], a = 0; a < this.size(); a++)t.push(a);
        var r = this.readMany(t);
        return this.assertShapesMatchAllowUndefinedSize(this.elementShape, r[0].shape, "TensorArray shape mismatch: tensor array shape (" + this.elementShape + ") vs first tensor shape (" + r[0].shape + ")"), _tfjsCore.concat(r, 0);
    }, e19.prototype.scatter = function(e, t) {
        if (t.dtype !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + t.dtype);
        if (e.length !== t.shape[0]) throw new Error("Expected len(indices) == tensor.shape[0], but saw: " + e.length + " vs. " + t.shape[0]);
        var a = Math.max.apply(Math, e);
        if (!this.dynamicSize && a >= this.maxSize) throw new Error("Max index must be < array size (" + a + "  vs. " + this.maxSize + ")");
        this.writeMany(e, _tfjsCore.unstack(t, 0));
    }, e19.prototype.split = function(e22, t) {
        var a = this;
        if (t.dtype !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + t.dtype);
        var r = 0, n = e22.map(function(e) {
            return r += e;
        });
        if (r !== t.shape[0]) throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        " + r + ", and tensor's shape is: " + t.shape);
        if (!this.dynamicSize && e22.length !== this.maxSize) throw new Error("TensorArray's size is not equal to the size of lengths (" + this.maxSize + " vs. " + e22.length + "), and the TensorArray is not marked as dynamically resizeable");
        var s = 0 === r ? 0 : t.size / r, o = [];
        _tfjsCore.tidy(function() {
            t = t.reshape([
                1,
                r,
                s
            ]);
            for(var p = 0; p < e22.length; ++p){
                var u = [
                    0,
                    0 === p ? 0 : n[p - 1],
                    0
                ], i = [
                    1,
                    e22[p],
                    s
                ];
                o[p] = _tfjsCore.slice(t, u, i).reshape(a.elementShape);
            }
            return o;
        });
        for(var p2 = [], u1 = 0; u1 < e22.length; u1++)p2[u1] = u1;
        this.writeMany(p2, o);
    }, e19.prototype.assertShapesMatchAllowUndefinedSize = function(e, t, a) {
        void 0 === a && (a = ""), _tfjsCore.util.assert(this.shapesEqualAllowUndefinedSize(e, t), function() {
            return a + " Shapes " + e + " and " + t + " must match";
        });
    }, e19.prototype.shapesEqualAllowUndefinedSize = function(e, t) {
        if (e.length !== t.length) return !1;
        for(var a = 0; a < e.length; a++)if (-1 !== e[a] && -1 !== t[a] && e[a] !== t[a]) return !1;
        return !0;
    }, e19.nextId = 0, e19;
}(), _this = void 0, executeOp$2 = function(e23, t, a) {
    return __awaiter(_this, void 0, void 0, function() {
        var r, n, s, o, p, u, i, m, l, c, d, y, f, g, h, N, x, V, b, P, T, v, O, S, _, w, A, D, E, I, M, C, k, z, F;
        return __generator(this, function(j) {
            switch(j.label){
                case 0:
                    switch(e23.op){
                        case "LoopCond":
                            return [
                                3,
                                1
                            ];
                        case "Switch":
                            return [
                                3,
                                2
                            ];
                        case "Merge":
                            return [
                                3,
                                4
                            ];
                        case "Enter":
                            return [
                                3,
                                5
                            ];
                        case "Exit":
                            return [
                                3,
                                6
                            ];
                        case "NextIteration":
                            return [
                                3,
                                7
                            ];
                        case "TensorArrayV3":
                            return [
                                3,
                                8
                            ];
                        case "TensorArrayWriteV3":
                            return [
                                3,
                                9
                            ];
                        case "TensorArrayReadV3":
                            return [
                                3,
                                10
                            ];
                        case "TensorArrayGatherV3":
                            return [
                                3,
                                11
                            ];
                        case "TensorArrayScatterV3":
                            return [
                                3,
                                12
                            ];
                        case "TensorArrayConcatV3":
                            return [
                                3,
                                13
                            ];
                        case "TensorArraySplitV3":
                            return [
                                3,
                                14
                            ];
                        case "TensorArraySizeV3":
                            return [
                                3,
                                15
                            ];
                        case "TensorArrayCloseV3":
                            return [
                                3,
                                16
                            ];
                    }
                    return [
                        3,
                        17
                    ];
                case 1:
                    return [
                        2,
                        [
                            getParamValue("pred", e23, t, a).clone()
                        ]
                    ];
                case 2:
                    return r = getParamValue("pred", e23, t, a), n = getParamValue("data", e23, t, a), [
                        4,
                        r.data()
                    ];
                case 3:
                    return [
                        2,
                        j.sent()[0] ? [
                            void 0,
                            n.clone()
                        ] : [
                            n.clone(),
                            void 0
                        ]
                    ];
                case 4:
                    return [
                        2,
                        (s = e23.inputNames.find(function(e) {
                            return void 0 !== getTensor(e, t, a);
                        })) ? [
                            getTensor(s, t, a).clone()
                        ] : void 0
                    ];
                case 5:
                    return o = getParamValue("frameName", e23, t, a), p = getParamValue("tensor", e23, t, a), a.enterFrame(o), [
                        2,
                        [
                            p.clone()
                        ]
                    ];
                case 6:
                    return u = getParamValue("tensor", e23, t, a), a.exitFrame(), [
                        2,
                        [
                            u.clone()
                        ]
                    ];
                case 7:
                    return i = getParamValue("tensor", e23, t, a), a.nextIteration(), [
                        2,
                        [
                            i.clone()
                        ]
                    ];
                case 8:
                    return m = getParamValue("size", e23, t, a), l = getParamValue("dtype", e23, t, a), c = getParamValue("elementShape", e23, t, a), d = getParamValue("dynamicSize", e23, t, a), y = getParamValue("clearAfterRead", e23, t, a), f = getParamValue("identicalElementShapes", e23, t, a), g = getParamValue("name", e23, t, a), h = new TensorArray(g, l, m, c, f, d, y), a.addTensorArray(h), [
                        2,
                        [
                            _tfjsCore.scalar(h.id),
                            _tfjsCore.scalar(1)
                        ]
                    ];
                case 9:
                    return N = getParamValue("tensorArrayId", e23, t, a), x = getParamValue("index", e23, t, a), V = getParamValue("tensor", e23, t, a), a.getTensorArray(N).write(x, V), [
                        2,
                        [
                            _tfjsCore.scalar(1)
                        ]
                    ];
                case 10:
                    return b = getParamValue("tensorArrayId", e23, t, a), P = getParamValue("index", e23, t, a), [
                        2,
                        [
                            a.getTensorArray(b).read(P)
                        ]
                    ];
                case 11:
                    return T = getParamValue("tensorArrayId", e23, t, a), v = getParamValue("indices", e23, t, a), O = getParamValue("dtype", e23, t, a), [
                        2,
                        [
                            a.getTensorArray(T).gather(v, O)
                        ]
                    ];
                case 12:
                    return S = getParamValue("tensorArrayId", e23, t, a), _ = getParamValue("indices", e23, t, a), w = getParamValue("tensor", e23, t, a), a.getTensorArray(S).scatter(_, w), [
                        2,
                        [
                            _tfjsCore.scalar(1)
                        ]
                    ];
                case 13:
                    return A = getParamValue("tensorArrayId", e23, t, a), D = a.getTensorArray(A), E = getParamValue("dtype", e23, t, a), [
                        2,
                        [
                            D.concat(E)
                        ]
                    ];
                case 14:
                    return I = getParamValue("tensorArrayId", e23, t, a), M = getParamValue("tensor", e23, t, a), C = getParamValue("lengths", e23, t, a), a.getTensorArray(I).split(C, M), [
                        2,
                        [
                            _tfjsCore.scalar(1)
                        ]
                    ];
                case 15:
                    return k = getParamValue("tensorArrayId", e23, t, a), z = a.getTensorArray(k), [
                        2,
                        [
                            _tfjsCore.scalar(z.size(), "int32")
                        ]
                    ];
                case 16:
                    return F = getParamValue("tensorArrayId", e23, t, a), a.getTensorArray(F).clearAndClose(), [
                        2,
                        [
                            _tfjsCore.scalar(0)
                        ]
                    ];
                case 17:
                    throw TypeError("Node type " + e23.op + " is not implemented");
            }
        });
    });
}, executeOp$3 = function(e, t, a) {
    switch(e.op){
        case "Conv1D":
            var r = getParamValue("stride", e, t, a), n = getParamValue("pad", e, t, a), s = getParamValue("dataFormat", e, t, a).toUpperCase(), o = getParamValue("dilation", e, t, a);
            return [
                _tfjsCore.conv1d(getParamValue("x", e, t, a), getParamValue("filter", e, t, a), r, n, s, o)
            ];
        case "Conv2D":
            r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a), s = getParamValue("dataFormat", e, t, a).toUpperCase();
            var p = getParamValue("dilations", e, t, a);
            return [
                _tfjsCore.conv2d(getParamValue("x", e, t, a), getParamValue("filter", e, t, a), [
                    r[1],
                    r[2]
                ], n, s, [
                    p[1],
                    p[2]
                ])
            ];
        case "_FusedConv2D":
        case "FusedDepthwiseConv2dNative":
            var u = getParamValue("fusedOps", e, t, a), i = u[0], m = u[1], l = "biasadd" === i, c = "prelu" === m, d = "fusedbatchnorm" === i, y = getParamValue("numArgs", e, t, a);
            if (l) {
                if (c && 2 !== y) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
                if (!c && 1 !== y) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
            }
            if (d) throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");
            r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a), s = getParamValue("dataFormat", e, t, a).toUpperCase(), p = getParamValue("dilations", e, t, a);
            var f = getParamValue("args", e, t, a), g = f[0], h = f[1];
            return [
                ("_FusedConv2D" === e.op ? _tfjsCore.fused.conv2d : _tfjsCore.fused.depthwiseConv2d)({
                    x: getParamValue("x", e, t, a),
                    filter: getParamValue("filter", e, t, a),
                    strides: [
                        r[1],
                        r[2]
                    ],
                    pad: n,
                    dataFormat: s,
                    dilations: [
                        p[1],
                        p[2]
                    ],
                    bias: g,
                    activation: m,
                    preluActivationWeights: h
                })
            ];
        case "Conv2DBackpropInput":
        case "Conv2dTranspose":
            var N = getParamValue("outputShape", e, t, a);
            r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a);
            return [
                _tfjsCore.conv2dTranspose(getParamValue("x", e, t, a), getParamValue("filter", e, t, a), N, [
                    r[1],
                    r[2]
                ], n)
            ];
        case "DepthwiseConv2dNative":
        case "DepthwiseConv2d":
            r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a), p = getParamValue("dilations", e, t, a), s = getParamValue("dataFormat", e, t, a).toUpperCase();
            return [
                _tfjsCore.depthwiseConv2d(getParamValue("input", e, t, a), getParamValue("filter", e, t, a), [
                    r[1],
                    r[2]
                ], n, s, [
                    p[1],
                    p[2]
                ])
            ];
        case "Conv3D":
            r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a), s = getParamValue("dataFormat", e, t, a).toUpperCase(), p = getParamValue("dilations", e, t, a);
            return [
                _tfjsCore.conv3d(getParamValue("x", e, t, a), getParamValue("filter", e, t, a), [
                    r[1],
                    r[2],
                    r[3]
                ], n, s, [
                    p[1],
                    p[2],
                    p[3]
                ])
            ];
        case "AvgPool":
            r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a);
            var x = getParamValue("kernelSize", e, t, a);
            return [
                _tfjsCore.avgPool(getParamValue("x", e, t, a), [
                    x[1],
                    x[2]
                ], [
                    r[1],
                    r[2]
                ], n)
            ];
        case "MaxPool":
            r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a), x = getParamValue("kernelSize", e, t, a);
            return [
                _tfjsCore.maxPool(getParamValue("x", e, t, a), [
                    x[1],
                    x[2]
                ], [
                    r[1],
                    r[2]
                ], n)
            ];
        case "MaxPoolWithArgmax":
            r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a), x = getParamValue("kernelSize", e, t, a);
            var V = getParamValue("includeBatchInIndex", e, t, a), b = _tfjsCore.maxPoolWithArgmax(getParamValue("x", e, t, a), [
                x[1],
                x[2]
            ], [
                r[1],
                r[2]
            ], n, V);
            return [
                b.result,
                b.indexes
            ];
        case "AvgPool3D":
            r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a), x = getParamValue("kernelSize", e, t, a);
            return [
                _tfjsCore.avgPool3d(getParamValue("x", e, t, a), [
                    x[1],
                    x[2],
                    x[3]
                ], [
                    r[1],
                    r[2],
                    r[3]
                ], n)
            ];
        case "MaxPool3D":
            r = getParamValue("strides", e, t, a), n = getParamValue("pad", e, t, a), x = getParamValue("kernelSize", e, t, a);
            return [
                _tfjsCore.maxPool3d(getParamValue("x", e, t, a), [
                    x[1],
                    x[2],
                    x[3]
                ], [
                    r[1],
                    r[2],
                    r[3]
                ], n)
            ];
        default:
            throw TypeError("Node type " + e.op + " is not implemented");
    }
}, executeOp$4 = function(e, t, a) {
    switch(e.op){
        case "Fill":
            var r = getParamValue("shape", e, t, a), n = getParamValue("dtype", e, t, a), s = getParamValue("value", e, t, a);
            return [
                _tfjsCore.fill(r, s, n)
            ];
        case "LinSpace":
            var o = getParamValue("start", e, t, a), p = getParamValue("stop", e, t, a), u = getParamValue("num", e, t, a);
            return [
                _tfjsCore.linspace(o, p, u)
            ];
        case "Multinomial":
            var i = getParamValue("logits", e, t, a), m = getParamValue("numSamples", e, t, a), l = getParamValue("seed", e, t, a);
            return [
                _tfjsCore.multinomial(i, m, l)
            ];
        case "OneHot":
            var c = getParamValue("indices", e, t, a), d = getParamValue("depth", e, t, a), y = getParamValue("onValue", e, t, a), f = getParamValue("offValue", e, t, a);
            return [
                _tfjsCore.oneHot(c, d, y, f)
            ];
        case "Ones":
            return [
                _tfjsCore.ones(getParamValue("shape", e, t, a), getParamValue("dtype", e, t, a))
            ];
        case "OnesLike":
            return [
                _tfjsCore.onesLike(getParamValue("x", e, t, a))
            ];
        case "RandomUniform":
            return [
                _tfjsCore.randomUniform(getParamValue("shape", e, t, a), getParamValue("minval", e, t, a), getParamValue("maxval", e, t, a), getParamValue("dtype", e, t, a))
            ];
        case "Range":
            o = getParamValue("start", e, t, a);
            var g = getParamValue("stop", e, t, a), h = getParamValue("step", e, t, a);
            return [
                _tfjsCore.range(o, g, h, getParamValue("dtype", e, t, a))
            ];
        case "TruncatedNormal":
            r = getParamValue("shape", e, t, a);
            var N = getParamValue("mean", e, t, a), x = getParamValue("stdDev", e, t, a);
            l = getParamValue("seed", e, t, a);
            return [
                _tfjsCore.truncatedNormal(r, N, x, getParamValue("dtype", e, t, a), l)
            ];
        case "Zeros":
            return [
                _tfjsCore.zeros(getParamValue("shape", e, t, a), getParamValue("dtype", e, t, a))
            ];
        case "ZerosLike":
            return [
                _tfjsCore.zerosLike(getParamValue("x", e, t, a))
            ];
        default:
            throw TypeError("Node type " + e.op + " is not implemented");
    }
}, _this$1 = void 0, executeOp$5 = function(e, t, a) {
    return __awaiter(_this$1, void 0, void 0, function() {
        var r, n, s, o, p, u, i, m;
        return __generator(this, function(l) {
            switch(l.label){
                case 0:
                    switch(e.op){
                        case "NonMaxSuppressionV5":
                        case "NonMaxSuppressionV3":
                        case "NonMaxSuppressionV2":
                            return [
                                3,
                                1
                            ];
                        case "Where":
                            return [
                                3,
                                5
                            ];
                        case "ListDiff":
                            return [
                                3,
                                7
                            ];
                    }
                    return [
                        3,
                        8
                    ];
                case 1:
                    return r = getParamValue("boxes", e, t, a), n = getParamValue("scores", e, t, a), s = getParamValue("maxOutputSize", e, t, a), o = getParamValue("iouThreshold", e, t, a), p = getParamValue("scoreThreshold", e, t, a), "NonMaxSuppressionV5" !== e.op ? [
                        3,
                        3
                    ] : (u = getParamValue("softNmsSigma", e, t, a), [
                        4,
                        _tfjsCore.image.nonMaxSuppressionWithScoreAsync(r, n, s, o, p, u)
                    ]);
                case 2:
                    return [
                        2,
                        [
                            (m = l.sent()).selectedIndices,
                            m.selectedScores
                        ]
                    ];
                case 3:
                    return [
                        4,
                        _tfjsCore.image.nonMaxSuppressionAsync(r, n, s, o, p)
                    ];
                case 4:
                    return [
                        2,
                        [
                            l.sent()
                        ]
                    ];
                case 5:
                    return i = getParamValue("condition", e, t, a).asType("bool"), [
                        4,
                        _tfjsCore.whereAsync(i)
                    ];
                case 6:
                    return m = [
                        l.sent()
                    ], i.dispose(), [
                        2,
                        m
                    ];
                case 7:
                    return [
                        2,
                        _tfjsCore.setdiff1dAsync(getParamValue("x", e, t, a), getParamValue("y", e, t, a))
                    ];
                case 8:
                    throw TypeError("Node type " + e.op + " is not implemented");
            }
        });
    });
}, executeOp$6 = function(e, t, a) {
    switch(e.op){
        case "TopKV2":
            var r = getParamValue("x", e, t, a), n = getParamValue("k", e, t, a), s = getParamValue("sorted", e, t, a), o = _tfjsCore.topk(r, n, s);
            return [
                o.values,
                o.indices
            ];
        default:
            throw TypeError("Node type " + e.op + " is not implemented");
    }
}, executeOp$7 = function(e24, t, a) {
    switch(e24.op){
        case "Const":
            return t[e24.name];
        case "PlaceholderWithDefault":
            var r = getParamValue("default", e24, t, a);
            return [
                getTensor(e24.name, t, a) || r
            ];
        case "Placeholder":
            return [
                getTensor(e24.name, t, a)
            ];
        case "Identity":
        case "StopGradient":
        case "FakeQuantWithMinMaxVars":
            return [
                getParamValue("x", e24, t, a).clone()
            ];
        case "IdentityN":
            return getParamValue("x", e24, t, a).map(function(e) {
                return e.clone();
            });
        case "Snapshot":
            return [
                getParamValue("x", e24, t, a).clone()
            ];
        case "Shape":
            return [
                _tfjsCore.tensor1d(getParamValue("x", e24, t, a).shape, "int32")
            ];
        case "ShapeN":
            return getParamValue("x", e24, t, a).map(function(e) {
                return _tfjsCore.tensor1d(e.shape);
            });
        case "Size":
            return [
                _tfjsCore.scalar(getParamValue("x", e24, t, a).size, "int32")
            ];
        case "Rank":
            return [
                _tfjsCore.scalar(getParamValue("x", e24, t, a).rank, "int32")
            ];
        case "NoOp":
            return [
                _tfjsCore.scalar(1)
            ];
        case "Print":
            var n = getParamValue("x", e24, t, a), s = getParamValue("data", e24, t, a), o = getParamValue("message", e24, t, a), p = getParamValue("summarize", e24, t, a);
            console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(o);
            for(var u = 0; u < s.length; u++)console.log(Array.prototype.slice.call(s[u].dataSync()).slice(0, p));
            return [
                n
            ];
        default:
            throw TypeError("Node type " + e24.op + " is not implemented");
    }
}, executeOp$8 = function(e, t, a) {
    switch(e.op){
        case "ResizeBilinear":
            var r = getParamValue("images", e, t, a), n = getParamValue("size", e, t, a), s = getParamValue("alignCorners", e, t, a);
            return [
                _tfjsCore.image.resizeBilinear(r, [
                    n[0],
                    n[1]
                ], s)
            ];
        case "ResizeNearestNeighbor":
            r = getParamValue("images", e, t, a), n = getParamValue("size", e, t, a), s = getParamValue("alignCorners", e, t, a);
            return [
                _tfjsCore.image.resizeNearestNeighbor(r, [
                    n[0],
                    n[1]
                ], s)
            ];
        case "CropAndResize":
            var o = getParamValue("image", e, t, a), p = getParamValue("boxes", e, t, a), u = getParamValue("boxInd", e, t, a), i = getParamValue("cropSize", e, t, a), m = getParamValue("method", e, t, a), l = getParamValue("extrapolationValue", e, t, a);
            return [
                _tfjsCore.image.cropAndResize(o, p, u, i, m, l)
            ];
        default:
            throw TypeError("Node type " + e.op + " is not implemented");
    }
}, executeOp$9 = function(e, t, a) {
    switch(e.op){
        case "Equal":
            return [
                _tfjsCore.equal(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        case "NotEqual":
            return [
                _tfjsCore.notEqual(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        case "Greater":
            return [
                _tfjsCore.greater(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        case "GreaterEqual":
            return [
                _tfjsCore.greaterEqual(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        case "Less":
            return [
                _tfjsCore.less(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        case "LessEqual":
            return [
                _tfjsCore.lessEqual(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        case "LogicalAnd":
            return [
                _tfjsCore.logicalAnd(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        case "LogicalNot":
            return [
                _tfjsCore.logicalNot(getParamValue("a", e, t, a))
            ];
        case "LogicalOr":
            return [
                _tfjsCore.logicalOr(getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        case "Select":
        case "SelectV2":
            return [
                _tfjsCore.where(getParamValue("condition", e, t, a), getParamValue("a", e, t, a), getParamValue("b", e, t, a))
            ];
        default:
            throw TypeError("Node type " + e.op + " is not implemented");
    }
}, executeOp$10 = function(e, t, a) {
    switch(e.op){
        case "BatchMatMul":
        case "BatchMatMulV2":
        case "MatMul":
            return [
                _tfjsCore.matMul(getParamValue("a", e, t, a), getParamValue("b", e, t, a), getParamValue("transposeA", e, t, a), getParamValue("transposeB", e, t, a))
            ];
        case "Transpose":
            return [
                _tfjsCore.transpose(getParamValue("x", e, t, a), getParamValue("perm", e, t, a))
            ];
        case "_FusedMatMul":
            var r = getParamValue("fusedOps", e, t, a), n = r[0], s = r[1], o = "biasadd" === n, p = "prelu" === s, u = getParamValue("numArgs", e, t, a);
            if (o) {
                if (p && 2 !== u) throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
                if (!p && 1 !== u) throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
            }
            var i = getParamValue("args", e, t, a), m = i[0], l = i[1];
            return [
                _tfjsCore.fused.matMul({
                    a: getParamValue("a", e, t, a),
                    b: getParamValue("b", e, t, a),
                    transposeA: getParamValue("transposeA", e, t, a),
                    transposeB: getParamValue("transposeB", e, t, a),
                    bias: m,
                    activation: s,
                    preluActivationWeights: l
                })
            ];
        default:
            throw TypeError("Node type " + e.op + " is not implemented");
    }
}, executeOp$11 = function(e, t, a) {
    switch(e.op){
        case "FusedBatchNorm":
        case "FusedBatchNormV2":
        case "FusedBatchNormV3":
            return [
                _tfjsCore.batchNorm(getParamValue("x", e, t, a), getParamValue("mean", e, t, a), getParamValue("variance", e, t, a), getParamValue("offset", e, t, a), getParamValue("scale", e, t, a), getParamValue("epsilon", e, t, a))
            ];
        case "LRN":
            return [
                _tfjsCore.localResponseNormalization(getParamValue("x", e, t, a), getParamValue("radius", e, t, a), getParamValue("bias", e, t, a), getParamValue("alpha", e, t, a), getParamValue("beta", e, t, a))
            ];
        case "Softmax":
            return [
                _tfjsCore.softmax(getParamValue("x", e, t, a))
            ];
        case "LogSoftmax":
            return [
                _tfjsCore.logSoftmax(getParamValue("x", e, t, a))
            ];
        case "SparseToDense":
            return [
                _tfjsCore.sparseToDense(getParamValue("sparseIndices", e, t, a), getParamValue("outputShape", e, t, a), getParamValue("sparseValues", e, t, a), getParamValue("defaultValue", e, t, a))
            ];
        default:
            throw TypeError("Node type " + e.op + " is not implemented");
    }
}, executeOp$12 = function(e, t, a) {
    switch(e.op){
        case "Max":
            var r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
            return [
                _tfjsCore.max(getParamValue("x", e, t, a), r, n)
            ];
        case "Mean":
            r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
            return [
                _tfjsCore.mean(getParamValue("x", e, t, a), r, n)
            ];
        case "Min":
            r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
            return [
                _tfjsCore.min(getParamValue("x", e, t, a), r, n)
            ];
        case "Sum":
            r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
            return [
                _tfjsCore.sum(getParamValue("x", e, t, a), r, n)
            ];
        case "All":
            r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
            return [
                _tfjsCore.all(getParamValue("x", e, t, a), r, n)
            ];
        case "Any":
            r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
            return [
                _tfjsCore.any(getParamValue("x", e, t, a), r, n)
            ];
        case "ArgMax":
            r = getParamValue("axis", e, t, a);
            return [
                _tfjsCore.argMax(getParamValue("x", e, t, a), r)
            ];
        case "ArgMin":
            r = getParamValue("axis", e, t, a);
            return [
                _tfjsCore.argMin(getParamValue("x", e, t, a), r)
            ];
        case "Prod":
            r = getParamValue("axis", e, t, a), n = getParamValue("keepDims", e, t, a);
            return [
                _tfjsCore.prod(getParamValue("x", e, t, a), r, n)
            ];
        default:
            throw TypeError("Node type " + e.op + " is not implemented");
    }
}, executeOp$13 = function(e25, t6, a) {
    switch(e25.op){
        case "ConcatV2":
        case "Concat":
            var r1 = getParamValue("n", e25, t6, a), n1 = getParamValue("axis", e25, t6, a), s3 = getParamValue("tensors", e25, t6, a);
            return s3 = s3.slice(0, r1), [
                _tfjsCore.concat(s3, n1)
            ];
        case "GatherV2":
        case "Gather":
            n1 = getParamValue("axis", e25, t6, a);
            var o1 = getParamValue("x", e25, t6, a), p3 = getParamValue("indices", e25, t6, a);
            return [
                _tfjsCore.gather(o1, p3.asType("int32"), n1)
            ];
        case "ReverseV2":
        case "Reverse":
            n1 = getParamValue("axis", e25, t6, a), o1 = getParamValue("x", e25, t6, a);
            return [
                _tfjsCore.reverse(o1, n1)
            ];
        case "Slice":
            var u = getParamValue("begin", e25, t6, a), i = getParamValue("size", e25, t6, a);
            return [
                _tfjsCore.slice(getParamValue("x", e25, t6, a), u, i)
            ];
        case "StridedSlice":
            u = getParamValue("begin", e25, t6, a);
            var m = getParamValue("end", e25, t6, a), l = getParamValue("strides", e25, t6, a), c = getParamValue("beginMask", e25, t6, a), d = getParamValue("endMask", e25, t6, a), y = getParamValue("ellipsisMask", e25, t6, a), f = getParamValue("newAxisMask", e25, t6, a), g = getParamValue("shrinkAxisMask", e25, t6, a), h = getParamValue("x", e25, t6, a);
            if (1 === u.length && h.shape.length > 1) for(var N = 1; N < h.shape.length; N++)u.push(0), m.push(h.shape[N]), l.push(l[0]);
            return [
                _tfjsCore.stridedSlice(h, u, m, l, c, d, y, f, g)
            ];
        case "Pack":
            return _tfjsCore.tidy(function() {
                var r = getParamValue("axis", e25, t6, a), n = getParamValue("tensors", e25, t6, a), s = n[0].shape, o = n[0].squeeze().shape, p = n.map(function(e) {
                    var t = _tfjsCore.util.arraysEqual(e.shape, s);
                    if (!t && !_tfjsCore.util.arraysEqual(e.squeeze().shape, o)) throw new Error("the input tensors shape does not match");
                    return t ? e : e.reshape(s);
                });
                return [
                    _tfjsCore.stack(p, r)
                ];
            });
        case "Unpack":
            return _tfjsCore.tidy(function() {
                var r = getParamValue("axis", e25, t6, a), n = getParamValue("tensor", e25, t6, a);
                return _tfjsCore.unstack(n, r);
            });
        case "Tile":
            var x = getParamValue("reps", e25, t6, a);
            return [
                _tfjsCore.tile(getParamValue("x", e25, t6, a), x)
            ];
        case "Split":
        case "SplitV":
            n1 = getParamValue("axis", e25, t6, a);
            var V = getParamValue("numOrSizeSplits", e25, t6, a);
            return _tfjsCore.split(getParamValue("x", e25, t6, a), V, n1);
        case "ScatterNd":
            p3 = getParamValue("indices", e25, t6, a);
            var b = getParamValue("values", e25, t6, a), P = getParamValue("shape", e25, t6, a);
            return [
                _tfjsCore.scatterND(p3, b, P)
            ];
        case "GatherNd":
            var T = getParamValue("x", e25, t6, a);
            p3 = getParamValue("indices", e25, t6, a);
            return [
                _tfjsCore.gatherND(T, p3)
            ];
        case "SparseToDense":
            p3 = getParamValue("sparseIndices", e25, t6, a), P = getParamValue("outputShape", e25, t6, a);
            var v = getParamValue("sparseValues", e25, t6, a), O = getParamValue("defaultValue", e25, t6, a);
            return [
                _tfjsCore.sparseToDense(p3, v, P, v.dtype === O.dtype ? O : O.asType(v.dtype))
            ];
        default:
            throw TypeError("Node type " + e25.op + " is not implemented");
    }
}, executeOp$14 = function(e, t, a) {
    switch(e.op){
        case "FFT":
            return [
                _tfjsCore.fft(getParamValue("x", e, t, a))
            ];
        case "IFFT":
            return [
                _tfjsCore.ifft(getParamValue("x", e, t, a))
            ];
        case "RFFT":
            return [
                _tfjsCore.rfft(getParamValue("x", e, t, a))
            ];
        case "IRFFT":
            return [
                _tfjsCore.irfft(getParamValue("x", e, t, a))
            ];
        default:
            throw TypeError("Node type " + e.op + " is not implemented");
    }
}, executeOp$15 = function(e, t, a) {
    switch(e.op){
        case "Cast":
            return [
                _tfjsCore.cast(getParamValue("x", e, t, a), getParamValue("dtype", e, t, a))
            ];
        case "ExpandDims":
            var r = getParamValue("axis", e, t, a);
            return [
                _tfjsCore.expandDims(getParamValue("x", e, t, a), r)
            ];
        case "Squeeze":
            r = getParamValue("axis", e, t, a);
            return [
                _tfjsCore.squeeze(getParamValue("x", e, t, a), r)
            ];
        case "Reshape":
            return [
                _tfjsCore.reshape(getParamValue("x", e, t, a), getParamValue("shape", e, t, a))
            ];
        case "PadV2":
        case "Pad":
            return [
                _tfjsCore.pad(getParamValue("x", e, t, a), split$1(getParamValue("padding", e, t, a), 2), getParamValue("constantValue", e, t, a))
            ];
        case "SpaceToBatchND":
            var n = getParamValue("blockShape", e, t, a), s = split$1(getParamValue("paddings", e, t, a), 2);
            return [
                _tfjsCore.spaceToBatchND(getParamValue("x", e, t, a), n, s)
            ];
        case "BatchToSpaceND":
            n = getParamValue("blockShape", e, t, a);
            var o = split$1(getParamValue("crops", e, t, a), 2);
            return [
                _tfjsCore.batchToSpaceND(getParamValue("x", e, t, a), n, o)
            ];
        case "DepthToSpace":
            var p = getParamValue("blockSize", e, t, a), u = getParamValue("dataFormat", e, t, a).toUpperCase();
            return [
                _tfjsCore.depthToSpace(getParamValue("x", e, t, a), p, u)
            ];
        default:
            throw TypeError("Node type " + e.op + " is not implemented");
    }
};
function executeOp$16(e26, t7, a3) {
    var r2 = function(e, t, a) {
        switch(e.category){
            case "arithmetic":
                return _tfjsCore.tidy(function() {
                    return executeOp(e, t, a);
                });
            case "basic_math":
                return _tfjsCore.tidy(function() {
                    return executeOp$1(e, t, a);
                });
            case "control":
                return executeOp$2(e, t, a);
            case "convolution":
                return _tfjsCore.tidy(function() {
                    return executeOp$3(e, t, a);
                });
            case "creation":
                return _tfjsCore.tidy(function() {
                    return executeOp$4(e, t, a);
                });
            case "dynamic":
                return executeOp$5(e, t, a);
            case "evaluation":
                return _tfjsCore.tidy(function() {
                    return executeOp$6(e, t, a);
                });
            case "image":
                return _tfjsCore.tidy(function() {
                    return executeOp$8(e, t, a);
                });
            case "graph":
                return _tfjsCore.tidy(function() {
                    return executeOp$7(e, t, a);
                });
            case "logical":
                return _tfjsCore.tidy(function() {
                    return executeOp$9(e, t, a);
                });
            case "matrices":
                return _tfjsCore.tidy(function() {
                    return executeOp$10(e, t, a);
                });
            case "normalization":
                return _tfjsCore.tidy(function() {
                    return executeOp$11(e, t, a);
                });
            case "reduction":
                return _tfjsCore.tidy(function() {
                    return executeOp$12(e, t, a);
                });
            case "slice_join":
                return _tfjsCore.tidy(function() {
                    return executeOp$13(e, t, a);
                });
            case "spectral":
                return _tfjsCore.tidy(function() {
                    return executeOp$14(e, t, a);
                });
            case "transformation":
                return _tfjsCore.tidy(function() {
                    return executeOp$15(e, t, a);
                });
            case "custom":
                var r = getRegisteredOp(e.op);
                if (r && r.customExecutor) return r.customExecutor(new NodeValueImpl(e, t, a));
                throw TypeError("Custom op " + e.op + " is not registered.");
            default:
                throw TypeError("Unknown op '" + e.op + "'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()");
        }
    }(e26, t7, a3);
    return r2 instanceof Promise ? r2.then(function(e) {
        return [].concat(e);
    }) : [].concat(r2);
}
var ExecutionContext = function() {
    function e27(e, t) {
        this.weightMap = e, this.tensorArrayMap = t, this.rootContext = {
            id: 0,
            frameName: "",
            iterationId: 0
        }, this.contexts = [
            this.rootContext
        ], this.lastId = 0, this.generateCurrentContextIds();
    }
    return e27.prototype.newFrame = function(e, t) {
        return {
            id: e,
            frameName: t,
            iterationId: 0
        };
    }, Object.defineProperty(e27.prototype, "currentContext", {
        get: function() {
            return this.contexts;
        },
        set: function(e) {
            this.contexts !== e && (this.contexts = e, this.generateCurrentContextIds());
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(e27.prototype, "currentContextId", {
        get: function() {
            return this._currentContextIds[0];
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(e27.prototype, "currentContextIds", {
        get: function() {
            return this._currentContextIds;
        },
        enumerable: !0,
        configurable: !0
    }), e27.prototype.generateCurrentContextIds = function() {
        for(var e = [], t = 0; t < this.contexts.length - 1; t++){
            var a = this.contexts.slice(0, this.contexts.length - t);
            e.push(this.contextIdforContexts(a));
        }
        e.push(""), this._currentContextIds = e;
    }, e27.prototype.contextIdforContexts = function(e28) {
        return e28 ? e28.map(function(e) {
            return 0 === e.id && 0 === e.iterationId ? "" : e.frameName + "-" + e.iterationId;
        }).join("/") : "";
    }, e27.prototype.enterFrame = function(e) {
        this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, e)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)));
    }, e27.prototype.exitFrame = function() {
        if (!(this.contexts && this.contexts.length > 1)) throw new Error("Cannot exit frame, the context is empty");
        this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift();
    }, e27.prototype.nextIteration = function() {
        if (!(this.contexts && this.contexts.length > 0)) throw new Error("Cannot increase frame iteration, the context is empty");
        this.contexts = this.contexts.slice(), this.lastId++;
        var e = Object.assign({
        }, this.contexts[this.contexts.length - 1]);
        e.iterationId += 1, e.id = this.lastId, this.contexts.splice(-1, 1, e), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
    }, e27.prototype.getWeight = function(e) {
        return this.weightMap[e];
    }, e27.prototype.addTensorArray = function(e) {
        this.tensorArrayMap[e.id] = e;
    }, e27.prototype.getTensorArray = function(e) {
        return this.tensorArrayMap[e];
    }, e27;
}();
function getExecutionSubgraph(e29, t, a) {
    for(var r = new Set, n = [], s = null, o = null, p = new Set, u = Object.keys(e29).map(function(e) {
        return parseNodeName(e)[0];
    }), i = t.slice(); i.length > 0;){
        var m = i.pop();
        (isControlFlow(m) || isDynamicShape(m)) && null == s && (o = (s = m).children.map(function(e) {
            return e.name;
        }).filter(function(e) {
            return r.has(e);
        })), r.add(m.name), null == a[m.name] && -1 === u.indexOf(m.name) && (0 !== m.inputs.length ? m.inputs.forEach(function(e) {
            p.has(e.name) || (p.add(e.name), i.push(e));
        }) : n.push(m.name));
    }
    return {
        inputs: e29,
        outputs: t,
        usedNodes: r,
        missingInputs: n,
        dynamicNode: s,
        syncInputs: o
    };
}
function getNodesInTopologicalOrder(e30, t, a) {
    var r = a.usedNodes, n = a.inputs, s = [];
    Object.keys(n).map(function(e) {
        return parseNodeName(e)[0];
    }).map(function(t) {
        return e30.nodes[t];
    }).forEach(function(e) {
        r.has(e.name) && s.push(e);
    }), e30.weights.forEach(function(e) {
        r.has(e.name) && s.push(e);
    });
    for(var o = new Set, p = []; s.length > 0;){
        var u = s.pop();
        o.add(u.name), t[u.name] || p.push(u), u.children.forEach(function(e31) {
            !o.has(e31.name) && r.has(e31.name) && e31.inputs.every(function(e) {
                return o.has(e.name);
            }) && s.push(e31);
        });
    }
    return p;
}
var CONTROL_FLOW_OPS = [
    "Switch",
    "Merge",
    "Enter",
    "Exit",
    "NextIteration"
], DYNAMIC_SHAPE_OPS = [
    "NonMaxSuppressionV2",
    "NonMaxSuppressionV3",
    "NonMaxSuppressionV5",
    "Where"
];
function isControlFlow(e) {
    return CONTROL_FLOW_OPS.indexOf(e.op) >= 0;
}
function isDynamicShape(e) {
    return DYNAMIC_SHAPE_OPS.indexOf(e.op) >= 0;
}
var GraphExecutor = function() {
    function e32(e) {
        this.graph = e, this.compiledMap = new Map, this._weightMap = {
        }, this.SEPERATOR = ",", this._outputs = e.outputs, this._inputs = e.inputs, this._signature = e.signature;
    }
    return Object.defineProperty(e32.prototype, "weightMap", {
        get: function() {
            return this._weightMap;
        },
        set: function(e33) {
            var t = Object.keys(e33).map(function(t) {
                return e33[t].map(function(e) {
                    return e.id;
                });
            });
            this.weightIds = [].concat.apply([], t), this._weightMap = e33;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(e32.prototype, "inputs", {
        get: function() {
            return this._inputs.map(function(e) {
                return {
                    name: e.name,
                    shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
                    dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
                };
            });
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(e32.prototype, "outputs", {
        get: function() {
            return this._outputs.map(function(e) {
                return {
                    name: e.name,
                    shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
                    dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
                };
            });
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(e32.prototype, "inputNodes", {
        get: function() {
            return this._inputs.map(function(e) {
                return e.signatureKey || e.name;
            });
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(e32.prototype, "outputNodes", {
        get: function() {
            return this._outputs.map(function(e) {
                return e.signatureKey || e.name;
            });
        },
        enumerable: !0,
        configurable: !0
    }), e32.prototype.getCompilationKey = function(e34, t) {
        var a = e34.map(function(e) {
            return e.name;
        }).sort(), r = t.map(function(e) {
            return e.name;
        }).sort();
        return a.join(this.SEPERATOR) + "--" + r.join(this.SEPERATOR);
    }, e32.prototype.compile = function(e35, t) {
        var a = getExecutionSubgraph(e35, t, this.weightMap), r = a.missingInputs, n = a.dynamicNode, s = a.syncInputs;
        if (null != n) throw new Error("This execution contains the node '" + n.name + "', which has the dynamic op '" + n.op + "'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [" + s + "]");
        if (r.length > 0) {
            var o = t.map(function(e) {
                return e.name;
            }), p = Object.keys(e35);
            throw new Error("Cannot compute the outputs [" + o + "] from the provided inputs [" + p + "]. Missing the following inputs: [" + r + "]");
        }
        return getNodesInTopologicalOrder(this.graph, this.weightMap, a);
    }, e32.prototype.execute = function(e36, t8) {
        var a4 = this;
        e36 = this.mapInputs(e36);
        var r3 = Object.keys(e36).sort();
        this.checkInputs(e36), this.checkInputShapeAndType(e36), t8 = this.mapOutputs(t8), this.checkOutputs(t8);
        var n2 = r3.map(function(e) {
            return a4.graph.nodes[parseNodeName(e)[0]];
        }), s4 = t8.map(function(e) {
            return a4.graph.nodes[parseNodeName(e)[0]];
        }), o2 = this.getCompilationKey(n2, s4), p = this.compiledMap.get(o2);
        null == p && (p = this.compile(e36, s4), this.compiledMap.set(o2, p));
        var u = {
        };
        return _tfjsCore.tidy(function() {
            var r = new ExecutionContext(a4._weightMap, u), n = __assign({
            }, a4.weightMap);
            Object.keys(e36).forEach(function(t) {
                var a = parseNodeName(t), r = a[0], s = [];
                s[a[1]] = e36[t], n[r] = s;
            });
            for(var s5 = a4.getFrozenTensorIds(n), o = {
            }, i = 0; i < p.length; i++){
                var m = p[i];
                if (!n[m.name]) {
                    var l = executeOp$16(m, n, r);
                    if (l instanceof Promise) throw new Error("The execution of the op '" + m.op + "' returned a promise. Please use model.executeAsync() instead.");
                    n[m.name] = l, a4.checkTensorForDisposal(m.name, m, n, r, s5, t8, o);
                }
            }
            return t8.map(function(e) {
                return getTensor(e, n, r);
            });
        });
    }, e32.prototype.getFrozenTensorIds = function(e37) {
        var t = [].concat.apply([], Object.keys(e37).map(function(t) {
            return e37[t];
        }).map(function(e38) {
            return e38.map(function(e) {
                return e.id;
            });
        }));
        return new Set(t);
    }, e32.prototype.checkTensorForDisposal = function(e39, t9, a, r, n, s, o) {
        "control" !== t9.category && -1 === s.indexOf(e39) && (a[e39].forEach(function(e) {
            null != e && (o[e.id] = (o[e.id] || 0) + t9.children.length);
        }), t9.inputs.forEach(function(e40) {
            if ("control" !== e40.category) {
                var t10 = getTensorsForCurrentContenxt(e40.name, a, r);
                null != t10 && t10.forEach(function(e) {
                    if (e && !n.has(e.id)) {
                        var t = o[e.id];
                        1 === t ? (e.dispose(), delete o[e.id]) : null != t && o[e.id]--;
                    }
                });
            }
        }));
    }, e32.prototype.executeAsync = function(e41, t) {
        return __awaiter(this, void 0, void 0, function() {
            var a, r, n, s, o, p, u = this;
            return __generator(this, function(i) {
                switch(i.label){
                    case 0:
                        return e41 = this.mapInputs(e41), this.checkInputs(e41), this.checkInputShapeAndType(e41), t = this.mapOutputs(t), this.checkOutputs(t), a = {
                        }, r = new ExecutionContext(this._weightMap, a), [
                            4,
                            this.executeWithControlFlow(e41, r, t)
                        ];
                    case 1:
                        return n = i.sent(), s = t.map(function(e) {
                            return getTensor(e, n, r);
                        }), o = new Set(s.map(function(e) {
                            return e.id;
                        })), p = new Set(Object.keys(e41).map(function(t) {
                            return e41[t].id;
                        })), Object.keys(n).forEach(function(e42) {
                            n[e42].forEach(function(e) {
                                !e || e.isDisposed || o.has(e.id) || p.has(e.id) || -1 !== u.weightIds.indexOf(e.id) || e.dispose();
                            });
                        }), [
                            2,
                            s
                        ];
                }
            });
        });
    }, e32.prototype.executeWithControlFlow = function(e43, t12, a5) {
        return __awaiter(this, void 0, void 0, function() {
            var r, n3, s, o, p, u, i, m, l, c, d, y, f, g, h, N, x = this;
            return __generator(this, function(V) {
                switch(V.label){
                    case 0:
                        r = Object.keys(e43), n3 = r.map(function(e) {
                            return x.graph.nodes[parseNodeName(e)[0]];
                        }), s = a5.map(function(e) {
                            return x.graph.nodes[parseNodeName(e)[0]];
                        }), o = getExecutionSubgraph(e43, s, this.weightMap), p = o.usedNodes, u = o.missingInputs, i = o.dynamicNode, m = o.syncInputs, l = n3.concat(this.graph.weights).map(function(e) {
                            return {
                                node: e,
                                contexts: t12.currentContext
                            };
                        }), c = __assign({
                        }, this.weightMap), Object.keys(e43).forEach(function(t) {
                            var a = parseNodeName(t), r = a[0], n = [];
                            n[a[1]] = e43[t], c[r] = n;
                        }), d = {
                        }, y = this.getFrozenTensorIds(c), f = {
                        }, V.label = 1;
                    case 1:
                        return l.length > 0 ? (g = this.processStack(n3, l, t12, c, f, y, a5, d, p), [
                            4,
                            Promise.all(g)
                        ]) : [
                            3,
                            3
                        ];
                    case 2:
                        return V.sent(), [
                            3,
                            1
                        ];
                    case 3:
                        if (null == i && console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead."), (h = s.filter(function(e) {
                            return !isControlFlow(e) && !getTensor(e.name, c, t12);
                        }).map(function(e) {
                            return e.name;
                        })).length > 0) throw N = "", null != i && (N = "Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [" + m + "]"), new Error("Cannot compute the outputs [" + h + "] from the provided inputs [" + r + "]. Consider providing the following inputs: [" + u + "]. " + N);
                        return [
                            2,
                            c
                        ];
                }
            });
        });
    }, e32.prototype.processStack = function(e44, t, a, r, n, s, o, p, u) {
        for(var i = this, m = [], l1 = function() {
            var l = t.pop();
            a.currentContext = l.contexts;
            var d = "";
            if ("Enter" === l.node.op && getParamValue("isConstant", l.node, r, a) && (d = getNodeNameAndIndex(l.node.name, a)[0]), -1 === e44.indexOf(l.node)) {
                var y = executeOp$16(l.node, r, a);
                d || (d = getNodeNameAndIndex(l.node.name, a)[0]);
                var f = a.currentContext;
                y instanceof Promise ? m.push(y.then(function(e) {
                    return r[d] = e, a.currentContext = f, i.checkTensorForDisposal(d, l.node, r, a, s, o, p), i.processChildNodes(l.node, t, a, r, n, u), e;
                })) : (r[d] = y, c.checkTensorForDisposal(d, l.node, r, a, s, o, p), c.processChildNodes(l.node, t, a, r, n, u));
            } else c.processChildNodes(l.node, t, a, r, n, u);
        }, c = this; t.length > 0;)l1();
        return m;
    }, e32.prototype.processChildNodes = function(e45, t, a, r, n, s) {
        e45.children.forEach(function(e46) {
            var o = getNodeNameAndIndex(e46.name, a)[0];
            !n[o] && s.has(e46.name) && ("Merge" === e46.op ? e46.inputNames.some(function(e) {
                return !!getTensor(e, r, a);
            }) && (n[o] = !0, t.push({
                contexts: a.currentContext,
                node: e46
            })) : e46.inputNames.every(function(e) {
                return !!getTensor(e, r, a);
            }) && (n[o] = !0, t.push({
                contexts: a.currentContext,
                node: e46
            })));
        });
    }, e32.prototype.dispose = function() {
        var e47 = this;
        Object.keys(this.weightMap).forEach(function(t) {
            return e47.weightMap[t].forEach(function(e) {
                return e.dispose();
            });
        });
    }, e32.prototype.checkInputShapeAndType = function(e48) {
        var t = this;
        Object.keys(e48).forEach(function(a) {
            var r = e48[a], n = parseNodeName(a)[0], s = t.graph.nodes[n];
            if (s.attrParams.shape && s.attrParams.shape.value) {
                var o = s.attrParams.shape.value, p = o.length === r.shape.length && r.shape.every(function(e, t) {
                    return -1 === o[t] || o[t] === e;
                });
                _tfjsCore.util.assert(p, function() {
                    return "The shape of dict['" + s.name + "'] provided in model.execute(dict) must be [" + o + "], but was [" + r.shape + "]";
                });
            }
            s.attrParams.dtype && s.attrParams.dtype.value && _tfjsCore.util.assert(r.dtype === s.attrParams.dtype.value, function() {
                return "The dtype of dict['" + s.name + "'] provided in model.execute(dict) must be " + s.attrParams.dtype.value + ", but was " + r.dtype;
            });
        });
    }, e32.prototype.mapInputs = function(e) {
        var t = {
        };
        for(var a in e)if (null != this._signature && null != this._signature.inputs && null != this._signature.inputs[a]) t[this._signature.inputs[a].name] = e[a];
        else t[a] = e[a];
        return t;
    }, e32.prototype.checkInputs = function(e49) {
        var t = this, a = Object.keys(e49).filter(function(e) {
            var a = parseNodeName(e)[0];
            return null == t.graph.nodes[a];
        });
        if (a.length > 0) throw new Error("The dict provided in model.execute(dict) has keys: [" + a + "] that are not part of graph");
    }, e32.prototype.mapOutputs = function(e50) {
        var t = this;
        return e50.map(function(e) {
            return null != t._signature && null != t._signature.outputs && null != t._signature.outputs[e] ? t._signature.outputs[e].name : e;
        }, {
        });
    }, e32.prototype.checkOutputs = function(e51) {
        var t = this;
        e51.forEach(function(e) {
            var a = parseNodeName(e)[0];
            if (!t.graph.nodes[a]) throw new Error("The output '" + e + "' is not found in the graph");
        });
    }, e32;
}(), TFHUB_SEARCH_PARAM = "?tfjs-format=file", DEFAULT_MODEL_NAME = "model.json", GraphModel = function() {
    function e52(e, t) {
        void 0 === t && (t = {
        }), this.modelUrl = e, this.loadOptions = t, this.version = "n/a", null == t && (this.loadOptions = {
        });
    }
    return Object.defineProperty(e52.prototype, "modelVersion", {
        get: function() {
            return this.version;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(e52.prototype, "inputNodes", {
        get: function() {
            return this.executor.inputNodes;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(e52.prototype, "outputNodes", {
        get: function() {
            return this.executor.outputNodes;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(e52.prototype, "inputs", {
        get: function() {
            return this.executor.inputs;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(e52.prototype, "outputs", {
        get: function() {
            return this.executor.outputs;
        },
        enumerable: !0,
        configurable: !0
    }), Object.defineProperty(e52.prototype, "weights", {
        get: function() {
            return this.executor.weightMap;
        },
        enumerable: !0,
        configurable: !0
    }), e52.prototype.findIOHandler = function() {
        var e = this.modelUrl;
        if (null != e.load) this.handler = e;
        else if (null != this.loadOptions.requestInit) this.handler = _tfjsCore.io.browserHTTPRequest(e, this.loadOptions);
        else {
            var t = _tfjsCore.io.getLoadHandlers(e, this.loadOptions.onProgress);
            if (0 === t.length) t.push(_tfjsCore.io.browserHTTPRequest(e, this.loadOptions));
            else if (t.length > 1) throw new Error("Found more than one (" + t.length + ") load handlers for URL '" + [
                e
            ] + "'");
            this.handler = t[0];
        }
    }, e52.prototype.load = function() {
        return __awaiter(this, void 0, void 0, function() {
            var e, t, a, r;
            return __generator(this, function(n) {
                switch(n.label){
                    case 0:
                        if (this.findIOHandler(), null == this.handler.load) throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
                        return e = this, [
                            4,
                            this.handler.load()
                        ];
                    case 1:
                        return e.artifacts = n.sent(), t = this.artifacts.modelTopology, a = {
                        }, null != this.artifacts.userDefinedMetadata && (a = this.artifacts.userDefinedMetadata.signature), this.version = t.versions.producer + "." + t.versions.minConsumer, r = _tfjsCore.io.decodeWeights(this.artifacts.weightData, this.artifacts.weightSpecs), this.executor = new GraphExecutor(OperationMapper.Instance.transformGraph(t, a)), this.executor.weightMap = this.convertTensorMapToTensorsMap(r), [
                            2,
                            !0
                        ];
                }
            });
        });
    }, e52.prototype.save = function(e, t13) {
        return __awaiter(this, void 0, void 0, function() {
            var t;
            return __generator(this, function(a) {
                if ("string" == typeof e) {
                    if (0 === (t = _tfjsCore.io.getSaveHandlers(e)).length) throw new Error("Cannot find any save handlers for URL '" + e + "'");
                    if (t.length > 1) throw new Error("Found more than one (" + t.length + ") save handlers for URL '" + e + "'");
                    e = t[0];
                }
                if (null == e.save) throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
                return [
                    2,
                    e.save(this.artifacts)
                ];
            });
        });
    }, e52.prototype.predict = function(e, t) {
        return this.execute(e, this.outputNodes);
    }, e52.prototype.normalizeInputs = function(e) {
        if (!(e instanceof _tfjsCore.Tensor || Array.isArray(e))) return e;
        if ((e = Array.isArray(e) ? e : [
            e
        ]).length !== this.inputNodes.length) throw new Error("Input tensor count mismatch,the graph model has " + this.inputNodes.length + " placeholders, while there are " + e.length + " input tensors.");
        return this.inputNodes.reduce(function(t, a, r) {
            return t[a] = e[r], t;
        }, {
        });
    }, e52.prototype.normalizeOutputs = function(e) {
        return e = e || this.outputNodes, Array.isArray(e) ? e : [
            e
        ];
    }, e52.prototype.execute = function(e, t) {
        e = this.normalizeInputs(e), t = this.normalizeOutputs(t);
        var a = this.executor.execute(e, t);
        return a.length > 1 ? a : a[0];
    }, e52.prototype.executeAsync = function(e, t) {
        return __awaiter(this, void 0, void 0, function() {
            var a;
            return __generator(this, function(r) {
                switch(r.label){
                    case 0:
                        return e = this.normalizeInputs(e), t = this.normalizeOutputs(t), [
                            4,
                            this.executor.executeAsync(e, t)
                        ];
                    case 1:
                        return [
                            2,
                            (a = r.sent()).length > 1 ? a : a[0]
                        ];
                }
            });
        });
    }, e52.prototype.convertTensorMapToTensorsMap = function(e) {
        return Object.keys(e).reduce(function(t, a) {
            return t[a] = [
                e[a]
            ], t;
        }, {
        });
    }, e52.prototype.dispose = function() {
        this.executor.dispose();
    }, e52;
}();
function loadGraphModel(e, t) {
    return void 0 === t && (t = {
    }), __awaiter(this, void 0, void 0, function() {
        var a;
        return __generator(this, function(r) {
            switch(r.label){
                case 0:
                    if (null == e) throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
                    return null == t && (t = {
                    }), t.fromTFHub && null == e.load && (e.endsWith("/") || (e += "/"), e = "" + e + DEFAULT_MODEL_NAME + TFHUB_SEARCH_PARAM), [
                        4,
                        (a = new GraphModel(e, t)).load()
                    ];
                case 1:
                    return r.sent(), [
                        2,
                        a
                    ];
            }
        });
    });
}
var version = "1.7.4";

},{"@tensorflow/tfjs-core":"djGzH","buffer":"fCgem","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"847Hn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "array", ()=>array
);
parcelHelpers.export(exports, "Dataset", ()=>Dataset
);
parcelHelpers.export(exports, "zip", ()=>zip
);
parcelHelpers.export(exports, "CSVDataset", ()=>CSVDataset
);
parcelHelpers.export(exports, "TextLineDataset", ()=>TextLineDataset
);
parcelHelpers.export(exports, "csv", ()=>csv
);
parcelHelpers.export(exports, "func", ()=>func
);
parcelHelpers.export(exports, "generator", ()=>generator
);
parcelHelpers.export(exports, "microphone", ()=>microphone
);
parcelHelpers.export(exports, "webcam", ()=>webcam
);
parcelHelpers.export(exports, "FileDataSource", ()=>FileDataSource
);
parcelHelpers.export(exports, "URLDataSource", ()=>URLDataSource
);
parcelHelpers.export(exports, "version_data", ()=>version
);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ var _tfjsCore = require("@tensorflow/tfjs-core");
var Buffer = require("buffer").Buffer;
var global = arguments[3];
var extendStatics = function(t1, e1) {
    return (extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(t, e) {
        t.__proto__ = e;
    } || function(t, e) {
        for(var r in e)e.hasOwnProperty(r) && (t[r] = e[r]);
    })(t1, e1);
};
function __extends(t, e) {
    function r() {
        this.constructor = t;
    }
    extendStatics(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r);
}
function __awaiter(t2, e2, r, n) {
    return new (r || (r = Promise))(function(i, o) {
        function a(t) {
            try {
                u(n.next(t));
            } catch (t3) {
                o(t3);
            }
        }
        function s(t) {
            try {
                u(n.throw(t));
            } catch (t4) {
                o(t4);
            }
        }
        function u(t) {
            t.done ? i(t.value) : new r(function(e) {
                e(t.value);
            }).then(a, s);
        }
        u((n = n.apply(t2, e2 || [])).next());
    });
}
function __generator(t5, e) {
    var r, n, i, o1, a = {
        label: 0,
        sent: function() {
            if (1 & i[0]) throw i[1];
            return i[1];
        },
        trys: [],
        ops: []
    };
    function s1(o2) {
        return function(s) {
            return (function(o) {
                if (r) throw new TypeError("Generator is already executing.");
                for(; a;)try {
                    if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
                    switch(n = 0, i && (o = [
                        2 & o[0],
                        i.value
                    ]), o[0]){
                        case 0:
                        case 1:
                            i = o;
                            break;
                        case 4:
                            return a.label++, {
                                value: o[1],
                                done: !1
                            };
                        case 5:
                            a.label++, n = o[1], o = [
                                0
                            ];
                            continue;
                        case 7:
                            o = a.ops.pop(), a.trys.pop();
                            continue;
                        default:
                            if (!(i = (i = a.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
                                a = 0;
                                continue;
                            }
                            if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                a.label = o[1];
                                break;
                            }
                            if (6 === o[0] && a.label < i[1]) {
                                a.label = i[1], i = o;
                                break;
                            }
                            if (i && a.label < i[2]) {
                                a.label = i[2], a.ops.push(o);
                                break;
                            }
                            i[2] && a.ops.pop(), a.trys.pop();
                            continue;
                    }
                    o = e.call(t5, a);
                } catch (t) {
                    o = [
                        6,
                        t
                    ], n = 0;
                } finally{
                    r = i = 0;
                }
                if (5 & o[0]) throw o[1];
                return {
                    value: o[0] ? o[1] : void 0,
                    done: !0
                };
            })([
                o2,
                s
            ]);
        };
    }
    return o1 = {
        next: s1(0),
        throw: s1(1),
        return: s1(2)
    }, "function" == typeof Symbol && (o1[Symbol.iterator] = function() {
        return this;
    }), o1;
}
var commonjsGlobal = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {
};
function createCommonjsModule(t, e) {
    return t(e = {
        exports: {
        }
    }, e.exports), e.exports;
}
var alea = createCommonjsModule(function(t6) {
    !function(t7, e3, r1) {
        function n1(t, e) {
            return e.c = t.c, e.s0 = t.s0, e.s1 = t.s1, e.s2 = t.s2, e;
        }
        function i1(t8, e4) {
            var r2 = new function(t9) {
                var e, r3 = this, n2 = (e = 4022871197, function(t) {
                    t = t.toString();
                    for(var r = 0; r < t.length; r++){
                        var n = 0.02519603282416938 * (e += t.charCodeAt(r));
                        n -= e = n >>> 0, e = (n *= e) >>> 0, e += 4294967296 * (n -= e);
                    }
                    return 0.00000000023283064365386963 * (e >>> 0);
                });
                r3.next = function() {
                    var t = 2091639 * r3.s0 + 0.00000000023283064365386963 * r3.c;
                    return r3.s0 = r3.s1, r3.s1 = r3.s2, r3.s2 = t - (r3.c = 0 | t);
                }, r3.c = 1, r3.s0 = n2(" "), r3.s1 = n2(" "), r3.s2 = n2(" "), r3.s0 -= n2(t9), r3.s0 < 0 && (r3.s0 += 1), r3.s1 -= n2(t9), r3.s1 < 0 && (r3.s1 += 1), r3.s2 -= n2(t9), r3.s2 < 0 && (r3.s2 += 1), n2 = null;
            }(t8), i = e4 && e4.state, o = r2.next;
            return o.int32 = function() {
                return 4294967296 * r2.next() | 0;
            }, o.double = function() {
                return o() + 0.00000000000000011102230246251565 * (2097152 * o() | 0);
            }, o.quick = o, i && ("object" == typeof i && n1(i, r2), o.state = function() {
                return n1(r2, {
                });
            }), o;
        }
        e3 && e3.exports ? e3.exports = i1 : r1 && r1.amd ? r1(function() {
            return i1;
        }) : this.alea = i1;
    }(0, t6, !1);
}), xor128 = createCommonjsModule(function(t10) {
    !function(t11, e5, r4) {
        function n3(t, e) {
            return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e;
        }
        function i2(t12, e6) {
            var r5 = new function(t13) {
                var e = this, r = "";
                e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.next = function() {
                    var t = e.x ^ e.x << 11;
                    return e.x = e.y, e.y = e.z, e.z = e.w, e.w ^= e.w >>> 19 ^ t ^ t >>> 8;
                }, t13 === (0 | t13) ? e.x = t13 : r += t13;
                for(var n = 0; n < r.length + 64; n++)e.x ^= 0 | r.charCodeAt(n), e.next();
            }(t12), i = e6 && e6.state, o = function() {
                return (r5.next() >>> 0) / 4294967296;
            };
            return o.double = function() {
                do var t = ((r5.next() >>> 11) + (r5.next() >>> 0) / 4294967296) / 2097152;
                while (0 === t)
                return t;
            }, o.int32 = r5.next, o.quick = o, i && ("object" == typeof i && n3(i, r5), o.state = function() {
                return n3(r5, {
                });
            }), o;
        }
        e5 && e5.exports ? e5.exports = i2 : r4 && r4.amd ? r4(function() {
            return i2;
        }) : this.xor128 = i2;
    }(0, t10, !1);
}), xorwow = createCommonjsModule(function(t14) {
    !function(t15, e7, r6) {
        function n4(t, e) {
            return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e.v = t.v, e.d = t.d, e;
        }
        function i3(t16, e8) {
            var r7 = new function(t17) {
                var e = this, r = "";
                e.next = function() {
                    var t = e.x ^ e.x >>> 2;
                    return e.x = e.y, e.y = e.z, e.z = e.w, e.w = e.v, (e.d = e.d + 362437 | 0) + (e.v = e.v ^ e.v << 4 ^ t ^ t << 1) | 0;
                }, e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.v = 0, t17 === (0 | t17) ? e.x = t17 : r += t17;
                for(var n = 0; n < r.length + 64; n++)e.x ^= 0 | r.charCodeAt(n), n == r.length && (e.d = e.x << 10 ^ e.x >>> 4), e.next();
            }(t16), i = e8 && e8.state, o = function() {
                return (r7.next() >>> 0) / 4294967296;
            };
            return o.double = function() {
                do var t = ((r7.next() >>> 11) + (r7.next() >>> 0) / 4294967296) / 2097152;
                while (0 === t)
                return t;
            }, o.int32 = r7.next, o.quick = o, i && ("object" == typeof i && n4(i, r7), o.state = function() {
                return n4(r7, {
                });
            }), o;
        }
        e7 && e7.exports ? e7.exports = i3 : r6 && r6.amd ? r6(function() {
            return i3;
        }) : this.xorwow = i3;
    }(0, t14, !1);
}), xorshift7 = createCommonjsModule(function(t18) {
    !function(t19, e9, r8) {
        function n5(t, e) {
            return e.x = t.x.slice(), e.i = t.i, e;
        }
        function i4(t20, e10) {
            null == t20 && (t20 = +new Date);
            var r9 = new function(t21) {
                var e11 = this;
                e11.next = function() {
                    var t, r, n = e11.x, i = e11.i;
                    return t = n[i], r = (t ^= t >>> 7) ^ t << 24, r ^= (t = n[i + 1 & 7]) ^ t >>> 10, r ^= (t = n[i + 3 & 7]) ^ t >>> 3, r ^= (t = n[i + 4 & 7]) ^ t << 7, t = n[i + 7 & 7], r ^= (t ^= t << 13) ^ t << 9, n[i] = r, e11.i = i + 1 & 7, r;
                }, (function(t, e) {
                    var r, n = [];
                    if (e === (0 | e)) n[0] = e;
                    else for(e = "" + e, r = 0; r < e.length; ++r)n[7 & r] = n[7 & r] << 15 ^ e.charCodeAt(r) + n[r + 1 & 7] << 13;
                    for(; n.length < 8;)n.push(0);
                    for(r = 0; r < 8 && 0 === n[r]; ++r);
                    for(8 == r ? n[7] = -1 : n[r], t.x = n, t.i = 0, r = 256; r > 0; --r)t.next();
                })(e11, t21);
            }(t20), i5 = e10 && e10.state, o = function() {
                return (r9.next() >>> 0) / 4294967296;
            };
            return o.double = function() {
                do var t = ((r9.next() >>> 11) + (r9.next() >>> 0) / 4294967296) / 2097152;
                while (0 === t)
                return t;
            }, o.int32 = r9.next, o.quick = o, i5 && (i5.x && n5(i5, r9), o.state = function() {
                return n5(r9, {
                });
            }), o;
        }
        e9 && e9.exports ? e9.exports = i4 : r8 && r8.amd ? r8(function() {
            return i4;
        }) : this.xorshift7 = i4;
    }(0, t18, !1);
}), xor4096 = createCommonjsModule(function(t22) {
    !function(t23, e12, r10) {
        function n6(t, e) {
            return e.i = t.i, e.w = t.w, e.X = t.X.slice(), e;
        }
        function i6(t24, e13) {
            null == t24 && (t24 = +new Date);
            var r11 = new function(t25) {
                var e14 = this;
                e14.next = function() {
                    var t, r, n = e14.w, i = e14.X, o = e14.i;
                    return e14.w = n = n + 1640531527 | 0, r = i[o + 34 & 127], t = i[o = o + 1 & 127], r ^= r << 13, t ^= t << 17, r ^= r >>> 15, t ^= t >>> 12, r = i[o] = r ^ t, e14.i = o, r + (n ^ n >>> 16) | 0;
                }, (function(t, e) {
                    var r, n, i, o, a, s = [], u = 128;
                    for(e === (0 | e) ? (n = e, e = null) : (e += "\0", n = 0, u = Math.max(u, e.length)), i = 0, o = -32; o < u; ++o)e && (n ^= e.charCodeAt((o + 32) % e.length)), 0 === o && (a = n), n ^= n << 10, n ^= n >>> 15, n ^= n << 4, n ^= n >>> 13, o >= 0 && (a = a + 1640531527 | 0, i = 0 == (r = s[127 & o] ^= n + a) ? i + 1 : 0);
                    for(i >= 128 && (s[127 & (e && e.length || 0)] = -1), i = 127, o = 512; o > 0; --o)n = s[i + 34 & 127], r = s[i = i + 1 & 127], n ^= n << 13, r ^= r << 17, n ^= n >>> 15, r ^= r >>> 12, s[i] = n ^ r;
                    t.w = a, t.X = s, t.i = i;
                })(e14, t25);
            }(t24), i7 = e13 && e13.state, o3 = function() {
                return (r11.next() >>> 0) / 4294967296;
            };
            return o3.double = function() {
                do var t = ((r11.next() >>> 11) + (r11.next() >>> 0) / 4294967296) / 2097152;
                while (0 === t)
                return t;
            }, o3.int32 = r11.next, o3.quick = o3, i7 && (i7.X && n6(i7, r11), o3.state = function() {
                return n6(r11, {
                });
            }), o3;
        }
        e12 && e12.exports ? e12.exports = i6 : r10 && r10.amd ? r10(function() {
            return i6;
        }) : this.xor4096 = i6;
    }(0, t22, !1);
}), tychei = createCommonjsModule(function(t26) {
    !function(t27, e15, r12) {
        function n7(t, e) {
            return e.a = t.a, e.b = t.b, e.c = t.c, e.d = t.d, e;
        }
        function i8(t28, e16) {
            var r13 = new function(t29) {
                var e = this, r14 = "";
                e.next = function() {
                    var t = e.b, r = e.c, n = e.d, i = e.a;
                    return t = t << 25 ^ t >>> 7 ^ r, r = r - n | 0, n = n << 24 ^ n >>> 8 ^ i, i = i - t | 0, e.b = t = t << 20 ^ t >>> 12 ^ r, e.c = r = r - n | 0, e.d = n << 16 ^ r >>> 16 ^ i, e.a = i - t | 0;
                }, e.a = 0, e.b = 0, e.c = -1640531527, e.d = 1367130551, t29 === Math.floor(t29) ? (e.a = t29 / 4294967296 | 0, e.b = 0 | t29) : r14 += t29;
                for(var n8 = 0; n8 < r14.length + 20; n8++)e.b ^= 0 | r14.charCodeAt(n8), e.next();
            }(t28), i9 = e16 && e16.state, o = function() {
                return (r13.next() >>> 0) / 4294967296;
            };
            return o.double = function() {
                do var t = ((r13.next() >>> 11) + (r13.next() >>> 0) / 4294967296) / 2097152;
                while (0 === t)
                return t;
            }, o.int32 = r13.next, o.quick = o, i9 && ("object" == typeof i9 && n7(i9, r13), o.state = function() {
                return n7(r13, {
                });
            }), o;
        }
        e15 && e15.exports ? e15.exports = i8 : r12 && r12.amd ? r12(function() {
            return i8;
        }) : this.tychei = i8;
    }(0, t26, !1);
}), seedrandom = createCommonjsModule(function(t30) {
    !function(e17, r15) {
        var n9, i10 = this, o4 = 256, a1 = 6, s2 = "random", u = r15.pow(o4, a1), c = r15.pow(2, 52), l = 2 * c, h = o4 - 1;
        function f1(t31, f, v) {
            var _ = [], w = p(function t(e, r) {
                var n, i = [], o = typeof e;
                if (r && "object" == o) for(n in e)try {
                    i.push(t(e[n], r - 1));
                } catch (t32) {
                }
                return i.length ? i : "string" == o ? e : e + "\0";
            }((f = 1 == f ? {
                entropy: !0
            } : f || {
            }).entropy ? [
                t31,
                m(e17)
            ] : null == t31 ? function() {
                try {
                    var t;
                    return n9 && (t = n9.randomBytes) ? t = t(o4) : (t = new Uint8Array(o4), (i10.crypto || i10.msCrypto).getRandomValues(t)), m(t);
                } catch (t) {
                    var r = i10.navigator, a = r && r.plugins;
                    return [
                        +new Date,
                        i10,
                        a,
                        i10.screen,
                        m(e17)
                    ];
                }
            }() : t31, 3), _), y = new function(t33) {
                var e18, r16 = t33.length, n = this, i11 = 0, a2 = n.i = n.j = 0, s3 = n.S = [];
                r16 || (t33 = [
                    r16++
                ]);
                for(; i11 < o4;)s3[i11] = i11++;
                for(i11 = 0; i11 < o4; i11++)s3[i11] = s3[a2 = h & a2 + t33[i11 % r16] + (e18 = s3[i11])], s3[a2] = e18;
                (n.g = function(t) {
                    for(var e, r = 0, i = n.i, a = n.j, s = n.S; t--;)e = s[i = h & i + 1], r = r * o4 + s[h & (s[i] = s[a = h & a + e]) + (s[a] = e)];
                    return n.i = i, n.j = a, r;
                })(o4);
            }(_), g = function() {
                for(var t = y.g(a1), e = u, r = 0; t < c;)t = (t + r) * o4, e *= o4, r = y.g(1);
                for(; t >= l;)t /= 2, e /= 2, r >>>= 1;
                return (t + r) / e;
            };
            return g.int32 = function() {
                return 0 | y.g(4);
            }, g.quick = function() {
                return y.g(4) / 4294967296;
            }, g.double = g, p(m(y.S), e17), (f.pass || v || function(t, e, n, i) {
                return i && (i.S && d(i, y), t.state = function() {
                    return d(y, {
                    });
                }), n ? (r15[s2] = t, e) : t;
            })(g, w, "global" in f ? f.global : this == r15, f.state);
        }
        function d(t, e) {
            return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e;
        }
        function p(t, e) {
            for(var r, n = t + "", i = 0; i < n.length;)e[h & i] = h & (r ^= 19 * e[h & i]) + n.charCodeAt(i++);
            return m(e);
        }
        function m(t) {
            return String.fromCharCode.apply(0, t);
        }
        if (r15["seed" + s2] = f1, p(r15.random(), e17), t30.exports) {
            t30.exports = f1;
            try {
                n9 = require("crypto");
            } catch (t) {
            }
        }
    }([], Math);
});
seedrandom.alea = alea, seedrandom.xor128 = xor128, seedrandom.xorwow = xorwow, seedrandom.xorshift7 = xorshift7, seedrandom.xor4096 = xor4096, seedrandom.tychei = tychei;
var seedrandom$1 = seedrandom, seedrandom_1 = seedrandom$1.alea;
function deepMap(t, e) {
    return deepMapInternal(t, e);
}
function deepMapInternal(t, e, r, n) {
    if (void 0 === r && (r = new Map), void 0 === n && (n = new Set), null == t) return null;
    if (n.has(t)) throw new Error("Circular references are not supported.");
    if (r.has(t)) return r.get(t);
    var i = e(t);
    if (i.recurse && null !== i.value) throw new Error("A deep map function may not return both a value and recurse=true.");
    if (i.recurse) {
        if (isIterable(t)) {
            var o = Array.isArray(t) ? [] : {
            };
            for(var a in n.add(t), t){
                var s = deepMapInternal(t[a], e, r, n);
                o[a] = s;
            }
            return n.delete(t), o;
        }
        throw new Error("Can't recurse into non-iterable type: " + t);
    }
    return r.set(t, i.value), i.value;
}
function deepZip(t, e) {
    return void 0 === e && (e = zipToList), deepZipInternal(t, e);
}
function deepZipInternal(t34, e, r) {
    void 0 === r && (r = new Set);
    var n = t34[0];
    if (r.has(n)) throw new Error("Circular references are not supported.");
    var i12 = e(t34);
    if (i12.recurse && null !== i12.value) throw new Error("A deep zip function may not return both a value and recurse=true.");
    if (i12.recurse) {
        if (isIterable(n)) {
            var o = Array.isArray(n) ? [] : {
            };
            r.add(n);
            var a = function(n) {
                var i = deepZipInternal(t34.map(function(t) {
                    return t[n];
                }), e, r);
                o[n] = i;
            };
            for(var s in n)a(s);
            return r.delete(n), o;
        }
        throw new Error("Can't recurse into non-iterable type: " + n);
    }
    return i12.value;
}
function zipToList(t) {
    return null === t ? null : isIterable(t[0]) ? {
        value: null,
        recurse: !0
    } : {
        value: t,
        recurse: !1
    };
}
function deepMapAndAwaitAll(t, e) {
    return __awaiter(this, void 0, void 0, function() {
        var r, n, i, o, a, s;
        return __generator(this, function(u) {
            switch(u.label){
                case 0:
                    r = new Map, deepMapInternal(t, e, r), n = 0, i = Array.from(r.keys()), u.label = 1;
                case 1:
                    return n < i.length ? (o = i[n], (a = r.get(o)) instanceof Promise ? [
                        4,
                        a
                    ] : [
                        3,
                        3
                    ]) : [
                        3,
                        4
                    ];
                case 2:
                    s = u.sent(), r.set(o, s), u.label = 3;
                case 3:
                    return n++, [
                        3,
                        1
                    ];
                case 4:
                    return [
                        2,
                        deepMapInternal(t, e, r)
                    ];
            }
        });
    });
}
function isIterable(t) {
    return null != t && !ArrayBuffer.isView(t) && (Array.isArray(t) || "object" == typeof t && !(t instanceof _tfjsCore.Tensor));
}
function canTensorify(t) {
    return null == t || isPrimitive(t) || Array.isArray(t) || "object" == typeof t && t instanceof _tfjsCore.Tensor || _tfjsCore.util.isTypedArray(t);
}
function isPrimitive(t) {
    return null === t || "object" != typeof t && "function" != typeof t;
}
function deepClone(t) {
    return deepMap(t, cloneIfTensor);
}
function cloneIfTensor(t) {
    return t instanceof _tfjsCore.Tensor ? {
        value: t.clone(),
        recurse: !1
    } : isIterable(t) ? {
        value: null,
        recurse: !0
    } : {
        value: t,
        recurse: !1
    };
}
var RingBuffer = function() {
    function t35(t) {
        if (this.capacity = t, this.begin = 0, this.end = 0, null == t) throw new RangeError("Can't create a ring buffer of unknown capacity.");
        if (t < 1) throw new RangeError("Can't create ring buffer of capacity < 1.");
        this.data = new Array(t), this.doubledCapacity = 2 * t;
    }
    return t35.prototype.wrap = function(t) {
        for(; t < 0;)t += this.doubledCapacity;
        return t % this.doubledCapacity;
    }, t35.prototype.get = function(t) {
        if (t < 0) throw new RangeError("Can't get item at a negative index.");
        return this.data[t % this.capacity];
    }, t35.prototype.set = function(t, e) {
        if (t < 0) throw new RangeError("Can't set item at a negative index.");
        this.data[t % this.capacity] = e;
    }, t35.prototype.length = function() {
        var t = this.end - this.begin;
        return t < 0 && (t = this.doubledCapacity + t), t;
    }, t35.prototype.isFull = function() {
        return this.length() === this.capacity;
    }, t35.prototype.isEmpty = function() {
        return 0 === this.length();
    }, t35.prototype.push = function(t) {
        if (this.isFull()) throw new RangeError("Ring buffer is full.");
        this.set(this.end, t), this.end = this.wrap(this.end + 1);
    }, t35.prototype.pushAll = function(t) {
        for(var e = 0, r = t; e < r.length; e++){
            var n = r[e];
            this.push(n);
        }
    }, t35.prototype.pop = function() {
        if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
        this.end = this.wrap(this.end - 1);
        var t = this.get(this.end);
        return this.set(this.end, void 0), t;
    }, t35.prototype.unshift = function(t) {
        if (this.isFull()) throw new RangeError("Ring buffer is full.");
        this.begin = this.wrap(this.begin - 1), this.set(this.begin, t);
    }, t35.prototype.shift = function() {
        if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
        var t = this.get(this.begin);
        return this.set(this.begin, void 0), this.begin = this.wrap(this.begin + 1), t;
    }, t35.prototype.shuffleExcise = function(t) {
        if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
        var e = this.wrap(this.begin + t), r = this.get(e);
        return this.set(e, this.pop()), r;
    }, t35;
}(), GrowingRingBuffer = function(t36) {
    function e19() {
        return t36.call(this, e19.INITIAL_CAPACITY) || this;
    }
    return __extends(e19, t36), e19.prototype.isFull = function() {
        return !1;
    }, e19.prototype.push = function(e) {
        t36.prototype.isFull.call(this) && this.expand(), t36.prototype.push.call(this, e);
    }, e19.prototype.unshift = function(e) {
        t36.prototype.isFull.call(this) && this.expand(), t36.prototype.unshift.call(this, e);
    }, e19.prototype.expand = function() {
        for(var t = 2 * this.capacity, e = new Array(t), r = this.length(), n = 0; n < r; n++)e[n] = this.get(this.wrap(this.begin + n));
        this.data = e, this.capacity = t, this.doubledCapacity = 2 * this.capacity, this.begin = 0, this.end = r;
    }, e19.INITIAL_CAPACITY = 32, e19;
}(RingBuffer);
function iteratorFromItems(t) {
    return new ArrayIterator(t);
}
function iteratorFromFunction(t) {
    return new FunctionCallIterator(t);
}
function iteratorFromConcatenated(t, e) {
    return new ChainedIterator(t, e);
}
function iteratorFromZipped(t, e) {
    return void 0 === e && (e = ZipMismatchMode.FAIL), new ZipIterator(t, e);
}
var ZipMismatchMode, LazyIterator = function() {
    function t37() {
    }
    return t37.prototype.toArray = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t, e;
            return __generator(this, function(r) {
                switch(r.label){
                    case 0:
                        return t = [], [
                            4,
                            this.next()
                        ];
                    case 1:
                        e = r.sent(), r.label = 2;
                    case 2:
                        return e.done ? [
                            3,
                            4
                        ] : (t.push(e.value), [
                            4,
                            this.next()
                        ]);
                    case 3:
                        return e = r.sent(), [
                            3,
                            2
                        ];
                    case 4:
                        return [
                            2,
                            t
                        ];
                }
            });
        });
    }, t37.prototype.toArrayForTest = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t, e, r;
            return __generator(this, function(n) {
                switch(n.label){
                    case 0:
                        return t = this.prefetch(100), e = [], [
                            4,
                            t.next()
                        ];
                    case 1:
                        r = n.sent(), n.label = 2;
                    case 2:
                        return r.done ? [
                            3,
                            4
                        ] : (e.push(r.value), [
                            4,
                            t.next()
                        ]);
                    case 3:
                        return r = n.sent(), [
                            3,
                            2
                        ];
                    case 4:
                        return [
                            2,
                            e
                        ];
                }
            });
        });
    }, t37.prototype.resolveFully = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t;
            return __generator(this, function(e) {
                switch(e.label){
                    case 0:
                        return [
                            4,
                            this.next()
                        ];
                    case 1:
                        t = e.sent(), e.label = 2;
                    case 2:
                        return t.done ? [
                            3,
                            4
                        ] : [
                            4,
                            this.next()
                        ];
                    case 3:
                        return t = e.sent(), [
                            3,
                            2
                        ];
                    case 4:
                        return [
                            2
                        ];
                }
            });
        });
    }, t37.prototype.resolveWhile = function(t) {
        return __awaiter(this, void 0, void 0, function() {
            var e, r;
            return __generator(this, function(n) {
                switch(n.label){
                    case 0:
                        return [
                            4,
                            this.next()
                        ];
                    case 1:
                        e = n.sent(), r = t(e.value), n.label = 2;
                    case 2:
                        return e.done || !r ? [
                            3,
                            4
                        ] : [
                            4,
                            this.next()
                        ];
                    case 3:
                        return e = n.sent(), r = t(e.value), [
                            3,
                            2
                        ];
                    case 4:
                        return [
                            2
                        ];
                }
            });
        });
    }, t37.prototype.handleErrors = function(t) {
        return new ErrorHandlingLazyIterator(this, t);
    }, t37.prototype.filter = function(t) {
        return new FilterIterator(this, t);
    }, t37.prototype.map = function(t) {
        return new MapIterator(this, t);
    }, t37.prototype.mapAsync = function(t) {
        return new AsyncMapIterator(this, t);
    }, t37.prototype.serialMapAsync = function(t) {
        return new AsyncMapIterator(this, t).serial();
    }, t37.prototype.flatmap = function(t) {
        return new FlatmapIterator(this, t);
    }, t37.prototype.forEachAsync = function(t) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(e) {
                return [
                    2,
                    this.map(t).resolveFully()
                ];
            });
        });
    }, t37.prototype.serialForEach = function(t38) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(e) {
                return [
                    2,
                    this.serialMapAsync(t38).resolveWhile(function(t) {
                        return !0 === t;
                    })
                ];
            });
        });
    }, t37.prototype.rowMajorBatch = function(t, e) {
        return void 0 === e && (e = !0), new RowMajorBatchIterator(this, t, e);
    }, t37.prototype.columnMajorBatch = function(t39, e, r) {
        return void 0 === e && (e = !0), void 0 === r && (r = zipToList), this.rowMajorBatch(t39, e).map(function(t) {
            return deepZip(t, r);
        });
    }, t37.prototype.concatenate = function(t, e) {
        return new ChainedIterator(iteratorFromItems([
            this,
            t
        ]), e);
    }, t37.prototype.take = function(t) {
        return t < 0 || null == t ? this : new TakeIterator(this, t);
    }, t37.prototype.skip = function(t) {
        return t < 0 || null == t ? this : new SkipIterator(this, t);
    }, t37.prototype.prefetch = function(t) {
        return new PrefetchIterator(this, t);
    }, t37.prototype.shuffle = function(t, e) {
        return new ShuffleIterator(this, t, e);
    }, t37.prototype.serial = function() {
        return new SerialIterator(this);
    }, t37;
}(), ArrayIterator = function(t40) {
    function e20(e) {
        var r = t40.call(this) || this;
        return r.items = e, r.trav = 0, r;
    }
    return __extends(e20, t40), e20.prototype.summary = function() {
        return "Array of " + this.items.length + " items";
    }, e20.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t;
            return __generator(this, function(e) {
                return this.trav >= this.items.length ? [
                    2,
                    {
                        value: null,
                        done: !0
                    }
                ] : (t = this.items[this.trav], this.trav++, [
                    2,
                    {
                        value: deepClone(t),
                        done: !1
                    }
                ]);
            });
        });
    }, e20;
}(LazyIterator), FunctionCallIterator = function(t) {
    function e21(e) {
        var r = t.call(this) || this;
        return r.nextFn = e, r;
    }
    return __extends(e21, t), e21.prototype.summary = function() {
        return "Function call";
    }, e21.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(t) {
                try {
                    return [
                        2,
                        this.nextFn()
                    ];
                } catch (t41) {
                    throw t41.message = "Error thrown while iterating through a dataset: " + t41.message, t41;
                }
                return [
                    2
                ];
            });
        });
    }, e21;
}(LazyIterator), SerialIterator = function(t42) {
    function e22(e) {
        var r = t42.call(this) || this;
        return r.upstream = e, r.lastRead = Promise.resolve({
            value: null,
            done: !1
        }), r;
    }
    return __extends(e22, t42), e22.prototype.summary = function() {
        return this.upstream.summary() + " -> Serial";
    }, e22.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t = this;
            return __generator(this, function(e) {
                return this.lastRead = this.lastRead.then(function() {
                    return t.serialNext();
                }), [
                    2,
                    this.lastRead
                ];
            });
        });
    }, e22.prototype.serialNext = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(t) {
                return [
                    2,
                    this.upstream.next()
                ];
            });
        });
    }, e22;
}(LazyIterator), SkipIterator = function(t43) {
    function e23(e, r) {
        var n = t43.call(this) || this;
        return n.upstream = e, n.maxCount = r, n.count = 0, n.lastRead = Promise.resolve({
            value: null,
            done: !1
        }), n;
    }
    return __extends(e23, t43), e23.prototype.summary = function() {
        return this.upstream.summary() + " -> Skip";
    }, e23.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t = this;
            return __generator(this, function(e) {
                return this.lastRead = this.lastRead.then(function() {
                    return t.serialNext();
                }), [
                    2,
                    this.lastRead
                ];
            });
        });
    }, e23.prototype.serialNext = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t;
            return __generator(this, function(e) {
                switch(e.label){
                    case 0:
                        return (this.count++) < this.maxCount ? [
                            4,
                            this.upstream.next()
                        ] : [
                            3,
                            2
                        ];
                    case 1:
                        return (t = e.sent()).done ? [
                            2,
                            t
                        ] : (_tfjsCore.dispose(t.value), [
                            3,
                            0
                        ]);
                    case 2:
                        return [
                            2,
                            this.upstream.next()
                        ];
                }
            });
        });
    }, e23;
}(LazyIterator), TakeIterator = function(t) {
    function e24(e, r) {
        var n = t.call(this) || this;
        return n.upstream = e, n.maxCount = r, n.count = 0, n;
    }
    return __extends(e24, t), e24.prototype.summary = function() {
        return this.upstream.summary() + " -> Take";
    }, e24.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(t) {
                return (this.count++) >= this.maxCount ? [
                    2,
                    {
                        value: null,
                        done: !0
                    }
                ] : [
                    2,
                    this.upstream.next()
                ];
            });
        });
    }, e24;
}(LazyIterator), RowMajorBatchIterator = function(t44) {
    function e25(e, r, n) {
        void 0 === n && (n = !0);
        var i = t44.call(this) || this;
        return i.upstream = e, i.batchSize = r, i.enableSmallLastBatch = n, i.lastRead = Promise.resolve({
            value: null,
            done: !1
        }), i;
    }
    return __extends(e25, t44), e25.prototype.summary = function() {
        return this.upstream.summary() + " -> RowMajorBatch";
    }, e25.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t = this;
            return __generator(this, function(e) {
                return this.lastRead = this.lastRead.then(function() {
                    return t.serialNext();
                }), [
                    2,
                    this.lastRead
                ];
            });
        });
    }, e25.prototype.serialNext = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t, e;
            return __generator(this, function(r) {
                switch(r.label){
                    case 0:
                        t = [], r.label = 1;
                    case 1:
                        return t.length < this.batchSize ? [
                            4,
                            this.upstream.next()
                        ] : [
                            3,
                            3
                        ];
                    case 2:
                        return (e = r.sent()).done ? this.enableSmallLastBatch && t.length > 0 ? [
                            2,
                            {
                                value: t,
                                done: !1
                            }
                        ] : [
                            2,
                            {
                                value: null,
                                done: !0
                            }
                        ] : (t.push(e.value), [
                            3,
                            1
                        ]);
                    case 3:
                        return [
                            2,
                            {
                                value: t,
                                done: !1
                            }
                        ];
                }
            });
        });
    }, e25;
}(LazyIterator), FilterIterator = function(t45) {
    function e26(e, r) {
        var n = t45.call(this) || this;
        return n.upstream = e, n.predicate = r, n.lastRead = Promise.resolve({
            value: null,
            done: !1
        }), n;
    }
    return __extends(e26, t45), e26.prototype.summary = function() {
        return this.upstream.summary() + " -> Filter";
    }, e26.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t = this;
            return __generator(this, function(e) {
                return this.lastRead = this.lastRead.then(function() {
                    return t.serialNext();
                }), [
                    2,
                    this.lastRead
                ];
            });
        });
    }, e26.prototype.serialNext = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t;
            return __generator(this, function(e) {
                switch(e.label){
                    case 0:
                        return [
                            4,
                            this.upstream.next()
                        ];
                    case 1:
                        return (t = e.sent()).done || this.predicate(t.value) ? [
                            2,
                            t
                        ] : (_tfjsCore.dispose(t.value), [
                            3,
                            0
                        ]);
                    case 2:
                        return [
                            2
                        ];
                }
            });
        });
    }, e26;
}(LazyIterator), MapIterator = function(t46) {
    function e27(e, r) {
        var n = t46.call(this) || this;
        return n.upstream = e, n.transform = r, n;
    }
    return __extends(e27, t46), e27.prototype.summary = function() {
        return this.upstream.summary() + " -> Map";
    }, e27.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t, e, r, n, i, o, a;
            return __generator(this, function(s) {
                switch(s.label){
                    case 0:
                        return [
                            4,
                            this.upstream.next()
                        ];
                    case 1:
                        if ((t = s.sent()).done) return [
                            2,
                            {
                                value: null,
                                done: !0
                            }
                        ];
                        for(e = _tfjsCore.tensor_util.getTensorsInContainer(t.value), r = this.transform(t.value), n = _tfjsCore.tensor_util.getTensorsInContainer(r), i = 0, o = e; i < o.length; i++)a = o[i], _tfjsCore.tensor_util.isTensorInList(a, n) || a.dispose();
                        return [
                            2,
                            {
                                value: r,
                                done: !1
                            }
                        ];
                }
            });
        });
    }, e27;
}(LazyIterator), ErrorHandlingLazyIterator = function(t47) {
    function e28(e, r) {
        var n = t47.call(this) || this;
        return n.upstream = e, n.handler = r, n.count = 0, n.lastRead = Promise.resolve({
            value: null,
            done: !1
        }), n;
    }
    return __extends(e28, t47), e28.prototype.summary = function() {
        return this.upstream.summary() + " -> handleErrors";
    }, e28.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t = this;
            return __generator(this, function(e) {
                return this.lastRead = this.lastRead.then(function() {
                    return t.serialNext();
                }), [
                    2,
                    this.lastRead
                ];
            });
        });
    }, e28.prototype.serialNext = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t;
            return __generator(this, function(e) {
                switch(e.label){
                    case 0:
                        e.label = 1;
                    case 1:
                        return e.trys.push([
                            1,
                            3,
                            ,
                            4
                        ]), [
                            4,
                            this.upstream.next()
                        ];
                    case 2:
                        return [
                            2,
                            e.sent()
                        ];
                    case 3:
                        return t = e.sent(), this.handler(t) ? [
                            3,
                            4
                        ] : [
                            2,
                            {
                                value: null,
                                done: !0
                            }
                        ];
                    case 4:
                        return [
                            3,
                            0
                        ];
                    case 5:
                        return [
                            2
                        ];
                }
            });
        });
    }, e28;
}(LazyIterator), AsyncMapIterator = function(t48) {
    function e29(e, r) {
        var n = t48.call(this) || this;
        return n.upstream = e, n.transform = r, n;
    }
    return __extends(e29, t48), e29.prototype.summary = function() {
        return this.upstream.summary() + " -> AsyncMap";
    }, e29.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t, e, r, n, i, o, a;
            return __generator(this, function(s) {
                switch(s.label){
                    case 0:
                        return [
                            4,
                            this.upstream.next()
                        ];
                    case 1:
                        return (t = s.sent()).done ? [
                            2,
                            {
                                value: null,
                                done: !0
                            }
                        ] : (e = _tfjsCore.tensor_util.getTensorsInContainer(t.value), [
                            4,
                            this.transform(t.value)
                        ]);
                    case 2:
                        for(r = s.sent(), n = _tfjsCore.tensor_util.getTensorsInContainer(r), i = 0, o = e; i < o.length; i++)a = o[i], _tfjsCore.tensor_util.isTensorInList(a, n) || a.dispose();
                        return [
                            2,
                            {
                                value: r,
                                done: !1
                            }
                        ];
                }
            });
        });
    }, e29;
}(LazyIterator), OneToManyIterator = function(t49) {
    function e30() {
        var e = t49.call(this) || this;
        return e.outputQueue = new GrowingRingBuffer, e.lastRead = Promise.resolve({
            value: null,
            done: !1
        }), e;
    }
    return __extends(e30, t49), e30.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t = this;
            return __generator(this, function(e) {
                return this.lastRead = this.lastRead.then(function() {
                    return t.serialNext();
                }), [
                    2,
                    this.lastRead
                ];
            });
        });
    }, e30.prototype.serialNext = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(t) {
                switch(t.label){
                    case 0:
                        return 0 !== this.outputQueue.length() ? [
                            3,
                            2
                        ] : [
                            4,
                            this.pump()
                        ];
                    case 1:
                        return t.sent() ? [
                            3,
                            0
                        ] : [
                            2,
                            {
                                value: null,
                                done: !0
                            }
                        ];
                    case 2:
                        return [
                            2,
                            {
                                value: this.outputQueue.shift(),
                                done: !1
                            }
                        ];
                }
            });
        });
    }, e30;
}(LazyIterator), FlatmapIterator = function(t50) {
    function e31(e, r) {
        var n = t50.call(this) || this;
        return n.upstream = e, n.transform = r, n;
    }
    return __extends(e31, t50), e31.prototype.summary = function() {
        return this.upstream.summary() + " -> Flatmap";
    }, e31.prototype.pump = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t, e, r, n, i, o, a;
            return __generator(this, function(s) {
                switch(s.label){
                    case 0:
                        return [
                            4,
                            this.upstream.next()
                        ];
                    case 1:
                        if ((t = s.sent()).done) return [
                            2,
                            !1
                        ];
                        for(e = _tfjsCore.tensor_util.getTensorsInContainer(t.value), r = this.transform(t.value), n = _tfjsCore.tensor_util.getTensorsInContainer(r), this.outputQueue.pushAll(r), i = 0, o = e; i < o.length; i++)a = o[i], _tfjsCore.tensor_util.isTensorInList(a, n) || a.dispose();
                        return [
                            2,
                            !0
                        ];
                }
            });
        });
    }, e31;
}(OneToManyIterator), ChainedIterator = function(t51) {
    function e32(e, r) {
        var n = t51.call(this) || this;
        return n.baseErrorHandler = r, n.lastRead = null, n.iterator = null, n.moreIterators = e, n;
    }
    return __extends(e32, t51), e32.prototype.summary = function() {
        return "TODO: fill in upstream of chained summaries -> Chained";
    }, e32.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(t) {
                return this.lastRead = this.readFromChain(this.lastRead), [
                    2,
                    this.lastRead
                ];
            });
        });
    }, e32.prototype.readFromChain = function(t) {
        return __awaiter(this, void 0, void 0, function() {
            var e, r;
            return __generator(this, function(n) {
                switch(n.label){
                    case 0:
                        return [
                            4,
                            t
                        ];
                    case 1:
                        return n.sent(), null != this.iterator ? [
                            3,
                            3
                        ] : [
                            4,
                            this.moreIterators.next()
                        ];
                    case 2:
                        if ((e = n.sent()).done) return [
                            2,
                            {
                                value: null,
                                done: !0
                            }
                        ];
                        this.iterator = e.value, null != this.baseErrorHandler && (this.iterator = this.iterator.handleErrors(this.baseErrorHandler)), n.label = 3;
                    case 3:
                        return [
                            4,
                            this.iterator.next()
                        ];
                    case 4:
                        return (r = n.sent()).done ? (this.iterator = null, [
                            2,
                            this.readFromChain(t)
                        ]) : [
                            2,
                            r
                        ];
                }
            });
        });
    }, e32;
}(LazyIterator);
!function(t) {
    t[t.FAIL = 0] = "FAIL", t[t.SHORTEST = 1] = "SHORTEST", t[t.LONGEST = 2] = "LONGEST";
}(ZipMismatchMode || (ZipMismatchMode = {
}));
var ZipIterator = function(t52) {
    function e33(e, r) {
        void 0 === r && (r = ZipMismatchMode.FAIL);
        var n = t52.call(this) || this;
        return n.iterators = e, n.mismatchMode = r, n.count = 0, n.currentPromise = null, n;
    }
    return __extends(e33, t52), e33.prototype.summary = function() {
        return "{TODO: fill in upstream of zip summaries} -> Zip";
    }, e33.prototype.nextState = function(t53) {
        return __awaiter(this, void 0, void 0, function() {
            function e(t54) {
                return t54 instanceof LazyIterator ? {
                    value: t54.next().then(function(t) {
                        return r++, t.done && n++, t.value;
                    }),
                    recurse: !1
                } : {
                    value: null,
                    recurse: !0
                };
            }
            var r, n, i;
            return __generator(this, function(o) {
                switch(o.label){
                    case 0:
                        return [
                            4,
                            t53
                        ];
                    case 1:
                        return o.sent(), r = 0, n = 0, [
                            4,
                            deepMapAndAwaitAll(this.iterators, e)
                        ];
                    case 2:
                        if (i = o.sent(), r === n) return [
                            2,
                            {
                                value: null,
                                done: !0
                            }
                        ];
                        if (n > 0) switch(this.mismatchMode){
                            case ZipMismatchMode.FAIL:
                                throw new Error("Zipped streams should have the same length. Mismatched at element " + this.count + ".");
                            case ZipMismatchMode.SHORTEST:
                                return [
                                    2,
                                    {
                                        value: null,
                                        done: !0
                                    }
                                ];
                            case ZipMismatchMode.LONGEST:
                        }
                        return this.count++, [
                            2,
                            {
                                value: i,
                                done: !1
                            }
                        ];
                }
            });
        });
    }, e33.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(t) {
                return this.currentPromise = this.nextState(this.currentPromise), [
                    2,
                    this.currentPromise
                ];
            });
        });
    }, e33;
}(LazyIterator), PrefetchIterator = function(t55) {
    function e34(e, r) {
        var n = t55.call(this) || this;
        return n.upstream = e, n.bufferSize = r, n.buffer = new RingBuffer(r), n;
    }
    return __extends(e34, t55), e34.prototype.summary = function() {
        return this.upstream.summary() + " -> Prefetch";
    }, e34.prototype.refill = function() {
        for(; !this.buffer.isFull();){
            var t = this.upstream.next();
            this.buffer.push(t);
        }
    }, e34.prototype.next = function() {
        return this.refill(), this.buffer.shift();
    }, e34;
}(LazyIterator), ShuffleIterator = function(t56) {
    function e35(e, r, n) {
        var i = t56.call(this, e, r) || this;
        return i.upstream = e, i.windowSize = r, i.upstreamExhausted = !1, i.random = seedrandom_1(n || _tfjsCore.util.now().toString()), i.lastRead = Promise.resolve({
            value: null,
            done: !1
        }), i;
    }
    return __extends(e35, t56), e35.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t = this;
            return __generator(this, function(e) {
                return this.lastRead = this.lastRead.then(function() {
                    return t.serialNext();
                }), [
                    2,
                    this.lastRead
                ];
            });
        });
    }, e35.prototype.randomInt = function(t) {
        return Math.floor(this.random() * t);
    }, e35.prototype.chooseIndex = function() {
        return this.randomInt(this.buffer.length());
    }, e35.prototype.serialNext = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t, e;
            return __generator(this, function(r) {
                switch(r.label){
                    case 0:
                        this.upstreamExhausted || this.refill(), r.label = 1;
                    case 1:
                        return this.buffer.isEmpty() ? [
                            3,
                            3
                        ] : (t = this.chooseIndex(), [
                            4,
                            this.buffer.shuffleExcise(t)
                        ]);
                    case 2:
                        return (e = r.sent()).done ? (this.upstreamExhausted = !0, [
                            3,
                            1
                        ]) : (this.refill(), [
                            2,
                            e
                        ]);
                    case 3:
                        return [
                            2,
                            {
                                value: null,
                                done: !0
                            }
                        ];
                }
            });
        });
    }, e35;
}(PrefetchIterator), Dataset = function() {
    function t57() {
        this.size = null;
    }
    return t57.prototype.batch = function(t, e) {
        var r17 = this;
        void 0 === e && (e = !0);
        var n = this;
        return _tfjsCore.util.assert(t > 0, function() {
            return "batchSize needs to be positive, but it is\n      " + t;
        }), datasetFromIteratorFn(function() {
            return __awaiter(r17, void 0, void 0, function() {
                return __generator(this, function(r) {
                    switch(r.label){
                        case 0:
                            return [
                                4,
                                n.iterator()
                            ];
                        case 1:
                            return [
                                2,
                                r.sent().columnMajorBatch(t, e, deepBatchConcat)
                            ];
                    }
                });
            });
        }, this.size === 1 / 0 || null == this.size ? this.size : e ? Math.ceil(this.size / t) : Math.floor(this.size / t));
    }, t57.prototype.concatenate = function(t) {
        var e36 = this, r = this;
        return datasetFromIteratorFn(function() {
            return __awaiter(e36, void 0, void 0, function() {
                var e, n;
                return __generator(this, function(i) {
                    switch(i.label){
                        case 0:
                            return [
                                4,
                                r.iterator()
                            ];
                        case 1:
                            return n = (e = i.sent()).concatenate, [
                                4,
                                t.iterator()
                            ];
                        case 2:
                            return [
                                2,
                                n.apply(e, [
                                    i.sent()
                                ])
                            ];
                    }
                });
            });
        }, this.size === 1 / 0 || t.size === 1 / 0 ? 1 / 0 : null != this.size && null != t.size ? this.size + t.size : null);
    }, t57.prototype.filter = function(t) {
        var e37 = this, r = this;
        return datasetFromIteratorFn(function() {
            return __awaiter(e37, void 0, void 0, function() {
                return __generator(this, function(e38) {
                    switch(e38.label){
                        case 0:
                            return [
                                4,
                                r.iterator()
                            ];
                        case 1:
                            return [
                                2,
                                e38.sent().filter(function(e) {
                                    return _tfjsCore.tidy(function() {
                                        return t(e);
                                    });
                                })
                            ];
                    }
                });
            });
        }, this.size === 1 / 0 ? 1 / 0 : null);
    }, t57.prototype.forEachAsync = function(t) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(e) {
                switch(e.label){
                    case 0:
                        return [
                            4,
                            this.iterator()
                        ];
                    case 1:
                        return [
                            2,
                            e.sent().forEachAsync(t)
                        ];
                }
            });
        });
    }, t57.prototype.forEach = function(t) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(e) {
                return _tfjsCore.deprecationWarn("dataset.forEach() is deprecated and will be removed. Please use dataset.forEachAsync() instead"), [
                    2,
                    this.forEachAsync(t)
                ];
            });
        });
    }, t57.prototype.map = function(t) {
        var e39 = this, r = this;
        return datasetFromIteratorFn(function() {
            return __awaiter(e39, void 0, void 0, function() {
                return __generator(this, function(e40) {
                    switch(e40.label){
                        case 0:
                            return [
                                4,
                                r.iterator()
                            ];
                        case 1:
                            return [
                                2,
                                e40.sent().map(function(e) {
                                    return _tfjsCore.tidy(function() {
                                        return t(e);
                                    });
                                })
                            ];
                    }
                });
            });
        }, this.size);
    }, t57.prototype.mapAsync = function(t) {
        var e41 = this, r = this;
        return datasetFromIteratorFn(function() {
            return __awaiter(e41, void 0, void 0, function() {
                return __generator(this, function(e) {
                    switch(e.label){
                        case 0:
                            return [
                                4,
                                r.iterator()
                            ];
                        case 1:
                            return [
                                2,
                                e.sent().mapAsync(t)
                            ];
                    }
                });
            });
        }, this.size);
    }, t57.prototype.prefetch = function(t) {
        var e42 = this;
        if (null == t) throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
        var r = this;
        return datasetFromIteratorFn(function() {
            return __awaiter(e42, void 0, void 0, function() {
                return __generator(this, function(e) {
                    switch(e.label){
                        case 0:
                            return [
                                4,
                                r.iterator()
                            ];
                        case 1:
                            return [
                                2,
                                e.sent().prefetch(t)
                            ];
                    }
                });
            });
        }, this.size);
    }, t57.prototype.repeat = function(t58) {
        var e43 = this, r = this;
        return datasetFromIteratorFn(function() {
            return __awaiter(e43, void 0, void 0, function() {
                var e44 = this;
                return __generator(this, function(n) {
                    return [
                        2,
                        iteratorFromConcatenated(iteratorFromFunction(function() {
                            return __awaiter(e44, void 0, void 0, function() {
                                var t;
                                return __generator(this, function(e) {
                                    switch(e.label){
                                        case 0:
                                            return t = {
                                            }, [
                                                4,
                                                r.iterator()
                                            ];
                                        case 1:
                                            return [
                                                2,
                                                (t.value = e.sent(), t.done = !1, t)
                                            ];
                                    }
                                });
                            });
                        }).take(t58))
                    ];
                });
            });
        }, null != this.size && t58 > 0 ? this.size * t58 : 0 === t58 ? 0 : null != this.size && (void 0 === t58 || t58 < 0) ? 1 / 0 : null);
    }, t57.prototype.skip = function(t) {
        var e45 = this, r = this;
        return datasetFromIteratorFn(function() {
            return __awaiter(e45, void 0, void 0, function() {
                return __generator(this, function(e) {
                    switch(e.label){
                        case 0:
                            return [
                                4,
                                r.iterator()
                            ];
                        case 1:
                            return [
                                2,
                                e.sent().skip(t)
                            ];
                    }
                });
            });
        }, null != this.size && t >= 0 && this.size >= t ? this.size - t : null != this.size && (this.size < t || void 0 === t || t < 0) ? 0 : null);
    }, t57.prototype.shuffle = function(t, e46, r) {
        var n10 = this;
        if (void 0 === r && (r = !0), null == t || t < 0) throw null == this.size ? new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.") : new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting bufferSize to the dataset size (" + this.size + " elements)");
        var i = this, o = seedrandom_1(e46 || _tfjsCore.util.now().toString());
        return datasetFromIteratorFn(function() {
            return __awaiter(n10, void 0, void 0, function() {
                var e;
                return __generator(this, function(n) {
                    switch(n.label){
                        case 0:
                            return e = o.int32(), r && (e += o.int32()), [
                                4,
                                i.iterator()
                            ];
                        case 1:
                            return [
                                2,
                                n.sent().shuffle(t, e.toString())
                            ];
                    }
                });
            });
        }, this.size);
    }, t57.prototype.take = function(t) {
        var e47 = this, r = this;
        return datasetFromIteratorFn(function() {
            return __awaiter(e47, void 0, void 0, function() {
                return __generator(this, function(e) {
                    switch(e.label){
                        case 0:
                            return [
                                4,
                                r.iterator()
                            ];
                        case 1:
                            return [
                                2,
                                e.sent().take(t)
                            ];
                    }
                });
            });
        }, null != this.size && this.size > t ? t : null != this.size && this.size <= t ? this.size : null);
    }, t57.prototype.toArray = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(t) {
                switch(t.label){
                    case 0:
                        if (this.size === 1 / 0) throw new Error("Can not convert infinite data stream to array.");
                        return [
                            4,
                            this.iterator()
                        ];
                    case 1:
                        return [
                            2,
                            t.sent().toArray()
                        ];
                }
            });
        });
    }, t57.prototype.toArrayForTest = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(t) {
                switch(t.label){
                    case 0:
                        if (this.size === 1 / 0) throw new Error("Can not convert infinite data stream to array.");
                        return [
                            4,
                            this.iterator()
                        ];
                    case 1:
                        return [
                            2,
                            t.sent().toArrayForTest()
                        ];
                }
            });
        });
    }, t57.MAX_BUFFER_SIZE = 10000, t57;
}();
function datasetFromIteratorFn(t59, e) {
    return void 0 === e && (e = null), new (function(r) {
        function n() {
            var t = null !== r && r.apply(this, arguments) || this;
            return t.size = e, t;
        }
        return __extends(n, r), n.prototype.iterator = function() {
            return __awaiter(this, void 0, void 0, function() {
                return __generator(this, function(e) {
                    return [
                        2,
                        t59()
                    ];
                });
            });
        }, n;
    }(Dataset));
}
function array(t) {
    var e = this;
    return datasetFromIteratorFn(function() {
        return __awaiter(e, void 0, void 0, function() {
            return __generator(this, function(e) {
                return [
                    2,
                    iteratorFromItems(t)
                ];
            });
        });
    }, t.length);
}
function zip(t60) {
    var e48, r = this;
    if (!isIterable(t60)) throw new Error("The argument to zip() must be an object or array.");
    if (Array.isArray(t60)) for(var n = 0; n < t60.length; n++)e48 = null == e48 ? t60[n].size : Math.min(e48, t60[n].size);
    else if (t60 instanceof Object) for(var i in t60)e48 = null == e48 ? t60[i].size : Math.min(e48, t60[i].size);
    return datasetFromIteratorFn(function() {
        return __awaiter(r, void 0, void 0, function() {
            return __generator(this, function(e) {
                switch(e.label){
                    case 0:
                        return [
                            4,
                            deepMapAndAwaitAll(t60, function(t) {
                                if (t instanceof Dataset) return {
                                    value: t.iterator(),
                                    recurse: !1
                                };
                                if (isIterable(t)) return {
                                    value: null,
                                    recurse: !0
                                };
                                throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.");
                            })
                        ];
                    case 1:
                        return [
                            2,
                            iteratorFromZipped(e.sent(), ZipMismatchMode.SHORTEST)
                        ];
                }
            });
        });
    }, e48);
}
function deepBatchConcat(t) {
    return null === t ? null : canTensorify(t[0]) ? {
        value: batchConcat(t),
        recurse: !1
    } : {
        value: null,
        recurse: !0
    };
}
function batchConcat(t) {
    if (0 === t.length) throw new Error("Can't make a batch of zero elements.");
    return t[0] instanceof _tfjsCore.Tensor ? _tfjsCore.stack(t) : _tfjsCore.tensor(t);
}
var TextLineDataset = function(t61) {
    function e49(e) {
        var r = t61.call(this) || this;
        return r.input = e, r;
    }
    return __extends(e49, t61), e49.prototype.iterator = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t62, e;
            return __generator(this, function(r) {
                switch(r.label){
                    case 0:
                        return [
                            4,
                            this.input.iterator()
                        ];
                    case 1:
                        return t62 = r.sent(), e = t62.decodeUTF8(), [
                            2,
                            e.split("\n").map(function(t) {
                                return t.endsWith("\r") && (t = t.slice(0, -1)), t;
                            })
                        ];
                }
            });
        });
    }, e49;
}(Dataset), CODE_QUOTE = '"', STATE_OUT = Symbol("out"), STATE_FIELD = Symbol("field"), STATE_QUOTE = Symbol("quote"), STATE_QUOTE_AFTER_QUOTE = Symbol("quoteafterquote"), STATE_WITHIN_QUOTE_IN_QUOTE = Symbol("quoteinquote"), CSVDataset = function(t63) {
    function e50(e, r) {
        var n = t63.call(this) || this;
        return n.input = e, n.hasHeader = !0, n.fullColumnNames = null, n.columnNamesValidated = !1, n.columnConfigs = null, n.configuredColumnsOnly = !1, n.delimiter = ",", n.delimWhitespace = !1, n.base = new TextLineDataset(e), r || (r = {
        }), n.hasHeader = !1 !== r.hasHeader, n.fullColumnNames = r.columnNames, n.columnConfigs = r.columnConfigs, n.configuredColumnsOnly = r.configuredColumnsOnly, r.delimWhitespace ? (_tfjsCore.util.assert(null == r.delimiter, function() {
            return "Delimiter should not be provided when delimWhitespace is true.";
        }), n.delimWhitespace = !0, n.delimiter = " ") : n.delimiter = r.delimiter ? r.delimiter : ",", n;
    }
    return __extends(e50, t63), e50.prototype.columnNames = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(t) {
                switch(t.label){
                    case 0:
                        return this.columnNamesValidated ? [
                            3,
                            2
                        ] : [
                            4,
                            this.setColumnNames()
                        ];
                    case 1:
                        t.sent(), t.label = 2;
                    case 2:
                        return [
                            2,
                            this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames
                        ];
                }
            });
        });
    }, e50.prototype.setColumnNames = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t64, e, r, n, i, o, a = this;
            return __generator(this, function(s) {
                switch(s.label){
                    case 0:
                        return [
                            4,
                            this.maybeReadHeaderLine()
                        ];
                    case 1:
                        if (t64 = s.sent(), !this.fullColumnNames && !t64) throw new Error("Column names must be provided if there is no header line.");
                        if (this.fullColumnNames && t64 && _tfjsCore.util.assert(t64.length === this.fullColumnNames.length, function() {
                            return "The length of provided columnNames (" + a.fullColumnNames.length.toString() + ") does not match the length of the header line read from file (" + t64.length.toString() + ").";
                        }), this.fullColumnNames || (this.fullColumnNames = t64), e = this.fullColumnNames.reduce(function(t, e) {
                            return t[e] = t[e] + 1 || 1, t;
                        }, {
                        }), r = Object.keys(e).filter(function(t) {
                            return e[t] > 1;
                        }), _tfjsCore.util.assert(0 === r.length, function() {
                            return "Duplicate column names found: " + r.toString();
                        }), this.columnConfigs) {
                            for(n = 0, i = Object.keys(this.columnConfigs); n < i.length; n++)if (o = i[n], -1 === this.fullColumnNames.indexOf(o)) throw new Error('The key "' + o + '" provided in columnConfigs does not match any of the column names (' + this.fullColumnNames.toString() + ").");
                        }
                        return this.columnNamesValidated = !0, [
                            2
                        ];
                }
            });
        });
    }, e50.prototype.maybeReadHeaderLine = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t, e;
            return __generator(this, function(r) {
                switch(r.label){
                    case 0:
                        return this.hasHeader ? [
                            4,
                            this.base.iterator()
                        ] : [
                            3,
                            3
                        ];
                    case 1:
                        return [
                            4,
                            r.sent().next()
                        ];
                    case 2:
                        if ((t = r.sent()).done) throw new Error("No data was found for CSV parsing.");
                        return e = t.value, [
                            2,
                            this.parseRow(e, !1)
                        ];
                    case 3:
                        return [
                            2,
                            null
                        ];
                }
            });
        });
    }, e50.prototype.iterator = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t65, e = this;
            return __generator(this, function(r) {
                switch(r.label){
                    case 0:
                        return this.columnNamesValidated ? [
                            3,
                            2
                        ] : [
                            4,
                            this.setColumnNames()
                        ];
                    case 1:
                        r.sent(), r.label = 2;
                    case 2:
                        return [
                            4,
                            this.base.iterator()
                        ];
                    case 3:
                        return t65 = r.sent(), this.hasHeader && (t65 = t65.skip(1)), [
                            2,
                            t65.map(function(t) {
                                return e.makeDataElement(t);
                            })
                        ];
                }
            });
        });
    }, e50.prototype.makeDataElement = function(t) {
        for(var e = this.parseRow(t), r = {
        }, n = {
        }, i = 0; i < this.fullColumnNames.length; i++){
            var o = this.fullColumnNames[i], a = this.columnConfigs ? this.columnConfigs[o] : null;
            if (!this.configuredColumnsOnly || a) {
                var s = e[i], u = null;
                if ("" === s) {
                    if (a && void 0 !== a.default) u = a.default;
                    else {
                        if (a && (a.required || a.isLabel)) throw new Error("Required column " + o + " is empty in this line: " + t);
                        u = void 0;
                    }
                } else {
                    var c = Number(s);
                    if (isNaN(c)) u = a && "bool" === a.dtype ? this.getBoolean(s) : s;
                    else if (a && a.dtype) switch(a.dtype){
                        case "float32":
                            u = c;
                            break;
                        case "int32":
                            u = Math.floor(c);
                            break;
                        case "bool":
                            u = this.getBoolean(s);
                            break;
                        default:
                            u = c;
                    }
                    else u = c;
                }
                a && a.isLabel ? n[o] = u : r[o] = u;
            }
        }
        return 0 === Object.keys(n).length ? r : {
            xs: r,
            ys: n
        };
    }, e50.prototype.getBoolean = function(t) {
        return "1" === t || "true" === t.toLowerCase() ? 1 : 0;
    }, e50.prototype.parseRow = function(t, e) {
        void 0 === e && (e = !0);
        for(var r = [], n = 0, i = t.length, o = STATE_OUT, a = 0; a < i; a++)switch(o){
            case STATE_OUT:
                switch(t.charAt(a)){
                    case CODE_QUOTE:
                        n = a + 1, o = STATE_QUOTE;
                        break;
                    case this.delimiter:
                        if (n = a + 1, " " === this.delimiter && this.delimWhitespace) break;
                        r.push(""), o = STATE_OUT;
                        break;
                    default:
                        o = STATE_FIELD, n = a;
                }
                break;
            case STATE_FIELD:
                switch(t.charAt(a)){
                    case this.delimiter:
                        r.push(t.substring(n, a)), o = STATE_OUT, n = a + 1;
                }
                break;
            case STATE_QUOTE:
                switch(t.charAt(a)){
                    case CODE_QUOTE:
                        o = STATE_QUOTE_AFTER_QUOTE;
                }
                break;
            case STATE_QUOTE_AFTER_QUOTE:
                switch(t.charAt(a)){
                    case this.delimiter:
                        r.push(t.substring(n, a - 1)), o = STATE_OUT, n = a + 1;
                        break;
                    case CODE_QUOTE:
                        o = STATE_QUOTE;
                        break;
                    default:
                        o = STATE_WITHIN_QUOTE_IN_QUOTE;
                }
                break;
            case STATE_WITHIN_QUOTE_IN_QUOTE:
                switch(t.charAt(a)){
                    case CODE_QUOTE:
                        o = STATE_QUOTE;
                }
        }
        if (o === STATE_QUOTE_AFTER_QUOTE ? r.push(t.substring(n, i - 1)) : r.push(t.substring(n)), e && r.length !== this.fullColumnNames.length) throw new Error("Invalid row in csv file. Should have " + this.fullColumnNames.length + " elements in a row, but got " + r);
        return r;
    }, e50;
}(Dataset), MicrophoneIterator = function(t66) {
    function e51(e) {
        var r = t66.call(this) || this;
        r.microphoneConfig = e, r.isClosed = !1, r.fftSize = e.fftSize || 1024;
        var n = Math.log2(r.fftSize);
        if (r.fftSize < 0 || n < 4 || n > 14 || !Number.isInteger(n)) throw new Error("Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got " + r.fftSize);
        if (r.numFrames = e.numFramesPerSpectrogram || 43, r.sampleRateHz = e.sampleRateHz, r.columnTruncateLength = e.columnTruncateLength || r.fftSize, r.audioTrackConstraints = e.audioTrackConstraints, r.smoothingTimeConstant = e.smoothingTimeConstant || 0, r.includeSpectrogram = !1 !== e.includeSpectrogram, r.includeWaveform = !0 === e.includeWaveform, !r.includeSpectrogram && !r.includeWaveform) throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.");
        return r;
    }
    return __extends(e51, t66), e51.prototype.summary = function() {
        return "microphone";
    }, e51.create = function(t) {
        return void 0 === t && (t = {
        }), __awaiter(this, void 0, void 0, function() {
            var r;
            return __generator(this, function(n) {
                switch(n.label){
                    case 0:
                        if (_tfjsCore.env().get("IS_NODE")) throw new Error("microphone API is only supported in browser environment.");
                        return [
                            4,
                            (r = new e51(t)).start()
                        ];
                    case 1:
                        return n.sent(), [
                            2,
                            r
                        ];
                }
            });
        });
    }, e51.prototype.start = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t, e, r, n;
            return __generator(this, function(i) {
                switch(i.label){
                    case 0:
                        return i.trys.push([
                            0,
                            2,
                            ,
                            3
                        ]), t = this, [
                            4,
                            navigator.mediaDevices.getUserMedia({
                                audio: null == this.audioTrackConstraints || this.audioTrackConstraints,
                                video: !1
                            })
                        ];
                    case 1:
                        return t.stream = i.sent(), [
                            3,
                            3
                        ];
                    case 2:
                        throw e = i.sent(), new Error("Error thrown while initializing video stream: " + e.message);
                    case 3:
                        if (!this.stream) throw new Error("Could not obtain audio from microphone.");
                        if (r = window.AudioContext || window.webkitAudioContext, this.audioContext = new r, this.sampleRateHz) {
                            if (this.audioContext.sampleRate !== this.sampleRateHz) throw new Error("Mismatch in sampling rate: Expected: " + this.sampleRateHz + "; Actual: " + this.audioContext.sampleRate);
                        } else this.sampleRateHz = this.audioContext.sampleRate;
                        return n = this.audioContext.createMediaStreamSource(this.stream), this.analyser = this.audioContext.createAnalyser(), this.analyser.fftSize = 2 * this.fftSize, this.analyser.smoothingTimeConstant = this.smoothingTimeConstant, n.connect(this.analyser), this.freqData = new Float32Array(this.fftSize), this.timeData = new Float32Array(this.fftSize), [
                            2
                        ];
                }
            });
        });
    }, e51.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t, e, r, n, i;
            return __generator(this, function(o) {
                switch(o.label){
                    case 0:
                        return this.isClosed ? [
                            2,
                            {
                                value: null,
                                done: !0
                            }
                        ] : [
                            4,
                            this.getAudioData()
                        ];
                    case 1:
                        return r = o.sent(), this.includeSpectrogram && (n = this.flattenQueue(r.freqDataQueue), t = this.getTensorFromAudioDataArray(n, [
                            this.numFrames,
                            this.columnTruncateLength,
                            1
                        ])), this.includeWaveform && (i = this.flattenQueue(r.timeDataQueue), e = this.getTensorFromAudioDataArray(i, [
                            this.numFrames * this.fftSize,
                            1
                        ])), [
                            2,
                            {
                                value: {
                                    spectrogram: t,
                                    waveform: e
                                },
                                done: !1
                            }
                        ];
                }
            });
        });
    }, e51.prototype.capture = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(t) {
                switch(t.label){
                    case 0:
                        return [
                            4,
                            this.next()
                        ];
                    case 1:
                        return [
                            2,
                            t.sent().value
                        ];
                }
            });
        });
    }, e51.prototype.getAudioData = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t, e, r, n = this;
            return __generator(this, function(i13) {
                return t = [], e = [], r = 0, [
                    2,
                    new Promise(function(i) {
                        var o = setInterval(function() {
                            n.includeSpectrogram && (n.analyser.getFloatFrequencyData(n.freqData), n.freqData[0] === -1 / 0 && i({
                                freqDataQueue: t,
                                timeDataQueue: e
                            }), t.push(n.freqData.slice(0, n.columnTruncateLength))), n.includeWaveform && (n.analyser.getFloatTimeDomainData(n.timeData), e.push(n.timeData.slice())), ++r === n.numFrames && (clearInterval(o), i({
                                freqDataQueue: t,
                                timeDataQueue: e
                            }));
                        }, n.fftSize / n.sampleRateHz * 1000);
                    })
                ];
            });
        });
    }, e51.prototype.stop = function() {
        this.isClosed || (this.isClosed = !0, this.analyser.disconnect(), this.audioContext.close(), null != this.stream && this.stream.getTracks().length > 0 && this.stream.getTracks()[0].stop());
    }, e51.prototype.toArray = function() {
        throw new Error("Can not convert infinite audio stream to array.");
    }, e51.prototype.getSampleRate = function() {
        return this.sampleRateHz;
    }, e51.prototype.flattenQueue = function(t67) {
        var e = t67[0].length, r = new Float32Array(t67.length * e);
        return t67.forEach(function(t, n) {
            return r.set(t, n * e);
        }), r;
    }, e51.prototype.getTensorFromAudioDataArray = function(t, e) {
        var r = new Float32Array(_tfjsCore.util.sizeFromShape(e));
        return r.set(t, r.length - t.length), _tfjsCore.tensor(r, e);
    }, e51;
}(LazyIterator), WebcamIterator = function(t68) {
    function e52(e, r) {
        var n = t68.call(this) || this;
        if (n.webcamVideoElement = e, n.webcamConfig = r, n.isClosed = !0, n.resize = !1, n.needToResize()) {
            if (n.resize = !0, n.cropSize = [
                n.webcamConfig.resizeHeight,
                n.webcamConfig.resizeWidth
            ], n.cropBoxInd = _tfjsCore.tensor1d([
                0
            ], "int32"), n.webcamConfig.centerCrop) {
                var i = 1 * n.webcamConfig.resizeWidth / n.webcamVideoElement.width, o = 1 * n.webcamConfig.resizeHeight / n.webcamVideoElement.height, a = (1 - i) / 2, s = (1 - o) / 2, u = a + i, c = o + s;
                n.cropBox = _tfjsCore.tensor2d([
                    s,
                    a,
                    c,
                    u
                ], [
                    1,
                    4
                ]);
            } else n.cropBox = _tfjsCore.tensor2d([
                0,
                0,
                1,
                1
            ], [
                1,
                4
            ]);
        }
        return n;
    }
    return __extends(e52, t68), e52.prototype.summary = function() {
        return "webcam";
    }, e52.create = function(t, r) {
        return void 0 === r && (r = {
        }), __awaiter(this, void 0, void 0, function() {
            var n;
            return __generator(this, function(i) {
                switch(i.label){
                    case 0:
                        if (_tfjsCore.env().get("IS_NODE")) throw new Error("tf.data.webcam is only supported in browser environment.");
                        if (!t) {
                            if (t = document.createElement("video"), !r.resizeWidth || !r.resizeHeight) throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");
                            t.width = r.resizeWidth, t.height = r.resizeHeight;
                        }
                        return [
                            4,
                            (n = new e52(t, r)).start()
                        ];
                    case 1:
                        return i.sent(), [
                            2,
                            n
                        ];
                }
            });
        });
    }, e52.prototype.start = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t69, e, r = this;
            return __generator(this, function(n) {
                switch(n.label){
                    case 0:
                        this.webcamConfig.facingMode && _tfjsCore.util.assert("user" === this.webcamConfig.facingMode || "environment" === this.webcamConfig.facingMode, function() {
                            return "Invalid webcam facing mode: " + r.webcamConfig.facingMode + ". Please provide 'user' or 'environment'";
                        }), n.label = 1;
                    case 1:
                        return n.trys.push([
                            1,
                            3,
                            ,
                            4
                        ]), t69 = this, [
                            4,
                            navigator.mediaDevices.getUserMedia({
                                video: {
                                    deviceId: this.webcamConfig.deviceId,
                                    facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : "user",
                                    width: this.webcamVideoElement.width,
                                    height: this.webcamVideoElement.height
                                }
                            })
                        ];
                    case 2:
                        return t69.stream = n.sent(), [
                            3,
                            4
                        ];
                    case 3:
                        throw (e = n.sent()).message = "Error thrown while initializing video stream: " + e.message, e;
                    case 4:
                        if (!this.stream) throw new Error("Could not obtain video from webcam.");
                        try {
                            this.webcamVideoElement.srcObject = this.stream;
                        } catch (t70) {
                            console.log(t70), this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);
                        }
                        return this.webcamVideoElement.play(), this.isClosed = !1, [
                            2,
                            new Promise(function(t) {
                                r.webcamVideoElement.onloadedmetadata = function() {
                                    t();
                                };
                            })
                        ];
                }
            });
        });
    }, e52.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t71;
            return __generator(this, function(e) {
                if (this.isClosed) return [
                    2,
                    {
                        value: null,
                        done: !0
                    }
                ];
                try {
                    t71 = _tfjsCore.browser.fromPixels(this.webcamVideoElement);
                } catch (t) {
                    throw new Error("Error thrown converting video to pixels: " + JSON.stringify(t));
                }
                if (!this.resize) return [
                    2,
                    {
                        value: t71,
                        done: !1
                    }
                ];
                try {
                    return [
                        2,
                        {
                            value: this.cropAndResizeFrame(t71),
                            done: !1
                        }
                    ];
                } catch (t72) {
                    throw new Error("Error thrown cropping the video: " + t72.message);
                } finally{
                    t71.dispose();
                }
                return [
                    2
                ];
            });
        });
    }, e52.prototype.needToResize = function() {
        return !(!this.webcamConfig.resizeWidth || !this.webcamConfig.resizeHeight || this.webcamVideoElement.width === this.webcamConfig.resizeWidth && this.webcamVideoElement.height === this.webcamConfig.resizeHeight);
    }, e52.prototype.cropAndResizeFrame = function(t) {
        var e = this;
        return _tfjsCore.tidy(function() {
            var r, n = t.toFloat().expandDims(0), i = (r = _tfjsCore.image.cropAndResize(n, e.cropBox, e.cropBoxInd, e.cropSize, "bilinear")).shape;
            return r.reshape(i.slice(1));
        });
    }, e52.prototype.capture = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(t) {
                switch(t.label){
                    case 0:
                        return [
                            4,
                            this.next()
                        ];
                    case 1:
                        return [
                            2,
                            t.sent().value
                        ];
                }
            });
        });
    }, e52.prototype.stop = function() {
        this.stream.getTracks().forEach(function(t) {
            return t.stop();
        });
        try {
            this.webcamVideoElement.srcObject = null;
        } catch (t) {
            console.log(t), this.webcamVideoElement.src = null;
        }
        this.isClosed = !0;
    }, e52.prototype.toArray = function() {
        throw new Error("Can not convert infinite video stream to array.");
    }, e52;
}(LazyIterator), DataSource = function() {
    return function() {
    };
}(), StringIterator = function(t73) {
    function e() {
        return null !== t73 && t73.apply(this, arguments) || this;
    }
    return __extends(e, t73), e.prototype.split = function(t) {
        return new SplitIterator(this, t);
    }, e;
}(LazyIterator), SplitIterator = function(t) {
    function e53(e, r) {
        var n = t.call(this) || this;
        return n.upstream = e, n.impl = new SplitIteratorImpl(e, r), n;
    }
    return __extends(e53, t), e53.prototype.summary = function() {
        return this.impl.summary();
    }, e53.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(t) {
                return [
                    2,
                    this.impl.next()
                ];
            });
        });
    }, e53;
}(StringIterator), SplitIteratorImpl = function(t74) {
    function e54(e, r) {
        var n = t74.call(this) || this;
        return n.upstream = e, n.separator = r, n.carryover = "", n;
    }
    return __extends(e54, t74), e54.prototype.summary = function() {
        return this.upstream.summary() + " -> Split('" + this.separator + "')";
    }, e54.prototype.pump = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t, e, r, n, i;
            return __generator(this, function(o) {
                switch(o.label){
                    case 0:
                        return [
                            4,
                            this.upstream.next()
                        ];
                    case 1:
                        if ((t = o.sent()).done) return "" === this.carryover ? [
                            2,
                            !1
                        ] : (this.outputQueue.push(this.carryover), this.carryover = "", [
                            2,
                            !0
                        ]);
                        for((e = t.value.split(this.separator))[0] = this.carryover + e[0], r = 0, n = e.slice(0, -1); r < n.length; r++)i = n[r], this.outputQueue.push(i);
                        return this.carryover = e[e.length - 1], [
                            2,
                            !0
                        ];
                }
            });
        });
    }, e54;
}(OneToManyIterator), ByteChunkIterator = function(t) {
    function e() {
        return null !== t && t.apply(this, arguments) || this;
    }
    return __extends(e, t), e.prototype.decodeUTF8 = function() {
        return new Utf8Iterator(this);
    }, e;
}(LazyIterator), Utf8Iterator = function(t) {
    function e55(e) {
        var r = t.call(this) || this;
        return r.upstream = e, r.impl = new Utf8IteratorImpl(e), r;
    }
    return __extends(e55, t), e55.prototype.summary = function() {
        return this.impl.summary();
    }, e55.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(t) {
                return [
                    2,
                    this.impl.next()
                ];
            });
        });
    }, e55;
}(StringIterator), Utf8IteratorImpl = function(t75) {
    function e56(e) {
        var r = t75.call(this) || this;
        if (r.upstream = e, _tfjsCore.env().get("IS_BROWSER")) r.decoder = new TextDecoder("utf-8");
        else {
            var n = require("string_decoder").StringDecoder;
            r.decoder = new n("utf8");
        }
        return r;
    }
    return __extends(e56, t75), e56.prototype.summary = function() {
        return this.upstream.summary() + " -> Utf8";
    }, e56.prototype.pump = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t, e, r;
            return __generator(this, function(n) {
                switch(n.label){
                    case 0:
                        return [
                            4,
                            this.upstream.next()
                        ];
                    case 1:
                        return (t = n.sent()).done ? [
                            2,
                            !1
                        ] : (e = t.value, r = _tfjsCore.env().get("IS_BROWSER") ? this.decoder.decode(e, {
                            stream: !0
                        }) : this.decoder.write(Buffer.from(e.buffer)), this.outputQueue.push(r), [
                            2,
                            !0
                        ]);
                }
            });
        });
    }, e56;
}(OneToManyIterator), FileChunkIterator = function(t76) {
    function e57(e, r) {
        void 0 === r && (r = {
        });
        var n = t76.call(this) || this;
        return n.file = e, n.options = r, _tfjsCore.util.assert(e instanceof Uint8Array || !!_tfjsCore.env().get("IS_BROWSER") && (e instanceof File || e instanceof Blob), function() {
            return "FileChunkIterator only supports File, Blob and Uint8Array right now.";
        }), n.offset = r.offset || 0, n.chunkSize = r.chunkSize || 1048576, n;
    }
    return __extends(e57, t76), e57.prototype.summary = function() {
        return "FileChunks " + this.file;
    }, e57.prototype.next = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t77, e58, r = this;
            return __generator(this, function(n11) {
                switch(n11.label){
                    case 0:
                        return this.offset >= (this.file instanceof Uint8Array ? this.file.byteLength : this.file.size) ? [
                            2,
                            {
                                value: null,
                                done: !0
                            }
                        ] : (t77 = new Promise(function(t78, e) {
                            var n12 = r.offset + r.chunkSize;
                            if (r.file instanceof Uint8Array) t78(new Uint8Array(r.file.slice(r.offset, n12)));
                            else {
                                var i = new FileReader;
                                i.onload = function(r) {
                                    var n = i.result;
                                    if (n instanceof ArrayBuffer && (n = new Uint8Array(n)), !(n instanceof Uint8Array)) return e(new TypeError("FileReader returned unknown type."));
                                    t78(n);
                                }, i.onabort = function(t) {
                                    return e(new Error("Aborted"));
                                }, i.onerror = function(t) {
                                    return e(new Error(t.type));
                                };
                                var o = r.file.slice(r.offset, n12);
                                i.readAsArrayBuffer(o);
                            }
                            r.offset = n12;
                        }), e58 = {
                        }, [
                            4,
                            t77
                        ]);
                    case 1:
                        return [
                            2,
                            (e58.value = n11.sent(), e58.done = !1, e58)
                        ];
                }
            });
        });
    }, e57;
}(ByteChunkIterator);
function urlChunkIterator(t, e) {
    return void 0 === e && (e = {
    }), __awaiter(this, void 0, void 0, function() {
        var r, n, i, o, a;
        return __generator(this, function(s) {
            switch(s.label){
                case 0:
                    return "string" == typeof t ? r = t : (r = t.url, n = getRequestInitFromRequest(t)), [
                        4,
                        _tfjsCore.util.fetch(r, n)
                    ];
                case 1:
                    return (i = s.sent()).ok ? (a = Uint8Array.bind, [
                        4,
                        i.arrayBuffer()
                    ]) : [
                        3,
                        3
                    ];
                case 2:
                    return o = new (a.apply(Uint8Array, [
                        void 0,
                        s.sent()
                    ])), [
                        2,
                        new FileChunkIterator(o, e)
                    ];
                case 3:
                    throw new Error(i.statusText);
            }
        });
    });
}
var getRequestInitFromRequest = function(t) {
    return {
        method: t.method,
        headers: t.headers,
        body: t.body,
        mode: t.mode,
        credentials: t.credentials,
        cache: t.cache,
        redirect: t.redirect,
        referrer: t.referrer,
        integrity: t.integrity
    };
};
function isLocalPath(t) {
    return "string" == typeof t && "file://" === t.substr(0, 7);
}
var FileDataSource = function(t79) {
    function e59(e, r) {
        void 0 === r && (r = {
        });
        var n = t79.call(this) || this;
        return n.input = e, n.options = r, n;
    }
    return __extends(e59, t79), e59.prototype.iterator = function() {
        return __awaiter(this, void 0, void 0, function() {
            var t;
            return __generator(this, function(e) {
                return isLocalPath(this.input) && _tfjsCore.env().get("IS_NODE") && (t = require("fs"), this.input = t.readFileSync(this.input.substr(7))), [
                    2,
                    new FileChunkIterator(this.input, this.options)
                ];
            });
        });
    }, e59;
}(DataSource), URLDataSource = function(t) {
    function e60(e, r) {
        void 0 === r && (r = {
        });
        var n = t.call(this) || this;
        return n.url = e, n.fileOptions = r, n;
    }
    return __extends(e60, t), e60.prototype.iterator = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(t) {
                return isLocalPath(this.url) ? [
                    2,
                    new FileDataSource(this.url, this.fileOptions).iterator()
                ] : [
                    2,
                    urlChunkIterator(this.url, this.fileOptions)
                ];
            });
        });
    }, e60;
}(DataSource);
function csv(t, e) {
    return void 0 === e && (e = {
    }), new CSVDataset(new URLDataSource(t), e);
}
function func(t) {
    var e = this, r = iteratorFromFunction(t);
    return datasetFromIteratorFn(function() {
        return __awaiter(e, void 0, void 0, function() {
            return __generator(this, function(t) {
                return [
                    2,
                    r
                ];
            });
        });
    });
}
function generator(t) {
    var e61 = this;
    return datasetFromIteratorFn(function() {
        return __awaiter(e61, void 0, void 0, function() {
            var e;
            return __generator(this, function(r) {
                switch(r.label){
                    case 0:
                        return [
                            4,
                            t()
                        ];
                    case 1:
                        return e = r.sent(), [
                            2,
                            iteratorFromFunction(function() {
                                return e.next();
                            })
                        ];
                }
            });
        });
    });
}
function webcam(t, e) {
    return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(r) {
            return [
                2,
                WebcamIterator.create(t, e)
            ];
        });
    });
}
function microphone(t) {
    return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(e) {
            return [
                2,
                MicrophoneIterator.create(t)
            ];
        });
    });
}
var version = "1.7.4";

},{"@tensorflow/tfjs-core":"djGzH","buffer":"fCgem","crypto":"jhUEF","string_decoder":"jhUEF","fs":"jhUEF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5PKub":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A dataset for webcam controls which allows the user to add example Tensors
 * for particular labels. This object will concat them into two large xs and ys.
 */ parcelHelpers.export(exports, "ControllerDataset", ()=>ControllerDataset
);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ var _tfjs = require("@tensorflow/tfjs");
class ControllerDataset {
    constructor(numClasses){
        this.numClasses = numClasses;
    }
    /**
   * Adds an example to the controller dataset.
   * @param {Tensor} example A tensor representing the example. It can be an image,
   *     an activation, or any other type of Tensor.
   * @param {number} label The label of the example. Should be a number.
   */ addExample(example, label) {
        // One-hot encode the label.
        const y = _tfjs.tidy(()=>_tfjs.oneHot(_tfjs.tensor1d([
                label
            ]).toInt(), this.numClasses)
        );
        if (this.xs == null) {
            // For the first example that gets added, keep example and y so that the
            // ControllerDataset owns the memory of the inputs. This makes sure that
            // if addExample() is called in a tf.tidy(), these Tensors will not get
            // disposed.
            this.xs = _tfjs.keep(example);
            this.ys = _tfjs.keep(y);
        } else {
            const oldX = this.xs;
            this.xs = _tfjs.keep(oldX.concat(example, 0));
            const oldY = this.ys;
            this.ys = _tfjs.keep(oldY.concat(y, 0));
            oldX.dispose();
            oldY.dispose();
            y.dispose();
        }
    }
}

},{"@tensorflow/tfjs":"2Nmqy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jRvde":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "init", ()=>init
);
parcelHelpers.export(exports, "getLearningRate", ()=>getLearningRate
);
parcelHelpers.export(exports, "getBatchSizeFraction", ()=>getBatchSizeFraction
);
parcelHelpers.export(exports, "getEpochs", ()=>getEpochs
);
parcelHelpers.export(exports, "getDenseUnits", ()=>getDenseUnits
);
parcelHelpers.export(exports, "startPacman", ()=>startPacman
);
parcelHelpers.export(exports, "predictClass", ()=>predictClass
);
parcelHelpers.export(exports, "isPredicting", ()=>isPredicting
);
parcelHelpers.export(exports, "donePredicting", ()=>donePredicting
);
parcelHelpers.export(exports, "trainStatus", ()=>trainStatus
);
parcelHelpers.export(exports, "addExampleHandler", ()=>addExampleHandler
);
parcelHelpers.export(exports, "setExampleHandler", ()=>setExampleHandler
);
parcelHelpers.export(exports, "drawThumb", ()=>drawThumb
);
parcelHelpers.export(exports, "draw", ()=>draw
);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ var _tfjs = require("@tensorflow/tfjs");
const CONTROLS = [
    'up',
    'down',
    'left',
    'right'
];
const CONTROL_CODES = [
    38,
    40,
    37,
    39
];
function init() {
    document.getElementById('controller').style.display = '';
    statusElement.style.display = 'none';
}
const trainStatusElement = document.getElementById('train-status');
// Set hyper params from UI values.
const learningRateElement = document.getElementById('learningRate');
const getLearningRate = ()=>+learningRateElement.value
;
const batchSizeFractionElement = document.getElementById('batchSizeFraction');
const getBatchSizeFraction = ()=>+batchSizeFractionElement.value
;
const epochsElement = document.getElementById('epochs');
const getEpochs = ()=>+epochsElement.value
;
const denseUnitsElement = document.getElementById('dense-units');
const getDenseUnits = ()=>+denseUnitsElement.value
;
const statusElement = document.getElementById('status');
function startPacman() {
    google.pacman.startGameplay();
}
function predictClass(classId) {
    google.pacman.keyPressed(CONTROL_CODES[classId]);
    document.body.setAttribute('data-active', CONTROLS[classId]);
}
function isPredicting() {
    statusElement.style.visibility = 'visible';
}
function donePredicting() {
    statusElement.style.visibility = 'hidden';
}
function trainStatus(status) {
    trainStatusElement.innerText = status;
}
let addExampleHandler;
function setExampleHandler(handler1) {
    addExampleHandler = handler1;
}
let mouseDown = false;
const totals = [
    0,
    0,
    0,
    0
];
const upButton = document.getElementById('up');
const downButton = document.getElementById('down');
const leftButton = document.getElementById('left');
const rightButton = document.getElementById('right');
const thumbDisplayed = {
};
async function handler(label) {
    mouseDown = true;
    const className = CONTROLS[label];
    const button = document.getElementById(className);
    const total = document.getElementById(className + '-total');
    if (mouseDown) {
        addExampleHandler(label);
        document.body.setAttribute('data-active', CONTROLS[label]);
        total.innerText = ++totals[label];
        await _tfjs.nextFrame();
    }
    document.body.removeAttribute('data-active');
}
upButton.addEventListener('mousedown', ()=>handler(0)
);
upButton.addEventListener('mouseup', ()=>mouseDown = false
);
downButton.addEventListener('mousedown', ()=>handler(1)
);
downButton.addEventListener('mouseup', ()=>mouseDown = false
);
leftButton.addEventListener('mousedown', ()=>handler(2)
);
leftButton.addEventListener('mouseup', ()=>mouseDown = false
);
rightButton.addEventListener('mousedown', ()=>handler(3)
);
rightButton.addEventListener('mouseup', ()=>mouseDown = false
);
function drawThumb(img, label) {
    if (thumbDisplayed[label] == null) {
        const thumbCanvas = document.getElementById(CONTROLS[label] + '-thumb');
        draw(img, thumbCanvas);
    }
}
function draw(image, canvas) {
    const [width, height] = [
        224,
        224
    ];
    const ctx = canvas.getContext('2d');
    const imageData = new ImageData(width, height);
    const data = image.dataSync();
    for(let i = 0; i < height * width; ++i){
        const j = i * 4;
        imageData.data[j + 0] = (data[i * 3 + 0] + 1) * 127;
        imageData.data[j + 1] = (data[i * 3 + 1] + 1) * 127;
        imageData.data[j + 2] = (data[i * 3 + 2] + 1) * 127;
        imageData.data[j + 3] = 255;
    }
    ctx.putImageData(imageData, 0, 0);
}

},{"@tensorflow/tfjs":"2Nmqy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["iKiqL","bB7Pu"], "bB7Pu", "parcelRequirec07e")

//# sourceMappingURL=index.3d214d75.js.map
